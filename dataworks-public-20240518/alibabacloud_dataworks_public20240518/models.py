# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, BinaryIO, Any


class Catalog(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        parent_meta_entity_id: str = None,
        type: str = None,
    ):
        self.comment = comment
        self.create_time = create_time
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.parent_meta_entity_id = parent_meta_entity_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ColumnBusinessMetadata(TeaModel):
    def __init__(
        self,
        description: str = None,
    ):
        self.description = description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class Column(TeaModel):
    def __init__(
        self,
        business_metadata: ColumnBusinessMetadata = None,
        comment: str = None,
        foreign_key: bool = None,
        id: str = None,
        name: str = None,
        partition_key: bool = None,
        position: int = None,
        primary_key: bool = None,
        table_id: str = None,
        type: str = None,
    ):
        self.business_metadata = business_metadata
        self.comment = comment
        self.foreign_key = foreign_key
        self.id = id
        self.name = name
        self.partition_key = partition_key
        self.position = position
        self.primary_key = primary_key
        self.table_id = table_id
        self.type = type

    def validate(self):
        if self.business_metadata:
            self.business_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_metadata is not None:
            result['BusinessMetadata'] = self.business_metadata.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.foreign_key is not None:
            result['ForeignKey'] = self.foreign_key
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.partition_key is not None:
            result['PartitionKey'] = self.partition_key
        if self.position is not None:
            result['Position'] = self.position
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessMetadata') is not None:
            temp_model = ColumnBusinessMetadata()
            self.business_metadata = temp_model.from_map(m['BusinessMetadata'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ForeignKey') is not None:
            self.foreign_key = m.get('ForeignKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PartitionKey') is not None:
            self.partition_key = m.get('PartitionKey')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CrawlerTypeSupportedEntityTypes(TeaModel):
    def __init__(
        self,
        optional: bool = None,
        parent_sub_type: str = None,
        sub_type: str = None,
        type: str = None,
    ):
        self.optional = optional
        self.parent_sub_type = parent_sub_type
        self.sub_type = sub_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.optional is not None:
            result['Optional'] = self.optional
        if self.parent_sub_type is not None:
            result['ParentSubType'] = self.parent_sub_type
        if self.sub_type is not None:
            result['SubType'] = self.sub_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Optional') is not None:
            self.optional = m.get('Optional')
        if m.get('ParentSubType') is not None:
            self.parent_sub_type = m.get('ParentSubType')
        if m.get('SubType') is not None:
            self.sub_type = m.get('SubType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CrawlerType(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        supported_entity_types: List[CrawlerTypeSupportedEntityTypes] = None,
        type: str = None,
    ):
        self.display_name = display_name
        self.supported_entity_types = supported_entity_types
        self.type = type

    def validate(self):
        if self.supported_entity_types:
            for k in self.supported_entity_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        result['SupportedEntityTypes'] = []
        if self.supported_entity_types is not None:
            for k in self.supported_entity_types:
                result['SupportedEntityTypes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        self.supported_entity_types = []
        if m.get('SupportedEntityTypes') is not None:
            for k in m.get('SupportedEntityTypes'):
                temp_model = CrawlerTypeSupportedEntityTypes()
                self.supported_entity_types.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        self.condition = condition
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class DataQualityEvaluationTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = DataQualityEvaluationTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = DataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[DataQualityEvaluationTaskNotificationsNotifications] = None,
    ):
        self.condition = condition
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        self.task_ids = task_ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTask(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        hooks: List[DataQualityEvaluationTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: List[DataQualityEvaluationTaskNotifications] = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: DataQualityEvaluationTaskTarget = None,
        tenant_id: int = None,
        trigger: DataQualityEvaluationTaskTrigger = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.hooks = hooks
        self.id = id
        self.name = name
        self.notifications = notifications
        self.project_id = project_id
        self.runtime_conf = runtime_conf
        self.target = target
        self.tenant_id = tenant_id
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = DataQualityEvaluationTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskNotifications()
                self.notifications.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = DataQualityEvaluationTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = DataQualityEvaluationTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class DataQualityEvaluationTaskInstanceTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        self.condition = condition
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        self.extension = extension
        self.receiver_type = receiver_type
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class DataQualityEvaluationTaskInstanceTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        self.notification_channels = notification_channels
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskInstanceTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[DataQualityEvaluationTaskInstanceTaskNotificationsNotifications] = None,
    ):
        self.condition = condition
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class DataQualityEvaluationTaskInstanceTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        self.task_ids = task_ids
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityEvaluationTaskInstanceTask(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        hooks: List[DataQualityEvaluationTaskInstanceTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: List[DataQualityEvaluationTaskInstanceTaskNotifications] = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: DataQualityEvaluationTaskInstanceTaskTarget = None,
        tenant_id: int = None,
        trigger: DataQualityEvaluationTaskInstanceTaskTrigger = None,
    ):
        self.data_source_id = data_source_id
        self.hooks = hooks
        self.id = id
        self.name = name
        self.notifications = notifications
        self.project_id = project_id
        self.runtime_conf = runtime_conf
        self.target = target
        self.tenant_id = tenant_id
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = DataQualityEvaluationTaskInstanceTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = DataQualityEvaluationTaskInstanceTaskNotifications()
                self.notifications.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('Trigger') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class DataQualityEvaluationTaskInstance(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        finish_time: int = None,
        id: int = None,
        status: str = None,
        task: DataQualityEvaluationTaskInstanceTask = None,
    ):
        self.create_time = create_time
        self.finish_time = finish_time
        self.id = id
        self.status = status
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Task') is not None:
            temp_model = DataQualityEvaluationTaskInstanceTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class DataQualityResultDetails(TeaModel):
    def __init__(
        self,
        checked_value: str = None,
        referenced_value: str = None,
        status: str = None,
    ):
        self.checked_value = checked_value
        self.referenced_value = referenced_value
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checked_value is not None:
            result['CheckedValue'] = self.checked_value
        if self.referenced_value is not None:
            result['ReferencedValue'] = self.referenced_value
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckedValue') is not None:
            self.checked_value = m.get('CheckedValue')
        if m.get('ReferencedValue') is not None:
            self.referenced_value = m.get('ReferencedValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DataQualityResultRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        operator: str = None,
        value: str = None,
    ):
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityResultRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: DataQualityResultRuleCheckingConfigThresholdsCritical = None,
        expected: DataQualityResultRuleCheckingConfigThresholdsExpected = None,
        warned: DataQualityResultRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class DataQualityResultRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: DataQualityResultRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = DataQualityResultRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class DataQualityResultRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityResultRule(TeaModel):
    def __init__(
        self,
        checking_config: DataQualityResultRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[DataQualityResultRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: DataQualityResultRuleSamplingConfig = None,
        severity: str = None,
        target: DataQualityResultRuleTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.severity = severity
        self.target = target
        self.template_code = template_code
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = DataQualityResultRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = DataQualityResultRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = DataQualityResultRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = DataQualityResultRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DataQualityResult(TeaModel):
    def __init__(
        self,
        details: List[DataQualityResultDetails] = None,
        id: int = None,
        rule: DataQualityResultRule = None,
        sample: str = None,
        status: str = None,
        task_instance_id: int = None,
    ):
        self.details = details
        self.id = id
        self.rule = rule
        self.sample = sample
        self.status = status
        self.task_instance_id = task_instance_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.rule:
            self.rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        if self.sample is not None:
            result['Sample'] = self.sample
        if self.status is not None:
            result['Status'] = self.status
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DataQualityResultDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Rule') is not None:
            temp_model = DataQualityResultRule()
            self.rule = temp_model.from_map(m['Rule'])
        if m.get('Sample') is not None:
            self.sample = m.get('Sample')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        return self


class DataQualityRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DataQualityRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: DataQualityRuleCheckingConfigThresholdsCritical = None,
        expected: DataQualityRuleCheckingConfigThresholdsExpected = None,
        warned: DataQualityRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class DataQualityRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: DataQualityRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = DataQualityRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class DataQualityRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.partition_spec = partition_spec
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRule(TeaModel):
    def __init__(
        self,
        checking_config: DataQualityRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[DataQualityRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: DataQualityRuleSamplingConfig = None,
        severity: str = None,
        target: DataQualityRuleTarget = None,
        template_code: str = None,
        tenant_id: int = None,
    ):
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.severity = severity
        self.target = target
        self.template_code = template_code
        self.tenant_id = tenant_id

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = DataQualityRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = DataQualityRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = DataQualityRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = DataQualityRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class DataQualityRuleTemplateCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DataQualityRuleTemplateSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class DataQualityRuleTemplate(TeaModel):
    def __init__(
        self,
        checking_config: DataQualityRuleTemplateCheckingConfig = None,
        code: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config: DataQualityRuleTemplateSamplingConfig = None,
        tenant_id: int = None,
        visible_scope: str = None,
    ):
        self.checking_config = checking_config
        self.code = code
        self.directory_path = directory_path
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.tenant_id = tenant_id
        self.visible_scope = visible_scope

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.visible_scope is not None:
            result['VisibleScope'] = self.visible_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = DataQualityRuleTemplateCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = DataQualityRuleTemplateSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('VisibleScope') is not None:
            self.visible_scope = m.get('VisibleScope')
        return self


class Database(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: int = None,
        id: str = None,
        location_uri: str = None,
        modify_time: int = None,
        name: str = None,
        parent_meta_entity_id: str = None,
    ):
        self.comment = comment
        self.create_time = create_time
        self.id = id
        self.location_uri = location_uri
        self.modify_time = modify_time
        self.name = name
        self.parent_meta_entity_id = parent_meta_entity_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.location_uri is not None:
            result['LocationUri'] = self.location_uri
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LocationUri') is not None:
            self.location_uri = m.get('LocationUri')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        return self


class LineageEntity(TeaModel):
    def __init__(
        self,
        attributes: Dict[str, str] = None,
        id: str = None,
        name: str = None,
    ):
        self.attributes = attributes
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class LineageTask(TeaModel):
    def __init__(
        self,
        attributes: Dict[str, str] = None,
        id: str = None,
        type: str = None,
    ):
        self.attributes = attributes
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class LineageRelationship(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        dst_entity: LineageEntity = None,
        id: str = None,
        src_entity: LineageEntity = None,
        task: LineageTask = None,
    ):
        self.create_time = create_time
        self.dst_entity = dst_entity
        self.id = id
        self.src_entity = src_entity
        self.task = task

    def validate(self):
        if self.dst_entity:
            self.dst_entity.validate()
        if self.src_entity:
            self.src_entity.validate()
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dst_entity is not None:
            result['DstEntity'] = self.dst_entity.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.src_entity is not None:
            result['SrcEntity'] = self.src_entity.to_map()
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DstEntity') is not None:
            temp_model = LineageEntity()
            self.dst_entity = temp_model.from_map(m['DstEntity'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SrcEntity') is not None:
            temp_model = LineageEntity()
            self.src_entity = temp_model.from_map(m['SrcEntity'])
        if m.get('Task') is not None:
            temp_model = LineageTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class Partition(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_size: int = None,
        modify_time: int = None,
        name: str = None,
        record_count: int = None,
        table_id: str = None,
    ):
        self.create_time = create_time
        self.data_size = data_size
        self.modify_time = modify_time
        self.name = name
        self.record_count = record_count
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_size is not None:
            result['DataSize'] = self.data_size
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.record_count is not None:
            result['RecordCount'] = self.record_count
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSize') is not None:
            self.data_size = m.get('DataSize')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecordCount') is not None:
            self.record_count = m.get('RecordCount')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class Schema(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        parent_meta_entity_id: str = None,
        type: str = None,
    ):
        self.comment = comment
        self.create_time = create_time
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.parent_meta_entity_id = parent_meta_entity_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class TableBusinessMetadataCategories(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        parent_id: str = None,
    ):
        self.id = id
        self.name = name
        self.parent_id = parent_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        return self


class TableBusinessMetadataExtension(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        favor_count: int = None,
        project_id: int = None,
        read_count: int = None,
        view_count: int = None,
    ):
        self.env_type = env_type
        self.favor_count = favor_count
        self.project_id = project_id
        self.read_count = read_count
        self.view_count = view_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.favor_count is not None:
            result['FavorCount'] = self.favor_count
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.read_count is not None:
            result['ReadCount'] = self.read_count
        if self.view_count is not None:
            result['ViewCount'] = self.view_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FavorCount') is not None:
            self.favor_count = m.get('FavorCount')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ReadCount') is not None:
            self.read_count = m.get('ReadCount')
        if m.get('ViewCount') is not None:
            self.view_count = m.get('ViewCount')
        return self


class TableBusinessMetadataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TableBusinessMetadataUpstreamTasks(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class TableBusinessMetadata(TeaModel):
    def __init__(
        self,
        categories: List[List[TableBusinessMetadataCategories]] = None,
        extension: TableBusinessMetadataExtension = None,
        readme: str = None,
        tags: List[TableBusinessMetadataTags] = None,
        upstream_tasks: List[TableBusinessMetadataUpstreamTasks] = None,
    ):
        self.categories = categories
        self.extension = extension
        self.readme = readme
        self.tags = tags
        self.upstream_tasks = upstream_tasks

    def validate(self):
        if self.categories:
            for k in self.categories:
                for k1 in k:
                    if k1:
                        k1.validate()
        if self.extension:
            self.extension.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.upstream_tasks:
            for k in self.upstream_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Categories'] = []
        if self.categories is not None:
            for k in self.categories:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['Categories'].append(l1)
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.readme is not None:
            result['Readme'] = self.readme
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        result['UpstreamTasks'] = []
        if self.upstream_tasks is not None:
            for k in self.upstream_tasks:
                result['UpstreamTasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.categories = []
        if m.get('Categories') is not None:
            for k in m.get('Categories'):
                l1 = []
                for k1 in k:
                    temp_model = TableBusinessMetadataCategories()
                    l1.append(temp_model.from_map(k1))
                self.categories.append(l1)
        if m.get('Extension') is not None:
            temp_model = TableBusinessMetadataExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Readme') is not None:
            self.readme = m.get('Readme')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = TableBusinessMetadataTags()
                self.tags.append(temp_model.from_map(k))
        self.upstream_tasks = []
        if m.get('UpstreamTasks') is not None:
            for k in m.get('UpstreamTasks'):
                temp_model = TableBusinessMetadataUpstreamTasks()
                self.upstream_tasks.append(temp_model.from_map(k))
        return self


class TableTechnicalMetadata(TeaModel):
    def __init__(
        self,
        compressed: bool = None,
        input_format: str = None,
        location: str = None,
        output_format: str = None,
        owner: str = None,
        parameters: Dict[str, str] = None,
        serialization_library: str = None,
    ):
        self.compressed = compressed
        self.input_format = input_format
        self.location = location
        self.output_format = output_format
        self.owner = owner
        self.parameters = parameters
        self.serialization_library = serialization_library

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compressed is not None:
            result['Compressed'] = self.compressed
        if self.input_format is not None:
            result['InputFormat'] = self.input_format
        if self.location is not None:
            result['Location'] = self.location
        if self.output_format is not None:
            result['OutputFormat'] = self.output_format
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.serialization_library is not None:
            result['SerializationLibrary'] = self.serialization_library
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Compressed') is not None:
            self.compressed = m.get('Compressed')
        if m.get('InputFormat') is not None:
            self.input_format = m.get('InputFormat')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('OutputFormat') is not None:
            self.output_format = m.get('OutputFormat')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('SerializationLibrary') is not None:
            self.serialization_library = m.get('SerializationLibrary')
        return self


class Table(TeaModel):
    def __init__(
        self,
        business_metadata: TableBusinessMetadata = None,
        comment: str = None,
        create_time: int = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        parent_meta_entity_id: str = None,
        partition_keys: List[str] = None,
        table_type: str = None,
        technical_metadata: TableTechnicalMetadata = None,
    ):
        self.business_metadata = business_metadata
        self.comment = comment
        self.create_time = create_time
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.parent_meta_entity_id = parent_meta_entity_id
        self.partition_keys = partition_keys
        self.table_type = table_type
        self.technical_metadata = technical_metadata

    def validate(self):
        if self.business_metadata:
            self.business_metadata.validate()
        if self.technical_metadata:
            self.technical_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_metadata is not None:
            result['BusinessMetadata'] = self.business_metadata.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.partition_keys is not None:
            result['PartitionKeys'] = self.partition_keys
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.technical_metadata is not None:
            result['TechnicalMetadata'] = self.technical_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessMetadata') is not None:
            temp_model = TableBusinessMetadata()
            self.business_metadata = temp_model.from_map(m['BusinessMetadata'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('PartitionKeys') is not None:
            self.partition_keys = m.get('PartitionKeys')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('TechnicalMetadata') is not None:
            temp_model = TableTechnicalMetadata()
            self.technical_metadata = temp_model.from_map(m['TechnicalMetadata'])
        return self


class SuccessInfoValue(TeaModel):
    def __init__(
        self,
        success: bool = None,
        message: str = None,
    ):
        # Indicates whether the request was successful.
        self.success = success
        # The error message.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class AbolishPipelineRunRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: int = None,
    ):
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AbolishPipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AbolishPipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AbolishPipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AbolishPipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddEntityIntoMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        meta_collection_id: str = None,
        remark: str = None,
    ):
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.meta_collection_id = meta_collection_id
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.meta_collection_id is not None:
            result['MetaCollectionId'] = self.meta_collection_id
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetaCollectionId') is not None:
            self.meta_collection_id = m.get('MetaCollectionId')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class AddEntityIntoMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddEntityIntoMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddEntityIntoMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddEntityIntoMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateProjectToResourceGroupRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the DataWorks workspace with which you want to associate the resource group.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class AssociateProjectToResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AssociateProjectToResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AssociateProjectToResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateProjectToResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachDataQualityRulesToEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        data_quality_rule_ids: List[int] = None,
        project_id: int = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The IDs of the monitoring rules.
        # 
        # This parameter is required.
        self.data_quality_rule_ids = data_quality_rule_ids
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_rule_ids is not None:
            result['DataQualityRuleIds'] = self.data_quality_rule_ids
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityRuleIds') is not None:
            self.data_quality_rule_ids = m.get('DataQualityRuleIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AttachDataQualityRulesToEvaluationTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        data_quality_rule_ids_shrink: str = None,
        project_id: int = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The IDs of the monitoring rules.
        # 
        # This parameter is required.
        self.data_quality_rule_ids_shrink = data_quality_rule_ids_shrink
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_rule_ids_shrink is not None:
            result['DataQualityRuleIds'] = self.data_quality_rule_ids_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityRuleIds') is not None:
            self.data_quality_rule_ids_shrink = m.get('DataQualityRuleIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AttachDataQualityRulesToEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Id of the request
        self.request_id = request_id
        # The value of the association is as follows:
        # - true: The call is successful.
        # - false: the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachDataQualityRulesToEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachDataQualityRulesToEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachDataQualityRulesToEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUpdateTasksRequestTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class BatchUpdateTasksRequestTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class BatchUpdateTasksRequestTasksTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class BatchUpdateTasksRequestTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the `yyyy-mm-dd hh:mm:ss`.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the `yyyy-mm-dd hh:mm:ss`.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BatchUpdateTasksRequestTasks(TeaModel):
    def __init__(
        self,
        data_source: BatchUpdateTasksRequestTasksDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: BatchUpdateTasksRequestTasksRuntimeResource = None,
        tags: List[BatchUpdateTasksRequestTasksTags] = None,
        timeout: int = None,
        trigger: BatchUpdateTasksRequestTasksTrigger = None,
    ):
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The name.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The tags.
        self.tags = tags
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSource') is not None:
            temp_model = BatchUpdateTasksRequestTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = BatchUpdateTasksRequestTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = BatchUpdateTasksRequestTasksTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = BatchUpdateTasksRequestTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class BatchUpdateTasksRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        tasks: List[BatchUpdateTasksRequestTasks] = None,
    ):
        # The remarks.
        self.comment = comment
        # The tasks.
        self.tasks = tasks

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = BatchUpdateTasksRequestTasks()
                self.tasks.append(temp_model.from_map(k))
        return self


class BatchUpdateTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        tasks_shrink: str = None,
    ):
        # The remarks.
        self.comment = comment
        # The tasks.
        self.tasks_shrink = tasks_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.tasks_shrink is not None:
            result['Tasks'] = self.tasks_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Tasks') is not None:
            self.tasks_shrink = m.get('Tasks')
        return self


class BatchUpdateTasksResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The task ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class BatchUpdateTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUpdateTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUpdateTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloneDataSourceRequest(TeaModel):
    def __init__(
        self,
        clone_data_source_name: str = None,
        id: int = None,
    ):
        # The name of the destination data source The name can contain letters, digits, and underscores (_), and must start with a letter. It cannot exceed 60 characters in length.
        # 
        # This parameter is required.
        self.clone_data_source_name = clone_data_source_name
        # The data source ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clone_data_source_name is not None:
            result['CloneDataSourceName'] = self.clone_data_source_name
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloneDataSourceName') is not None:
            self.clone_data_source_name = m.get('CloneDataSourceName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class CloneDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the cloned data source.
        self.id = id
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CloneDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloneDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloneDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertRuleRequestNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The additional configuration of the alert recipient. If the ReceiverType parameter is set to DingdingUrl, you can set this parameter to {"atAll":true} to remind all members in a DingTalk group.
        self.extension = extension
        # The type of the alert recipient. Valid valves:
        # 
        # *   AliUid: Alibaba Cloud account ID.
        # *   Shift Schedules: the personnel in a shift schedule.
        # *   TaskOwner: the task owner. The task owner can receive custom alerts and event alerts.
        # *   Owner: the baseline owner. The baseline owner can receive baseline alerts.
        # *   WebhookUrl: URL of a custom webhook.
        # *   DingdingUrl: DingTalk webhook URL.
        # *   FeishuUrl: Lark webhook URL.
        # *   WeixinUrl: WeCom webhook URL.
        self.receiver_type = receiver_type
        # The ID of the alert recipient.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class CreateAlertRuleRequestNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[CreateAlertRuleRequestNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        # The alert notification channels.
        # 
        # This parameter is required.
        self.channels = channels
        # The interval at which an alert notification is sent. Unit: minutes. Valid values: [5,10000].
        self.interval_in_minutes = interval_in_minutes
        # The maximum number of times an alert notification can be sent within a calendar day. Valid values: [1, 10000].
        self.maximum = maximum
        # The alert recipients.
        # 
        # This parameter is required.
        self.receivers = receivers
        # The end time for silence. The time is in the HH:mm format.
        self.silence_end_time = silence_end_time
        # The start time for silence. The time is in the HH:mm format.
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = CreateAlertRuleRequestNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        # The ID of the scheduling cycle of the instance. Valid values: [1,288].
        self.cycle_id = cycle_id
        # The latest completion time of the instance within the scheduling cycle. The time is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        # The configurations of the scheduling cycle and timeout period of the instance.
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class CreateAlertRuleRequestTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert_enabled: bool = None,
        stream_task_ids: List[int] = None,
    ):
        # Specifies whether to trigger an alert if a batch synchronization task is automatically rerun upon a failure.
        self.auto_rerun_alert_enabled = auto_rerun_alert_enabled
        # The IDs of the real-time computing tasks. This parameter is required when you monitor real-time computing tasks.
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert_enabled is not None:
            result['AutoRerunAlertEnabled'] = self.auto_rerun_alert_enabled
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlertEnabled') is not None:
            self.auto_rerun_alert_enabled = m.get('AutoRerunAlertEnabled')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        # The maximum number of instances on which an error occurs. Valid values: [1,10000].
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        # The maximum percentage of instances on which an error occurs in the workspace to the total number of instances. Valid values: [1-100].
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        # The maximum percentage of fluctuation in the number of auto triggered node instances that are generated in your workspace. Valid values: [1-100].
        self.percentage = percentage
        # The way in which the number of auto triggered node instances that are generated in your workspace fluctuates. Valid values:
        # 
        # *   abs: the absolute value. The number of instances increases or decreases.
        # *   increase: The number of instances increases.
        # *   decrease: The number of instances decreases.
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        # The timeout period. Unit: minutes. Valid values: [1, 21600].
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class CreateAlertRuleRequestTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        # The latest completion time of the instance. The period is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class CreateAlertRuleRequestTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished = None,
        error: CreateAlertRuleRequestTriggerConditionExtensionError = None,
        instance_error_count: CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: CreateAlertRuleRequestTriggerConditionExtensionTimeout = None,
        un_finished: CreateAlertRuleRequestTriggerConditionExtensionUnFinished = None,
    ):
        # The configuration for an alert of the CycleUnfinished type.
        self.cycle_unfinished = cycle_unfinished
        # The configuration for an alert of the Error type.
        self.error = error
        # The configuration for an alert of the InstanceErrorCount type.
        self.instance_error_count = instance_error_count
        # The configuration for an alert of the InstanceErrorPercentage type.
        self.instance_error_percentage = instance_error_percentage
        # The configuration for an alert of the InstanceTransferFluctuate type.
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        # The configuration for an alert of the Timeout type.
        self.timeout = timeout
        # The configuration for an alert of the UnFinished type.
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class CreateAlertRuleRequestTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        # The nodes that are not to be monitored.
        self.allow_tasks = allow_tasks
        # The IDs of monitored objects.
        self.ids = ids
        # The type of the monitored objects. Valid values:
        # 
        # *   Task: node
        # *   Baseline: baseline
        # *   Project: workspace
        # *   BizProcess: workflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAlertRuleRequestTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: CreateAlertRuleRequestTriggerConditionExtension = None,
        target: CreateAlertRuleRequestTriggerConditionTarget = None,
        type: str = None,
    ):
        # The extended information about the rule. This parameter is required for specific types of alerts.
        self.extension = extension
        # The monitored objects.
        self.target = target
        # The alert type. Valid values:
        # 
        # *   Finished: An instance is successfully run.
        # *   UnFinished: An instance does not finish running before a specified point in time.
        # *   Error: An error occurs on an instance.
        # *   CycleUnfinished: An instance does not finish running as expected within a specific cycle.
        # *   Timeout: An instance times out.
        # *   InstanceTransferComplete: An instance is generated by the auto triggered node.
        # *   InstanceTransferFluctuate: The number of generated instances fluctuates.
        # *   ExhaustedError: An error persists after an instance is automatically rerun.
        # *   InstanceKeyword: An instance with errors contains specified keywords.
        # *   InstanceErrorCount: The number of instances on which an error occurs reaches a specified threshold.
        # *   InstanceErrorPercentage: The proportion of instances on which an error occurs in the workspace to the total number of instances reaches a specified threshold.
        # *   ResourceGroupPercentage: The usage rate of the resource group reaches a specified threshold.
        # *   ResourceGroupWaitCount: The number of instances that are waiting for resources in the resource group reaches a specified threshold.
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = CreateAlertRuleRequestTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        name: str = None,
        notification: CreateAlertRuleRequestNotification = None,
        owner: str = None,
        trigger_condition: CreateAlertRuleRequestTriggerCondition = None,
    ):
        # Indicates whether the rule is enabled.
        # 
        # This parameter is required.
        self.enabled = enabled
        # The name of the rule.
        # 
        # This parameter is required.
        self.name = name
        # The configuration for the alert notification.
        self.notification = notification
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        # 
        # This parameter is required.
        self.owner = owner
        # The alert triggering condition.
        # 
        # This parameter is required.
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = CreateAlertRuleRequestNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = CreateAlertRuleRequestTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class CreateAlertRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        name: str = None,
        notification_shrink: str = None,
        owner: str = None,
        trigger_condition_shrink: str = None,
    ):
        # Indicates whether the rule is enabled.
        # 
        # This parameter is required.
        self.enabled = enabled
        # The name of the rule.
        # 
        # This parameter is required.
        self.name = name
        # The configuration for the alert notification.
        self.notification_shrink = notification_shrink
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        # 
        # This parameter is required.
        self.owner = owner
        # The alert triggering condition.
        # 
        # This parameter is required.
        self.trigger_condition_shrink = trigger_condition_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_shrink is not None:
            result['Notification'] = self.notification_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition_shrink is not None:
            result['TriggerCondition'] = self.trigger_condition_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            self.notification_shrink = m.get('Notification')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            self.trigger_condition_shrink = m.get('TriggerCondition')
        return self


class CreateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The rule ID.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateBusinessRequest(TeaModel):
    def __init__(
        self,
        business_name: str = None,
        description: str = None,
        owner: str = None,
        project_id: int = None,
        project_identifier: str = None,
        use_type: str = None,
    ):
        # This parameter is required.
        self.business_name = business_name
        self.description = description
        self.owner = owner
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class CreateBusinessResponseBody(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.business_id = business_id
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        # The alert notification method. Valid values:
        # 
        # *   Mail
        # *   Phone
        # *   Sms
        # *   Ding
        self.channels = channels
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The recipient type. Valid values: AliyunUid, DingToken, FeishuToken, and WebHookUrl.
        self.receiver_type = receiver_type
        # The recipient.
        # 
        # *   If the ReceiverType parameter is set to AliyunUid, set this parameter to the Alibaba Cloud account ID of a user.
        # *   If the ReceiverType parameter is set to DingToken, set this parameter to the token of a DingTalk chatbot.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class CreateDIAlarmRuleRequestNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        mute_interval: int = None,
        notification_channels: List[CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers] = None,
    ):
        # This parameter is deprecated and replaced by the MuteInterval parameter.
        self.inhibition_interval = inhibition_interval
        # The duration of the alert suppression interval. Default value: 5. Unit: minutes.
        self.mute_interval = mute_interval
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The settings of alert notification recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        if self.mute_interval is not None:
            result['MuteInterval'] = self.mute_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        if m.get('MuteInterval') is not None:
            self.mute_interval = m.get('MuteInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class CreateDIAlarmRuleRequestTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        ddl_types: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        # This parameter is deprecated and replaced by the DdlTypes parameter.
        self.ddl_report_tags = ddl_report_tags
        # The types of DDL operations for which the alert rule takes effect.
        self.ddl_types = ddl_types
        # The time interval for alert calculation. Unit: minutes.
        self.duration = duration
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity
        # The alert threshold.
        # 
        # *   If the alert rule is for task status, you do not need to specify a threshold.
        # *   If the alert rule is for failovers, you must specify the number of failovers.
        # *   If the alert rule is for latency, you must specify the latency duration, in seconds.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.ddl_types is not None:
            result['DdlTypes'] = self.ddl_types
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('DdlTypes') is not None:
            self.ddl_types = m.get('DdlTypes')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class CreateDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: CreateDIAlarmRuleRequestNotificationSettings = None,
        trigger_conditions: List[CreateDIAlarmRuleRequestTriggerConditions] = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The ID of the synchronization task with which the alert rule is associated.
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # The description of the alert rule.
        self.description = description
        # Specifies whether to enable the alert rule. By default, the alert rule is disabled.
        self.enabled = enabled
        # The metric type in the alert rule. Valid values:
        # 
        # *   Heartbeat
        # *   FailoverCount
        # *   Delay
        # *   DdlReport
        # *   ResourceUtilization
        # 
        # This parameter is required.
        self.metric_type = metric_type
        # The name of the alert rule.
        # 
        # This parameter is required.
        self.name = name
        # The alert notification settings.
        # 
        # This parameter is required.
        self.notification_settings = notification_settings
        # The conditions that can trigger the alert rule.
        # 
        # This parameter is required.
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = CreateDIAlarmRuleRequestNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = CreateDIAlarmRuleRequestTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class CreateDIAlarmRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        metric_type: str = None,
        name: str = None,
        notification_settings_shrink: str = None,
        trigger_conditions_shrink: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        self.client_token = client_token
        # The ID of the synchronization task with which the alert rule is associated.
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # The description of the alert rule.
        self.description = description
        # Specifies whether to enable the alert rule. By default, the alert rule is disabled.
        self.enabled = enabled
        # The metric type in the alert rule. Valid values:
        # 
        # *   Heartbeat
        # *   FailoverCount
        # *   Delay
        # *   DdlReport
        # *   ResourceUtilization
        # 
        # This parameter is required.
        self.metric_type = metric_type
        # The name of the alert rule.
        # 
        # This parameter is required.
        self.name = name
        # The alert notification settings.
        # 
        # This parameter is required.
        self.notification_settings_shrink = notification_settings_shrink
        # The conditions that can trigger the alert rule.
        # 
        # This parameter is required.
        self.trigger_conditions_shrink = trigger_conditions_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings_shrink is not None:
            result['NotificationSettings'] = self.notification_settings_shrink
        if self.trigger_conditions_shrink is not None:
            result['TriggerConditions'] = self.trigger_conditions_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            self.notification_settings_shrink = m.get('NotificationSettings')
        if m.get('TriggerConditions') is not None:
            self.trigger_conditions_shrink = m.get('TriggerConditions')
        return self


class CreateDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: str = None,
        id: int = None,
        request_id: str = None,
    ):
        # This parameter is deprecated and is replaced by the Id parameter.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the alert rule.
        self.id = id
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDIJobRequestDestinationDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
    ):
        # The name of the data source.
        self.data_source_name = data_source_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        return self


class CreateDIJobRequestJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        # The data type of the destination field. Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.destination_data_type = destination_data_type
        # The data type of the source field. Valid values: Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class CreateDIJobRequestJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        cycle_migration_type: str = None,
        schedule_parameters: str = None,
    ):
        # The synchronization type that requires periodic scheduling. Valid values:
        # 
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        self.cycle_migration_type = cycle_migration_type
        # The scheduling parameters.
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_migration_type is not None:
            result['CycleMigrationType'] = self.cycle_migration_type
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleMigrationType') is not None:
            self.cycle_migration_type = m.get('CycleMigrationType')
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class CreateDIJobRequestJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        # The processing policy. Valid values:
        # 
        # *   Ignore: ignores a DDL message.
        # *   Critical: reports an error for a DDL message.
        # *   Normal: normally processes a DDL message.
        self.action = action
        # The type of the DDL operation. Valid values:
        # 
        # *   RenameColumn
        # *   ModifyColumn
        # *   CreateTable
        # *   TruncateTable
        # *   DropTable
        # *   DropColumn
        # *   AddColumn
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDIJobRequestJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the configuration item. Valid values:
        # 
        # *   src.offline.datasource.max.connection: specifies the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
        # *   dst.offline.truncate: specifies whether to clear the destination table before data writing.
        # *   runtime.offline.speed.limit.enable: specifies whether throttling is enabled for a batch synchronization task.
        # *   runtime.offline.concurrent: specifies the maximum number of parallel threads that are allowed for a batch synchronization task.
        # *   runtime.enable.auto.create.schema: specifies whether schemas are automatically created in the destination of a synchronization task.
        # *   runtime.realtime.concurrent: specifies the maximum number of parallel threads that are allowed for a real-time synchronization task.
        # *   runtime.realtime.failover.minute.dataxcdc: specifies the maximum waiting duration before a synchronization task retries the next restart if the previous restart fails after failover occurs. Unit: minutes.
        # *   runtime.realtime.failover.times.dataxcdc: specifies the maximum number of failures that are allowed for restarting a synchronization task after failovers occur.
        self.name = name
        # The value of the configuration item.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDIJobRequestJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[CreateDIJobRequestJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: CreateDIJobRequestJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[CreateDIJobRequestJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[CreateDIJobRequestJobSettingsRuntimeSettings] = None,
    ):
        # The channel control settings for the synchronization task. You can configure special channel control settings for the following synchronization links: data synchronization between Hologres data sources and data synchronization from Hologres to Kafka.
        # 
        # 1.  Holo2Kafka
        # 
        # *   Example: {"destinationChannelSettings":{"kafkaClientProperties":[{"key":"linger.ms","value":"100"}],"keyColumns":["col3"],"writeMode":"canal"}}
        # *   kafkaClientProperties: the parameters related to a Kafka producer, which are used when you write data to a Kafka data source.
        # *   keyColumns: the names of Kafka columns to which you want to write data.
        # *   writeMode: the writing format of the Kafka data source. Valid values: json and canal.
        # 
        # 2.  Holo2Holo
        # 
        # *   Example: {"destinationChannelSettings":{"conflictMode":"replace","dynamicColumnAction":"replay","writeMode":"replay"}}
        # *   conflictMode: the policy used to handle a conflict that occurs during data writing to Hologres. Valid values: replace and ignore.
        # *   writeMode: the mode in which you want to write data to Hologres. Valid values: replay and insert.
        # *   dynamicColumnAction: the mode in which you want to write data to dynamic columns in a Hologres table. Valid values: replay, insert, and ignore.
        self.channel_settings = channel_settings
        # The data type mappings between source fields and destination fields.
        # 
        # >  "ColumnDataTypeSettings":[ { "SourceDataType":"Bigint", "DestinationDataType":"Text" } ]
        self.column_data_type_settings = column_data_type_settings
        # The settings for periodic scheduling.
        self.cycle_schedule_settings = cycle_schedule_settings
        # The processing settings for DDL messages.
        # 
        # >  "DDLHandlingSettings":[ { "Type":"Insert", "Action":"Normal" } ]
        self.ddl_handling_settings = ddl_handling_settings
        # The runtime settings.
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = CreateDIJobRequestJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = CreateDIJobRequestJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = CreateDIJobRequestJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = CreateDIJobRequestJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class CreateDIJobRequestResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of compute units (CUs) in the resource group for Data Integration that are used for batch synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for Data Integration that are used for batch synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for Data Integration that are used for real-time synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for Data Integration that are used for real-time synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for scheduling that are used for batch synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for scheduling that is used for batch synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class CreateDIJobRequestResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: CreateDIJobRequestResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: CreateDIJobRequestResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: CreateDIJobRequestResourceSettingsScheduleResourceSettings = None,
    ):
        # The resource settings for batch synchronization.
        self.offline_resource_settings = offline_resource_settings
        # The resource settings for real-time synchronization.
        self.realtime_resource_settings = realtime_resource_settings
        # The resource settings for scheduling.
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties(TeaModel):
    def __init__(
        self,
        encoding: str = None,
        timezone: str = None,
    ):
        # The encoding format of the database.
        self.encoding = encoding
        # The time zone.
        self.timezone = timezone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        return self


class CreateDIJobRequestSourceDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
        data_source_properties: CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties = None,
    ):
        # The name of the data source.
        self.data_source_name = data_source_name
        # The properties of the data source.
        self.data_source_properties = data_source_properties

    def validate(self):
        if self.data_source_properties:
            self.data_source_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.data_source_properties is not None:
            result['DataSourceProperties'] = self.data_source_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('DataSourceProperties') is not None:
            temp_model = CreateDIJobRequestSourceDataSourceSettingsDataSourceProperties()
            self.data_source_properties = temp_model.from_map(m['DataSourceProperties'])
        return self


class CreateDIJobRequestTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        # The operation that is performed to select objects. Valid values: Include and Exclude.
        self.action = action
        # The expression.
        self.expression = expression
        # The expression type. Valid values: Exact and Regex.
        self.expression_type = expression_type
        # The object type. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class CreateDIJobRequestTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        # *   DefineIncrementalCondition
        # *   DefineCycleScheduleSettings
        # *   DefineRuntimeSettings
        # *   DefinePartitionKey
        self.rule_action_type = rule_action_type
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which you want to perform the action. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class CreateDIJobRequestTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[CreateDIJobRequestTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[CreateDIJobRequestTableMappingsTransformationRules] = None,
    ):
        # The list of rules used to select synchronization objects in the source.
        self.source_object_selection_rules = source_object_selection_rules
        # The list of transformation rules that you want to apply to the synchronization objects selected from the source. Each entry in the list defines a transformation rule.
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = CreateDIJobRequestTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = CreateDIJobRequestTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class CreateDIJobRequestTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        # *   DefineIncrementalCondition
        # *   DefineCycleScheduleSettings
        # *   DefinePartitionKey
        self.rule_action_type = rule_action_type
        # The expression of the rule. The expression must be a JSON string.
        # 
        # 1.  Example of a renaming rule
        # 
        # *   Example: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922" }
        # *   expression: the expression of the renaming rule. You can use the following variables in an expression: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} specifies the name of the source. ${srcDatabaseName} specifies the name of a source database. ${srcTableName} specifies the name of a source table.
        # 
        # 2.  Example of a column addition rule
        # 
        # *   Example: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}
        # *   If you do not configure such a rule, no fields are added to the destination and no values are assigned by default.
        # *   columnName: the name of the field that is added.
        # *   columnValueType: the value type of the field. Valid values: Constant and Variable.
        # *   columnValue: the value of the field. If the columnValueType parameter is set to Constant, set the columnValue parameter to a constant of the STRING data type. If the columnValueType parameter is set to Variable, set the columnValue parameter to a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME specifies the execution time. DB_NAME_SRC specifies the name of a source database. DATASOURCE_NAME_SRC specifies the name of the source. TABLE_NAME_SRC specifies the name of a source table. DB_NAME_DEST specifies the name of a destination database. DATASOURCE_NAME_DEST specifies the name of the destination. TABLE_NAME_DEST specifies the name of a destination table. DB_NAME_SRC_TRANSED specifies the database name obtained after a transformation.
        # 
        # 3.  Example of a rule used to specify primary key fields for a destination table
        # 
        # *   Example: {"columns":["ukcolumn1","ukcolumn2"]}
        # *   If you do not configure such a rule, the primary key fields in the mapped source table are used for the destination table by default.
        # *   If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # *   If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # 
        # 4.  Example of a rule used to process DML messages
        # 
        # *   Example: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}
        # *   If you do not configure such a rule, the default processing policy for messages generated for insert, update, and delete operations is Normal.
        # *   dmlType: the DML operation. Valid values: Insert, Update, and Delete.
        # *   dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. You can set the dmlAction parameter to Filter only when the dmlType parameter is set to Update or Delete.
        # *   filterCondition: the condition used to filter DML messages. This parameter is required only when the dmlAction parameter is set to Filter.
        # 
        # 5.  Example of a rule used to perform incremental synchronization
        # 
        # *   Example: {"where":"id > 0"}
        # *   You can configure such a rule to perform incremental synchronization.
        # 
        # 6.  Example of a rule used to configure scheduling parameters for an auto triggered task
        # 
        # *   Example: {"cronExpress":" \\* \\* \\* \\* \\* \\*", "cycleType":"1"}
        # *   You can configure such a rule to configure scheduling parameters for an auto triggered task.
        # 
        # 7.  Example of a rule used to specify a partition key
        # 
        # *   Example: {"columns":["id"]}
        # *   You can configure such a rule to specify a partition key.
        self.rule_expression = rule_expression
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which you want to perform the action. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class CreateDIJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        destination_data_source_settings: List[CreateDIJobRequestDestinationDataSourceSettings] = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_settings: CreateDIJobRequestJobSettings = None,
        job_type: str = None,
        migration_type: str = None,
        name: str = None,
        project_id: int = None,
        resource_settings: CreateDIJobRequestResourceSettings = None,
        source_data_source_settings: List[CreateDIJobRequestSourceDataSourceSettings] = None,
        source_data_source_type: str = None,
        table_mappings: List[CreateDIJobRequestTableMappings] = None,
        transformation_rules: List[CreateDIJobRequestTransformationRules] = None,
    ):
        # The description of the synchronization task.
        self.description = description
        # The settings of the destination. Only a single destination is supported.
        # 
        # This parameter is required.
        self.destination_data_source_settings = destination_data_source_settings
        # The destination type. Valid values: Hologres, OSS-HDFS, OSS, MaxCompute, LogHub, StarRocks, DataHub, AnalyticDB for MySQL, Kafka, and Hive.
        # 
        # This parameter is required.
        self.destination_data_source_type = destination_data_source_type
        # This parameter is deprecated and is replaced by the Name parameter.
        self.job_name = job_name
        # The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
        self.job_settings = job_settings
        # The type of the task. This parameter is optional. Valid values:
        # 
        # *   DatabaseRealtimeMigration: A real-time synchronization task used to synchronize only full data, only incremental data, or full and incremental data in multiple tables of multiple databases at the source.
        # *   DatabaseOfflineMigration: A batch synchronization task used to synchronize only full data, only incremental data, or full and incremental data in multiple tables of multiple databases at the source.
        # *   SingleTableRealtimeMigration: A real-time synchronization task used to synchronize only data in single table at the source.
        self.job_type = job_type
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: full synchronization and real-time incremental synchronization of data in an entire database
        # *   RealtimeIncremental: real-time incremental synchronization of data in a single table
        # *   Full: full batch synchronization of data in an entire database
        # *   OfflineIncremental: batch incremental synchronization of data in an entire database
        # *   FullAndOfflineIncremental: full synchronization and batch incremental synchronization of data in an entire database
        # 
        # This parameter is required.
        self.migration_type = migration_type
        # The name of the synchronization task.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id
        # The resource settings.
        # 
        # This parameter is required.
        self.resource_settings = resource_settings
        # The settings of the source. Only a single source is supported.
        # 
        # This parameter is required.
        self.source_data_source_settings = source_data_source_settings
        # The source type. Valid values: PolarDB, MySQL, Kafka, LogHub, Hologres, Oracle, OceanBase, MongoDB, Redshift, Hive, SQL Server, Doris, and ClickHouse.
        # 
        # This parameter is required.
        self.source_data_source_type = source_data_source_type
        # The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
        # 
        # >  [ { "SourceObjectSelectionRules":[ { "ObjectType":"Database", "Action":"Include", "ExpressionType":"Exact", "Expression":"biz_db" }, { "ObjectType":"Schema", "Action":"Include", "ExpressionType":"Exact", "Expression":"s1" }, { "ObjectType":"Table", "Action":"Include", "ExpressionType":"Exact", "Expression":"table1" } ], "TransformationRuleNames":[ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema" } ] } ]
        # 
        # This parameter is required.
        self.table_mappings = table_mappings
        # The list of transformation rules for objects involved in the synchronization task.
        # 
        # >  [ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema", "RuleExpression":"{"expression":"${srcDatasoureName}_${srcDatabaseName}"}" } ]
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.destination_data_source_settings:
            for k in self.destination_data_source_settings:
                if k:
                    k.validate()
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.source_data_source_settings:
            for k in self.source_data_source_settings:
                if k:
                    k.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['DestinationDataSourceSettings'] = []
        if self.destination_data_source_settings is not None:
            for k in self.destination_data_source_settings:
                result['DestinationDataSourceSettings'].append(k.to_map() if k else None)
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['SourceDataSourceSettings'] = []
        if self.source_data_source_settings is not None:
            for k in self.source_data_source_settings:
                result['SourceDataSourceSettings'].append(k.to_map() if k else None)
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.destination_data_source_settings = []
        if m.get('DestinationDataSourceSettings') is not None:
            for k in m.get('DestinationDataSourceSettings'):
                temp_model = CreateDIJobRequestDestinationDataSourceSettings()
                self.destination_data_source_settings.append(temp_model.from_map(k))
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            temp_model = CreateDIJobRequestJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = CreateDIJobRequestResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.source_data_source_settings = []
        if m.get('SourceDataSourceSettings') is not None:
            for k in m.get('SourceDataSourceSettings'):
                temp_model = CreateDIJobRequestSourceDataSourceSettings()
                self.source_data_source_settings.append(temp_model.from_map(k))
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = CreateDIJobRequestTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = CreateDIJobRequestTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class CreateDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        destination_data_source_settings_shrink: str = None,
        destination_data_source_type: str = None,
        job_name: str = None,
        job_settings_shrink: str = None,
        job_type: str = None,
        migration_type: str = None,
        name: str = None,
        project_id: int = None,
        resource_settings_shrink: str = None,
        source_data_source_settings_shrink: str = None,
        source_data_source_type: str = None,
        table_mappings_shrink: str = None,
        transformation_rules_shrink: str = None,
    ):
        # The description of the synchronization task.
        self.description = description
        # The settings of the destination. Only a single destination is supported.
        # 
        # This parameter is required.
        self.destination_data_source_settings_shrink = destination_data_source_settings_shrink
        # The destination type. Valid values: Hologres, OSS-HDFS, OSS, MaxCompute, LogHub, StarRocks, DataHub, AnalyticDB for MySQL, Kafka, and Hive.
        # 
        # This parameter is required.
        self.destination_data_source_type = destination_data_source_type
        # This parameter is deprecated and is replaced by the Name parameter.
        self.job_name = job_name
        # The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
        self.job_settings_shrink = job_settings_shrink
        # The type of the task. This parameter is optional. Valid values:
        # 
        # *   DatabaseRealtimeMigration: A real-time synchronization task used to synchronize only full data, only incremental data, or full and incremental data in multiple tables of multiple databases at the source.
        # *   DatabaseOfflineMigration: A batch synchronization task used to synchronize only full data, only incremental data, or full and incremental data in multiple tables of multiple databases at the source.
        # *   SingleTableRealtimeMigration: A real-time synchronization task used to synchronize only data in single table at the source.
        self.job_type = job_type
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: full synchronization and real-time incremental synchronization of data in an entire database
        # *   RealtimeIncremental: real-time incremental synchronization of data in a single table
        # *   Full: full batch synchronization of data in an entire database
        # *   OfflineIncremental: batch incremental synchronization of data in an entire database
        # *   FullAndOfflineIncremental: full synchronization and batch incremental synchronization of data in an entire database
        # 
        # This parameter is required.
        self.migration_type = migration_type
        # The name of the synchronization task.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id
        # The resource settings.
        # 
        # This parameter is required.
        self.resource_settings_shrink = resource_settings_shrink
        # The settings of the source. Only a single source is supported.
        # 
        # This parameter is required.
        self.source_data_source_settings_shrink = source_data_source_settings_shrink
        # The source type. Valid values: PolarDB, MySQL, Kafka, LogHub, Hologres, Oracle, OceanBase, MongoDB, Redshift, Hive, SQL Server, Doris, and ClickHouse.
        # 
        # This parameter is required.
        self.source_data_source_type = source_data_source_type
        # The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
        # 
        # >  [ { "SourceObjectSelectionRules":[ { "ObjectType":"Database", "Action":"Include", "ExpressionType":"Exact", "Expression":"biz_db" }, { "ObjectType":"Schema", "Action":"Include", "ExpressionType":"Exact", "Expression":"s1" }, { "ObjectType":"Table", "Action":"Include", "ExpressionType":"Exact", "Expression":"table1" } ], "TransformationRuleNames":[ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema" } ] } ]
        # 
        # This parameter is required.
        self.table_mappings_shrink = table_mappings_shrink
        # The list of transformation rules for objects involved in the synchronization task.
        # 
        # >  [ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema", "RuleExpression":"{"expression":"${srcDatasoureName}_${srcDatabaseName}"}" } ]
        self.transformation_rules_shrink = transformation_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_data_source_settings_shrink is not None:
            result['DestinationDataSourceSettings'] = self.destination_data_source_settings_shrink
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings_shrink is not None:
            result['JobSettings'] = self.job_settings_shrink
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings_shrink is not None:
            result['ResourceSettings'] = self.resource_settings_shrink
        if self.source_data_source_settings_shrink is not None:
            result['SourceDataSourceSettings'] = self.source_data_source_settings_shrink
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        if self.table_mappings_shrink is not None:
            result['TableMappings'] = self.table_mappings_shrink
        if self.transformation_rules_shrink is not None:
            result['TransformationRules'] = self.transformation_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationDataSourceSettings') is not None:
            self.destination_data_source_settings_shrink = m.get('DestinationDataSourceSettings')
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            self.job_settings_shrink = m.get('JobSettings')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            self.resource_settings_shrink = m.get('ResourceSettings')
        if m.get('SourceDataSourceSettings') is not None:
            self.source_data_source_settings_shrink = m.get('SourceDataSourceSettings')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        if m.get('TableMappings') is not None:
            self.table_mappings_shrink = m.get('TableMappings')
        if m.get('TransformationRules') is not None:
            self.transformation_rules_shrink = m.get('TransformationRules')
        return self


class CreateDIJobResponseBody(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        id: int = None,
        request_id: str = None,
    ):
        # This parameter is deprecated and is replaced by the Id parameter.
        self.dijob_id = dijob_id
        # The ID of the synchronization task.
        self.id = id
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataAssetTagRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        managers: List[str] = None,
        value_type: str = None,
        values: List[str] = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag administrators.
        self.managers = managers
        # The type of the tag value. Valid values:
        # 
        # *   Boolean
        # *   Int
        # *   String
        # *   Double
        self.value_type = value_type
        # The tag values.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.managers is not None:
            result['Managers'] = self.managers
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Managers') is not None:
            self.managers = m.get('Managers')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class CreateDataAssetTagShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        managers_shrink: str = None,
        value_type: str = None,
        values_shrink: str = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag administrators.
        self.managers_shrink = managers_shrink
        # The type of the tag value. Valid values:
        # 
        # *   Boolean
        # *   Int
        # *   String
        # *   Double
        self.value_type = value_type
        # The tag values.
        self.values_shrink = values_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.managers_shrink is not None:
            result['Managers'] = self.managers_shrink
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        if self.values_shrink is not None:
            result['Values'] = self.values_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Managers') is not None:
            self.managers_shrink = m.get('Managers')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        if m.get('Values') is not None:
            self.values_shrink = m.get('Values')
        return self


class CreateDataAssetTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataAssetTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataAssetTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataAssetTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical = None,
        expected: CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected = None,
        warned: CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain specific types of thresholds, you must query reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If you define the rule by using custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: specifies that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class CreateDataQualityEvaluationTaskRequestDataQualityRules(TeaModel):
    def __init__(
        self,
        checking_config: CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers] = None,
        id: int = None,
        name: str = None,
        sampling_config: CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig = None,
        severity: str = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the monitoring rule.
        self.description = description
        # Specifies whether to enable the monitoring rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        self.id = id
        # The name of the monitoring rule.
        self.name = name
        # The parameters required for sampling.
        self.sampling_config = sampling_config
        # The strength of the monitoring rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The ID of the template used by the monitoring rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SamplingConfig') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class CreateDataQualityEvaluationTaskRequestHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The hook trigger condition. When this condition is met, the hook action is triggered. Only two conditional expressions are supported:
        # 
        # 1.  Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # 2.  Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The hook type. Only one hook type is supported.
        # 
        # *   BlockTaskInstance: Blocks the running of scheduling tasks. A monitor is triggered by scheduling tasks. After a monitor finishes running, the monitor determines whether to block the running of scheduling tasks based on the hook condition.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The additional parameters that are required when alerts are sent. The parameters are JSON-formatted strings. The following keys are supported:
        # 
        # *   atAll: specifies that all members in a group are mentioned when alerts are sent by using DingTalk. This parameter is valid only if you set ReceiverType to DingdingUrl.
        self.extension = extension
        # The type of the alert recipient. Valid values:
        # 
        # *   WebhookUrl
        # *   FeishuUrl
        # *   DingdingUrl
        # *   WeixinUrl
        # *   AliUid
        self.receiver_type = receiver_type
        # The alert recipient.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class CreateDataQualityEvaluationTaskRequestNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The configurations of alert recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = CreateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class CreateDataQualityEvaluationTaskRequestNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[CreateDataQualityEvaluationTaskRequestNotificationsNotifications] = None,
    ):
        # The notification trigger condition. When this condition is met, the alert notification is triggered. Only two conditional expressions are supported:
        # 
        # Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical. Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The configurations of the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = CreateDataQualityEvaluationTaskRequestNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class CreateDataQualityEvaluationTaskRequestTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   hologres
        # *   cdh
        # *   analyticdb_for_mysql
        # *   starrocks
        # *   emr
        # *   analyticdb_for_postgresql
        # 
        # This parameter is required.
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        # 
        # This parameter is required.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class CreateDataQualityEvaluationTaskRequestTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of scheduling tasks. This parameter is valid only if you set Type to ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger type of the monitor. Valid values:
        # 
        # *   ByManual (default): The monitor is manually triggered.
        # *   ByScheduledTaskInstance: The monitor is triggered by the associated scheduling tasks.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        data_quality_rules: List[CreateDataQualityEvaluationTaskRequestDataQualityRules] = None,
        data_source_id: int = None,
        description: str = None,
        hooks: List[CreateDataQualityEvaluationTaskRequestHooks] = None,
        name: str = None,
        notifications: CreateDataQualityEvaluationTaskRequestNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: CreateDataQualityEvaluationTaskRequestTarget = None,
        trigger: CreateDataQualityEvaluationTaskRequestTrigger = None,
    ):
        # The list of monitoring rules that are associated with the monitor. If you configure the ID of a monitoring rule by using the DataQualityRule.Id parameter, the system associates the rule with a created monitor. If you do not configure the ID of a monitoring rule, the system creates a new monitoring rule by using other fields and associates the rule with a created monitor.
        self.data_quality_rules = data_quality_rules
        # The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks = hooks
        # The name of the monitor.
        # 
        # This parameter is required.
        self.name = name
        # The configurations of alert notifications.
        self.notifications = notifications
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The extended configurations in JSON-formatted strings. You can use this parameter only for monitors that are used to monitor the quality of E-MapReduce (EMR) data.
        # 
        # *   queue: The Yarn queue used when a monitor checks the quality of EMR data. By default, the queue configured for the current workspace is used.
        # 
        # *   sqlEngine: The SQL engine used when a monitor checks the quality of EMR data.
        # 
        #     *   HIVE_SQL
        #     *   SPARK_SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the monitor.
        # 
        # This parameter is required.
        self.target = target
        # The trigger configuration of the monitor.
        self.trigger = trigger

    def validate(self):
        if self.data_quality_rules:
            for k in self.data_quality_rules:
                if k:
                    k.validate()
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityRules'] = []
        if self.data_quality_rules is not None:
            for k in self.data_quality_rules:
                result['DataQualityRules'].append(k.to_map() if k else None)
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_rules = []
        if m.get('DataQualityRules') is not None:
            for k in m.get('DataQualityRules'):
                temp_model = CreateDataQualityEvaluationTaskRequestDataQualityRules()
                self.data_quality_rules.append(temp_model.from_map(k))
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = CreateDataQualityEvaluationTaskRequestHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = CreateDataQualityEvaluationTaskRequestTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class CreateDataQualityEvaluationTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        data_quality_rules_shrink: str = None,
        data_source_id: int = None,
        description: str = None,
        hooks_shrink: str = None,
        name: str = None,
        notifications_shrink: str = None,
        project_id: int = None,
        runtime_conf: str = None,
        target_shrink: str = None,
        trigger_shrink: str = None,
    ):
        # The list of monitoring rules that are associated with the monitor. If you configure the ID of a monitoring rule by using the DataQualityRule.Id parameter, the system associates the rule with a created monitor. If you do not configure the ID of a monitoring rule, the system creates a new monitoring rule by using other fields and associates the rule with a created monitor.
        self.data_quality_rules_shrink = data_quality_rules_shrink
        # The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks_shrink = hooks_shrink
        # The name of the monitor.
        # 
        # This parameter is required.
        self.name = name
        # The configurations of alert notifications.
        self.notifications_shrink = notifications_shrink
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The extended configurations in JSON-formatted strings. You can use this parameter only for monitors that are used to monitor the quality of E-MapReduce (EMR) data.
        # 
        # *   queue: The Yarn queue used when a monitor checks the quality of EMR data. By default, the queue configured for the current workspace is used.
        # 
        # *   sqlEngine: The SQL engine used when a monitor checks the quality of EMR data.
        # 
        #     *   HIVE_SQL
        #     *   SPARK_SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the monitor.
        # 
        # This parameter is required.
        self.target_shrink = target_shrink
        # The trigger configuration of the monitor.
        self.trigger_shrink = trigger_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_rules_shrink is not None:
            result['DataQualityRules'] = self.data_quality_rules_shrink
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.hooks_shrink is not None:
            result['Hooks'] = self.hooks_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications_shrink is not None:
            result['Notifications'] = self.notifications_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target_shrink is not None:
            result['Target'] = self.target_shrink
        if self.trigger_shrink is not None:
            result['Trigger'] = self.trigger_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityRules') is not None:
            self.data_quality_rules_shrink = m.get('DataQualityRules')
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Hooks') is not None:
            self.hooks_shrink = m.get('Hooks')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            self.notifications_shrink = m.get('Notifications')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            self.target_shrink = m.get('Target')
        if m.get('Trigger') is not None:
            self.trigger_shrink = m.get('Trigger')
        return self


class CreateDataQualityEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the new monitor.
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataQualityEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataQualityEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataQualityEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: float = None,
        resource_group_id: str = None,
    ):
        # The task runs to configure CU consumption. If Serverless resource groups are used, you must specify this parameter.
        self.cu = cu
        # The identifier of the scheduling resource group configured for running the task.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class CreateDataQualityEvaluationTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        parameters: str = None,
        project_id: int = None,
        runtime_resource: CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource = None,
    ):
        # The ID of the data quality monitoring task.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # Data quality verification execution parameters in JSON format. The available keys are as follows:
        # - triggerTime: the millisecond timestamp of the trigger time. The baseline time of the $[yyyymmdd] expression in the data range of data quality monitoring. Required.
        # 
        # This parameter is required.
        self.parameters = parameters
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the workspace management page to obtain the ID.
        # 
        # This parameter is used to determine the DataWorks workspaces used for this API call.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Resource Group information, which must be filled in when running non-MaxCompute data quality verification.
        self.runtime_resource = runtime_resource

    def validate(self):
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            temp_model = CreateDataQualityEvaluationTaskInstanceRequestRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        return self


class CreateDataQualityEvaluationTaskInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        parameters: str = None,
        project_id: int = None,
        runtime_resource_shrink: str = None,
    ):
        # The ID of the data quality monitoring task.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # Data quality verification execution parameters in JSON format. The available keys are as follows:
        # - triggerTime: the millisecond timestamp of the trigger time. The baseline time of the $[yyyymmdd] expression in the data range of data quality monitoring. Required.
        # 
        # This parameter is required.
        self.parameters = parameters
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the workspace management page to obtain the ID.
        # 
        # This parameter is used to determine the DataWorks workspaces used for this API call.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Resource Group information, which must be filled in when running non-MaxCompute data quality verification.
        self.runtime_resource_shrink = runtime_resource_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource_shrink is not None:
            result['RuntimeResource'] = self.runtime_resource_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource_shrink = m.get('RuntimeResource')
        return self


class CreateDataQualityEvaluationTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the data quality monitoring instance.
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataQualityEvaluationTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataQualityEvaluationTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataQualityEvaluationTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataQualityRuleRequestCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Example:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityRuleRequestCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Example:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityRuleRequestCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Example:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDataQualityRuleRequestCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: CreateDataQualityRuleRequestCheckingConfigThresholdsCritical = None,
        expected: CreateDataQualityRuleRequestCheckingConfigThresholdsExpected = None,
        warned: CreateDataQualityRuleRequestCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = CreateDataQualityRuleRequestCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = CreateDataQualityRuleRequestCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = CreateDataQualityRuleRequestCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class CreateDataQualityRuleRequestCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: CreateDataQualityRuleRequestCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference samples and perform aggregate operations on the reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The method that is used to calculate a threshold. You can leave this parameter empty if you use a rule template. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = CreateDataQualityRuleRequestCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityRuleRequestErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If you define the rule by using custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityRuleRequestSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. You can leave this parameter empty if you use a rule template. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: specifies that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class CreateDataQualityRuleRequestTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table that is limited by the rule in Data Map.
        # 
        # This parameter is required.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityRuleRequest(TeaModel):
    def __init__(
        self,
        checking_config: CreateDataQualityRuleRequestCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[CreateDataQualityRuleRequestErrorHandlers] = None,
        name: str = None,
        project_id: int = None,
        sampling_config: CreateDataQualityRuleRequestSamplingConfig = None,
        severity: str = None,
        target: CreateDataQualityRuleRequestTarget = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Specifies whether to enable the monitoring rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The name of the rule.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = CreateDataQualityRuleRequestCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = CreateDataQualityRuleRequestErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = CreateDataQualityRuleRequestSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = CreateDataQualityRuleRequestTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class CreateDataQualityRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        checking_config_shrink: str = None,
        description: str = None,
        enabled: bool = None,
        error_handlers_shrink: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config_shrink: str = None,
        severity: str = None,
        target_shrink: str = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config_shrink = checking_config_shrink
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Specifies whether to enable the monitoring rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers_shrink = error_handlers_shrink
        # The name of the rule.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config_shrink = sampling_config_shrink
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The monitored object of the rule.
        self.target_shrink = target_shrink
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config_shrink is not None:
            result['CheckingConfig'] = self.checking_config_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.error_handlers_shrink is not None:
            result['ErrorHandlers'] = self.error_handlers_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config_shrink is not None:
            result['SamplingConfig'] = self.sampling_config_shrink
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target_shrink is not None:
            result['Target'] = self.target_shrink
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            self.checking_config_shrink = m.get('CheckingConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('ErrorHandlers') is not None:
            self.error_handlers_shrink = m.get('ErrorHandlers')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            self.sampling_config_shrink = m.get('SamplingConfig')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            self.target_shrink = m.get('Target')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class CreateDataQualityRuleResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the rule.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataQualityRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataQualityRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataQualityRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataQualityRuleTemplateRequestCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference samples and perform aggregate operations on the reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataQualityRuleTemplateRequestSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: specifies that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class CreateDataQualityRuleTemplateRequest(TeaModel):
    def __init__(
        self,
        checking_config: CreateDataQualityRuleTemplateRequestCheckingConfig = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config: CreateDataQualityRuleTemplateRequestSamplingConfig = None,
        visible_scope: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # The applicable scope of the template. Valid values:
        # 
        # *   Tenant: The template is available in all workspaces in the current tenant.
        # *   Project: The template is available only in the current workspace.
        self.visible_scope = visible_scope

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.visible_scope is not None:
            result['VisibleScope'] = self.visible_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = CreateDataQualityRuleTemplateRequestCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = CreateDataQualityRuleTemplateRequestSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('VisibleScope') is not None:
            self.visible_scope = m.get('VisibleScope')
        return self


class CreateDataQualityRuleTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        checking_config_shrink: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config_shrink: str = None,
        visible_scope: str = None,
    ):
        # The check settings for sample data.
        self.checking_config_shrink = checking_config_shrink
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config_shrink = sampling_config_shrink
        # The applicable scope of the template. Valid values:
        # 
        # *   Tenant: The template is available in all workspaces in the current tenant.
        # *   Project: The template is available only in the current workspace.
        self.visible_scope = visible_scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config_shrink is not None:
            result['CheckingConfig'] = self.checking_config_shrink
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config_shrink is not None:
            result['SamplingConfig'] = self.sampling_config_shrink
        if self.visible_scope is not None:
            result['VisibleScope'] = self.visible_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            self.checking_config_shrink = m.get('CheckingConfig')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            self.sampling_config_shrink = m.get('SamplingConfig')
        if m.get('VisibleScope') is not None:
            self.visible_scope = m.get('VisibleScope')
        return self


class CreateDataQualityRuleTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        request_id: str = None,
    ):
        # The Code of the rule template.
        self.code = code
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataQualityRuleTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataQualityRuleTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataQualityRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceRequest(TeaModel):
    def __init__(
        self,
        connection_properties: str = None,
        connection_properties_mode: str = None,
        description: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # The connection configurations of the data source, including the connection address, access identity, and environment information. The envType parameter specifies the environment in which the data source is used. Valid values of the envType parameter:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        # 
        # The parameters that you need to configure to the data source vary based on the mode in which the data source is added. For more information, see [Data source connection information (ConnectionProperties)](https://help.aliyun.com/document_detail/2852465.html).
        # 
        # This parameter is required.
        self.connection_properties = connection_properties
        # The mode in which you want to add the data source. The mode varies based on the data source type. Valid values for MySQL data sources:
        # 
        # *   InstanceMode: instance mode
        # *   UrlMode: connection string mode
        # 
        # This parameter is required.
        self.connection_properties_mode = connection_properties_mode
        # The description of the data source. The description cannot exceed 3,000 characters in length.
        self.description = description
        # The name of the data source. The name can be up to 255 characters in length and can contain letters, digits, and underscores (_). The name must start with a letter.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/overview) and go to the workspace management page to obtain the ID.
        # 
        # This parameter is used to determine the DataWorks workspaces used for this API call.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The type of the data source. More than 70 types of data sources are supported in DataWorks. For more information, see [Data source types](https://help.aliyun.com/document_detail/2852465.html).
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The data source ID.
        self.id = id
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceSharedRuleRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        env_type: str = None,
        shared_user: str = None,
        target_project_id: int = None,
    ):
        # The data source ID.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # Share data sources to the target project environment, including
        # - Dev (Development Environment)
        # - Prod (production environment)
        # 
        # This parameter is required.
        self.env_type = env_type
        # The user with which you want to share the data source. If you do not configure this parameter, the data source is shared to an entire workspace.
        self.shared_user = shared_user
        # The ID of the workspace to which you want to share the data source. You cannot share the data source to the workspace with which the data source is associated.
        # 
        # This parameter is required.
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.shared_user is not None:
            result['SharedUser'] = self.shared_user
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('SharedUser') is not None:
            self.shared_user = m.get('SharedUser')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class CreateDataSourceSharedRuleResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The sharing rule ID.
        self.id = id
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDataSourceSharedRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceSharedRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceSharedRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileRequest(TeaModel):
    def __init__(
        self,
        advanced_settings: str = None,
        apply_schedule_immediately: bool = None,
        auto_parsing: bool = None,
        auto_rerun_interval_millis: int = None,
        auto_rerun_times: int = None,
        connection_name: str = None,
        content: str = None,
        create_folder_if_not_exists: bool = None,
        cron_express: str = None,
        cycle_type: str = None,
        dependent_node_id_list: str = None,
        dependent_type: str = None,
        end_effect_date: int = None,
        file_description: str = None,
        file_folder_path: str = None,
        file_name: str = None,
        file_type: int = None,
        ignore_parent_skip_running_property: bool = None,
        image_id: str = None,
        input_list: str = None,
        input_parameters: str = None,
        output_parameters: str = None,
        owner: str = None,
        para_value: str = None,
        project_id: int = None,
        project_identifier: str = None,
        rerun_mode: str = None,
        resource_group_id: int = None,
        resource_group_identifier: str = None,
        scheduler_type: str = None,
        start_effect_date: int = None,
        start_immediately: bool = None,
        stop: bool = None,
        timeout: int = None,
    ):
        self.advanced_settings = advanced_settings
        self.apply_schedule_immediately = apply_schedule_immediately
        self.auto_parsing = auto_parsing
        self.auto_rerun_interval_millis = auto_rerun_interval_millis
        self.auto_rerun_times = auto_rerun_times
        self.connection_name = connection_name
        self.content = content
        self.create_folder_if_not_exists = create_folder_if_not_exists
        self.cron_express = cron_express
        self.cycle_type = cycle_type
        self.dependent_node_id_list = dependent_node_id_list
        self.dependent_type = dependent_type
        self.end_effect_date = end_effect_date
        self.file_description = file_description
        self.file_folder_path = file_folder_path
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.file_type = file_type
        self.ignore_parent_skip_running_property = ignore_parent_skip_running_property
        self.image_id = image_id
        self.input_list = input_list
        self.input_parameters = input_parameters
        self.output_parameters = output_parameters
        self.owner = owner
        self.para_value = para_value
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.rerun_mode = rerun_mode
        self.resource_group_id = resource_group_id
        self.resource_group_identifier = resource_group_identifier
        self.scheduler_type = scheduler_type
        self.start_effect_date = start_effect_date
        self.start_immediately = start_immediately
        self.stop = stop
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_settings is not None:
            result['AdvancedSettings'] = self.advanced_settings
        if self.apply_schedule_immediately is not None:
            result['ApplyScheduleImmediately'] = self.apply_schedule_immediately
        if self.auto_parsing is not None:
            result['AutoParsing'] = self.auto_parsing
        if self.auto_rerun_interval_millis is not None:
            result['AutoRerunIntervalMillis'] = self.auto_rerun_interval_millis
        if self.auto_rerun_times is not None:
            result['AutoRerunTimes'] = self.auto_rerun_times
        if self.connection_name is not None:
            result['ConnectionName'] = self.connection_name
        if self.content is not None:
            result['Content'] = self.content
        if self.create_folder_if_not_exists is not None:
            result['CreateFolderIfNotExists'] = self.create_folder_if_not_exists
        if self.cron_express is not None:
            result['CronExpress'] = self.cron_express
        if self.cycle_type is not None:
            result['CycleType'] = self.cycle_type
        if self.dependent_node_id_list is not None:
            result['DependentNodeIdList'] = self.dependent_node_id_list
        if self.dependent_type is not None:
            result['DependentType'] = self.dependent_type
        if self.end_effect_date is not None:
            result['EndEffectDate'] = self.end_effect_date
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.ignore_parent_skip_running_property is not None:
            result['IgnoreParentSkipRunningProperty'] = self.ignore_parent_skip_running_property
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.input_list is not None:
            result['InputList'] = self.input_list
        if self.input_parameters is not None:
            result['InputParameters'] = self.input_parameters
        if self.output_parameters is not None:
            result['OutputParameters'] = self.output_parameters
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.para_value is not None:
            result['ParaValue'] = self.para_value
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        if self.scheduler_type is not None:
            result['SchedulerType'] = self.scheduler_type
        if self.start_effect_date is not None:
            result['StartEffectDate'] = self.start_effect_date
        if self.start_immediately is not None:
            result['StartImmediately'] = self.start_immediately
        if self.stop is not None:
            result['Stop'] = self.stop
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdvancedSettings') is not None:
            self.advanced_settings = m.get('AdvancedSettings')
        if m.get('ApplyScheduleImmediately') is not None:
            self.apply_schedule_immediately = m.get('ApplyScheduleImmediately')
        if m.get('AutoParsing') is not None:
            self.auto_parsing = m.get('AutoParsing')
        if m.get('AutoRerunIntervalMillis') is not None:
            self.auto_rerun_interval_millis = m.get('AutoRerunIntervalMillis')
        if m.get('AutoRerunTimes') is not None:
            self.auto_rerun_times = m.get('AutoRerunTimes')
        if m.get('ConnectionName') is not None:
            self.connection_name = m.get('ConnectionName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateFolderIfNotExists') is not None:
            self.create_folder_if_not_exists = m.get('CreateFolderIfNotExists')
        if m.get('CronExpress') is not None:
            self.cron_express = m.get('CronExpress')
        if m.get('CycleType') is not None:
            self.cycle_type = m.get('CycleType')
        if m.get('DependentNodeIdList') is not None:
            self.dependent_node_id_list = m.get('DependentNodeIdList')
        if m.get('DependentType') is not None:
            self.dependent_type = m.get('DependentType')
        if m.get('EndEffectDate') is not None:
            self.end_effect_date = m.get('EndEffectDate')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IgnoreParentSkipRunningProperty') is not None:
            self.ignore_parent_skip_running_property = m.get('IgnoreParentSkipRunningProperty')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InputList') is not None:
            self.input_list = m.get('InputList')
        if m.get('InputParameters') is not None:
            self.input_parameters = m.get('InputParameters')
        if m.get('OutputParameters') is not None:
            self.output_parameters = m.get('OutputParameters')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParaValue') is not None:
            self.para_value = m.get('ParaValue')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        if m.get('SchedulerType') is not None:
            self.scheduler_type = m.get('SchedulerType')
        if m.get('StartEffectDate') is not None:
            self.start_effect_date = m.get('StartEffectDate')
        if m.get('StartImmediately') is not None:
            self.start_immediately = m.get('StartImmediately')
        if m.get('Stop') is not None:
            self.stop = m.get('Stop')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateFileResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFolderRequest(TeaModel):
    def __init__(
        self,
        folder_path: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.folder_path = folder_path
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_path is not None:
            result['FolderPath'] = self.folder_path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderPath') is not None:
            self.folder_path = m.get('FolderPath')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class CreateFolderResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateFolderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFolderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFolderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFunctionRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateFunctionResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the UDF.
        self.id = id
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLineageRelationshipRequest(TeaModel):
    def __init__(
        self,
        dst_entity: LineageEntity = None,
        src_entity: LineageEntity = None,
        task: LineageTask = None,
    ):
        self.dst_entity = dst_entity
        self.src_entity = src_entity
        self.task = task

    def validate(self):
        if self.dst_entity:
            self.dst_entity.validate()
        if self.src_entity:
            self.src_entity.validate()
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_entity is not None:
            result['DstEntity'] = self.dst_entity.to_map()
        if self.src_entity is not None:
            result['SrcEntity'] = self.src_entity.to_map()
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstEntity') is not None:
            temp_model = LineageEntity()
            self.dst_entity = temp_model.from_map(m['DstEntity'])
        if m.get('SrcEntity') is not None:
            temp_model = LineageEntity()
            self.src_entity = temp_model.from_map(m['SrcEntity'])
        if m.get('Task') is not None:
            temp_model = LineageTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class CreateLineageRelationshipShrinkRequest(TeaModel):
    def __init__(
        self,
        dst_entity_shrink: str = None,
        src_entity_shrink: str = None,
        task_shrink: str = None,
    ):
        self.dst_entity_shrink = dst_entity_shrink
        self.src_entity_shrink = src_entity_shrink
        self.task_shrink = task_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_entity_shrink is not None:
            result['DstEntity'] = self.dst_entity_shrink
        if self.src_entity_shrink is not None:
            result['SrcEntity'] = self.src_entity_shrink
        if self.task_shrink is not None:
            result['Task'] = self.task_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstEntity') is not None:
            self.dst_entity_shrink = m.get('DstEntity')
        if m.get('SrcEntity') is not None:
            self.src_entity_shrink = m.get('SrcEntity')
        if m.get('Task') is not None:
            self.task_shrink = m.get('Task')
        return self


class CreateLineageRelationshipResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.id = id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLineageRelationshipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLineageRelationshipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLineageRelationshipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        parent_id: str = None,
        type: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        self.parent_id = parent_id
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        resource_group_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The ID of the serverless resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id
        # The ID of the virtual private cloud (VPC).
        # 
        # This parameter is required.
        self.vpc_id = vpc_id
        # The VSwitch ID.
        # 
        # This parameter is required.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class CreateNetworkResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The network ID.
        self.id = id
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNodeRequest(TeaModel):
    def __init__(
        self,
        container_id: int = None,
        project_id: int = None,
        scene: str = None,
        spec: str = None,
    ):
        # The container ID. If you want to create a node in a container, you must configure this parameter to specify the container. The container can be a workflow or a node in a container.
        # 
        # >  If you configure this parameter, the path field defined in FlowSpec becomes invalid.
        self.container_id = container_id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The scene of the node. This parameter determines the location (the DataStudio pane or the Manual pane) of the node. You can set this parameter to DataworksManualWorkflow only if the ContainerId parameter is configured and the container specified by ContainerId is a manually triggered workflow.
        # 
        # Valid values:
        # 
        # *   DataworksProject
        # *   DataworksManualWorkflow
        # *   DataworksManualTask
        # 
        # This parameter is required.
        self.scene = scene
        # { "type": "object", "description": "CycleWorkflow the structure of the workflow configurations", "properties": { "version": { "type": "string", "description": "the version ID of the workflow configuration files" }, "kind": { "type": "string", "description": "the category ID of the workflow", "enum": [ "CycleWorkflow", "ManualWorkflow", "ManualNode", "TemporaryWorkflow", "PaiFlow", "BatchDeployment", "DataSource", "DataQuality", "DataService", "DataCatalog", "Table", "Node", "Component", "Resource", "Function", "Workflow" ] }, "spec": { "type": "object", "description": "the key configurations of the workflow", "properties": { "name": { "type": "string", "description": "the readable name identifier of the workflow" }, "id": { "type": "string", "description": "the UUID of the workflow" }, "type": { "type": "string", "description": "the type of the workflow instance", "enum": [ "CycleWorkflow", "ManualWorkflow" ] }, "owner": { "type": "string", "description": "the system user ID of the workflow owner" }, "description": { "type": "string", "description": "the detailed description of the features and usage of the workflow" }, "workflows": { "type": "array", "description": an array of node configurations in the workflow. The workflows can be run at the same time", "items": { "type": "object", "properties": { "script": { "type": "object", "description": "the script parameters", "properties": { "path": { "type": "string", "description": "the storage path of the script file. Example: HDFS/S3" }, "runtime": { "type": "object", "description": "the parameter settings for the runtime environment, such as the specifications of computing resources" }, "id": { "type": "string", "description": "the unique identifiers of the script parameters" } } }, "id": { "type": "string", "description": "the ID of the node in the workflow" }, "trigger": { "type": "object", "description": "the rule configurations to trigger the node, "properties": { "type": { "type": "string", "enum": [ "Scheduler", "Manual", "Streaming", "None" ], "description": "the trigger type. Valid values: Scheduler, Manual, Streaming, and None" }, "id": { "type": "string", "description": "the trigger ID" }, "cron": { "type": "string", "description": "the scheduling rule of the node. The rule is in the cron expression format" }, "startTime": { "type": "string", "description": "the start time for scheduling. The value is in the ISO 8601 format" }, "endTime": { "type": "string", "description": "the end time for scheduling. The value is in the ISO 8601 format" }, "timezone": { "type": "string", "description": "the time zone. Example: UTC+8" }, "delaySeconds": { "type": "number", "description": "the delayed execution time. Unit: seconds" } } }, "strategy": { "type": "object", "description": "the execution policy parameters", "properties": { "timeout": { "type": "number", "description": "the timeout period. Unit: seconds" }, "instanceMode": { "type": "string", "enum": [ "T+1", "Immediately" ], "description": "the instance scheduling mode. Valid values: T+1 and Immediately" }, "rerunMode": { "type": "string", "enum": [ "Allowed", "Denied", "FailureAllowed" ], "description": "the rerun mode. Valid values: Allowed, Denied, and FailureAllowed" }, "rerunTimes": { "type": "number", "description": "the maximum number of reruns allowed after a failure" }, "rerunInterval": { "type": "number", "description": "the rerun interval. Unit: seconds" }, "failureStrategy": { "type": "string", "enum": [ "Continue", "Break" ], "description": "the failure handling policy. Valid values: Continue and Break" }, "recurrenceType": { "type": "string", "enum": [ "Normal", "Pause", "Skip", "NoneAuto" ], "description": "the running mode of the auto triggered node. Valid values: Normal, Pause, Skip, and NoneAuto" } } }, "name": { "type": "string", "description": "the readable name of the node" }, "owner": { "type": "string", "description": "the system ID of the node owner" }, "description": { "type": "string", "description": "the feature description of the node" }, "citable": { "type": "boolean", "description": "specifies whether the node can be referenced by other workflows. Valid values: true and false" }, "metadata": { "type": "object", "description": "the container that stores the metadata information", "properties": { "owner": { "type": "string", "description": "the metadata owner ID" }, "project": { "type": "object", "properties": { "projectIdentifier": { "type": "string", "description": "the unique code of the project" }, "projectName": { "type": "string", "description": "the project name" }, "projectId": { "type": "string", "Description": "the project ID" } } }, "ownerName": { "type": "string", "description": "the name of the project owner" }, "projectId": { "type": "string", "description": "the ID of the associated project" } } }, "inputs": { "type": "object", "description": "the structure of the node input", "properties": { "nodeOutputs": { "type": "array", "description": "the configuration items for node input", "items": { "type": "object", "properties": { "data": { "type": "string", "description": "the content of the node input" }, "artifactType": { "type": "string", "enum": [ "Table", "File", "NodeOutput", "Variable" ], "description": "the type of the node input. Valid values: Table, File, NodeOutput, and Variable" }, "refTableName": { "type": "string", "description": "the name of the referenced table" }, "isDefault": { "type": "boolean", "description": "specifies whether the table is the default output } } } }, "tables": { "type": "array", "description": "the metadata collection in the input table", "items": { "type": "object", "properties": { "artifactType": { "type": "string", "enum": [ "Table", "File", "NodeOutput", "Variable" ], "description": "the type of the table" }, "guid": { "type": "string", "description": "the GUID of the table" } } } } } }, "outputs": { "type": "object", "description": "the structure of the node output", "properties": { "nodeOutputs": { "type": "array", "description": "the configuration items for node output", "items": { "type": "object", "properties": { "data": { "type": "string", "description": "the content of the node output" }, "artifactType": { "type": "string", "enum": [ "Table", "File", "NodeOutput", "Variable" ], "description": "the type of the node output. Valid values: Table, File, NodeOutput, and Variable" }, "refTableName": { "type": "string", "description": "the name of the referenced table" }, "isDefault": { "type": "boolean", "description": "specifies whether the table is the default output } } } }, "tables": { "type": "array", "description": "the metadata collection in the output table", "items": { "type": "object", "properties": { "artifactType": { "type": "string", "enum": [ "Table", "File", "NodeOutput", "Variable" ], "description": "the type of the table" }, "guid": { "type": "string", "description": "the GUID of the table" } } } } } }, "nodes": { "type": "array", "description": "the configuration items for descendant nodes that are used for workflow nesting", "items": { "type": "object", "properties": { "recurrence": { "type": "string", "enum": [ "Normal", "Pause", "Skip", "NoneAuto" ], "description": "the running mode of the descendant node" }, "id": { "type": "string", "description": "the descendant node ID" }, "timeout": { "type": "number", "description": "the timeout period of the descendant node. Unit: seconds" }, "instanceMode": { "type": "string", "enum": [ "T+1", "Immediately" ], "description": "the instance scheduling mode of the descendant node. Valid values: T+1 and Immediately" }, "rerunMode": { "type": "string", "enum": [ "Allowed", "Denied", "FailureAllowed" ], "description": "the rerun mode of the descendant node" }, "rerunTimes": { "type": "number", "description": "the maximum number of reruns allowed after a failure for the descendant node" }, "rerunInterval": { "type": "number", "description": "the rerun interval" }, "datasource": { "type": "object", "description": "the parameters of the associated data source", "properties": { "name": { "type": "string", "description": "the name of the data source" }, "type": { "type": "string", "description": "the type of the data source. Examples: MySQL and Oracle" } } }, "script": { "type": "object", "description": "the script configurations of the node", "properties": { "language": { "type": "string", "enum": [ "python2", "python3", "java8", "java11", "java17" ], "description": "the programming language of the script" }, "path": { "type": "string", "description": "the storage path of the code" }, "runtime": { "type": "object", "description": "the configurations of the runtime environment" }, "content": { "type": "string", "description": "the content of the inline script" }, "id": { "type": "string", "description": "the identifier of the script content" }, "parameters": { "type": "array", "description": "the parameters for initialization", "items": { "type": "object", "properties": { "name": { "type": "string", "description": "the identifier of the parameter name" }, "artifactType": { "type": "string", "enum": [ "Table", "File", "NodeOutput", "Variable" ], "description": "the identifier of the data type" }, "scope": { "type": "string", "enum": [ "Tenant", "Workspace", "Workflow", "NodeParameter", "NodeContext" ], "description": "the application scope of the parameter" }, "type": { "type": "string", "enum": [ "NoKvVariableExpression", "System", "Constant", "NodeOutput", "PaiOutput", "PassThrough" ], "description": "the type of the parameter" }, "value": { "type": "string", "description": "the default value of the parameter" }, "id": { "type": "string", "description": "the parameter ID" } } } } } }, "trigger": { "type": "object", "description": "the configurations of the trigger at the node level. You can overwrite or inherit the configurations" }, "runtimeResource": { "type": "object", "description": "the configurations of computing resources, such as CPU and memory" }, "name": { "type": "string", "description": "the readable name of the descendant node" }, "owner": { "type": "string", "description": "the ID of the descendant node owner" }, "metadata": { "type": "object", "description": "the extended metadata of the descendant node" }, "inputs": { "type": "object", "description": "the parameter definitions of the node input" }, "outputs": { "type": "object", "description": "the parameter definitions of the node output" } } } }, "dependencies": { "type": "array", "description": "the node dependencies", "items": { "type": "object", "properties": { "nodeId": { "type": "string", "description": "the ID of the current node" }, "depends": { "type": "array", "description": "the ancestor node output", "items": { "type": "object", "properties": { "type": { "type": "string", "enum": [ "Normal", "CrossCycleDependsOnSelf", "CrossCycleDependsOnChildren", "CrossCycleDependsOnOtherNode" ], "description": "the dependency type. Valid values: Normal, CrossCycleDependsOnSelf, CrossCycleDependsOnChildren, and CrossCycleDependsOnOtherNode" }, "output": { "type": "string", "description": "the unique identifier of the ancestor node output" }, "refTableName": { "type": "string", "description": "the identifier of the referenced table name" } } } } } } } } } }, "metadata": { "type": "object", "description": "the high-level metadata of the workflow", "properties": { "innerVersion": { "type": "object", "description": "the mappings between the versions of components", "additionalProperties": { "type": "number" } }, "gmtModified": { "type": "number", "description": "the last modification time. The value is a UNIX timestamp" }, "projectId": { "type": "string", "description": "the ID of the associated project" }, "uuid": { "type": "string", "description": "the GUID of the instance" } } } } } }, "required": [ "version", "kind", "spec" ] }
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateNodeResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the node.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePipelineRunRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        object_ids: List[str] = None,
        project_id: int = None,
        type: str = None,
    ):
        # The description of the process.
        self.description = description
        # The IDs of entities to which you want to apply the process.
        # 
        # >  A process can be applied to only a single entity and its child entities. If you specify multiple entities in the array, the process is applied only to the first entity in the array and its child entities. Make sure that the array in your request contains only one element. Extra elements will be ignored.
        # 
        # This parameter is required.
        self.object_ids = object_ids
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to deploy or undeploy the entity. Valid values:
        # 
        # *   Online: deploys the entity.
        # *   Offline: undeploys the entity.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.object_ids is not None:
            result['ObjectIds'] = self.object_ids
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ObjectIds') is not None:
            self.object_ids = m.get('ObjectIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePipelineRunShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        object_ids_shrink: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # The description of the process.
        self.description = description
        # The IDs of entities to which you want to apply the process.
        # 
        # >  A process can be applied to only a single entity and its child entities. If you specify multiple entities in the array, the process is applied only to the first entity in the array and its child entities. Make sure that the array in your request contains only one element. Extra elements will be ignored.
        # 
        # This parameter is required.
        self.object_ids_shrink = object_ids_shrink
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to deploy or undeploy the entity. Valid values:
        # 
        # *   Online: deploys the entity.
        # *   Offline: undeploys the entity.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.object_ids_shrink is not None:
            result['ObjectIds'] = self.object_ids_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ObjectIds') is not None:
            self.object_ids_shrink = m.get('ObjectIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        # The ID of the process.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateProjectRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[CreateProjectRequestAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        name: str = None,
        pai_task_enabled: bool = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspace belongs. You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) and go to the Resource Group page to query the ID.
        # 
        # You must configure this parameter to specify an Alibaba Cloud resource group for the workspace that you want to create.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # The description of the workspace.
        self.description = description
        # Specifies whether to enable the development environment. Valid values:
        # 
        # *   true : enables the development environment. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: disables the development environment. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Specifies whether to disable the Develop role. Valid values:
        # 
        # *   false (default)
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        # 
        # This parameter is required.
        self.display_name = display_name
        # The name of the workspace.
        # 
        # Limits:
        # 
        # *   The workspace name must be unqiue in a region.
        # *   The workspace name can contain letters, digits, and underscores (_), and must start with a letter.
        # *   The workspace name must be 3 to 28 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # Specifies whether to enable scheduling of Platform for AI (PAI) tasks. Valid values:
        # 
        # *   true: enables scheduling of PAI tasks. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: disables scheduling of PAI tasks.
        self.pai_task_enabled = pai_task_enabled

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.name is not None:
            result['Name'] = self.name
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = CreateProjectRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        return self


class CreateProjectShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        name: str = None,
        pai_task_enabled: bool = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspace belongs. You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) and go to the Resource Group page to query the ID.
        # 
        # You must configure this parameter to specify an Alibaba Cloud resource group for the workspace that you want to create.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        # The description of the workspace.
        self.description = description
        # Specifies whether to enable the development environment. Valid values:
        # 
        # *   true : enables the development environment. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: disables the development environment. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Specifies whether to disable the Develop role. Valid values:
        # 
        # *   false (default)
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        # 
        # This parameter is required.
        self.display_name = display_name
        # The name of the workspace.
        # 
        # Limits:
        # 
        # *   The workspace name must be unqiue in a region.
        # *   The workspace name can contain letters, digits, and underscores (_), and must start with a letter.
        # *   The workspace name must be 3 to 28 characters in length.
        # 
        # This parameter is required.
        self.name = name
        # Specifies whether to enable scheduling of Platform for AI (PAI) tasks. Valid values:
        # 
        # *   true: enables scheduling of PAI tasks. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: disables scheduling of PAI tasks.
        self.pai_task_enabled = pai_task_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.name is not None:
            result['Name'] = self.name
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        return self


class CreateProjectResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        request_id: str = None,
    ):
        # The workspace ID.
        self.id = id
        # The workspace ID. Note: This parameter is deprecated and is replaced by the Id parameter.
        self.project_id = project_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # This parameter specifies the roles that you can assign to a member when you add the member.
        # 
        # This parameter is required.
        self.role_codes = role_codes
        # The ID of the account that you want to add to the workspace as a member. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click **Tenant Members and Roles**. On the Tenant Members and Roles page, view the ID of the account that you want to add to the workspace as a member.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProjectMemberShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # This parameter specifies the roles that you can assign to a member when you add the member.
        # 
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # The ID of the account that you want to add to the workspace as a member. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click **Tenant Members and Roles**. On the Tenant Members and Roles page, view the ID of the account that you want to add to the workspace as a member.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_file: str = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        self.resource_file = resource_file
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_file is not None:
            result['ResourceFile'] = self.resource_file
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceFile') is not None:
            self.resource_file = m.get('ResourceFile')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateResourceAdvanceRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_file_object: BinaryIO = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        self.resource_file_object = resource_file_object
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_file_object is not None:
            result['ResourceFile'] = self.resource_file_object
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceFile') is not None:
            self.resource_file_object = m.get('ResourceFile')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateResourceResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the file resource.
        self.id = id
        # A5B97987-66EA-5563-9599-A2752292XXXX
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceFileRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        file_description: str = None,
        file_folder_path: str = None,
        file_name: str = None,
        file_type: int = None,
        origin_resource_name: str = None,
        owner: str = None,
        project_id: int = None,
        register_to_calc_engine: bool = None,
        resource_file: str = None,
        storage_url: str = None,
        upload_mode: bool = None,
    ):
        # The code for the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, open the directed acyclic graph (DAG) of a node of the file type, right-click the node, and then select View Code.
        self.content = content
        # The description of the file.
        self.file_description = file_description
        # The path of the file.
        # 
        # This parameter is required.
        self.file_folder_path = file_folder_path
        # The name of the file.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The type of the code for the file.
        # 
        # The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html). You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
        # 
        # This parameter is required.
        self.file_type = file_type
        # The name of the original resource file.
        # 
        # This parameter is required.
        self.origin_resource_name = origin_resource_name
        # The ID of the Alibaba Cloud account used by the file owner. If this parameter is not configured, the ID of the Alibaba Cloud account of the user who calls the operation is used by default.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to upload the resource file to a desired compute engine.
        # 
        # This parameter is required.
        self.register_to_calc_engine = register_to_calc_engine
        # The URL of the Object Storage Service (OSS) bucket to which you upload the file. The URL is provided by the POP platform.
        self.resource_file = resource_file
        # The storage path of the resource file in a desired compute engine. This parameter takes effect only for E-MapReduce (EMR) and Cloudera\\"s Distribution including Apache Hadoop (CDH) compute engines. In an EMR compute engine, this parameter is configured in the [osshdfs]://path/to/object format. In a CDH compute engine, this parameter is set to /user/admin/lib by default.
        self.storage_url = storage_url
        # The upload mode of MaxCompute file resources. This parameter takes effect only for MaxCompute file resources. Valid values:
        # 
        # *   true: indicates the resource upload and download mode.
        # *   false: indicates the online editing mode.
        self.upload_mode = upload_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.origin_resource_name is not None:
            result['OriginResourceName'] = self.origin_resource_name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.register_to_calc_engine is not None:
            result['RegisterToCalcEngine'] = self.register_to_calc_engine
        if self.resource_file is not None:
            result['ResourceFile'] = self.resource_file
        if self.storage_url is not None:
            result['StorageURL'] = self.storage_url
        if self.upload_mode is not None:
            result['UploadMode'] = self.upload_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('OriginResourceName') is not None:
            self.origin_resource_name = m.get('OriginResourceName')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RegisterToCalcEngine') is not None:
            self.register_to_calc_engine = m.get('RegisterToCalcEngine')
        if m.get('ResourceFile') is not None:
            self.resource_file = m.get('ResourceFile')
        if m.get('StorageURL') is not None:
            self.storage_url = m.get('StorageURL')
        if m.get('UploadMode') is not None:
            self.upload_mode = m.get('UploadMode')
        return self


class CreateResourceFileAdvanceRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        file_description: str = None,
        file_folder_path: str = None,
        file_name: str = None,
        file_type: int = None,
        origin_resource_name: str = None,
        owner: str = None,
        project_id: int = None,
        register_to_calc_engine: bool = None,
        resource_file_object: BinaryIO = None,
        storage_url: str = None,
        upload_mode: bool = None,
    ):
        # The code for the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, open the directed acyclic graph (DAG) of a node of the file type, right-click the node, and then select View Code.
        self.content = content
        # The description of the file.
        self.file_description = file_description
        # The path of the file.
        # 
        # This parameter is required.
        self.file_folder_path = file_folder_path
        # The name of the file.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The type of the code for the file.
        # 
        # The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html). You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
        # 
        # This parameter is required.
        self.file_type = file_type
        # The name of the original resource file.
        # 
        # This parameter is required.
        self.origin_resource_name = origin_resource_name
        # The ID of the Alibaba Cloud account used by the file owner. If this parameter is not configured, the ID of the Alibaba Cloud account of the user who calls the operation is used by default.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # Specifies whether to upload the resource file to a desired compute engine.
        # 
        # This parameter is required.
        self.register_to_calc_engine = register_to_calc_engine
        # The URL of the Object Storage Service (OSS) bucket to which you upload the file. The URL is provided by the POP platform.
        self.resource_file_object = resource_file_object
        # The storage path of the resource file in a desired compute engine. This parameter takes effect only for E-MapReduce (EMR) and Cloudera\\"s Distribution including Apache Hadoop (CDH) compute engines. In an EMR compute engine, this parameter is configured in the [osshdfs]://path/to/object format. In a CDH compute engine, this parameter is set to /user/admin/lib by default.
        self.storage_url = storage_url
        # The upload mode of MaxCompute file resources. This parameter takes effect only for MaxCompute file resources. Valid values:
        # 
        # *   true: indicates the resource upload and download mode.
        # *   false: indicates the online editing mode.
        self.upload_mode = upload_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.origin_resource_name is not None:
            result['OriginResourceName'] = self.origin_resource_name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.register_to_calc_engine is not None:
            result['RegisterToCalcEngine'] = self.register_to_calc_engine
        if self.resource_file_object is not None:
            result['ResourceFile'] = self.resource_file_object
        if self.storage_url is not None:
            result['StorageURL'] = self.storage_url
        if self.upload_mode is not None:
            result['UploadMode'] = self.upload_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('OriginResourceName') is not None:
            self.origin_resource_name = m.get('OriginResourceName')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RegisterToCalcEngine') is not None:
            self.register_to_calc_engine = m.get('RegisterToCalcEngine')
        if m.get('ResourceFile') is not None:
            self.resource_file_object = m.get('ResourceFile')
        if m.get('StorageURL') is not None:
            self.storage_url = m.get('StorageURL')
        if m.get('UploadMode') is not None:
            self.upload_mode = m.get('UploadMode')
        return self


class CreateResourceFileResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        # The ID of the file that is created.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateResourceFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceGroupRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateResourceGroupRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[CreateResourceGroupRequestAliyunResourceTags] = None,
        auto_renew_enabled: bool = None,
        client_token: str = None,
        name: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
        remark: str = None,
        spec: int = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The ID of the Alibaba Cloud resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # Specifies whether to enable auto-renewal.
        self.auto_renew_enabled = auto_renew_enabled
        # The client token that is used to ensure the idempotence of the request.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The name of the serverless resource group. The name can be a maximum of 128 characters in length and can contain letters, digits, and underscores (_). The name must start with a letter.
        # 
        # This parameter is required.
        self.name = name
        # The subscription duration.
        self.payment_duration = payment_duration
        # The unit of the subscription duration. Valid values: Month and Year.
        self.payment_duration_unit = payment_duration_unit
        # The billing method of the serverless resource group. Valid values: PrePaid and PostPaid. The value PrePaid indicates the subscription billing method, and the value PostPaid indicates the pay-as-you-go billing method.
        # 
        # This parameter is required.
        self.payment_type = payment_type
        # The description of the serverless resource group. The description can be a maximum of 128 characters in length and can contain letters, digits, and underscores (_).
        self.remark = remark
        # The specifications of the serverless resource group. Unit: CU. This parameter is required only if you set the PaymentType parameter to PrePaid.
        self.spec = spec
        # The ID of the virtual private cloud (VPC) with which the serverless resource group is associated by default.
        # 
        # This parameter is required.
        self.vpc_id = vpc_id
        # The ID of the vSwitch with which the serverless resource group is associated by default.
        # 
        # This parameter is required.
        self.vswitch_id = vswitch_id

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.auto_renew_enabled is not None:
            result['AutoRenewEnabled'] = self.auto_renew_enabled
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.name is not None:
            result['Name'] = self.name
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = CreateResourceGroupRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('AutoRenewEnabled') is not None:
            self.auto_renew_enabled = m.get('AutoRenewEnabled')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class CreateResourceGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        auto_renew_enabled: bool = None,
        client_token: str = None,
        name: str = None,
        payment_duration: int = None,
        payment_duration_unit: str = None,
        payment_type: str = None,
        remark: str = None,
        spec: int = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The ID of the Alibaba Cloud resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        # Specifies whether to enable auto-renewal.
        self.auto_renew_enabled = auto_renew_enabled
        # The client token that is used to ensure the idempotence of the request.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The name of the serverless resource group. The name can be a maximum of 128 characters in length and can contain letters, digits, and underscores (_). The name must start with a letter.
        # 
        # This parameter is required.
        self.name = name
        # The subscription duration.
        self.payment_duration = payment_duration
        # The unit of the subscription duration. Valid values: Month and Year.
        self.payment_duration_unit = payment_duration_unit
        # The billing method of the serverless resource group. Valid values: PrePaid and PostPaid. The value PrePaid indicates the subscription billing method, and the value PostPaid indicates the pay-as-you-go billing method.
        # 
        # This parameter is required.
        self.payment_type = payment_type
        # The description of the serverless resource group. The description can be a maximum of 128 characters in length and can contain letters, digits, and underscores (_).
        self.remark = remark
        # The specifications of the serverless resource group. Unit: CU. This parameter is required only if you set the PaymentType parameter to PrePaid.
        self.spec = spec
        # The ID of the virtual private cloud (VPC) with which the serverless resource group is associated by default.
        # 
        # This parameter is required.
        self.vpc_id = vpc_id
        # The ID of the vSwitch with which the serverless resource group is associated by default.
        # 
        # This parameter is required.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.auto_renew_enabled is not None:
            result['AutoRenewEnabled'] = self.auto_renew_enabled
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.name is not None:
            result['Name'] = self.name
        if self.payment_duration is not None:
            result['PaymentDuration'] = self.payment_duration
        if self.payment_duration_unit is not None:
            result['PaymentDurationUnit'] = self.payment_duration_unit
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('AutoRenewEnabled') is not None:
            self.auto_renew_enabled = m.get('AutoRenewEnabled')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PaymentDuration') is not None:
            self.payment_duration = m.get('PaymentDuration')
        if m.get('PaymentDurationUnit') is not None:
            self.payment_duration_unit = m.get('PaymentDurationUnit')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class CreateResourceGroupResponseBodyResourceGroupOrder(TeaModel):
    def __init__(
        self,
        id: str = None,
        order_id: int = None,
        order_instance_id: str = None,
    ):
        # The ID of the serverless resource group.
        self.id = id
        # The ID of the order that is used to create the serverless resource group.
        self.order_id = order_id
        # The instance ID of the order that is used to create the serverless resource group.
        self.order_instance_id = order_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        return self


class CreateResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_group_order: CreateResourceGroupResponseBodyResourceGroupOrder = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the order that is used to create the serverless resource group.
        self.resource_group_order = resource_group_order
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.resource_group_order:
            self.resource_group_order.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_order is not None:
            result['ResourceGroupOrder'] = self.resource_group_order.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupOrder') is not None:
            temp_model = CreateResourceGroupResponseBodyResourceGroupOrder()
            self.resource_group_order = temp_model.from_map(m['ResourceGroupOrder'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRouteRequest(TeaModel):
    def __init__(
        self,
        destination_cidr: str = None,
        network_id: int = None,
        resource_group_id: str = None,
    ):
        # The CIDR blocks of the destination-based route.
        # 
        # This parameter is required.
        self.destination_cidr = destination_cidr
        # The network ID.
        # 
        # This parameter is required.
        self.network_id = network_id
        # Unique identifier of the serverless resource group.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class CreateRouteResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The route ID.
        self.id = id
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUdfFileRequest(TeaModel):
    def __init__(
        self,
        class_name: str = None,
        cmd_description: str = None,
        create_folder_if_not_exists: bool = None,
        example: str = None,
        file_folder_path: str = None,
        file_name: str = None,
        function_type: str = None,
        parameter_description: str = None,
        project_id: int = None,
        project_identifier: str = None,
        resources: str = None,
        return_value: str = None,
        udf_description: str = None,
    ):
        # This parameter is required.
        self.class_name = class_name
        self.cmd_description = cmd_description
        self.create_folder_if_not_exists = create_folder_if_not_exists
        self.example = example
        # This parameter is required.
        self.file_folder_path = file_folder_path
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.function_type = function_type
        self.parameter_description = parameter_description
        self.project_id = project_id
        self.project_identifier = project_identifier
        # This parameter is required.
        self.resources = resources
        self.return_value = return_value
        self.udf_description = udf_description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.cmd_description is not None:
            result['CmdDescription'] = self.cmd_description
        if self.create_folder_if_not_exists is not None:
            result['CreateFolderIfNotExists'] = self.create_folder_if_not_exists
        if self.example is not None:
            result['Example'] = self.example
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.parameter_description is not None:
            result['ParameterDescription'] = self.parameter_description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.return_value is not None:
            result['ReturnValue'] = self.return_value
        if self.udf_description is not None:
            result['UdfDescription'] = self.udf_description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CmdDescription') is not None:
            self.cmd_description = m.get('CmdDescription')
        if m.get('CreateFolderIfNotExists') is not None:
            self.create_folder_if_not_exists = m.get('CreateFolderIfNotExists')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('ParameterDescription') is not None:
            self.parameter_description = m.get('ParameterDescription')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('ReturnValue') is not None:
            self.return_value = m.get('ReturnValue')
        if m.get('UdfDescription') is not None:
            self.udf_description = m.get('UdfDescription')
        return self


class CreateUdfFileResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUdfFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUdfFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUdfFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow/).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        # The ID of the workflow.
        self.id = id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkflowInstancesRequestDefaultRunPropertiesAlert(TeaModel):
    def __init__(
        self,
        notice_type: str = None,
        type: str = None,
    ):
        # The alert notification method. Valid values:
        # 
        # *   Sms
        # *   Mail
        # *   SmsMail
        self.notice_type = notice_type
        # The alerting policy. Valid values:
        # 
        # *   SUCCESS: An alert is reported when data backfill succeeds.
        # *   FAILURE: An alert is reported when data backfill fails.
        # *   SuccessFailure: An alert is reported regardless of whether data backfill succeeds or fails.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notice_type is not None:
            result['NoticeType'] = self.notice_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NoticeType') is not None:
            self.notice_type = m.get('NoticeType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis(TeaModel):
    def __init__(
        self,
        blocked: bool = None,
        enabled: bool = None,
    ):
        # Specifies whether to block the running of the instance if the analysis fails.
        self.blocked = blocked
        # Specifies whether to enable the analysis feature.
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.blocked is not None:
            result['Blocked'] = self.blocked
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Blocked') is not None:
            self.blocked = m.get('Blocked')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        return self


class CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        immediately: bool = None,
        start_time: str = None,
        type: str = None,
    ):
        # The time when the instance finishes running. This parameter is required if you specify the RunPolicy parameter.
        self.end_time = end_time
        # Specifies whether the instance can be run immediately during the time period in the future. Default value: false.
        self.immediately = immediately
        # The time when the instance starts to run. This parameter is required if you specify the RunPolicy parameter.
        self.start_time = start_time
        # The type of the time period during which the data is backfilled. This parameter is required if you specify the RunPolicy parameter. Valid values:
        # 
        # *   Daily
        # *   Weekend
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.immediately is not None:
            result['Immediately'] = self.immediately
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Immediately') is not None:
            self.immediately = m.get('Immediately')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateWorkflowInstancesRequestDefaultRunProperties(TeaModel):
    def __init__(
        self,
        alert: CreateWorkflowInstancesRequestDefaultRunPropertiesAlert = None,
        analysis: CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis = None,
        exclude_project_ids: List[int] = None,
        exclude_task_ids: List[int] = None,
        include_project_ids: List[int] = None,
        include_task_ids: List[int] = None,
        mode: str = None,
        order: str = None,
        parallelism: int = None,
        root_task_ids: List[int] = None,
        run_policy: CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy = None,
        runtime_resource: str = None,
    ):
        # The alert settings.
        self.alert = alert
        # The analysis of the configurations.
        self.analysis = analysis
        # The IDs of the projects that do not need to be run.
        self.exclude_project_ids = exclude_project_ids
        # The IDs of the tasks that do not need to be run.
        self.exclude_task_ids = exclude_task_ids
        # The IDs of the projects that need to be run.
        self.include_project_ids = include_project_ids
        # The IDs of the tasks that need to be run.
        self.include_task_ids = include_task_ids
        # The data backfill mode. Default value: ManualSelection. Valid values:
        # 
        # *   General: You can specify only one root task ID. The `IncludeTaskIds` parameter is optional. If you do not specify the IncludeTaskIds parameter, the tasks that are specified by the `RootTaskIds` parameter are included by default.``
        # *   ManualSelection: You can specify multiple root tasks IDs. The `IncludeTaskIds` parameter is optional. If you do not specify the IncludeTaskIds parameter, the tasks that are specified by the `RootTaskIds` parameter are included by default.``
        # *   Chain: The value of the `RootTaskIds` parameter is left empty. You must set the `IncludeTaskIds` parameter to the start task ID and the end task ID.
        # *   AllDownstream: You can specify only one root task ID.``
        self.mode = mode
        # The running order. Default value: Asc. Valid values:
        # 
        # *   Asc: The tasks are sorted by data timestamp in ascending order.
        # *   Desc: The tasks are sorted by data timestamp in descending order.
        self.order = order
        # The number of tasks that can be run in parallel. If you specify the value to 2 to 10, the value indicates the number of tasks that can be run in parallel. If you specify the value to 1, the tasks are run one by one.
        self.parallelism = parallelism
        # The root task IDs.
        self.root_task_ids = root_task_ids
        # The data backfill policy. If you leave this parameter empty, the runtime configuration is used.
        self.run_policy = run_policy
        # The identifier of the custom resource group for scheduling. If you leave this parameter empty, the runtime configuration is used.
        self.runtime_resource = runtime_resource

    def validate(self):
        if self.alert:
            self.alert.validate()
        if self.analysis:
            self.analysis.validate()
        if self.run_policy:
            self.run_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert is not None:
            result['Alert'] = self.alert.to_map()
        if self.analysis is not None:
            result['Analysis'] = self.analysis.to_map()
        if self.exclude_project_ids is not None:
            result['ExcludeProjectIds'] = self.exclude_project_ids
        if self.exclude_task_ids is not None:
            result['ExcludeTaskIds'] = self.exclude_task_ids
        if self.include_project_ids is not None:
            result['IncludeProjectIds'] = self.include_project_ids
        if self.include_task_ids is not None:
            result['IncludeTaskIds'] = self.include_task_ids
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.order is not None:
            result['Order'] = self.order
        if self.parallelism is not None:
            result['Parallelism'] = self.parallelism
        if self.root_task_ids is not None:
            result['RootTaskIds'] = self.root_task_ids
        if self.run_policy is not None:
            result['RunPolicy'] = self.run_policy.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alert') is not None:
            temp_model = CreateWorkflowInstancesRequestDefaultRunPropertiesAlert()
            self.alert = temp_model.from_map(m['Alert'])
        if m.get('Analysis') is not None:
            temp_model = CreateWorkflowInstancesRequestDefaultRunPropertiesAnalysis()
            self.analysis = temp_model.from_map(m['Analysis'])
        if m.get('ExcludeProjectIds') is not None:
            self.exclude_project_ids = m.get('ExcludeProjectIds')
        if m.get('ExcludeTaskIds') is not None:
            self.exclude_task_ids = m.get('ExcludeTaskIds')
        if m.get('IncludeProjectIds') is not None:
            self.include_project_ids = m.get('IncludeProjectIds')
        if m.get('IncludeTaskIds') is not None:
            self.include_task_ids = m.get('IncludeTaskIds')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('Parallelism') is not None:
            self.parallelism = m.get('Parallelism')
        if m.get('RootTaskIds') is not None:
            self.root_task_ids = m.get('RootTaskIds')
        if m.get('RunPolicy') is not None:
            temp_model = CreateWorkflowInstancesRequestDefaultRunPropertiesRunPolicy()
            self.run_policy = temp_model.from_map(m['RunPolicy'])
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        return self


class CreateWorkflowInstancesRequestPeriodsBizDates(TeaModel):
    def __init__(
        self,
        end_biz_date: str = None,
        start_biz_date: str = None,
    ):
        # The end date of the business.
        # 
        # This parameter is required.
        self.end_biz_date = end_biz_date
        # The start business date.
        # 
        # This parameter is required.
        self.start_biz_date = start_biz_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_biz_date is not None:
            result['EndBizDate'] = self.end_biz_date
        if self.start_biz_date is not None:
            result['StartBizDate'] = self.start_biz_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndBizDate') is not None:
            self.end_biz_date = m.get('EndBizDate')
        if m.get('StartBizDate') is not None:
            self.start_biz_date = m.get('StartBizDate')
        return self


class CreateWorkflowInstancesRequestPeriods(TeaModel):
    def __init__(
        self,
        biz_dates: List[CreateWorkflowInstancesRequestPeriodsBizDates] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The list of business dates. You can specify a multi-segment business date (up to 7 segments).
        # 
        # This parameter is required.
        self.biz_dates = biz_dates
        # Specifies the end cycle time. Default value: 23:59:59.
        # 
        # If you enter this field, StartTime and EndTime must be filled in at the same time.
        self.end_time = end_time
        # Specifies the start cycle time. Default value: 00:00:00.
        # 
        # If you enter this field, StartTime and EndTime must be filled in at the same time.
        self.start_time = start_time

    def validate(self):
        if self.biz_dates:
            for k in self.biz_dates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BizDates'] = []
        if self.biz_dates is not None:
            for k in self.biz_dates:
                result['BizDates'].append(k.to_map() if k else None)
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.biz_dates = []
        if m.get('BizDates') is not None:
            for k in m.get('BizDates'):
                temp_model = CreateWorkflowInstancesRequestPeriodsBizDates()
                self.biz_dates.append(temp_model.from_map(k))
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateWorkflowInstancesRequest(TeaModel):
    def __init__(
        self,
        auto_start_enabled: bool = None,
        comment: str = None,
        default_run_properties: CreateWorkflowInstancesRequestDefaultRunProperties = None,
        env_type: str = None,
        name: str = None,
        periods: CreateWorkflowInstancesRequestPeriods = None,
        project_id: int = None,
        task_parameters: str = None,
        type: str = None,
        workflow_id: int = None,
        workflow_parameters: str = None,
    ):
        # The default value is true.
        self.auto_start_enabled = auto_start_enabled
        # The reason for the creation.
        self.comment = comment
        # The runtime configuration.
        self.default_run_properties = default_run_properties
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The name.
        # 
        # This parameter is required.
        self.name = name
        # Make up the data cycle settings.
        self.periods = periods
        # The project ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The task-specific parameters. The value is in the JSON format. The key specifies the task ID. You can call the GetTask operation to obtain the format of the value by querying the script parameters.
        self.task_parameters = task_parameters
        # The type of the workflow instance. Valid values:
        # 
        # *   SupplementData The values of the RootTaskIds and IncludeTaskIds parameters vary based on the value of the Mode parameter. For more information, see the Mode parameter in this API operation.
        # *   ManualWorkflow You must set the WorkflowId parameter to the ID of the manually triggered workflow. The RootTaskIds parameter is optional. If you do not specify the RootTaskIds parameter, the IDs of the default root nodes of the manually triggered workflow are used.
        # *   Manual You need to specify only the RootTaskIds parameter. The RootTaskIds parameter specifies the IDs of the manually triggered tasks that need to be run.
        # *   SmokeTest You need to specify only the RootTaskIds parameter. The RootTaskIds parameter specifies the IDs of the test tasks that need to be run.
        # 
        # This parameter is required.
        self.type = type
        # The ID of the workflow to which the instance belongs. This parameter is set to 1 for auto triggered tasks.
        # 
        # This parameter is required.
        self.workflow_id = workflow_id
        # The workflow parameters. The priority of workflow parameters is higher than that of task parameters. You can call the GetTask operation to obtain the format of the workflow parameters by querying the Parameters parameter.
        self.workflow_parameters = workflow_parameters

    def validate(self):
        if self.default_run_properties:
            self.default_run_properties.validate()
        if self.periods:
            self.periods.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_start_enabled is not None:
            result['AutoStartEnabled'] = self.auto_start_enabled
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.default_run_properties is not None:
            result['DefaultRunProperties'] = self.default_run_properties.to_map()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.periods is not None:
            result['Periods'] = self.periods.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.task_parameters is not None:
            result['TaskParameters'] = self.task_parameters
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_parameters is not None:
            result['WorkflowParameters'] = self.workflow_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoStartEnabled') is not None:
            self.auto_start_enabled = m.get('AutoStartEnabled')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('DefaultRunProperties') is not None:
            temp_model = CreateWorkflowInstancesRequestDefaultRunProperties()
            self.default_run_properties = temp_model.from_map(m['DefaultRunProperties'])
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Periods') is not None:
            temp_model = CreateWorkflowInstancesRequestPeriods()
            self.periods = temp_model.from_map(m['Periods'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TaskParameters') is not None:
            self.task_parameters = m.get('TaskParameters')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowParameters') is not None:
            self.workflow_parameters = m.get('WorkflowParameters')
        return self


class CreateWorkflowInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        auto_start_enabled: bool = None,
        comment: str = None,
        default_run_properties_shrink: str = None,
        env_type: str = None,
        name: str = None,
        periods_shrink: str = None,
        project_id: int = None,
        task_parameters: str = None,
        type: str = None,
        workflow_id: int = None,
        workflow_parameters: str = None,
    ):
        # The default value is true.
        self.auto_start_enabled = auto_start_enabled
        # The reason for the creation.
        self.comment = comment
        # The runtime configuration.
        self.default_run_properties_shrink = default_run_properties_shrink
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The name.
        # 
        # This parameter is required.
        self.name = name
        # Make up the data cycle settings.
        self.periods_shrink = periods_shrink
        # The project ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The task-specific parameters. The value is in the JSON format. The key specifies the task ID. You can call the GetTask operation to obtain the format of the value by querying the script parameters.
        self.task_parameters = task_parameters
        # The type of the workflow instance. Valid values:
        # 
        # *   SupplementData The values of the RootTaskIds and IncludeTaskIds parameters vary based on the value of the Mode parameter. For more information, see the Mode parameter in this API operation.
        # *   ManualWorkflow You must set the WorkflowId parameter to the ID of the manually triggered workflow. The RootTaskIds parameter is optional. If you do not specify the RootTaskIds parameter, the IDs of the default root nodes of the manually triggered workflow are used.
        # *   Manual You need to specify only the RootTaskIds parameter. The RootTaskIds parameter specifies the IDs of the manually triggered tasks that need to be run.
        # *   SmokeTest You need to specify only the RootTaskIds parameter. The RootTaskIds parameter specifies the IDs of the test tasks that need to be run.
        # 
        # This parameter is required.
        self.type = type
        # The ID of the workflow to which the instance belongs. This parameter is set to 1 for auto triggered tasks.
        # 
        # This parameter is required.
        self.workflow_id = workflow_id
        # The workflow parameters. The priority of workflow parameters is higher than that of task parameters. You can call the GetTask operation to obtain the format of the workflow parameters by querying the Parameters parameter.
        self.workflow_parameters = workflow_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_start_enabled is not None:
            result['AutoStartEnabled'] = self.auto_start_enabled
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.default_run_properties_shrink is not None:
            result['DefaultRunProperties'] = self.default_run_properties_shrink
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.periods_shrink is not None:
            result['Periods'] = self.periods_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.task_parameters is not None:
            result['TaskParameters'] = self.task_parameters
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_parameters is not None:
            result['WorkflowParameters'] = self.workflow_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoStartEnabled') is not None:
            self.auto_start_enabled = m.get('AutoStartEnabled')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('DefaultRunProperties') is not None:
            self.default_run_properties_shrink = m.get('DefaultRunProperties')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Periods') is not None:
            self.periods_shrink = m.get('Periods')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TaskParameters') is not None:
            self.task_parameters = m.get('TaskParameters')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowParameters') is not None:
            self.workflow_parameters = m.get('WorkflowParameters')
        return self


class CreateWorkflowInstancesResponseBody(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
        request_id: str = None,
    ):
        # The ID of the operation. You can use this field to query the results of the creation operation through the GetCreateWorkflowInstancesResult interface.
        self.operation_id = operation_id
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateWorkflowInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkflowInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkflowInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The rule ID.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBusinessRequest(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.business_id = business_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class DeleteBusinessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCertificateRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the certificate file.
        # 
        # This parameter is required.
        self.id = id
        # The ID of the workspace to which the certificate file belongs.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteCertificateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCertificateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCertificateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCertificateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        id: int = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The ID of the synchronization task.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        id: int = None,
        project_id: int = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The ID of the synchronization task.
        self.id = id
        # The DataWorks workspace ID.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # true
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataAssetTagRequest(TeaModel):
    def __init__(
        self,
        key: str = None,
        values: List[str] = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag values.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DeleteDataAssetTagShrinkRequest(TeaModel):
    def __init__(
        self,
        key: str = None,
        values_shrink: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag values.
        self.values_shrink = values_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.values_shrink is not None:
            result['Values'] = self.values_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Values') is not None:
            self.values_shrink = m.get('Values')
        return self


class DeleteDataAssetTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataAssetTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataAssetTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataAssetTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataQualityEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the data quality monitor.
        self.id = id
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the workspace management page to obtain the ID.
        # 
        # This parameter is used to determine the DataWorks workspaces used for this API call.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteDataQualityEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Id of the request
        self.request_id = request_id
        # Whether the deletion is successful.
        # - true: Successful
        # - false: Failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataQualityEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataQualityEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataQualityEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataQualityRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The rule ID.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteDataQualityRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataQualityRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataQualityRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataQualityRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataQualityRuleTemplateRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        project_id: int = None,
    ):
        # The code for the template.
        # 
        # This parameter is required.
        self.code = code
        # The DataWorks workspace ID.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteDataQualityRuleTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataQualityRuleTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataQualityRuleTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataQualityRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The data source ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Whether the call is successful.
        # - true: Successful
        # - false: Failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceSharedRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The sharing rule ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteDataSourceSharedRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Whether the data source sharing rule is deleted successfully. The value is as follows:
        # -true: The request is successful.
        # -false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataSourceSharedRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceSharedRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceSharedRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFileRequest(TeaModel):
    def __init__(
        self,
        file_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.file_id = file_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class DeleteFileResponseBody(TeaModel):
    def __init__(
        self,
        deployment_id: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.deployment_id = deployment_id
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFolderRequest(TeaModel):
    def __init__(
        self,
        folder_id: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.folder_id = folder_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class DeleteFolderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteFolderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFolderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFolderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFunctionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID. You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLineageRelationshipRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteLineageRelationshipResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLineageRelationshipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLineageRelationshipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLineageRelationshipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the network that you want to delete.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteNetworkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNodeRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
        # 
        # You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # true\\
        # false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteProjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the **Tenant Members and Roles** page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DeleteProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteResourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID. You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteResourceGroupRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRouteRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The route ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_env: str = None,
    ):
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class DeleteTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkflowRequest(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        env_type: str = None,
        id: int = None,
    ):
        # The unique code of the client. This parameter is used to create a workflow asynchronously and implement the idempotence of the workflow. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The workflow ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeployFileRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        file_id: int = None,
        node_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        self.comment = comment
        self.file_id = file_id
        self.node_id = node_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class DeployFileResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeployFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeployFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeployFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachDataQualityRulesFromEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        data_quality_rule_ids: List[int] = None,
        project_id: int = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The IDs of the monitoring rules.
        # 
        # This parameter is required.
        self.data_quality_rule_ids = data_quality_rule_ids
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the workspace configuration page to obtain the workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_rule_ids is not None:
            result['DataQualityRuleIds'] = self.data_quality_rule_ids
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityRuleIds') is not None:
            self.data_quality_rule_ids = m.get('DataQualityRuleIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DetachDataQualityRulesFromEvaluationTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        data_quality_rule_ids_shrink: str = None,
        project_id: int = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        # 
        # This parameter is required.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The IDs of the monitoring rules.
        # 
        # This parameter is required.
        self.data_quality_rule_ids_shrink = data_quality_rule_ids_shrink
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the workspace configuration page to obtain the workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_rule_ids_shrink is not None:
            result['DataQualityRuleIds'] = self.data_quality_rule_ids_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityRuleIds') is not None:
            self.data_quality_rule_ids_shrink = m.get('DataQualityRuleIds')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DetachDataQualityRulesFromEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Id of the request
        self.request_id = request_id
        # Whether the call is successful. The values are as follows:
        # - true: The call is successful.
        # - false: the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachDataQualityRulesFromEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachDataQualityRulesFromEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachDataQualityRulesFromEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DissociateProjectFromResourceGroupRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the workspace from which you want to disassociate the resource group.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class DissociateProjectFromResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DissociateProjectFromResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DissociateProjectFromResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DissociateProjectFromResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EstablishRelationTableToBusinessRequest(TeaModel):
    def __init__(
        self,
        business_id: str = None,
        folder_id: str = None,
        project_id: int = None,
        project_identifier: str = None,
        table_guid: str = None,
    ):
        # This parameter is required.
        self.business_id = business_id
        self.folder_id = folder_id
        self.project_id = project_id
        self.project_identifier = project_identifier
        # This parameter is required.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class EstablishRelationTableToBusinessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EstablishRelationTableToBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EstablishRelationTableToBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EstablishRelationTableToBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecPipelineRunStageRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        id: str = None,
        project_id: int = None,
    ):
        # The code of the stage in the process. You can call the GetDeployment operation to query the code.
        # 
        # This parameter is required.
        self.code = code
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ExecPipelineRunStageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # 
        # *   false
        # 
        #     **\
        # 
        #     **Note:** The value of this parameter indicates only whether the stage is triggered but does not indicate whether the execution of the stage is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecPipelineRunStageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecPipelineRunStageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecPipelineRunStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksDependencies(TeaModel):
    def __init__(
        self,
        upstream_output: str = None,
    ):
        # The identifier of the output of the ancestor task.
        self.upstream_output = upstream_output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The value of the variable. You must configure this parameter in the `The ancestor output: The output variable name of the ancestor task` format.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksInputs(TeaModel):
    def __init__(
        self,
        variables: List[ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ExecuteAdhocWorkflowInstanceRequestTasksInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   System
        # *   Constant
        # *   NodeOutput
        # *   PassThrough
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs] = None,
        variables: List[ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = ExecuteAdhocWorkflowInstanceRequestTasksOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ExecuteAdhocWorkflowInstanceRequestTasksOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasksScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class ExecuteAdhocWorkflowInstanceRequestTasks(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        data_source: ExecuteAdhocWorkflowInstanceRequestTasksDataSource = None,
        dependencies: List[ExecuteAdhocWorkflowInstanceRequestTasksDependencies] = None,
        inputs: ExecuteAdhocWorkflowInstanceRequestTasksInputs = None,
        name: str = None,
        outputs: ExecuteAdhocWorkflowInstanceRequestTasksOutputs = None,
        owner: str = None,
        runtime_resource: ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource = None,
        script: ExecuteAdhocWorkflowInstanceRequestTasksScript = None,
        timeout: int = None,
        type: str = None,
    ):
        # The unique code of the client. This code uniquely identifies a task.
        # 
        # This parameter is required.
        self.client_unique_code = client_unique_code
        # The information about the associated data source.
        self.data_source = data_source
        # The dependency information.
        self.dependencies = dependencies
        # The input information.
        self.inputs = inputs
        # The name of the task.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The configurations of the runtime environment, such as the resource group information.
        # 
        # This parameter is required.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The type of the task.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('DataSource') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceRequestTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = ExecuteAdhocWorkflowInstanceRequestTasksDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Inputs') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceRequestTasksInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceRequestTasksOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RuntimeResource') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceRequestTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceRequestTasksScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ExecuteAdhocWorkflowInstanceRequest(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        env_type: str = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        tasks: List[ExecuteAdhocWorkflowInstanceRequestTasks] = None,
    ):
        # The data timestamp.
        self.biz_date = biz_date
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The name of the workflow instance.
        # 
        # This parameter is required.
        self.name = name
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The tasks.
        # 
        # This parameter is required.
        self.tasks = tasks

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ExecuteAdhocWorkflowInstanceRequestTasks()
                self.tasks.append(temp_model.from_map(k))
        return self


class ExecuteAdhocWorkflowInstanceShrinkRequest(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        env_type: str = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        tasks_shrink: str = None,
    ):
        # The data timestamp.
        self.biz_date = biz_date
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The name of the workflow instance.
        # 
        # This parameter is required.
        self.name = name
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The tasks.
        # 
        # This parameter is required.
        self.tasks_shrink = tasks_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.tasks_shrink is not None:
            result['Tasks'] = self.tasks_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Tasks') is not None:
            self.tasks_shrink = m.get('Tasks')
        return self


class ExecuteAdhocWorkflowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow_instance_id: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ExecuteAdhocWorkflowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteAdhocWorkflowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteAdhocWorkflowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlertRuleRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # The rule ID.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetAlertRuleResponseBodyAlertRuleNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The additional configuration of the alert recipient. If the ReceiverType parameter is set to DingdingUrl, you can set this parameter to {"atAll":true} to remind all members in a DingTalk group.
        self.extension = extension
        # The type of the alert recipient. Valid valves:
        # 
        # *   AliUid: Alibaba Cloud account ID.
        # *   Shift Schedules: the personnel in a shift schedule.
        # *   TaskOwner: the task owner. The task owner can receive custom alerts and event alerts.
        # *   Owner: the baseline owner. The baseline owner can receive baseline alerts.
        # *   WebhookUrl: URL of a custom webhook.
        # *   DingdingUrl: DingTalk webhook URL.
        # *   FeishuUrl: Lark webhook URL.
        # *   WeixinUrl: WeCom webhook URL.
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class GetAlertRuleResponseBodyAlertRuleNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[GetAlertRuleResponseBodyAlertRuleNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        # The alert notification channels.
        self.channels = channels
        # The interval at which an alert notification is sent. Unit: minutes. Valid values: [5,10000].
        self.interval_in_minutes = interval_in_minutes
        # The maximum number of times an alert notification can be sent within a calendar day. Valid values: [1, 10000].
        self.maximum = maximum
        # The alert recipients.
        self.receivers = receivers
        # The end time for silence. The time is in the HH:mm:ss format.
        self.silence_end_time = silence_end_time
        # The start time for silence. The time is in the HH:mm:ss format.
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = GetAlertRuleResponseBodyAlertRuleNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        # The ID of the scheduling cycle of the instance. Valid values: [1,288].
        self.cycle_id = cycle_id
        # The latest completion time of the instance within the scheduling cycle. The time is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        # The configurations of the scheduling cycle and timeout period of the instance.
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert_enabled: bool = None,
        stream_task_ids: List[int] = None,
    ):
        # Indicates whether an alert is triggered if a batch synchronization task is automatically rerun upon a failure.
        self.auto_rerun_alert_enabled = auto_rerun_alert_enabled
        # The IDs of the real-time computing tasks. This parameter is required when you monitor real-time computing tasks.
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert_enabled is not None:
            result['AutoRerunAlertEnabled'] = self.auto_rerun_alert_enabled
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlertEnabled') is not None:
            self.auto_rerun_alert_enabled = m.get('AutoRerunAlertEnabled')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        # The maximum number of instances on which an error occurs. Valid values: [1,10000].
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        # The maximum percentage of instances on which an error occurs in the workspace to the total number of instances. Valid values: [1-100].
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        # The maximum percentage of fluctuation in the number of auto triggered node instances that are generated in your workspace. Valid values: [1-100].
        self.percentage = percentage
        # The way in which the number of auto triggered node instances that are generated in your workspace fluctuates. Valid values:
        # 
        # *   abs: the absolute value. The number of instances increases or decreases.
        # *   increase: The number of instances increases.
        # *   decrease: The number of instances decreases.
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        # The timeout period. Unit: minutes. Valid values: [1, 21600].
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        # The latest completion time of the instance. The period is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished = None,
        error: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError = None,
        instance_error_count: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout = None,
        un_finished: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished = None,
    ):
        # The configuration for an alert of the CycleUnfinished type.
        self.cycle_unfinished = cycle_unfinished
        # The configuration for an alert of the Error type.
        self.error = error
        # The configuration for an alert of the InstanceErrorCount type.
        self.instance_error_count = instance_error_count
        # The configuration for an alert of the InstanceErrorPercentage type.
        self.instance_error_percentage = instance_error_percentage
        # The configuration for an alert of the InstanceTransferFluctuate type.
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        # The configuration for an alert of the Timeout type.
        self.timeout = timeout
        # The configuration for an alert of the UnFinished type.
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        # The nodes that are not to be monitored.
        self.allow_tasks = allow_tasks
        # The IDs of monitored objects.
        self.ids = ids
        # The type of the monitored objects. Valid values:
        # 
        # *   Task: node
        # *   Baseline: baseline
        # *   project: workspace
        # *   BizProcess: workflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetAlertRuleResponseBodyAlertRuleTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension = None,
        target: GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget = None,
        type: str = None,
    ):
        # The extended information about the rule. This parameter is required for specific types of alerts.
        self.extension = extension
        # The monitored objects.
        self.target = target
        # The alert type. Valid values:
        # 
        # *   Finished: An instance is successfully run.
        # *   UnFinished: An instance does not finish running before a specified point in time.
        # *   Error: An error occurs on an instance.
        # *   CycleUnfinished: An instance does not finish running as expected within a specific cycle.
        # *   Timeout: An instance times out.
        # *   InstanceTransferComplete: An instance is generated by the auto triggered node.
        # *   InstanceTransferFluctuate: The number of generated instances fluctuates.
        # *   ExhaustedError: An error persists after an instance is automatically rerun.
        # *   InstanceKeyword: An instance with errors contains specified keywords.
        # *   InstanceErrorCount: The number of instances on which an error occurs reaches a specified threshold.
        # *   InstanceErrorPercentage: The proportion of instances on which an error occurs in the workspace to the total number of instances reaches a specified threshold.
        # *   ResourceGroupPercentage: The usage rate of the resource group reaches a specified threshold.
        # *   ResourceGroupWaitCount: The number of instances that are waiting for resources in the resource group reaches a specified threshold.
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetAlertRuleResponseBodyAlertRule(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification: GetAlertRuleResponseBodyAlertRuleNotification = None,
        owner: str = None,
        trigger_condition: GetAlertRuleResponseBodyAlertRuleTriggerCondition = None,
    ):
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The rule ID.
        self.id = id
        # The name of the rule.
        self.name = name
        # The configuration for the alert notification.
        self.notification = notification
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The alert triggering condition.
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRuleTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class GetAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        alert_rule: GetAlertRuleResponseBodyAlertRule = None,
        request_id: str = None,
    ):
        # The information about the rule.
        self.alert_rule = alert_rule
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_rule:
            self.alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule is not None:
            result['AlertRule'] = self.alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRule') is not None:
            temp_model = GetAlertRuleResponseBodyAlertRule()
            self.alert_rule = temp_model.from_map(m['AlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBusinessRequest(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.business_id = business_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class GetBusinessResponseBodyData(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        business_name: str = None,
        description: str = None,
        owner: str = None,
        project_id: str = None,
        use_type: str = None,
    ):
        self.business_id = business_id
        self.business_name = business_name
        self.description = description
        self.owner = owner
        self.project_id = project_id
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class GetBusinessResponseBody(TeaModel):
    def __init__(
        self,
        data: GetBusinessResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetBusinessResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCatalogRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetCatalogResponseBody(TeaModel):
    def __init__(
        self,
        catalog: Catalog = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.catalog = catalog
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.catalog:
            self.catalog.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog is not None:
            result['Catalog'] = self.catalog.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Catalog') is not None:
            temp_model = Catalog()
            self.catalog = temp_model.from_map(m['Catalog'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCatalogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCatalogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCatalogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCertificateRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the certificate file.
        # 
        # This parameter is required.
        self.id = id
        # The ID of the workspace to which the certificate file belongs.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetCertificateResponseBodyCertificate(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        file_size_in_bytes: int = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
    ):
        # The time when the certificate file was created. The value is a UNIX timestamp. Unit: milliseconds.
        self.create_time = create_time
        # The ID of the user who created the certificate file.
        self.create_user = create_user
        # The description.
        self.description = description
        # The size of the certificate file, in bytes.
        self.file_size_in_bytes = file_size_in_bytes
        # The ID of the certificate file.
        self.id = id
        # The name of the certificate file.
        self.name = name
        # The ID of the workspace to which the certificate file belongs.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.file_size_in_bytes is not None:
            result['FileSizeInBytes'] = self.file_size_in_bytes
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileSizeInBytes') is not None:
            self.file_size_in_bytes = m.get('FileSizeInBytes')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetCertificateResponseBody(TeaModel):
    def __init__(
        self,
        certificate: GetCertificateResponseBodyCertificate = None,
        request_id: str = None,
    ):
        # The details of the certificate file.
        self.certificate = certificate
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.certificate:
            self.certificate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.certificate is not None:
            result['Certificate'] = self.certificate.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Certificate') is not None:
            temp_model = GetCertificateResponseBodyCertificate()
            self.certificate = temp_model.from_map(m['Certificate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCertificateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCertificateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCertificateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetColumnRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetColumnResponseBody(TeaModel):
    def __init__(
        self,
        column: Column = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.column = column
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.column:
            self.column.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column is not None:
            result['Column'] = self.column.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Column') is not None:
            temp_model = Column()
            self.column = temp_model.from_map(m['Column'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetColumnResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetColumnResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetColumnResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCreateWorkflowInstancesResultRequest(TeaModel):
    def __init__(
        self,
        operation_id: str = None,
    ):
        # The operation ID. This parameter is used to query the result of asynchronously creating a workflow instance. You can call the CreateWorkflowInstances operation to query the ID.
        # 
        # This parameter is required.
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_id is not None:
            result['OperationId'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OperationId') is not None:
            self.operation_id = m.get('OperationId')
        return self


class GetCreateWorkflowInstancesResultResponseBodyResult(TeaModel):
    def __init__(
        self,
        failure_message: str = None,
        status: str = None,
        workflow_instance_ids: List[int] = None,
    ):
        # The error message. This parameter is returned only if the creation fails.
        self.failure_message = failure_message
        # The creation status. Valid values:
        # 
        # *   Creating
        # *   Created
        # *   CreateFailure
        self.status = status
        # The workflow instance IDs. This parameter is returned only if the creation is successful.
        self.workflow_instance_ids = workflow_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failure_message is not None:
            result['FailureMessage'] = self.failure_message
        if self.status is not None:
            result['Status'] = self.status
        if self.workflow_instance_ids is not None:
            result['WorkflowInstanceIds'] = self.workflow_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailureMessage') is not None:
            self.failure_message = m.get('FailureMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WorkflowInstanceIds') is not None:
            self.workflow_instance_ids = m.get('WorkflowInstanceIds')
        return self


class GetCreateWorkflowInstancesResultResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetCreateWorkflowInstancesResultResponseBodyResult = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The result of asynchronously creating a workflow instance.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = GetCreateWorkflowInstancesResultResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class GetCreateWorkflowInstancesResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCreateWorkflowInstancesResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCreateWorkflowInstancesResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        id: int = None,
        project_id: int = None,
        with_details: bool = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The ID of the synchronization task.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id
        # Specifies whether to return detailed configuration information, including TransformationRules, TableMappings, and JobSettings. Valid values: true and false. Default value: true.
        self.with_details = with_details

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.with_details is not None:
            result['WithDetails'] = self.with_details
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('WithDetails') is not None:
            self.with_details = m.get('WithDetails')
        return self


class GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
    ):
        # The name of the data source.
        self.data_source_name = data_source_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        # The data type of the destination field. Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.destination_data_type = destination_data_type
        # The data type of the source field. Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        cycle_migration_type: str = None,
        schedule_parameters: str = None,
    ):
        # The synchronization type that requires periodic scheduling. Valid values:
        # 
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        self.cycle_migration_type = cycle_migration_type
        # The scheduling parameters.
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_migration_type is not None:
            result['CycleMigrationType'] = self.cycle_migration_type
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleMigrationType') is not None:
            self.cycle_migration_type = m.get('CycleMigrationType')
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        # The processing policy for a specific type of DDL message. Valid values:
        # 
        # *   Ignore: ignores a DDL message.
        # *   Critical: reports an error for a DDL message.
        # *   Normal: normally processes a DDL message.
        self.action = action
        # The DDL operation type. Valid values:
        # 
        # *   RenameColumn
        # *   ModifyColumn
        # *   CreateTable
        # *   TruncateTable
        # *   DropTable
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the configuration item. Valid values:
        # 
        # *   src.offline.datasource.max.connection: indicates the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
        # *   dst.offline.truncate: indicates whether to clear the destination table before data writing.
        # *   runtime.offline.speed.limit.enable: indicates whether throttling is enabled for a batch synchronization task.
        # *   runtime.offline.concurrent: indicates the maximum number of parallel threads that are allowed for a batch synchronization task.
        # *   runtime.enable.auto.create.schema: indicates whether schemas are automatically created in the destination of a synchronization task.
        # *   runtime.realtime.concurrent: indicates the maximum number of parallel threads that are allowed for a real-time synchronization task.
        # *   runtime.realtime.failover.minute.dataxcdc: indicates the maximum waiting duration before a synchronization task retries the next restart if the previous restart fails after failover occurs. Unit: minutes.
        # *   runtime.realtime.failover.times.dataxcdc: indicates the maximum number of failures that are allowed for restarting a synchronization task after failovers occur.
        self.name = name
        # The value of the configuration item.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDIJobResponseBodyPagingInfoJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings] = None,
    ):
        # The channel control settings for the synchronization task. You can configure special channel control settings for the following synchronization links: data synchronization between Hologres data sources and data synchronization from Hologres to Kafka.
        # 
        # 1.  Holo2Kafka
        # 
        # *   Example: {"destinationChannelSettings":{"kafkaClientProperties":[{"key":"linger.ms","value":"100"}],"keyColumns":["col3"],"writeMode":"canal"}}
        # *   kafkaClientProperties: the parameters related to a Kafka producer, which are used when you write data to a Kafka data source.
        # *   keyColumns: the names of Kafka columns to which data is written.
        # *   writeMode: the writing format. Valid values: json and canal.
        # 
        # 2.  Holo2Holo
        # 
        # *   Example: {"destinationChannelSettings":{"conflictMode":"replace","dynamicColumnAction":"replay","writeMode":"replay"}}
        # *   conflictMode: the policy used to handle a conflict that occurs during data writing to Hologres. Valid values: replace and ignore.
        # *   writeMode: the mode in which data is written to Hologres. Valid values: replay and insert.
        # *   dynamicColumnAction: the mode in which data is written to dynamic columns in a Hologres table. Valid values: replay, insert, and ignore.
        self.channel_settings = channel_settings
        # The data type mappings between source fields and destination fields.
        self.column_data_type_settings = column_data_type_settings
        # The settings for periodic scheduling.
        self.cycle_schedule_settings = cycle_schedule_settings
        # The DDL operation types. Valid values:
        # 
        # *   RenameColumn
        # *   ModifyColumn
        # *   CreateTable
        # *   TruncateTable
        # *   DropTable
        # *   DropColumn
        # *   AddColumn
        self.ddl_handling_settings = ddl_handling_settings
        # The runtime settings.
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of compute units (CUs) in the resource group for scheduling that are used for batch synchronization.
        self.requested_cu = requested_cu
        # The identifier of the resource group for Data Integration used for batch synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for Data Integration that are used for real-time synchronization.
        self.requested_cu = requested_cu
        # The identifier of the resource group for Data Integration used for real-time synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for Data Integration that are used for scheduling.
        self.requested_cu = requested_cu
        # The identifier of the resource group for scheduling used by the synchronization task.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class GetDIJobResponseBodyPagingInfoResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings = None,
    ):
        # The resource used for batch synchronization.
        self.offline_resource_settings = offline_resource_settings
        # The resource used for real-time synchronization.
        self.realtime_resource_settings = realtime_resource_settings
        # The resource used for scheduling.
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties(TeaModel):
    def __init__(
        self,
        encoding: str = None,
        timezone: str = None,
    ):
        # The encoding format of the database.
        self.encoding = encoding
        # The time zone.
        self.timezone = timezone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        return self


class GetDIJobResponseBodyPagingInfoSourceDataSourceSettings(TeaModel):
    def __init__(
        self,
        data_source_name: str = None,
        data_source_properties: GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties = None,
    ):
        # The name of the data source.
        self.data_source_name = data_source_name
        # The properties of the data source.
        self.data_source_properties = data_source_properties

    def validate(self):
        if self.data_source_properties:
            self.data_source_properties.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.data_source_properties is not None:
            result['DataSourceProperties'] = self.data_source_properties.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('DataSourceProperties') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoSourceDataSourceSettingsDataSourceProperties()
            self.data_source_properties = temp_model.from_map(m['DataSourceProperties'])
        return self


class GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        # The operation that is performed to select objects. Valid values: Include and Exclude.
        self.action = action
        # The expression.
        self.expression = expression
        # The expression type. Valid values: Exact and Regex.
        self.expression_type = expression_type
        # The object type. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        self.rule_action_type = rule_action_type
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which the action is performed. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class GetDIJobResponseBodyPagingInfoTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules] = None,
    ):
        # The list of rules used to select synchronization objects in the source.
        self.source_object_selection_rules = source_object_selection_rules
        # The list of transformation rules that are applied to the synchronization objects selected from the source. Each entry in the list defines a transformation rule.
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBodyPagingInfoTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        # *   DefineIncrementalCondition
        # *   DefineCycleScheduleSettings
        # *   DefinePartitionKey
        self.rule_action_type = rule_action_type
        # The expression of the rule. The expression is a JSON string.
        # 
        # 1.  Example of a renaming rule
        # 
        # *   Example: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922" }
        # *   expression: the expression of the renaming rule. You can use the following variables in an expression: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} indicates the name of the source. ${srcDatabaseName} indicates the name of a source database. ${srcTableName} indicates the name of a source table.
        # 
        # 2.  Example of a column addition rule
        # 
        # *   Example: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}
        # *   If no rule of this type is configured, no fields are added to the destination and no values are assigned by default.
        # *   columnName: the name of the field that is added.
        # *   columnValueType: the value type of the field. Valid values: Constant and Variable.
        # *   columnValue: the value of the field. If the columnValueType parameter is set to Constant, the value of the columnValue parameter is a constant of the STRING data type. If the columnValueType parameter is set to Variable, the value of the columnValue parameter is a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME indicates the execution time. DB_NAME_SRC indicates the name of a source database. DATASOURCE_NAME_SRC indicates the name of the source. TABLE_NAME_SRC indicates the name of a source table. DB_NAME_DEST indicates the name of a destination database. DATASOURCE_NAME_DEST indicates the name of the destination. TABLE_NAME_DEST indicates the name of a destination table. DB_NAME_SRC_TRANSED indicates the database name obtained after a transformation.
        # 
        # 3.  Example of a rule used to specify primary key fields for a destination table
        # 
        # *   Example: {"columns":["ukcolumn1","ukcolumn2"]}
        # *   If no rule of this type is configured, the primary key fields in the mapped source table are used for the destination table by default.
        # *   If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # *   If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # 
        # 4.  Example of a rule used to process DML messages
        # 
        # *   Example: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}
        # *   If no rule of this type is configured, the default processing policy for messages generated for insert, update, and delete operations is Normal.
        # *   dmlType: the DML operation. Valid values: Insert, Update, and Delete.
        # *   dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. The value Filter is returned for the dmlAction parameter only when the value of the dmlType parameter is Update or Delete.
        # *   filterCondition: the condition used to filter DML messages. This parameter is returned only when the value of the dmlAction parameter is Filter.
        # 
        # 5.  Example of a rule used to perform incremental synchronization
        # 
        # *   Example: {"where":"id > 0"}
        # *   The rule used to perform incremental synchronization is returned.
        # 
        # 6.  Example of a rule used to configure scheduling parameters for an auto triggered task
        # 
        # *   Example: {"cronExpress":" \\* \\* \\* \\* \\* \\*", "cycleType":"1"}
        # *   The rule used to configure scheduling parameters for an auto triggered task is returned.
        # 
        # 7.  Example of a rule used to specify a partition key
        # 
        # *   Example: {"columns":["id"]}
        # *   The rule used to specify a partition key is returned.
        self.rule_expression = rule_expression
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which the action is performed. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class GetDIJobResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_id: str = None,
        description: str = None,
        destination_data_source_settings: List[GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings] = None,
        destination_data_source_type: str = None,
        id: int = None,
        job_name: str = None,
        job_settings: GetDIJobResponseBodyPagingInfoJobSettings = None,
        job_status: str = None,
        job_type: str = None,
        migration_type: str = None,
        project_id: int = None,
        resource_settings: GetDIJobResponseBodyPagingInfoResourceSettings = None,
        source_data_source_settings: List[GetDIJobResponseBodyPagingInfoSourceDataSourceSettings] = None,
        source_data_source_type: str = None,
        table_mappings: List[GetDIJobResponseBodyPagingInfoTableMappings] = None,
        transformation_rules: List[GetDIJobResponseBodyPagingInfoTransformationRules] = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The description of the synchronization task.
        self.description = description
        # The properties of the destination.
        self.destination_data_source_settings = destination_data_source_settings
        # The destination type. Valid values: Hologres, OSS-HDFS, OSS, MaxCompute, LogHub, StarRocks, DataHub, AnalyticDB_For_MySQL, Kafka, Hive.
        self.destination_data_source_type = destination_data_source_type
        # The ID of the synchronization task.
        self.id = id
        # The name of the synchronization task.
        self.job_name = job_name
        # The runtime settings.
        self.job_settings = job_settings
        # The status of the job.
        self.job_status = job_status
        # 
        # 
        # - DatabaseRealtimeMigration():+
        # 
        # - DatabaseOfflineMigration():+
        # 
        # - SingleTableRealtimeMigration():
        self.job_type = job_type
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: full synchronization and real-time incremental synchronization of data in an entire database
        # *   RealtimeIncremental: real-time incremental synchronization of data in a single table
        # *   Full: full batch synchronization of data in an entire database
        # *   OfflineIncremental: batch incremental synchronization of data in an entire database
        # *   FullAndOfflineIncremental: full synchronization and batch incremental synchronization of data in an entire database
        self.migration_type = migration_type
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter indicates the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id
        # The resource settings.
        self.resource_settings = resource_settings
        # The settings of the source. Only a single source is supported.
        self.source_data_source_settings = source_data_source_settings
        # The source type. Valid values: PolarDB, MySQL, Kafka, LogHub, Hologres, Oracle, OceanBase, MongoDB, RedShift, Hive, SQLServer, Doris, ClickHouse.
        self.source_data_source_type = source_data_source_type
        # The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
        # 
        # >  [ { "SourceObjectSelectionRules":[ { "ObjectType":"Database", "Action":"Include", "ExpressionType":"Exact", "Expression":"biz_db" }, { "ObjectType":"Schema", "Action":"Include", "ExpressionType":"Exact", "Expression":"s1" }, { "ObjectType":"Table", "Action":"Include", "ExpressionType":"Exact", "Expression":"table1" } ], "TransformationRuleNames":[ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema" } ] } ]
        self.table_mappings = table_mappings
        # The list of transformation rules that are applied to the synchronization objects selected from the source.
        # 
        # >  [ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema", "RuleExpression":"{"expression":"${srcDatasoureName}_${srcDatabaseName}"}" } ]
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.destination_data_source_settings:
            for k in self.destination_data_source_settings:
                if k:
                    k.validate()
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.source_data_source_settings:
            for k in self.source_data_source_settings:
                if k:
                    k.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        result['DestinationDataSourceSettings'] = []
        if self.destination_data_source_settings is not None:
            for k in self.destination_data_source_settings:
                result['DestinationDataSourceSettings'].append(k.to_map() if k else None)
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.id is not None:
            result['Id'] = self.id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['SourceDataSourceSettings'] = []
        if self.source_data_source_settings is not None:
            for k in self.source_data_source_settings:
                result['SourceDataSourceSettings'].append(k.to_map() if k else None)
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.destination_data_source_settings = []
        if m.get('DestinationDataSourceSettings') is not None:
            for k in m.get('DestinationDataSourceSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoDestinationDataSourceSettings()
                self.destination_data_source_settings.append(temp_model.from_map(k))
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = GetDIJobResponseBodyPagingInfoResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.source_data_source_settings = []
        if m.get('SourceDataSourceSettings') is not None:
            for k in m.get('SourceDataSourceSettings'):
                temp_model = GetDIJobResponseBodyPagingInfoSourceDataSourceSettings()
                self.source_data_source_settings.append(temp_model.from_map(k))
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = GetDIJobResponseBodyPagingInfoTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = GetDIJobResponseBodyPagingInfoTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class GetDIJobResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: GetDIJobResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = GetDIJobResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDIJobLogRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        failover_id: int = None,
        id: int = None,
        instance_id: int = None,
        node_type: str = None,
        page_number: int = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The failover ID.
        self.failover_id = failover_id
        # The ID of the synchronization task.
        self.id = id
        # The instance ID.
        self.instance_id = instance_id
        # The type of the node. This parameter is applicable only to the tasks that are run on serverless resource groups. Valid values:
        # 
        # *   **MASTER**: the master node, which is used to query the logs of JobManagers.
        # *   **WORKER**: the worker node, which is used to query the logs of TaskManagers.
        self.node_type = node_type
        # The page number of the pagination query. The value is a positive integer greater than or equal to 1.
        self.page_number = page_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.failover_id is not None:
            result['FailoverId'] = self.failover_id
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('FailoverId') is not None:
            self.failover_id = m.get('FailoverId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        return self


class GetDIJobLogResponseBody(TeaModel):
    def __init__(
        self,
        log: str = None,
        request_id: str = None,
    ):
        # The log.
        self.log = log
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log is not None:
            result['Log'] = self.log
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDIJobLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDIJobLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDIJobLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataQualityEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the data quality monitor.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The hook trigger condition. When this condition is met, the hook action is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The hook type. Only one hook type is supported.
        # 
        # *   BlockTaskInstance: Blocks the running of scheduling tasks. A monitor is triggered by scheduling tasks. After a monitor finishes running, the monitor determines whether to block the running of scheduling tasks based on the hook condition.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The extended information.
        self.extension = extension
        # The additional parameters that are required when alerts are sent. The parameters are JSON-formatted strings. The following keys are supported:
        # 
        # *   atAll: specifies that all members in a group are mentioned when alerts are sent by using DingTalk. This parameter is valid only if you set ReceiverType to DingdingUrl.
        # 
        # Valid values:
        # 
        # *   WebhookUrl
        # *   FeishuUrl
        # *   DingdingUrl
        # *   WeixinUrl
        # *   AliUid
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The configurations of alert recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications] = None,
    ):
        # The notification trigger condition. When this condition is met, the alert notification is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High"AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The configurations of alert notifications.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   hologres
        # *   cdh
        # *   analyticdb_for_mysql
        # *   starrocks
        # *   emr
        # *   analyticdb_for_postgresql
        self.database_type = database_type
        # Data quality monitoring partition range settings.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitoring object.
        # 
        # - Table: Table.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of scheduling tasks. This parameter is valid only if you set Type to ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger type of the monitor. Valid values:
        # 
        # *   ByManual: The monitor is manually triggered.
        # *   ByScheduledTaskInstance: The monitor is triggered by associated scheduling tasks.
        # *   ByQualityNode: The monitor is triggered by created data quality monitoring nodes.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        hooks: List[GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget = None,
        trigger: GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger = None,
    ):
        # The ID of the data source used for the monitor.
        self.data_source_id = data_source_id
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks = hooks
        # The ID of the data quality monitor.
        self.id = id
        # The name of the monitor.
        # 
        # This parameter is required.
        self.name = name
        # The configurations of alert notifications.
        self.notifications = notifications
        # The workspace ID.
        self.project_id = project_id
        # Extended configuration, JSON-formatted string, takes effect only for EMR-type data quality monitoring.
        # 
        # - queue: the yarn queue used when performing EMR data quality verification. The default queue is the queue configured for this project.
        # - sqlEngine: SQL engine used when performing EMR data verification
        #     - HIVE_ SQL
        #     - SPARK_ SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the monitor.
        self.target = target
        # The trigger configuration of the monitor.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class GetDataQualityEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task: GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask = None,
        request_id: str = None,
    ):
        # The details of the monitor.
        self.data_quality_evaluation_task = data_quality_evaluation_task
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data_quality_evaluation_task:
            self.data_quality_evaluation_task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task is not None:
            result['DataQualityEvaluationTask'] = self.data_quality_evaluation_task.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTask') is not None:
            temp_model = GetDataQualityEvaluationTaskResponseBodyDataQualityEvaluationTask()
            self.data_quality_evaluation_task = temp_model.from_map(m['DataQualityEvaluationTask'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataQualityEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataQualityEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataQualityEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataQualityEvaluationTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the data quality monitoring instance.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails(TeaModel):
    def __init__(
        self,
        checked_value: str = None,
        referenced_value: str = None,
        status: str = None,
    ):
        self.checked_value = checked_value
        self.referenced_value = referenced_value
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checked_value is not None:
            result['CheckedValue'] = self.checked_value
        if self.referenced_value is not None:
            result['ReferencedValue'] = self.referenced_value
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckedValue') is not None:
            self.checked_value = m.get('CheckedValue')
        if m.get('ReferencedValue') is not None:
            self.referenced_value = m.get('ReferencedValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.expression = expression
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical = None,
        expected: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected = None,
        warned: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned = None,
    ):
        self.critical = critical
        self.expected = expected
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        self.referenced_samples_filter = referenced_samples_filter
        self.thresholds = thresholds
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        self.error_data_filter = error_data_filter
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        self.metric = metric
        self.metric_parameters = metric_parameters
        self.sampling_filter = sampling_filter
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        self.database_type = database_type
        self.table_guid = table_guid
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule(TeaModel):
    def __init__(
        self,
        checking_config: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig = None,
        severity: str = None,
        target: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget = None,
        template_code: str = None,
    ):
        self.checking_config = checking_config
        self.description = description
        self.enabled = enabled
        self.error_handlers = error_handlers
        self.id = id
        self.name = name
        self.project_id = project_id
        self.sampling_config = sampling_config
        self.severity = severity
        self.target = target
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        details: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails] = None,
        id: int = None,
        rule: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule = None,
        sample: str = None,
        status: str = None,
        task_instance_id: int = None,
    ):
        self.create_time = create_time
        self.details = details
        self.id = id
        self.rule = rule
        self.sample = sample
        self.status = status
        self.task_instance_id = task_instance_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.rule:
            self.rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        if self.sample is not None:
            result['Sample'] = self.sample
        if self.status is not None:
            result['Status'] = self.status
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Rule') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResultsRule()
            self.rule = temp_model.from_map(m['Rule'])
        if m.get('Sample') is not None:
            self.sample = m.get('Sample')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The hook trigger condition. When this condition is met, the hook action is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # Hook type. Currently, only one type is supported:
        # 
        # - BlockTaskInstance: the blocking scheduling task continues to run. Data quality monitoring is triggered by the scheduling task. After the data quality monitoring is completed, the Hook.Condition is used to determine whether the blocking scheduling task continues to run.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The notification method.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # Additional parameter settings for sending alerts in json format. The supported keys are as follows:
        # 
        # - atAll: when sending DingTalk alerts, do you need to @ everyone in the group. It takes effect when ReceiverType is DingdingUrl.
        self.extension = extension
        # The type of alert recipient.
        self.receiver_type = receiver_type
        # The recipient of the alert.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The notification method.
        self.notification_channels = notification_channels
        # The value of the receiver.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications] = None,
    ):
        # The notification trigger condition. When this condition is met, the alert notification is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The alert notification methods.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs.
        self.database_type = database_type
        # The partition range monitored.
        self.partition_spec = partition_spec
        # The unique ID of the table in the data map.
        self.table_guid = table_guid
        # The type of the monitoring object.
        # - Table: Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The Id list of the scheduled task, which is valid when the Type is ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger type of the monitor. Valid values:
        # 
        # *   ByManual (default): The monitor is manually triggered.
        # *   ByScheduledTaskInstance: The monitor is triggered by the associated scheduling tasks.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask(TeaModel):
    def __init__(
        self,
        description: str = None,
        hooks: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget = None,
        trigger: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger = None,
    ):
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks = hooks
        # The ID of the data quality monitor.
        self.id = id
        # The name of the monitor.
        self.name = name
        # The configurations of alert notifications.
        self.notifications = notifications
        # The ID of the workspace.
        self.project_id = project_id
        # Extended configuration, JSON-formatted string, takes effect only for EMR-type data quality monitoring.
        # 
        # - queue: the yarn queue used when performing EMR data quality verification. The default queue is the queue configured for this project.
        # - sqlEngine: SQL engine used when performing EMR data verification
        #   - HIVE_ SQL
        #   - SPARK_ SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the monitor.
        self.target = target
        # The trigger configuration of the monitor.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        finish_time: int = None,
        id: int = None,
        parameters: str = None,
        project_id: int = None,
        results: List[GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults] = None,
        status: str = None,
        task: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask = None,
        trigger_context: str = None,
    ):
        # The creation time.
        self.create_time = create_time
        # The end time of the instance.
        self.finish_time = finish_time
        # The ID of the data quality monitoring instance.
        self.id = id
        # Data quality verification execution parameters in JSON format. The available keys are as follows:
        # - triggerTime: the millisecond timestamp of the trigger time. The baseline time of the $[yyyymmdd] expression in the data range of data quality monitoring. Required.
        self.parameters = parameters
        # The ID of the workspace.
        self.project_id = project_id
        self.results = results
        # The status of the data quality monitoring instance.
        # - Running: Verifying
        # - Error: A rule verification Error occurred.
        # - Passed: all rules are verified
        # - Warned: normal alarm threshold triggered by rules
        # - Critical: Threshold for serious alerts triggered by rules
        self.status = status
        # The monitor.
        self.task = task
        # The context information when the instance is triggered, in JSON format. The possible keys are as follows:
        # - TriggerClient: the trigger source of the data quality monitoring instance, such as CWF2 (scheduling system), may be added later.
        # - TriggerClientId: associated with a specific business resource in the source system. For example, if TriggerClient is CWF2, the ID of the scheduling task is recorded here.
        self.trigger_context = trigger_context

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.task is not None:
            result['Task'] = self.task.to_map()
        if self.trigger_context is not None:
            result['TriggerContext'] = self.trigger_context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceResults()
                self.results.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Task') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstanceTask()
            self.task = temp_model.from_map(m['Task'])
        if m.get('TriggerContext') is not None:
            self.trigger_context = m.get('TriggerContext')
        return self


class GetDataQualityEvaluationTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_instance: GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance = None,
        request_id: str = None,
    ):
        # The details of the monitor instance.
        self.data_quality_evaluation_task_instance = data_quality_evaluation_task_instance
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        if self.data_quality_evaluation_task_instance:
            self.data_quality_evaluation_task_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_instance is not None:
            result['DataQualityEvaluationTaskInstance'] = self.data_quality_evaluation_task_instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskInstance') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBodyDataQualityEvaluationTaskInstance()
            self.data_quality_evaluation_task_instance = temp_model.from_map(m['DataQualityEvaluationTaskInstance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataQualityEvaluationTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataQualityEvaluationTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataQualityEvaluationTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataQualityRuleRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The rule ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical = None,
        expected: GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected = None,
        warned: GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference values. In this example, an expression is used to indicate the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If you define the rule by using custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # Processor type:
        # - SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class GetDataQualityRuleResponseBodyDataQualityRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The dataset of the table type. The database type to which the table belongs.
        # - maxcompute
        # - emr
        # - cdh
        # - hologres
        # - analyticdb_for_postgresql
        # - analyticdb_for_mysql
        # - starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table that is limited by the rule in Data Map.
        self.table_guid = table_guid
        # Monitoring object type
        # 
        # - Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityRuleResponseBodyDataQualityRule(TeaModel):
    def __init__(
        self,
        checking_config: GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig = None,
        severity: str = None,
        target: GetDataQualityRuleResponseBodyDataQualityRuleTarget = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        self.id = id
        # The rule name.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # Rule for the business level (corresponding to the strong and weak rules on the page), optional enumeration value:
        # - Normal
        # - High
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = GetDataQualityRuleResponseBodyDataQualityRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class GetDataQualityRuleResponseBody(TeaModel):
    def __init__(
        self,
        data_quality_rule: GetDataQualityRuleResponseBodyDataQualityRule = None,
        request_id: str = None,
    ):
        # The information about the rule.
        self.data_quality_rule = data_quality_rule
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_quality_rule:
            self.data_quality_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_rule is not None:
            result['DataQualityRule'] = self.data_quality_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityRule') is not None:
            temp_model = GetDataQualityRuleResponseBodyDataQualityRule()
            self.data_quality_rule = temp_model.from_map(m['DataQualityRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataQualityRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataQualityRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataQualityRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataQualityRuleTemplateRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
    ):
        # The code for the template.
        # 
        # This parameter is required.
        self.code = code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        return self


class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference samples and perform aggregate operations on the reference values. In this example, an expression is used to indicate the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate(TeaModel):
    def __init__(
        self,
        checking_config: GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig = None,
        code: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config: GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig = None,
        visible_scope: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The code for the template.
        self.code = code
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # Available range of templates:
        # - Tenant: all tenants are available
        # - Project: only available in the current Project
        self.visible_scope = visible_scope

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.visible_scope is not None:
            result['VisibleScope'] = self.visible_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplateSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('VisibleScope') is not None:
            self.visible_scope = m.get('VisibleScope')
        return self


class GetDataQualityRuleTemplateResponseBody(TeaModel):
    def __init__(
        self,
        data_quality_rule_template: GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate = None,
        request_id: str = None,
    ):
        # The information about the template.
        self.data_quality_rule_template = data_quality_rule_template
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_quality_rule_template:
            self.data_quality_rule_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_rule_template is not None:
            result['DataQualityRuleTemplate'] = self.data_quality_rule_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityRuleTemplate') is not None:
            temp_model = GetDataQualityRuleTemplateResponseBodyDataQualityRuleTemplate()
            self.data_quality_rule_template = temp_model.from_map(m['DataQualityRuleTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataQualityRuleTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataQualityRuleTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataQualityRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataSourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The data source ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDataSourceResponseBodyDataSource(TeaModel):
    def __init__(
        self,
        connection_properties: Any = None,
        connection_properties_mode: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        project_id: int = None,
        qualified_name: str = None,
        type: str = None,
    ):
        # The connection configurations of the data source, including the connection address, access identity, and environment information. The envType parameter specifies the environment in which the data source is used. Valid values of the envType parameter:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        # 
        # The parameters that you need to configure for the data source vary based on the mode in which the data source is added. For more information, see [Data source connection information (ConnectionProperties)](https://help.aliyun.com/document_detail/2852465.html).
        self.connection_properties = connection_properties
        # The mode in which the data source is added. The mode varies based on the data source type. Valid values:
        # 
        # *   InstanceMode: instance mode
        # *   UrlMode: connection string mode
        # *   CdhMode: CDH cluster mode
        self.connection_properties_mode = connection_properties_mode
        # The time when the data source was added. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who adds the data source.
        self.create_user = create_user
        # The description of the data source.
        self.description = description
        # The data source ID.
        self.id = id
        # The time when the data source was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The ID of the user who modifies the data source.
        self.modify_user = modify_user
        # The name of the data source.
        self.name = name
        # The ID of the workspace with which the data source is associated.
        self.project_id = project_id
        # The unique business key of the data source. For example, the unique business key of a Hologres data source is in the `${tenantOwnerId}:${regionId}:${type}:${instanceId}:${database}` format.
        self.qualified_name = qualified_name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.qualified_name is not None:
            result['QualifiedName'] = self.qualified_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('QualifiedName') is not None:
            self.qualified_name = m.get('QualifiedName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        data_source: GetDataSourceResponseBodyDataSource = None,
        request_id: str = None,
    ):
        # The information about the data source.
        self.data_source = data_source
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSource') is not None:
            temp_model = GetDataSourceResponseBodyDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: Database = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.database = database
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = Database()
            self.database = temp_model.from_map(m['Database'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeploymentPackageRequest(TeaModel):
    def __init__(
        self,
        deployment_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.deployment_id = deployment_id
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class GetDeploymentPackageResponseBodyDataDeployedItems(TeaModel):
    def __init__(
        self,
        file_id: int = None,
        file_version: int = None,
        status: int = None,
    ):
        self.file_id = file_id
        self.file_version = file_version
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_version is not None:
            result['FileVersion'] = self.file_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileVersion') is not None:
            self.file_version = m.get('FileVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDeploymentPackageResponseBodyDataDeployment(TeaModel):
    def __init__(
        self,
        checking_status: int = None,
        create_time: int = None,
        creator_id: str = None,
        error_message: str = None,
        execute_time: int = None,
        from_environment: int = None,
        handler_id: str = None,
        name: str = None,
        status: int = None,
        to_environment: int = None,
    ):
        self.checking_status = checking_status
        self.create_time = create_time
        self.creator_id = creator_id
        self.error_message = error_message
        self.execute_time = execute_time
        self.from_environment = from_environment
        self.handler_id = handler_id
        self.name = name
        self.status = status
        self.to_environment = to_environment

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_status is not None:
            result['CheckingStatus'] = self.checking_status
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.from_environment is not None:
            result['FromEnvironment'] = self.from_environment
        if self.handler_id is not None:
            result['HandlerId'] = self.handler_id
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.to_environment is not None:
            result['ToEnvironment'] = self.to_environment
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingStatus') is not None:
            self.checking_status = m.get('CheckingStatus')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('FromEnvironment') is not None:
            self.from_environment = m.get('FromEnvironment')
        if m.get('HandlerId') is not None:
            self.handler_id = m.get('HandlerId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('ToEnvironment') is not None:
            self.to_environment = m.get('ToEnvironment')
        return self


class GetDeploymentPackageResponseBodyData(TeaModel):
    def __init__(
        self,
        deployed_items: List[GetDeploymentPackageResponseBodyDataDeployedItems] = None,
        deployment: GetDeploymentPackageResponseBodyDataDeployment = None,
    ):
        self.deployed_items = deployed_items
        self.deployment = deployment

    def validate(self):
        if self.deployed_items:
            for k in self.deployed_items:
                if k:
                    k.validate()
        if self.deployment:
            self.deployment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeployedItems'] = []
        if self.deployed_items is not None:
            for k in self.deployed_items:
                result['DeployedItems'].append(k.to_map() if k else None)
        if self.deployment is not None:
            result['Deployment'] = self.deployment.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployed_items = []
        if m.get('DeployedItems') is not None:
            for k in m.get('DeployedItems'):
                temp_model = GetDeploymentPackageResponseBodyDataDeployedItems()
                self.deployed_items.append(temp_model.from_map(k))
        if m.get('Deployment') is not None:
            temp_model = GetDeploymentPackageResponseBodyDataDeployment()
            self.deployment = temp_model.from_map(m['Deployment'])
        return self


class GetDeploymentPackageResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDeploymentPackageResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDeploymentPackageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDeploymentPackageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeploymentPackageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeploymentPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileRequest(TeaModel):
    def __init__(
        self,
        file_id: int = None,
        node_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # The file ID. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
        self.file_id = file_id
        # The ID of the node that is scheduled. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
        self.node_id = node_id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
        self.project_id = project_id
        # The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the name.
        # 
        # You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class GetFileResponseBodyDataFile(TeaModel):
    def __init__(
        self,
        advanced_settings: str = None,
        auto_parsing: bool = None,
        biz_id: int = None,
        business_id: int = None,
        commit_status: int = None,
        connection_name: str = None,
        content: str = None,
        create_time: int = None,
        create_user: str = None,
        current_version: int = None,
        deleted_status: str = None,
        file_description: str = None,
        file_folder_id: str = None,
        file_id: int = None,
        file_name: str = None,
        file_type: int = None,
        is_max_compute: bool = None,
        last_edit_time: int = None,
        last_edit_user: str = None,
        node_id: int = None,
        owner: str = None,
        parent_id: int = None,
        use_type: str = None,
    ):
        # The advanced configurations of the node.
        # 
        # This parameter is valid for an EMR node. This parameter corresponds to the Advanced Settings tab in the right-side navigation pane on the configuration tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
        # 
        # >  You cannot configure advanced parameters for EMR Shell nodes.
        # 
        # For information about the advanced parameters of each type of EMR node, see [Develop EMR tasks](https://help.aliyun.com/document_detail/473077.html).
        self.advanced_settings = advanced_settings
        # Indicates whether the automatic parsing feature is enabled for the file. Valid values:
        # 
        # *   true
        # *   false
        # 
        # This parameter corresponds to the Automatic Parsing From Code Before Node Committing parameter that is displayed after you select Same Cycle in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.auto_parsing = auto_parsing
        # The ID of the workflow to which the file belongs. This parameter is deprecated and replaced by the BusinessId parameter.
        self.biz_id = biz_id
        # The ID of the workflow to which the file belongs.
        self.business_id = business_id
        # Indicates whether the latest code in the file is committed. Valid values: 0 and 1. The value 0 indicates that the latest code in the file is not committed. The value 1 indicates that the latest code in the file is committed.
        self.commit_status = commit_status
        # The name of the data source that is used to run the node that corresponds to the file.
        self.connection_name = connection_name
        # The code in the file.
        self.content = content
        # The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The ID of the Alibaba Cloud account used to create the file.
        self.create_user = create_user
        # The latest version number of the file.
        self.current_version = current_version
        # The status of the file. Valid values:
        # 
        # *   NORMAL: The file is not deleted.
        # *   RECYCLE_BIN: The file is stored in the recycle bin.
        # *   DELETED: The file is deleted.
        self.deleted_status = deleted_status
        # The description of the file.
        self.file_description = file_description
        # The ID of the folder to which the file belongs.
        self.file_folder_id = file_folder_id
        # The file ID.
        self.file_id = file_id
        # The name of the file.
        self.file_name = file_name
        # The type of the code for the file. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
        self.file_type = file_type
        # Indicates whether the resource file needs to be uploaded to MaxCompute. This parameter is returned only if the file is a MaxCompute resource file.
        self.is_max_compute = is_max_compute
        # The time when the file was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.last_edit_time = last_edit_time
        # The ID of the Alibaba Cloud account used to last modify the file.
        self.last_edit_user = last_edit_user
        # The ID of the auto triggered node that is generated in the scheduling system after the file is committed.
        self.node_id = node_id
        # The ID of the Alibaba Cloud account used by the file owner.
        self.owner = owner
        # The ID of the node group file to which the current file belongs. This parameter is returned only if the current file is an inner file of the node group file.
        self.parent_id = parent_id
        # The module to which the file belongs. Valid values:
        # 
        # *   NORMAL: The file is used for DataStudio.
        # *   MANUAL: The file is used for a manually triggered node.
        # *   MANUAL_BIZ: The file is used for a manually triggered workflow.
        # *   SKIP: The file is used for a dry-run node in DataStudio.
        # *   ADHOCQUERY: The file is used for an ad hoc query.
        # *   COMPONENT: The file is used for a script template.
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_settings is not None:
            result['AdvancedSettings'] = self.advanced_settings
        if self.auto_parsing is not None:
            result['AutoParsing'] = self.auto_parsing
        if self.biz_id is not None:
            result['BizId'] = self.biz_id
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.commit_status is not None:
            result['CommitStatus'] = self.commit_status
        if self.connection_name is not None:
            result['ConnectionName'] = self.connection_name
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.deleted_status is not None:
            result['DeletedStatus'] = self.deleted_status
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_id is not None:
            result['FileFolderId'] = self.file_folder_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.is_max_compute is not None:
            result['IsMaxCompute'] = self.is_max_compute
        if self.last_edit_time is not None:
            result['LastEditTime'] = self.last_edit_time
        if self.last_edit_user is not None:
            result['LastEditUser'] = self.last_edit_user
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdvancedSettings') is not None:
            self.advanced_settings = m.get('AdvancedSettings')
        if m.get('AutoParsing') is not None:
            self.auto_parsing = m.get('AutoParsing')
        if m.get('BizId') is not None:
            self.biz_id = m.get('BizId')
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('CommitStatus') is not None:
            self.commit_status = m.get('CommitStatus')
        if m.get('ConnectionName') is not None:
            self.connection_name = m.get('ConnectionName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('DeletedStatus') is not None:
            self.deleted_status = m.get('DeletedStatus')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderId') is not None:
            self.file_folder_id = m.get('FileFolderId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IsMaxCompute') is not None:
            self.is_max_compute = m.get('IsMaxCompute')
        if m.get('LastEditTime') is not None:
            self.last_edit_time = m.get('LastEditTime')
        if m.get('LastEditUser') is not None:
            self.last_edit_user = m.get('LastEditUser')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class GetFileResponseBodyDataNodeConfigurationInputList(TeaModel):
    def __init__(
        self,
        input: str = None,
        parse_type: str = None,
    ):
        # The output name of the parent file on which the current file depends.
        # 
        # This parameter corresponds to the Output Name of Ancestor Node parameter under Parent Nodes after Same Cycle is selected in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.input = input
        # The mode of the configuration file dependency. Valid values:
        # 
        # *   MANUAL: Scheduling dependencies are manually configured.
        # *   AUTO: Scheduling dependencies are automatically parsed.
        self.parse_type = parse_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.parse_type is not None:
            result['ParseType'] = self.parse_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('ParseType') is not None:
            self.parse_type = m.get('ParseType')
        return self


class GetFileResponseBodyDataNodeConfigurationInputParameters(TeaModel):
    def __init__(
        self,
        parameter_name: str = None,
        value_source: str = None,
    ):
        # The name of the input parameter of the node. In the code, you can use the ${...} method to reference the input parameter of the node.
        # 
        # This parameter corresponds to the Parameter Name parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.parameter_name = parameter_name
        # The value source of the input parameter of the node.
        # 
        # This parameter corresponds to the Value Source parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.value_source = value_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.parameter_name is not None:
            result['ParameterName'] = self.parameter_name
        if self.value_source is not None:
            result['ValueSource'] = self.value_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ParameterName') is not None:
            self.parameter_name = m.get('ParameterName')
        if m.get('ValueSource') is not None:
            self.value_source = m.get('ValueSource')
        return self


class GetFileResponseBodyDataNodeConfigurationOutputList(TeaModel):
    def __init__(
        self,
        output: str = None,
        ref_table_name: str = None,
    ):
        # The output name of the current file.
        # 
        # This parameter corresponds to the Output Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.output = output
        # The output table name of the current file.
        # 
        # This parameter corresponds to the Output Table Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.ref_table_name = ref_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        if self.ref_table_name is not None:
            result['RefTableName'] = self.ref_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('RefTableName') is not None:
            self.ref_table_name = m.get('RefTableName')
        return self


class GetFileResponseBodyDataNodeConfigurationOutputParameters(TeaModel):
    def __init__(
        self,
        description: str = None,
        parameter_name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The description of the output parameter of the node.
        self.description = description
        # The name of the output parameter of the node.
        # 
        # This parameter corresponds to the Parameter Name parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.parameter_name = parameter_name
        # The type of the output parameter of the node. Valid values:
        # 
        # *   1: indicates a constant.
        # *   2: indicates a variable.
        # *   3: indicates a pass-through variable.
        # 
        # This parameter corresponds to the Type parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.type = type
        # The value of the output parameter of the node.
        # 
        # This parameter corresponds to the Value parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.parameter_name is not None:
            result['ParameterName'] = self.parameter_name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ParameterName') is not None:
            self.parameter_name = m.get('ParameterName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetFileResponseBodyDataNodeConfiguration(TeaModel):
    def __init__(
        self,
        apply_schedule_immediately: str = None,
        auto_rerun_interval_millis: int = None,
        auto_rerun_times: int = None,
        cron_express: str = None,
        cycle_type: str = None,
        dependent_node_id_list: str = None,
        dependent_type: str = None,
        end_effect_date: int = None,
        ignore_parent_skip_running_property: str = None,
        image_id: str = None,
        input_list: List[GetFileResponseBodyDataNodeConfigurationInputList] = None,
        input_parameters: List[GetFileResponseBodyDataNodeConfigurationInputParameters] = None,
        output_list: List[GetFileResponseBodyDataNodeConfigurationOutputList] = None,
        output_parameters: List[GetFileResponseBodyDataNodeConfigurationOutputParameters] = None,
        para_value: str = None,
        rerun_mode: str = None,
        resource_group_id: int = None,
        scheduler_type: str = None,
        start_effect_date: int = None,
        start_immediately: bool = None,
        stop: bool = None,
        timeout: int = None,
    ):
        # Indicates whether scheduling configurations immediately take effect after the deployment.
        self.apply_schedule_immediately = apply_schedule_immediately
        # The interval between automatic reruns after an error occurs. Unit: milliseconds.
        # 
        # This parameter corresponds to the Rerun interval parameter that is displayed after the Auto Rerun upon Failure check box is selected in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console). The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
        self.auto_rerun_interval_millis = auto_rerun_interval_millis
        # The number of automatic reruns that are allowed after an error occurs.
        self.auto_rerun_times = auto_rerun_times
        # The cron expression that represents the periodic scheduling policy of the node.
        self.cron_express = cron_express
        # The type of the scheduling cycle. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
        # 
        # This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.cycle_type = cycle_type
        # The ID of the node on which the node that corresponds to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
        # 
        # The value of this parameter is equivalent to the ID of the node that you specified after you select Previous Cycle and set Depend On to Other Nodes in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.dependent_node_id_list = dependent_node_id_list
        # The type of the cross-cycle scheduling dependency of the node. Valid values:
        # 
        # *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
        # *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
        # *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
        # *   NONE: No cross-cycle scheduling dependency type is selected for the node.
        self.dependent_type = dependent_type
        # The end of the time range for automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        # 
        # Configuring this parameter is equivalent to specifying an end time for the Validity Period parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.end_effect_date = end_effect_date
        # Indicates whether the dry-run property of the ancestor nodes of the node is skipped. This parameter corresponds to the Skip the dry-run property of the ancestor node parameter that is displayed after you configure the Depend On parameter in the Dependencies section of the Properties tab on the DataStudio page in the DataWorks console.
        self.ignore_parent_skip_running_property = ignore_parent_skip_running_property
        # The custom image ID.
        self.image_id = image_id
        # The output information about the parent files on which the current file depends.
        self.input_list = input_list
        # The input parameters of the node.
        self.input_parameters = input_parameters
        # The output information about the current file.
        self.output_list = output_list
        # The output parameters of the node.
        self.output_parameters = output_parameters
        # The scheduling parameters of the node.
        # 
        # This parameter corresponds to the Scheduling Parameter section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of scheduling parameters, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
        self.para_value = para_value
        # Indicates whether the node that corresponds to the file can be rerun. Valid values:
        # 
        # *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
        # *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
        # *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
        # 
        # This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.rerun_mode = rerun_mode
        # The ID of the resource group that is used to run the node that corresponds to the file. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace.
        self.resource_group_id = resource_group_id
        # The scheduling type of the node. Valid values:
        # 
        # *   NORMAL: The node is an auto triggered node.
        # *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
        # *   PAUSE: The node is a paused node.
        # *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled, but the system sets the status of the nodes to successful when it starts to run them.
        self.scheduler_type = scheduler_type
        # The beginning of the time range for automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        # 
        # Configuring this parameter is equivalent to specifying a start time for the Validity Period parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.start_effect_date = start_effect_date
        # Indicates whether a node is immediately run after the node is deployed to the production environment.
        # 
        # This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.start_immediately = start_immediately
        # Indicates whether the scheduling for the node is suspended Valid values:
        # 
        # *   true
        # *   false
        # 
        # This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.stop = stop
        # The timeout period.
        self.timeout = timeout

    def validate(self):
        if self.input_list:
            for k in self.input_list:
                if k:
                    k.validate()
        if self.input_parameters:
            for k in self.input_parameters:
                if k:
                    k.validate()
        if self.output_list:
            for k in self.output_list:
                if k:
                    k.validate()
        if self.output_parameters:
            for k in self.output_parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_schedule_immediately is not None:
            result['ApplyScheduleImmediately'] = self.apply_schedule_immediately
        if self.auto_rerun_interval_millis is not None:
            result['AutoRerunIntervalMillis'] = self.auto_rerun_interval_millis
        if self.auto_rerun_times is not None:
            result['AutoRerunTimes'] = self.auto_rerun_times
        if self.cron_express is not None:
            result['CronExpress'] = self.cron_express
        if self.cycle_type is not None:
            result['CycleType'] = self.cycle_type
        if self.dependent_node_id_list is not None:
            result['DependentNodeIdList'] = self.dependent_node_id_list
        if self.dependent_type is not None:
            result['DependentType'] = self.dependent_type
        if self.end_effect_date is not None:
            result['EndEffectDate'] = self.end_effect_date
        if self.ignore_parent_skip_running_property is not None:
            result['IgnoreParentSkipRunningProperty'] = self.ignore_parent_skip_running_property
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        result['InputList'] = []
        if self.input_list is not None:
            for k in self.input_list:
                result['InputList'].append(k.to_map() if k else None)
        result['InputParameters'] = []
        if self.input_parameters is not None:
            for k in self.input_parameters:
                result['InputParameters'].append(k.to_map() if k else None)
        result['OutputList'] = []
        if self.output_list is not None:
            for k in self.output_list:
                result['OutputList'].append(k.to_map() if k else None)
        result['OutputParameters'] = []
        if self.output_parameters is not None:
            for k in self.output_parameters:
                result['OutputParameters'].append(k.to_map() if k else None)
        if self.para_value is not None:
            result['ParaValue'] = self.para_value
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.scheduler_type is not None:
            result['SchedulerType'] = self.scheduler_type
        if self.start_effect_date is not None:
            result['StartEffectDate'] = self.start_effect_date
        if self.start_immediately is not None:
            result['StartImmediately'] = self.start_immediately
        if self.stop is not None:
            result['Stop'] = self.stop
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyScheduleImmediately') is not None:
            self.apply_schedule_immediately = m.get('ApplyScheduleImmediately')
        if m.get('AutoRerunIntervalMillis') is not None:
            self.auto_rerun_interval_millis = m.get('AutoRerunIntervalMillis')
        if m.get('AutoRerunTimes') is not None:
            self.auto_rerun_times = m.get('AutoRerunTimes')
        if m.get('CronExpress') is not None:
            self.cron_express = m.get('CronExpress')
        if m.get('CycleType') is not None:
            self.cycle_type = m.get('CycleType')
        if m.get('DependentNodeIdList') is not None:
            self.dependent_node_id_list = m.get('DependentNodeIdList')
        if m.get('DependentType') is not None:
            self.dependent_type = m.get('DependentType')
        if m.get('EndEffectDate') is not None:
            self.end_effect_date = m.get('EndEffectDate')
        if m.get('IgnoreParentSkipRunningProperty') is not None:
            self.ignore_parent_skip_running_property = m.get('IgnoreParentSkipRunningProperty')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        self.input_list = []
        if m.get('InputList') is not None:
            for k in m.get('InputList'):
                temp_model = GetFileResponseBodyDataNodeConfigurationInputList()
                self.input_list.append(temp_model.from_map(k))
        self.input_parameters = []
        if m.get('InputParameters') is not None:
            for k in m.get('InputParameters'):
                temp_model = GetFileResponseBodyDataNodeConfigurationInputParameters()
                self.input_parameters.append(temp_model.from_map(k))
        self.output_list = []
        if m.get('OutputList') is not None:
            for k in m.get('OutputList'):
                temp_model = GetFileResponseBodyDataNodeConfigurationOutputList()
                self.output_list.append(temp_model.from_map(k))
        self.output_parameters = []
        if m.get('OutputParameters') is not None:
            for k in m.get('OutputParameters'):
                temp_model = GetFileResponseBodyDataNodeConfigurationOutputParameters()
                self.output_parameters.append(temp_model.from_map(k))
        if m.get('ParaValue') is not None:
            self.para_value = m.get('ParaValue')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SchedulerType') is not None:
            self.scheduler_type = m.get('SchedulerType')
        if m.get('StartEffectDate') is not None:
            self.start_effect_date = m.get('StartEffectDate')
        if m.get('StartImmediately') is not None:
            self.start_immediately = m.get('StartImmediately')
        if m.get('Stop') is not None:
            self.stop = m.get('Stop')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetFileResponseBodyDataResourceDownloadLink(TeaModel):
    def __init__(
        self,
        download_link: str = None,
    ):
        # The download URL of the resource.
        self.download_link = download_link

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_link is not None:
            result['downloadLink'] = self.download_link
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('downloadLink') is not None:
            self.download_link = m.get('downloadLink')
        return self


class GetFileResponseBodyData(TeaModel):
    def __init__(
        self,
        file: GetFileResponseBodyDataFile = None,
        node_configuration: GetFileResponseBodyDataNodeConfiguration = None,
        resource_download_link: GetFileResponseBodyDataResourceDownloadLink = None,
    ):
        # The basic information about the file.
        self.file = file
        # The scheduling configurations of the file.
        self.node_configuration = node_configuration
        # The download URL of the resource.
        self.resource_download_link = resource_download_link

    def validate(self):
        if self.file:
            self.file.validate()
        if self.node_configuration:
            self.node_configuration.validate()
        if self.resource_download_link:
            self.resource_download_link.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.node_configuration is not None:
            result['NodeConfiguration'] = self.node_configuration.to_map()
        if self.resource_download_link is not None:
            result['ResourceDownloadLink'] = self.resource_download_link.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('File') is not None:
            temp_model = GetFileResponseBodyDataFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('NodeConfiguration') is not None:
            temp_model = GetFileResponseBodyDataNodeConfiguration()
            self.node_configuration = temp_model.from_map(m['NodeConfiguration'])
        if m.get('ResourceDownloadLink') is not None:
            temp_model = GetFileResponseBodyDataResourceDownloadLink()
            self.resource_download_link = temp_model.from_map(m['ResourceDownloadLink'])
        return self


class GetFileResponseBody(TeaModel):
    def __init__(
        self,
        data: GetFileResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the file.
        self.data = data
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetFileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileVersionRequest(TeaModel):
    def __init__(
        self,
        file_id: int = None,
        file_version: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # The file ID. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
        # 
        # This parameter is required.
        self.file_id = file_id
        # The file version whose information you want to query.
        # 
        # This parameter is required.
        self.file_version = file_version
        # The DataWorks workspace ID. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace page and query the workspace ID.
        self.project_id = project_id
        # The unique identifier of the DataWorks workspace. You can view the identifier in the upper part of the DataStudio page. You can also select another identifier to switch to another workspace.
        # 
        # You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_version is not None:
            result['FileVersion'] = self.file_version
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileVersion') is not None:
            self.file_version = m.get('FileVersion')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class GetFileVersionResponseBodyData(TeaModel):
    def __init__(
        self,
        change_type: str = None,
        comment: str = None,
        commit_time: int = None,
        commit_user: str = None,
        file_content: str = None,
        file_name: str = None,
        file_property_content: str = None,
        file_version: int = None,
        is_current_prod: bool = None,
        node_content: str = None,
        node_id: int = None,
        status: str = None,
        use_type: str = None,
    ):
        # The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
        self.change_type = change_type
        # The description of the file version.
        self.comment = comment
        # The time when the file version was generated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.commit_time = commit_time
        # The ID of the Alibaba Cloud account that is used to generate the file of the current version.
        self.commit_user = commit_user
        # The code in the file of the current version.
        self.file_content = file_content
        # The name of the file of the current version.
        self.file_name = file_name
        # The basic information about the file of the current version.
        self.file_property_content = file_property_content
        # The file version.
        self.file_version = file_version
        # Indicates whether the version is the latest version in the production environment. Valid values:
        # 
        # *   true
        # *   false
        self.is_current_prod = is_current_prod
        # The scheduling configurations of the node that corresponds to the file of the current version.
        self.node_content = node_content
        # The ID of the node that corresponds to the file version.
        self.node_id = node_id
        # The status of the file version. Valid values:
        # 
        # *   COMMITTING
        # *   COMMITTED or CHECK_OK
        # *   PACKAGED
        # *   DEPLOYING
        # *   DEPLOYED
        # *   CANCELLED
        self.status = status
        # The module to which the file belongs. Valid values:
        # 
        # *   0: NORMAL, which indicates that the file is used for DataStudio.
        # *   1: MANUAL, which indicates that the file is used for a manually triggered node.
        # *   2: MANUAL_BIZ, which indicates that the file is used for a manually triggered workflow.
        # *   3: SKIP, which indicates that the file is used for a dry-run node in DataStudio.
        # *   10: ADHOCQUERY, which indicates that the file is used for an ad hoc query.
        # *   30: COMPONENT, which indicates that the file is used for a script template.
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.commit_time is not None:
            result['CommitTime'] = self.commit_time
        if self.commit_user is not None:
            result['CommitUser'] = self.commit_user
        if self.file_content is not None:
            result['FileContent'] = self.file_content
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_property_content is not None:
            result['FilePropertyContent'] = self.file_property_content
        if self.file_version is not None:
            result['FileVersion'] = self.file_version
        if self.is_current_prod is not None:
            result['IsCurrentProd'] = self.is_current_prod
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.status is not None:
            result['Status'] = self.status
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CommitTime') is not None:
            self.commit_time = m.get('CommitTime')
        if m.get('CommitUser') is not None:
            self.commit_user = m.get('CommitUser')
        if m.get('FileContent') is not None:
            self.file_content = m.get('FileContent')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FilePropertyContent') is not None:
            self.file_property_content = m.get('FilePropertyContent')
        if m.get('FileVersion') is not None:
            self.file_version = m.get('FileVersion')
        if m.get('IsCurrentProd') is not None:
            self.is_current_prod = m.get('IsCurrentProd')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class GetFileVersionResponseBody(TeaModel):
    def __init__(
        self,
        data: GetFileVersionResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the file version.
        self.data = data
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetFileVersionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFileVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFolderRequest(TeaModel):
    def __init__(
        self,
        folder_id: str = None,
        folder_path: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        self.folder_id = folder_id
        self.folder_path = folder_path
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.folder_path is not None:
            result['FolderPath'] = self.folder_path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('FolderPath') is not None:
            self.folder_path = m.get('FolderPath')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class GetFolderResponseBodyData(TeaModel):
    def __init__(
        self,
        folder_id: str = None,
        folder_path: str = None,
    ):
        self.folder_id = folder_id
        self.folder_path = folder_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.folder_path is not None:
            result['FolderPath'] = self.folder_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('FolderPath') is not None:
            self.folder_path = m.get('FolderPath')
        return self


class GetFolderResponseBody(TeaModel):
    def __init__(
        self,
        data: GetFolderResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetFolderResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFolderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFolderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFolderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFunctionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetFunctionResponseBodyFunction(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        spec: str = None,
    ):
        # The time when the UDF was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the UDF.
        self.id = id
        # The time when the UDF was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the UDF.
        self.name = name
        # The owner of the UDF.
        self.owner = owner
        # The ID of the DataWorks workspace to which the UDF belongs.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetFunctionResponseBody(TeaModel):
    def __init__(
        self,
        function: GetFunctionResponseBodyFunction = None,
        request_id: str = None,
    ):
        # The information about the UDF.
        self.function = function
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.function:
            self.function.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Function') is not None:
            temp_model = GetFunctionResponseBodyFunction()
            self.function = temp_model.from_map(m['Function'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIDEEventDetailRequest(TeaModel):
    def __init__(
        self,
        message_id: str = None,
        project_id: int = None,
    ):
        # The message ID in DataWorks OpenEvent. You can obtain the ID from a received message when an extension point event is triggered.
        # 
        # This parameter is required.
        self.message_id = message_id
        # The DataWorks workspace ID. You can obtain the ID from the message.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        current_version: int = None,
        data_source_name: str = None,
        folder_id: str = None,
        owner: str = None,
        parent_file_id: int = None,
    ):
        # The ID of the workflow to which the file belongs.
        self.business_id = business_id
        # The latest version number of the file.
        self.current_version = current_version
        # The name of the data source with which the file is associated.
        self.data_source_name = data_source_name
        # The ID of the folder to which the file belongs. You can call the [GetFolder](https://help.aliyun.com/document_detail/173952.html) operation to query the details of the file based on the folder ID.
        self.folder_id = folder_id
        # The file owner.
        self.owner = owner
        # The ID of the do-while node or for-each node that corresponds to the file.
        self.parent_file_id = parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parent_file_id is not None:
            result['ParentFileId'] = self.parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParentFileId') is not None:
            self.parent_file_id = m.get('ParentFileId')
        return self


class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList(TeaModel):
    def __init__(
        self,
        input: str = None,
        parse_type: str = None,
    ):
        # The output name of the parent file on which the current file depends.
        # 
        # This parameter corresponds to the Output Name of Ancestor Node parameter under Parent Nodes in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.input = input
        # The mode of the configuration file dependency. Valid values:
        # 
        # *   MANUAL: Scheduling dependencies are manually configured.
        # *   AUTO: Scheduling dependencies are automatically parsed.
        self.parse_type = parse_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input
        if self.parse_type is not None:
            result['ParseType'] = self.parse_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('ParseType') is not None:
            self.parse_type = m.get('ParseType')
        return self


class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList(TeaModel):
    def __init__(
        self,
        output: str = None,
        ref_table_name: str = None,
    ):
        # The output name of the current file.
        # 
        # This parameter corresponds to the Output Name parameter under Output Name of Current Node in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.output = output
        # The output table name of the current file.
        # 
        # This parameter corresponds to the Output Table Name parameter under Output Name of Current Node in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.ref_table_name = ref_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        if self.ref_table_name is not None:
            result['RefTableName'] = self.ref_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('RefTableName') is not None:
            self.ref_table_name = m.get('RefTableName')
        return self


class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration(TeaModel):
    def __init__(
        self,
        auto_rerun_interval_millis: int = None,
        auto_rerun_times: int = None,
        cron_express: str = None,
        cycle_type: str = None,
        dependent_node_id_list: str = None,
        dependent_type: str = None,
        input_list: List[GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList] = None,
        output_list: List[GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList] = None,
        para_value: str = None,
        rerun_mode: str = None,
        resource_group_id: int = None,
        scheduler_type: str = None,
    ):
        # The interval at which the node corresponding to the file is rerun. Unit: milliseconds.
        self.auto_rerun_interval_millis = auto_rerun_interval_millis
        # The number of times that the node corresponding to the file can be rerun.
        self.auto_rerun_times = auto_rerun_times
        # The cron expression that is used to schedule the node corresponding to the file.
        self.cron_express = cron_express
        # The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
        # 
        # This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.cycle_type = cycle_type
        # The ID of the node on which the node that corresponds to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
        # 
        # The value of this parameter is equivalent to the ID of the node that you specified after you select Other Nodes for Cross-Cycle Dependency (Original Previous-Cycle Dependency) in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.dependent_node_id_list = dependent_node_id_list
        # The type of the cross-cycle scheduling dependency of the node. Valid values:
        # 
        # *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
        # *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
        # *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
        # *   NONE: No cross-cycle scheduling dependency type is selected for the node.
        self.dependent_type = dependent_type
        # The output information about the parent files on which the current file depends.
        self.input_list = input_list
        # The output information about the current file.
        self.output_list = output_list
        # The scheduling parameters of the node.
        # 
        # This parameter corresponds to the Scheduling Parameter section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of scheduling parameters, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
        self.para_value = para_value
        # Indicates whether the node that corresponds to the file can be rerun. Valid values:
        # 
        # *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
        # *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
        # *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
        # 
        # This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
        self.rerun_mode = rerun_mode
        # The ID of the resource group that is used to run the node that corresponds to the file. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace.
        self.resource_group_id = resource_group_id
        # The scheduling type of the node. Valid values:
        # 
        # *   NORMAL: The node is an auto triggered node.
        # *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
        # *   PAUSE: The node is a paused node.
        # *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled, but the system sets the status of the nodes to successful when it starts to run them.
        self.scheduler_type = scheduler_type

    def validate(self):
        if self.input_list:
            for k in self.input_list:
                if k:
                    k.validate()
        if self.output_list:
            for k in self.output_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_interval_millis is not None:
            result['AutoRerunIntervalMillis'] = self.auto_rerun_interval_millis
        if self.auto_rerun_times is not None:
            result['AutoRerunTimes'] = self.auto_rerun_times
        if self.cron_express is not None:
            result['CronExpress'] = self.cron_express
        if self.cycle_type is not None:
            result['CycleType'] = self.cycle_type
        if self.dependent_node_id_list is not None:
            result['DependentNodeIdList'] = self.dependent_node_id_list
        if self.dependent_type is not None:
            result['DependentType'] = self.dependent_type
        result['InputList'] = []
        if self.input_list is not None:
            for k in self.input_list:
                result['InputList'].append(k.to_map() if k else None)
        result['OutputList'] = []
        if self.output_list is not None:
            for k in self.output_list:
                result['OutputList'].append(k.to_map() if k else None)
        if self.para_value is not None:
            result['ParaValue'] = self.para_value
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.scheduler_type is not None:
            result['SchedulerType'] = self.scheduler_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunIntervalMillis') is not None:
            self.auto_rerun_interval_millis = m.get('AutoRerunIntervalMillis')
        if m.get('AutoRerunTimes') is not None:
            self.auto_rerun_times = m.get('AutoRerunTimes')
        if m.get('CronExpress') is not None:
            self.cron_express = m.get('CronExpress')
        if m.get('CycleType') is not None:
            self.cycle_type = m.get('CycleType')
        if m.get('DependentNodeIdList') is not None:
            self.dependent_node_id_list = m.get('DependentNodeIdList')
        if m.get('DependentType') is not None:
            self.dependent_type = m.get('DependentType')
        self.input_list = []
        if m.get('InputList') is not None:
            for k in m.get('InputList'):
                temp_model = GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList()
                self.input_list.append(temp_model.from_map(k))
        self.output_list = []
        if m.get('OutputList') is not None:
            for k in m.get('OutputList'):
                temp_model = GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList()
                self.output_list.append(temp_model.from_map(k))
        if m.get('ParaValue') is not None:
            self.para_value = m.get('ParaValue')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SchedulerType') is not None:
            self.scheduler_type = m.get('SchedulerType')
        return self


class GetIDEEventDetailResponseBodyEventDetailCommittedFile(TeaModel):
    def __init__(
        self,
        change_type: str = None,
        comment: str = None,
        committor: str = None,
        content: str = None,
        file_id: int = None,
        file_name: str = None,
        file_property_content: GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent = None,
        file_type: int = None,
        node_configuration: GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration = None,
        node_id: int = None,
        use_type: str = None,
    ):
        # The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
        self.change_type = change_type
        # The description of the file version.
        self.comment = comment
        # The ID of the Alibaba Cloud account that is used to generate the file of the current version.
        self.committor = committor
        # The code in the file of the current version.
        self.content = content
        # The file ID.
        self.file_id = file_id
        # The name of the file.
        self.file_name = file_name
        # The details of the file.
        self.file_property_content = file_property_content
        # The file type. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
        self.file_type = file_type
        # The scheduling properties of the node that corresponds to the file.
        self.node_configuration = node_configuration
        # The ID of the node that is scheduled.
        self.node_id = node_id
        # The module to which the file belongs. Valid values:
        # 
        # *   NORMAL: The file is used for DataStudio.
        # *   MANUAL: The file is used for a manually triggered node.
        # *   MANUAL_BIZ: The file is used for a manually triggered workflow.
        # *   SKIP: The file is used for a dry-run node in DataStudio.
        # *   ADHOCQUERY: The file is used for an ad hoc query.
        # *   COMPONENT: The file is used for a script template.
        self.use_type = use_type

    def validate(self):
        if self.file_property_content:
            self.file_property_content.validate()
        if self.node_configuration:
            self.node_configuration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committor is not None:
            result['Committor'] = self.committor
        if self.content is not None:
            result['Content'] = self.content
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_property_content is not None:
            result['FilePropertyContent'] = self.file_property_content.to_map()
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.node_configuration is not None:
            result['NodeConfiguration'] = self.node_configuration.to_map()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committor') is not None:
            self.committor = m.get('Committor')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FilePropertyContent') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent()
            self.file_property_content = temp_model.from_map(m['FilePropertyContent'])
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('NodeConfiguration') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration()
            self.node_configuration = temp_model.from_map(m['NodeConfiguration'])
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class GetIDEEventDetailResponseBodyEventDetailDeletedFile(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        content: str = None,
        current_version: int = None,
        data_source_name: str = None,
        file_id: int = None,
        file_name: str = None,
        file_type: int = None,
        folder_id: str = None,
        node_id: int = None,
        owner: str = None,
        parent_file_id: int = None,
        use_type: str = None,
    ):
        # The ID of the workflow to which the file belongs.
        self.business_id = business_id
        # The code in the file of the current version.
        self.content = content
        # The latest version number of the file.
        self.current_version = current_version
        # The name of the data source with which the file is associated.
        self.data_source_name = data_source_name
        # The file ID.
        self.file_id = file_id
        # The name of the file.
        self.file_name = file_name
        # The file type. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
        self.file_type = file_type
        # The ID of the folder to which the file belongs. You can call the [GetFolder](https://help.aliyun.com/document_detail/173952.html) operation to query the details of the file based on the folder ID.
        self.folder_id = folder_id
        # The ID of the node that is scheduled.
        self.node_id = node_id
        # The file owner.
        self.owner = owner
        # The ID of the do-while node or for-each node that corresponds to the file.
        self.parent_file_id = parent_file_id
        # The module to which the file belongs. Valid values:
        # 
        # *   NORMAL: The file is used for DataStudio.
        # *   MANUAL: The file is used for a manually triggered node.
        # *   MANUAL_BIZ: The file is used for a manually triggered workflow.
        # *   SKIP: The file is used for a dry-run node in DataStudio.
        # *   ADHOCQUERY: The file is used for an ad hoc query.
        # *   COMPONENT: The file is used for a script template.
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.content is not None:
            result['Content'] = self.content
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parent_file_id is not None:
            result['ParentFileId'] = self.parent_file_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParentFileId') is not None:
            self.parent_file_id = m.get('ParentFileId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand(TeaModel):
    def __init__(
        self,
        content: str = None,
        data_source_name: str = None,
        file_id: int = None,
        file_type: int = None,
    ):
        # The code in the file of the current version.
        self.content = content
        # The name of the data source with which the file is associated.
        self.data_source_name = data_source_name
        # The file ID.
        self.file_id = file_id
        # The file type. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
        self.file_type = file_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_type is not None:
            result['FileType'] = self.file_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        return self


class GetIDEEventDetailResponseBodyEventDetailTableModelColumns(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        column_type: str = None,
        comment: str = None,
        is_partition_column: bool = None,
    ):
        # The name of the column.
        self.column_name = column_name
        # The data type of the column.
        self.column_type = column_type
        # The remarks of the column.
        self.comment = comment
        # Indicates whether the column is a partition key column. Valid values:
        # 
        # *   true
        # *   false
        self.is_partition_column = is_partition_column

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.is_partition_column is not None:
            result['IsPartitionColumn'] = self.is_partition_column
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('IsPartitionColumn') is not None:
            self.is_partition_column = m.get('IsPartitionColumn')
        return self


class GetIDEEventDetailResponseBodyEventDetailTableModel(TeaModel):
    def __init__(
        self,
        columns: List[GetIDEEventDetailResponseBodyEventDetailTableModelColumns] = None,
        comment: str = None,
        data_source_name: str = None,
        env: str = None,
        life_cycle: int = None,
        location: str = None,
        table_name: str = None,
    ):
        # The columns in the table.
        self.columns = columns
        # The remarks of the table.
        self.comment = comment
        # The name of the data source to which the table belongs.
        self.data_source_name = data_source_name
        # The environment in which the table is used. Valid values:
        # 
        # *   DEV
        # *   PROD
        self.env = env
        # The lifecycle of the table. Unit: day.
        self.life_cycle = life_cycle
        # The path of the table.
        self.location = location
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.data_source_name is not None:
            result['DataSourceName'] = self.data_source_name
        if self.env is not None:
            result['Env'] = self.env
        if self.life_cycle is not None:
            result['LifeCycle'] = self.life_cycle
        if self.location is not None:
            result['Location'] = self.location
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = GetIDEEventDetailResponseBodyEventDetailTableModelColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('DataSourceName') is not None:
            self.data_source_name = m.get('DataSourceName')
        if m.get('Env') is not None:
            self.env = m.get('Env')
        if m.get('LifeCycle') is not None:
            self.life_cycle = m.get('LifeCycle')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetIDEEventDetailResponseBodyEventDetail(TeaModel):
    def __init__(
        self,
        committed_file: GetIDEEventDetailResponseBodyEventDetailCommittedFile = None,
        deleted_file: GetIDEEventDetailResponseBodyEventDetailDeletedFile = None,
        file_execution_command: GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand = None,
        table_model: GetIDEEventDetailResponseBodyEventDetailTableModel = None,
    ):
        # The data snapshot when the file is committed and deployed.
        # 
        # This parameter is valid only if the message type is IDE_FILE_SUBMIT_BEFORE or IDE_FILE_DEPLOY_BEFORE.
        self.committed_file = committed_file
        # The data snapshot when the file is deleted. This parameter is valid only if the message type is IDE_FILE_DELETE_BEFORE.
        self.deleted_file = deleted_file
        # The data snapshot when the code in the file is run. This parameter is valid only if the message type is IDE_FILE_EXECUTE_BEFORE.
        self.file_execution_command = file_execution_command
        # The data snapshot when the table is committed and deployed. This parameter is valid only if the message type is IDE_TABLE_SUBMIT_BEFORE or IDE_TABLE_DEPLOY_BEFORE.
        self.table_model = table_model

    def validate(self):
        if self.committed_file:
            self.committed_file.validate()
        if self.deleted_file:
            self.deleted_file.validate()
        if self.file_execution_command:
            self.file_execution_command.validate()
        if self.table_model:
            self.table_model.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.committed_file is not None:
            result['CommittedFile'] = self.committed_file.to_map()
        if self.deleted_file is not None:
            result['DeletedFile'] = self.deleted_file.to_map()
        if self.file_execution_command is not None:
            result['FileExecutionCommand'] = self.file_execution_command.to_map()
        if self.table_model is not None:
            result['TableModel'] = self.table_model.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommittedFile') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailCommittedFile()
            self.committed_file = temp_model.from_map(m['CommittedFile'])
        if m.get('DeletedFile') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailDeletedFile()
            self.deleted_file = temp_model.from_map(m['DeletedFile'])
        if m.get('FileExecutionCommand') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand()
            self.file_execution_command = temp_model.from_map(m['FileExecutionCommand'])
        if m.get('TableModel') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetailTableModel()
            self.table_model = temp_model.from_map(m['TableModel'])
        return self


class GetIDEEventDetailResponseBody(TeaModel):
    def __init__(
        self,
        event_detail: GetIDEEventDetailResponseBodyEventDetail = None,
        request_id: str = None,
    ):
        # The data snapshot that is generated when an extension point event is triggered.
        # 
        # The fields contained in data snapshots vary based on the types of the triggered extension point events. For more information, see the description of the fields.
        self.event_detail = event_detail
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.event_detail:
            self.event_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_detail is not None:
            result['EventDetail'] = self.event_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventDetail') is not None:
            temp_model = GetIDEEventDetailResponseBodyEventDetail()
            self.event_detail = temp_model.from_map(m['EventDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetIDEEventDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIDEEventDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIDEEventDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetJobStatusRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the asynchronous task that is generated after you call an asynchronous operation.
        # 
        # This parameter is required.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetJobStatusResponseBodyJobStatus(TeaModel):
    def __init__(
        self,
        completed: str = None,
        create_time: str = None,
        error: str = None,
        job_id: str = None,
        job_type: str = None,
        status: str = None,
    ):
        # Indicates whether the asynchronous task is complete. Valid values: True False
        self.completed = completed
        # The time when the asynchronous task was created.
        self.create_time = create_time
        # The error message returned if the asynchronous task fails.
        self.error = error
        # The ID of the asynchronous task.
        self.job_id = job_id
        # The type of the asynchronous task. Valid values:
        # 
        # *   **Create**: The asynchronous task is used to create an object.
        # *   **Update**: The asynchronous task is used to update an object.
        # *   **Cancel**: The asynchronous task is used to cancel an operation.
        self.job_type = job_type
        # The status of the asynchronous task. Valid values:
        # 
        # *   **Success**\
        # *   **Fail**\
        # *   **Cancel**\
        # *   **Running**\
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.error is not None:
            result['Error'] = self.error
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetJobStatusResponseBody(TeaModel):
    def __init__(
        self,
        job_status: GetJobStatusResponseBodyJobStatus = None,
        request_id: str = None,
    ):
        # The real-time status information of the asynchronous task.
        self.job_status = job_status
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job_status:
            self.job_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            temp_model = GetJobStatusResponseBodyJobStatus()
            self.job_status = temp_model.from_map(m['JobStatus'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetJobStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetJobStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetJobStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLineageRelationshipRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetLineageRelationshipResponseBody(TeaModel):
    def __init__(
        self,
        lineage_relationship: LineageRelationship = None,
        request_id: str = None,
    ):
        self.lineage_relationship = lineage_relationship
        self.request_id = request_id

    def validate(self):
        if self.lineage_relationship:
            self.lineage_relationship.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lineage_relationship is not None:
            result['LineageRelationship'] = self.lineage_relationship.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LineageRelationship') is not None:
            temp_model = LineageRelationship()
            self.lineage_relationship = temp_model.from_map(m['LineageRelationship'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLineageRelationshipResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLineageRelationshipResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLineageRelationshipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetMetaCollectionResponseBodyMetaCollection(TeaModel):
    def __init__(
        self,
        administrators: List[int] = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        parent_id: str = None,
        type: str = None,
    ):
        self.administrators = administrators
        self.create_time = create_time
        self.create_user = create_user
        self.description = description
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.parent_id = parent_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators is not None:
            result['Administrators'] = self.administrators
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators = m.get('Administrators')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        meta_collection: GetMetaCollectionResponseBodyMetaCollection = None,
        request_id: str = None,
    ):
        self.meta_collection = meta_collection
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.meta_collection:
            self.meta_collection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_collection is not None:
            result['MetaCollection'] = self.meta_collection.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaCollection') is not None:
            temp_model = GetMetaCollectionResponseBodyMetaCollection()
            self.meta_collection = temp_model.from_map(m['MetaCollection'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNetworkRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The network ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetNetworkResponseBodyNetwork(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        id: int = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The time when the network resource was created. The value is a 64-bit timestamp.
        self.create_time = create_time
        # The ID of the user who creates the network resource.
        self.create_user = create_user
        # The network ID.
        self.id = id
        # The ID of the serverless resource group.
        self.resource_group_id = resource_group_id
        # The security group ID.
        self.security_group_id = security_group_id
        # The status of the network resource. Valid values:
        # 
        # *   Pending: The network resource is waiting to be created.
        # *   Creating: The network resource is being created.
        # *   Running: The network resource is running as expected.
        # *   Deleting: The network resource is being deleted.
        # *   Deleted: The network resource is deleted.
        self.status = status
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The VSwitch ID.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class GetNetworkResponseBody(TeaModel):
    def __init__(
        self,
        network: GetNetworkResponseBodyNetwork = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the network resource.
        self.network = network
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.network:
            self.network.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network is not None:
            result['Network'] = self.network.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Network') is not None:
            temp_model = GetNetworkResponseBodyNetwork()
            self.network = temp_model.from_map(m['Network'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetNetworkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNetworkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNetworkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNodeRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetNodeResponseBodyNode(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        spec: str = None,
        task_id: int = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the node.
        self.id = id
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The owner of the node.
        self.owner = owner
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The FlowSpec field information about this node. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow).
        self.spec = spec
        # The Id of the scheduled task after the node is published.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetNodeResponseBody(TeaModel):
    def __init__(
        self,
        node: GetNodeResponseBodyNode = None,
        request_id: str = None,
    ):
        # The information about the node.
        self.node = node
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Node') is not None:
            temp_model = GetNodeResponseBodyNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPartitionRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        table_id: str = None,
    ):
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class GetPartitionResponseBody(TeaModel):
    def __init__(
        self,
        partition: Partition = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.partition = partition
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition:
            self.partition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.partition is not None:
            result['Partition'] = self.partition.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Partition') is not None:
            temp_model = Partition()
            self.partition = temp_model.from_map(m['Partition'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineRunRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        project_id: int = None,
    ):
        # The ID of the process.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetPipelineRunResponseBodyPipelineStages(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        detail: Dict[str, Any] = None,
        message: str = None,
        name: str = None,
        status: str = None,
        step: int = None,
        type: str = None,
    ):
        # The code of the stage.
        self.code = code
        # The description of the stage.
        self.description = description
        # The details of the stage.
        self.detail = detail
        # The error message returned for the stage.
        self.message = message
        # The name of the stage.
        self.name = name
        # The status of the stage.
        # 
        # Valid values:
        # 
        # *   Init
        # *   Running
        # *   Success
        # *   Fail
        # *   Termination
        # *   Cancel
        self.status = status
        # The step number of the stage.
        self.step = step
        # The type of the stage.
        # 
        # Valid values:
        # 
        # *   Deploy
        # *   Check
        # *   Offline
        # *   Build
        # *   Delete
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.step is not None:
            result['Step'] = self.step
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPipelineRunResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator: str = None,
        id: str = None,
        message: str = None,
        modify_time: int = None,
        project_id: int = None,
        stages: List[GetPipelineRunResponseBodyPipelineStages] = None,
        status: str = None,
    ):
        # The time when the process was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The creator of the process.
        self.creator = creator
        # The process ID.
        self.id = id
        # The error message returned when the process fails.
        self.message = message
        # The time when the process was modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The information about stages in the process.
        self.stages = stages
        # The status of the process.
        # 
        # Valid values:
        # 
        # *   Init
        # *   Running
        # *   Success
        # *   Fail
        # *   Termination
        # *   Cancel
        self.status = status

    def validate(self):
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['Stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.stages = []
        if m.get('Stages') is not None:
            for k in m.get('Stages'):
                temp_model = GetPipelineRunResponseBodyPipelineStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetPipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        pipeline: GetPipelineRunResponseBodyPipeline = None,
        request_id: str = None,
    ):
        # The information about the process.
        self.pipeline = pipeline
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = GetPipelineRunResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetProjectResponseBodyProjectAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetProjectResponseBodyProject(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[GetProjectResponseBodyProjectAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspace belongs.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # The description of the workspace.
        self.description = description
        # Indicates whether the development environment is enabled. Valid values:
        # 
        # *   true: The development environment is enabled. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: The development environment is disabled. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Indicates whether the Develop role is disabled. Valid values:
        # 
        # *   false
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        self.display_name = display_name
        # The workspace ID.
        self.id = id
        # The name of the workspace.
        self.name = name
        # The ID of the Alibaba Cloud account to which the workspace belongs.
        self.owner = owner
        # Indicates whether scheduling of PAI tasks is enabled. Valid values:
        # 
        # *   true: Scheduling of PAI tasks is enabled. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: Scheduling of PAI tasks is disabled.
        self.pai_task_enabled = pai_task_enabled
        # The status of the workspace. Valid values:
        # 
        # *   Available
        # *   Initializing
        # *   InitFailed
        # *   Forbidden
        # *   Deleting
        # *   DeleteFailed
        # *   Frozen
        # *   Updating
        # *   UpdateFailed
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = GetProjectResponseBodyProjectAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetProjectResponseBody(TeaModel):
    def __init__(
        self,
        project: GetProjectResponseBodyProject = None,
        request_id: str = None,
    ):
        # The information about the workspace.
        self.project = project
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = GetProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectMemberRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetProjectMemberResponseBodyProjectMemberRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        type: str = None,
    ):
        # The code of the role. Valid values:
        # 
        # *   role_project_admin: Workspace Administrator
        # *   role_project_dev: Develop
        # *   role_project_dg_admin: Data Governance Administrator
        # *   role_project_guest: Visitor
        # *   role_project_security: Security Administrator
        # *   role_project_deploy: Deploy
        # *   role_project_owner: Workspace Owner
        # *   role_project_data_analyst: Data Analyst
        # *   role_project_pe: O\\&M
        # *   role_project_erd: Model Designer
        self.code = code
        # The name of the role.
        self.name = name
        # The type of the role. Valid values:
        # 
        # *   UserCustom: custom role
        # *   System: built-in role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetProjectMemberResponseBodyProjectMember(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        roles: List[GetProjectMemberResponseBodyProjectMemberRoles] = None,
        status: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The roles that are assigned to the member in the workspace.
        self.roles = roles
        # The status of the member.
        # 
        # *   Normal
        # *   Forbidden
        self.status = status
        # The ID of the account used by the member in the workspace.
        self.user_id = user_id

    def validate(self):
        if self.roles:
            for k in self.roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Roles'] = []
        if self.roles is not None:
            for k in self.roles:
                result['Roles'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.roles = []
        if m.get('Roles') is not None:
            for k in m.get('Roles'):
                temp_model = GetProjectMemberResponseBodyProjectMemberRoles()
                self.roles.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        project_member: GetProjectMemberResponseBodyProjectMember = None,
        request_id: str = None,
    ):
        # The details about the member in the workspace.
        self.project_member = project_member
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.project_member:
            self.project_member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_member is not None:
            result['ProjectMember'] = self.project_member.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectMember') is not None:
            temp_model = GetProjectMemberResponseBodyProjectMember()
            self.project_member = temp_model.from_map(m['ProjectMember'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectRoleRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        project_id: int = None,
    ):
        # The code of the role in the DataWorks workspace. Valid values:
        # 
        # *   role_project_admin: workspace administrator
        # *   role_project_dev: developer
        # *   role_project_dg_admin: data governance administrator
        # *   role_project_guest: visitor
        # *   role_project_security: security administrator
        # *   role_project_deploy: deployer
        # *   role_project_owner: workspace owner
        # *   role_project_data_analyst: data analyst
        # *   role_project_pe: O\\&M engineer
        # *   role_project_erd: model designer
        # 
        # This parameter is required.
        self.code = code
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetProjectRoleResponseBodyProjectRole(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # The code of the role in the DataWorks workspace.
        self.code = code
        # The name of the role in the DataWorks workspace.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The type of the role in the DataWorks workspace. Valid values:
        # 
        # *   UserCustom: user-defined role
        # *   System: system role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetProjectRoleResponseBody(TeaModel):
    def __init__(
        self,
        project_role: GetProjectRoleResponseBodyProjectRole = None,
        request_id: str = None,
    ):
        # The role in the DataWorks workspace.
        self.project_role = project_role
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.project_role:
            self.project_role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_role is not None:
            result['ProjectRole'] = self.project_role.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectRole') is not None:
            temp_model = GetProjectRoleResponseBodyProjectRole()
            self.project_role = temp_model.from_map(m['ProjectRole'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetProjectRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetResourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetResourceResponseBodyResource(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        spec: str = None,
    ):
        # The time when the file resource was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the file resource.
        self.id = id
        # The time when the file resource was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the file resource.
        self.name = name
        # The owner of the file resource.
        self.owner = owner
        # The ID of the workspace to which the file resource belongs.
        self.project_id = project_id
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow).
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class GetResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource: GetResourceResponseBodyResource = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the file resource.
        self.resource = resource

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = GetResourceResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        return self


class GetResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetResourceGroupRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetResourceGroupResponseBodyResourceGroupAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetResourceGroupResponseBodyResourceGroupSpec(TeaModel):
    def __init__(
        self,
        amount: int = None,
        standard: str = None,
    ):
        # The number of resources in the resource group.
        self.amount = amount
        # The number of compute units (CUs) in the resource group.
        self.standard = standard

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.standard is not None:
            result['Standard'] = self.standard
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Standard') is not None:
            self.standard = m.get('Standard')
        return self


class GetResourceGroupResponseBodyResourceGroup(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[GetResourceGroupResponseBodyResourceGroupAliyunResourceTags] = None,
        create_time: int = None,
        create_user: str = None,
        default_vpc_id: str = None,
        default_vswitch_id: str = None,
        id: str = None,
        name: str = None,
        order_instance_id: str = None,
        payment_type: str = None,
        remark: str = None,
        resource_group_type: str = None,
        spec: GetResourceGroupResponseBodyResourceGroupSpec = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # The time when the resource group was created. The value is a 64-bit timestamp.
        self.create_time = create_time
        # The ID of the account that is used to create the resource group.
        self.create_user = create_user
        # The ID of the virtual private cloud (VPC) with which the resource group is associated by default.
        self.default_vpc_id = default_vpc_id
        # The ID of the vSwitch with which the resource group is associated by default.
        self.default_vswitch_id = default_vswitch_id
        # The ID of the resource group.
        self.id = id
        # The name of the resource group.
        self.name = name
        # The instance ID of the order that is used to create the resource group.
        self.order_instance_id = order_instance_id
        # The billing method of the resource group. Valid values: PrePaid and PostPaid. The value PrePaid indicates the subscription billing method, and the value PostPaid indicates the pay-as-you-go billing method.
        self.payment_type = payment_type
        # The description of the resource group.
        self.remark = remark
        # The type of the resource group. Valid values:
        # 
        # *   CommonV2: serverless resource group
        # *   ExclusiveDataIntegration: exclusive resource group for Data Integration
        # *   ExclusiveScheduler: exclusive resource group for scheduling
        # *   ExclusiveDataService: exclusive resource group for DataService Studio
        self.resource_group_type = resource_group_type
        # The specifications of the resource group.
        self.spec = spec
        # The status of the resource group. Valid values:
        # 
        # *   Normal: The resource group is running or in use.
        # *   Stop: The resource group is expired.
        # *   Deleted: The resource group is released or destroyed.
        # *   Creating: The resource group is being created.
        # *   CreateFailed: The resource group fails to be created.
        # *   Updating: The resource group is being scaled in or out, or the configurations of the resource group are being changed.
        # *   UpdateFailed: The resource group fails to be scaled out or upgraded.
        # *   Deleting: The resource group is being released or destroyed.
        # *   DeleteFailed: The resource group fails to be released or destroyed.
        # *   Timeout: The operations that are performed on the resource group time out.
        # *   Freezed: The resource group is frozen.
        # *   Starting: The resource group is being started.
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.default_vpc_id is not None:
            result['DefaultVpcId'] = self.default_vpc_id
        if self.default_vswitch_id is not None:
            result['DefaultVswitchId'] = self.default_vswitch_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.resource_group_type is not None:
            result['ResourceGroupType'] = self.resource_group_type
        if self.spec is not None:
            result['Spec'] = self.spec.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = GetResourceGroupResponseBodyResourceGroupAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DefaultVpcId') is not None:
            self.default_vpc_id = m.get('DefaultVpcId')
        if m.get('DefaultVswitchId') is not None:
            self.default_vswitch_id = m.get('DefaultVswitchId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ResourceGroupType') is not None:
            self.resource_group_type = m.get('ResourceGroupType')
        if m.get('Spec') is not None:
            temp_model = GetResourceGroupResponseBodyResourceGroupSpec()
            self.spec = temp_model.from_map(m['Spec'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_group: GetResourceGroupResponseBodyResourceGroup = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details about the resource group.
        self.resource_group = resource_group
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.resource_group:
            self.resource_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group is not None:
            result['ResourceGroup'] = self.resource_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroup') is not None:
            temp_model = GetResourceGroupResponseBodyResourceGroup()
            self.resource_group = temp_model.from_map(m['ResourceGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRouteRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The route ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetRouteResponseBodyRoute(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        destination_cidr: str = None,
        id: int = None,
        network_id: int = None,
        resource_group_id: str = None,
        resource_id: str = None,
    ):
        # The time when the route was created. The value is a 64-bit timestamp.
        self.create_time = create_time
        # The CIDR block of the destination-based route.
        self.destination_cidr = destination_cidr
        # The route ID.
        self.id = id
        # The network ID.
        self.network_id = network_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The network resource ID.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class GetRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        route: GetRouteResponseBodyRoute = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the route.
        self.route = route
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.route:
            self.route.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route is not None:
            result['Route'] = self.route.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Route') is not None:
            temp_model = GetRouteResponseBodyRoute()
            self.route = temp_model.from_map(m['Route'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSchemaRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetSchemaResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        schema: Schema = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.schema = schema
        self.success = success

    def validate(self):
        if self.schema:
            self.schema.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schema is not None:
            result['Schema'] = self.schema.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Schema') is not None:
            temp_model = Schema()
            self.schema = temp_model.from_map(m['Schema'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        include_business_metadata: bool = None,
    ):
        # This parameter is required.
        self.id = id
        self.include_business_metadata = include_business_metadata

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.include_business_metadata is not None:
            result['IncludeBusinessMetadata'] = self.include_business_metadata
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IncludeBusinessMetadata') is not None:
            self.include_business_metadata = m.get('IncludeBusinessMetadata')
        return self


class GetTableResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
        table: Table = None,
    ):
        self.request_id = request_id
        self.success = success
        self.table = table

    def validate(self):
        if self.table:
            self.table.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table is not None:
            result['Table'] = self.table.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Table') is not None:
            temp_model = Table()
            self.table = temp_model.from_map(m['Table'])
        return self


class GetTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_env: str = None,
    ):
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class GetTaskResponseBodyTaskDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskResponseBodyTaskDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: str = None,
    ):
        # The dependency type. Valid values:
        # 
        # *   CrossCycleDependsOnChildren: cross-cycle dependency on level-1 descendant nodes
        # *   CrossCycleDependsOnSelf: cross-cycle dependency on the current node
        # *   CrossCycleDependsOnOtherNode: cross-cycle dependency on other nodes
        # *   Normal: same-cycle scheduling dependency
        self.type = type
        # The identifier of the output of the ancestor task. This parameter is returned only if `same-cycle scheduling dependencies` and the node input are configured.
        self.upstream_output = upstream_output
        # The ancestor task ID. This parameter is returned only if `cross-cycle scheduling dependencies` or `same-cycle scheduling dependencies` and the node input are not configured.
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class GetTaskResponseBodyTaskInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskInputs(TeaModel):
    def __init__(
        self,
        variables: List[GetTaskResponseBodyTaskInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskResponseBodyTaskInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskResponseBodyTaskOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class GetTaskResponseBodyTaskOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[GetTaskResponseBodyTaskOutputsTaskOutputs] = None,
        variables: List[GetTaskResponseBodyTaskOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = GetTaskResponseBodyTaskOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskResponseBodyTaskOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskResponseBodyTaskRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskResponseBodyTaskScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of CUs configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression of the task. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: periodic scheduling
        # *   Manual: manual scheduling
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTaskSubTasksSubTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskResponseBodyTaskSubTasksSubTasksDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource = None,
        timeout: int = None,
        trigger: GetTaskResponseBodyTaskSubTasksSubTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. This parameter is deprecated and replaced by the EnvType parameter. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to be run.
        # *   FailureAllowed: The task can be rerun only after it fails to be run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to be run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The runtime environment configuration of the task, such as the resource group.
        self.runtime_resource = runtime_resource
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The method to trigger task scheduling.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasksSubTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetTaskResponseBodyTaskSubTasks(TeaModel):
    def __init__(
        self,
        sub_tasks: List[GetTaskResponseBodyTaskSubTasksSubTasks] = None,
        type: str = None,
    ):
        # The subtasks.
        self.sub_tasks = sub_tasks
        # The type of the subtask. Valid values:
        # 
        # *   DoWhile: do-while node
        # *   Combined: node group
        # *   ForEach: for-each node
        self.type = type

    def validate(self):
        if self.sub_tasks:
            for k in self.sub_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubTasks'] = []
        if self.sub_tasks is not None:
            for k in self.sub_tasks:
                result['SubTasks'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sub_tasks = []
        if m.get('SubTasks') is not None:
            for k in m.get('SubTasks'):
                temp_model = GetTaskResponseBodyTaskSubTasksSubTasks()
                self.sub_tasks.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTaskTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskResponseBodyTaskTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression of the task. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: periodic scheduling
        # *   Manual: manual scheduling
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTaskResponseBodyTask(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskResponseBodyTaskDataSource = None,
        dependencies: List[GetTaskResponseBodyTaskDependencies] = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        inputs: GetTaskResponseBodyTaskInputs = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        outputs: GetTaskResponseBodyTaskOutputs = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: GetTaskResponseBodyTaskRuntimeResource = None,
        script: GetTaskResponseBodyTaskScript = None,
        sub_tasks: GetTaskResponseBodyTaskSubTasks = None,
        tags: List[GetTaskResponseBodyTaskTags] = None,
        timeout: int = None,
        trigger: GetTaskResponseBodyTaskTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The dependency information.
        self.dependencies = dependencies
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The instance ID.
        self.id = id
        # The input information.
        self.inputs = inputs
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. This parameter is deprecated and replaced by the EnvType parameter. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to be run.
        # *   FailureAllowed: The task can be rerun only after it fails to be run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to be run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The configurations of the subtasks, such as a do-while node.
        self.sub_tasks = sub_tasks
        # The tags.
        self.tags = tags
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The method to trigger task scheduling.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The workflow ID.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.sub_tasks:
            self.sub_tasks.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.sub_tasks is not None:
            result['SubTasks'] = self.sub_tasks.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskResponseBodyTaskDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = GetTaskResponseBodyTaskDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = GetTaskResponseBodyTaskInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = GetTaskResponseBodyTaskOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskResponseBodyTaskRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = GetTaskResponseBodyTaskScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('SubTasks') is not None:
            temp_model = GetTaskResponseBodyTaskSubTasks()
            self.sub_tasks = temp_model.from_map(m['SubTasks'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTaskResponseBodyTaskTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = GetTaskResponseBodyTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task: GetTaskResponseBodyTask = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the task.
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Task') is not None:
            temp_model = GetTaskResponseBodyTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class GetTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetTaskInstanceResponseBodyTaskInstanceDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetTaskInstanceResponseBodyTaskInstanceInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstanceInputs(TeaModel):
    def __init__(
        self,
        variables: List[GetTaskInstanceResponseBodyTaskInstanceInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output identifier.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstanceOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs] = None,
        variables: List[GetTaskInstanceResponseBodyTaskInstanceOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetTaskInstanceResponseBodyTaskInstanceRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class GetTaskInstanceResponseBodyTaskInstanceRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of CUs configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetTaskInstanceResponseBodyTaskInstanceScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class GetTaskInstanceResponseBodyTaskInstanceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTaskInstanceResponseBodyTaskInstance(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetTaskInstanceResponseBodyTaskInstanceDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        inputs: GetTaskInstanceResponseBodyTaskInstanceInputs = None,
        modify_time: int = None,
        modify_user: str = None,
        outputs: GetTaskInstanceResponseBodyTaskInstanceOutputs = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: GetTaskInstanceResponseBodyTaskInstanceRuntime = None,
        runtime_resource: GetTaskInstanceResponseBodyTaskInstanceRuntimeResource = None,
        script: GetTaskInstanceResponseBodyTaskInstanceScript = None,
        started_time: int = None,
        status: str = None,
        tags: List[GetTaskInstanceResponseBodyTaskInstanceTags] = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The input information.
        self.inputs = inputs
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The output information.
        self.outputs = outputs
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the cycle. This parameter indicates the cycle of the task instance on the current day.
        self.period_number = period_number
        # The task priority. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The information about the resource group with which the instance is associated.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        # The tags of the task.
        self.tags = tags
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        # 
        # Note: The value of this parameter is rounded up by hour.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The method to trigger instance scheduling. The value of the Trigger.Type parameter in the response of the GetTask operation is used. Valid values:
        # 
        # *   Scheduler
        # *   Manual
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   SmokeTest
        # *   SupplementData
        # *   Manual
        # *   ManualWorkflow
        # *   Normal
        # *   ManualFlow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Outputs') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstanceScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTaskInstanceResponseBodyTaskInstanceTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class GetTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_instance: GetTaskInstanceResponseBodyTaskInstance = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the instance.
        self.task_instance = task_instance

    def validate(self):
        if self.task_instance:
            self.task_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_instance is not None:
            result['TaskInstance'] = self.task_instance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskInstance') is not None:
            temp_model = GetTaskInstanceResponseBodyTaskInstance()
            self.task_instance = temp_model.from_map(m['TaskInstance'])
        return self


class GetTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceLogRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        run_number: int = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The sequence number of an instance run. Minimum value: 1. By default, the latest run is used.
        self.run_number = run_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        return self


class GetTaskInstanceLogResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_instance_log: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The run log of the instance.
        self.task_instance_log = task_instance_log

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_instance_log is not None:
            result['TaskInstanceLog'] = self.task_instance_log
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskInstanceLog') is not None:
            self.task_instance_log = m.get('TaskInstanceLog')
        return self


class GetTaskInstanceLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkflowRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        id: int = None,
    ):
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The workflow ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetWorkflowResponseBodyWorkflowDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: int = None,
    ):
        # The scheduling dependency type. Valid values:
        # 
        # *   CrossCycleDependsOnChildren: cross-cycle dependency on the level-1 descendant nodes of a node
        # *   CrossCycleDependsOnSelf: cross-cycle dependency on the current node
        # *   CrossCycleDependsOnOtherNode: cross-cycle dependency on other nodes
        # *   Normal: same-cycle scheduling dependency
        self.type = type
        # The identifier of the output of the ancestor task. This parameter is returned only if `same-cycle scheduling dependencies` and the node input are configured.
        self.upstream_output = upstream_output
        # The ancestor task ID. This parameter is returned only if `cross-cycle scheduling dependencies` or `same-cycle scheduling dependencies` and the node input are not configured.
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class GetWorkflowResponseBodyWorkflowOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class GetWorkflowResponseBodyWorkflowOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[GetWorkflowResponseBodyWorkflowOutputsTaskOutputs] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = GetWorkflowResponseBodyWorkflowOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        return self


class GetWorkflowResponseBodyWorkflowTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetWorkflowResponseBodyWorkflowTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetWorkflowResponseBodyWorkflowTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetWorkflowResponseBodyWorkflowTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        client_unique_code: str = None,
        create_time: int = None,
        create_user: str = None,
        data_source: GetWorkflowResponseBodyWorkflowTasksDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: GetWorkflowResponseBodyWorkflowTasksRuntimeResource = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The unique code of the client. This parameter is used to create a task asynchronously and implement the idempotence of the task. If you do not specify this parameter when you create the task, the system automatically generates a unique code. The unique code is uniquely associated with the task ID. If you specify this parameter when you update or delete the task, the value of this parameter must be the unique code that is used to create the task.
        self.client_unique_code = client_unique_code
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The running mode of the task after it is triggered. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = GetWorkflowResponseBodyWorkflowTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = GetWorkflowResponseBodyWorkflowTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetWorkflowResponseBodyWorkflowTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the workflow after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetWorkflowResponseBodyWorkflow(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        create_time: int = None,
        create_user: str = None,
        dependencies: List[GetWorkflowResponseBodyWorkflowDependencies] = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        outputs: GetWorkflowResponseBodyWorkflowOutputs = None,
        owner: str = None,
        parameters: str = None,
        project_id: int = None,
        tags: List[GetWorkflowResponseBodyWorkflowTags] = None,
        tasks: List[GetWorkflowResponseBodyWorkflowTasks] = None,
        trigger: GetWorkflowResponseBodyWorkflowTrigger = None,
    ):
        # The unique code of the client. This parameter is used to create a workflow asynchronously and implement the idempotence of the workflow. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The dependency information.
        self.dependencies = dependencies
        # The description of the workflow.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The workflow ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the workflow.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the workflow owner.
        self.owner = owner
        # The parameters.
        self.parameters = parameters
        # The workspace ID.
        self.project_id = project_id
        # The tags.
        self.tags = tags
        # The tasks.
        self.tasks = tasks
        # The trigger method.
        self.trigger = trigger

    def validate(self):
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.outputs:
            self.outputs.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = GetWorkflowResponseBodyWorkflowDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = GetWorkflowResponseBodyWorkflowOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetWorkflowResponseBodyWorkflowTags()
                self.tags.append(temp_model.from_map(k))
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = GetWorkflowResponseBodyWorkflowTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('Trigger') is not None:
            temp_model = GetWorkflowResponseBodyWorkflowTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class GetWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow: GetWorkflowResponseBodyWorkflow = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the workflow.
        self.workflow = workflow

    def validate(self):
        if self.workflow:
            self.workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow is not None:
            result['Workflow'] = self.workflow.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Workflow') is not None:
            temp_model = GetWorkflowResponseBodyWorkflow()
            self.workflow = temp_model.from_map(m['Workflow'])
        return self


class GetWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        include_script_content: bool = None,
        project_id: int = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # 
        self.include_script_content = include_script_content
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.include_script_content is not None:
            result['IncludeScriptContent'] = self.include_script_content
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IncludeScriptContent') is not None:
            self.include_script_content = m.get('IncludeScriptContent')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetWorkflowDefinitionResponseBodyWorkflowDefinition(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        spec: str = None,
        workflow_id: int = None,
    ):
        # The time when the workflow was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the workflow.
        self.id = id
        # The time when the workflow was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the workflow.
        self.name = name
        # The owner of the workflow.
        self.owner = owner
        # The ID of the workspace to which the workflow belongs.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow/).
        self.spec = spec
        # The ID of the workflow on the scheduling side after publishing.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow_definition: GetWorkflowDefinitionResponseBodyWorkflowDefinition = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the workflow.
        self.workflow_definition = workflow_definition

    def validate(self):
        if self.workflow_definition:
            self.workflow_definition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_definition is not None:
            result['WorkflowDefinition'] = self.workflow_definition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowDefinition') is not None:
            temp_model = GetWorkflowDefinitionResponseBodyWorkflowDefinition()
            self.workflow_definition = temp_model.from_map(m['WorkflowDefinition'])
        return self


class GetWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkflowInstanceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the workflow instance.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetWorkflowInstanceResponseBodyWorkflowInstance(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        create_time: int = None,
        create_user: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        project_id: int = None,
        started_time: int = None,
        status: str = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The data timestamp.
        self.biz_date = biz_date
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The ID of the workflow instance.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the workflow instance.
        self.name = name
        # The workspace ID.
        self.project_id = project_id
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the workflow instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        # The type of the workflow instance. Valid values:
        # 
        # *   Normal
        # *   Manual
        # *   SmokeTest
        # *   SupplementData
        # *   ManualWorkflow
        self.type = type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class GetWorkflowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workflow_instance: GetWorkflowInstanceResponseBodyWorkflowInstance = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the workflow instance.
        self.workflow_instance = workflow_instance

    def validate(self):
        if self.workflow_instance:
            self.workflow_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.workflow_instance is not None:
            result['WorkflowInstance'] = self.workflow_instance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WorkflowInstance') is not None:
            temp_model = GetWorkflowInstanceResponseBodyWorkflowInstance()
            self.workflow_instance = temp_model.from_map(m['WorkflowInstance'])
        return self


class GetWorkflowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkflowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkflowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantMemberProjectRolesRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to assign to members in the workspace.
        # 
        # This parameter is required.
        self.role_codes = role_codes
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantMemberProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to assign to members in the workspace.
        # 
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantMemberProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GrantMemberProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantMemberProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantMemberProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportCertificateRequest(TeaModel):
    def __init__(
        self,
        certificate_file: str = None,
        description: str = None,
        name: str = None,
        project_id: int = None,
    ):
        # This parameter is required.
        self.certificate_file = certificate_file
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.certificate_file is not None:
            result['CertificateFile'] = self.certificate_file
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertificateFile') is not None:
            self.certificate_file = m.get('CertificateFile')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ImportCertificateAdvanceRequest(TeaModel):
    def __init__(
        self,
        certificate_file_object: BinaryIO = None,
        description: str = None,
        name: str = None,
        project_id: int = None,
    ):
        # This parameter is required.
        self.certificate_file_object = certificate_file_object
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.certificate_file_object is not None:
            result['CertificateFile'] = self.certificate_file_object
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertificateFile') is not None:
            self.certificate_file_object = m.get('CertificateFile')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ImportCertificateResponseBody(TeaModel):
    def __init__(
        self,
        id: int = None,
        request_id: str = None,
    ):
        self.id = id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportCertificateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportCertificateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportCertificateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        spec: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/alibabacloud-dataworks-tool-dflow/).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class ImportWorkflowDefinitionResponseBodyAsyncJob(TeaModel):
    def __init__(
        self,
        completed: bool = None,
        create_time: int = None,
        error: str = None,
        id: str = None,
        progress: int = None,
        response: str = None,
        status: str = None,
        type: str = None,
    ):
        # Indicates whether the asynchronous task is complete.
        self.completed = completed
        # The time when the asynchronous task was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The error message returned if the asynchronous task fails.
        self.error = error
        # The ID of the asynchronous task.
        self.id = id
        # The progress of the asynchronous task. Valid values: 0 to 100.
        self.progress = progress
        # The response.
        # 
        # >  The workflow ID is returned.
        self.response = response
        # The status of the asynchronous task.
        # 
        # Valid values:
        # 
        # *   Running: The asynchronous task is running.
        # *   Success: The asynchronous task is complete.
        # *   Fail: The asynchronous task fails.
        # *   Cancel: The asynchronous task is canceled.
        self.status = status
        # The type of the asynchronous task.
        # 
        # Valid values:
        # 
        # *   Create: The asynchronous task is used to create an object.
        # *   Cancel: The asynchronous task is used to cancel an operation.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.error is not None:
            result['Error'] = self.error
        if self.id is not None:
            result['Id'] = self.id
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.response is not None:
            result['Response'] = self.response
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Response') is not None:
            self.response = m.get('Response')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ImportWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        async_job: ImportWorkflowDefinitionResponseBodyAsyncJob = None,
        request_id: str = None,
    ):
        # The status information of the asynchronous task.
        self.async_job = async_job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.async_job:
            self.async_job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_job is not None:
            result['AsyncJob'] = self.async_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncJob') is not None:
            temp_model = ImportWorkflowDefinitionResponseBodyAsyncJob()
            self.async_job = temp_model.from_map(m['AsyncJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertRulesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        receiver: str = None,
        task_ids: List[int] = None,
        types: List[str] = None,
    ):
        # The name of the rule.
        self.name = name
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The page number. Pages start from page 1.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 100.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The ID of the Alibaba Cloud account used by the alert recipient.
        self.receiver = receiver
        # The IDs of the scheduling tasks.
        self.task_ids = task_ids
        # The alert triggering condition.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.receiver is not None:
            result['Receiver'] = self.receiver
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Receiver') is not None:
            self.receiver = m.get('Receiver')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        receiver: str = None,
        task_ids_shrink: str = None,
        types_shrink: str = None,
    ):
        # The name of the rule.
        self.name = name
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The page number. Pages start from page 1.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of entries per page. Maximum value: 100.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The ID of the Alibaba Cloud account used by the alert recipient.
        self.receiver = receiver
        # The IDs of the scheduling tasks.
        self.task_ids_shrink = task_ids_shrink
        # The alert triggering condition.
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.receiver is not None:
            result['Receiver'] = self.receiver
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Receiver') is not None:
            self.receiver = m.get('Receiver')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        # The ID of the scheduling cycle of the instance. Valid values: [1,288].
        self.cycle_id = cycle_id
        # The latest completion time of the instance within the scheduling cycle. The time is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        # The configurations of the scheduling cycle and timeout period of the instance.
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert_enabled: bool = None,
        stream_task_ids: List[int] = None,
    ):
        # Indicates whether an alert is triggered if a batch synchronization task is automatically rerun upon a failure.
        self.auto_rerun_alert_enabled = auto_rerun_alert_enabled
        # The IDs of the real-time computing tasks. This parameter is required when you monitor real-time computing tasks.
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert_enabled is not None:
            result['AutoRerunAlertEnabled'] = self.auto_rerun_alert_enabled
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlertEnabled') is not None:
            self.auto_rerun_alert_enabled = m.get('AutoRerunAlertEnabled')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        # The maximum number of instances on which an error occurs. Valid values: [1,10000].
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        # The maximum percentage of instances on which an error occurs in the workspace to the total number of instances. Valid values: [1-100].
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        # The maximum percentage of fluctuation in the number of auto triggered node instances that are generated in your workspace. Valid values: [1-100].
        self.percentage = percentage
        # The way in which the number of auto triggered node instances that are generated in your workspace fluctuates. Valid values:
        # 
        # *   abs: the absolute value. The number of instances increases or decreases.
        # *   increase: The number of instances increases.
        # *   decrease: The number of instances decreases.
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        # The timeout period. Unit: minutes.
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        # The latest completion time of the instance. The period is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished = None,
        error: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError = None,
        instance_error_count: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout = None,
        un_finished: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished = None,
    ):
        # The configuration for an alert of the CycleUnfinished type.
        self.cycle_unfinished = cycle_unfinished
        # The configuration for an alert of the Error type.
        self.error = error
        # The configuration for an alert of the InstanceErrorCount type.
        self.instance_error_count = instance_error_count
        # The configuration for an alert of the InstanceErrorPercentage type.
        self.instance_error_percentage = instance_error_percentage
        # The configuration for an alert of the InstanceTransferFluctuate type.
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        # The configuration for an alert of the Timeout type.
        self.timeout = timeout
        # The configuration for an alert of the UnFinished type.
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        # The nodes that are not to be monitored.
        self.allow_tasks = allow_tasks
        # The IDs of monitored objects.
        self.ids = ids
        # The type of the monitored objects. Valid values:
        # 
        # *   Task: node
        # *   Baseline: baseline
        # *   Project: workspace
        # *   BizProcess: workflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension = None,
        target: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget = None,
        type: str = None,
    ):
        # The extended information about the rule. This parameter is required for specific types of alerts.
        self.extension = extension
        # The monitored objects.
        self.target = target
        # The alert type. Valid values:
        # 
        # *   Finished: An instance is successfully run.
        # *   UnFinished: An instance does not finish running before a specified point in time.
        # *   Error: An error occurs on an instance.
        # *   CycleUnfinished: An instance does not finish running as expected within a specific cycle.
        # *   Timeout: An instance times out.
        # *   InstanceTransferComplete: An instance is generated by the auto triggered node.
        # *   InstanceTransferFluctuate: The number of generated instances fluctuates.
        # *   ExhaustedError: An error persists after an instance is automatically rerun.
        # *   InstanceKeyword: An instance with errors contains specified keywords.
        # *   InstanceErrorCount: The number of instances on which an error occurs reaches a specified threshold.
        # *   InstanceErrorPercentage: The proportion of instances on which an error occurs in the workspace to the total number of instances reaches a specified threshold.
        # *   ResourceGroupPercentage: The usage rate of the resource group reaches a specified threshold.
        # *   ResourceGroupWaitCount: The number of instances that are waiting for resources in the resource group reaches a specified threshold.
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAlertRulesResponseBodyPagingInfoAlertRules(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        trigger_condition: ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition = None,
    ):
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The rule ID.
        self.id = id
        # The name of the rule.
        self.name = name
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The alert triggering condition.
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfoAlertRulesTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class ListAlertRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        alert_rules: List[ListAlertRulesResponseBodyPagingInfoAlertRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The rules.
        self.alert_rules = alert_rules
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.alert_rules:
            for k in self.alert_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRules'] = []
        if self.alert_rules is not None:
            for k in self.alert_rules:
                result['AlertRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rules = []
        if m.get('AlertRules') is not None:
            for k in m.get('AlertRules'):
                temp_model = ListAlertRulesResponseBodyPagingInfoAlertRules()
                self.alert_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListAlertRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListAlertRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBusinessRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        self.keyword = keyword
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class ListBusinessResponseBodyDataBusiness(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        business_name: str = None,
        description: str = None,
        owner: str = None,
        project_id: int = None,
        use_type: str = None,
    ):
        self.business_id = business_id
        self.business_name = business_name
        self.description = description
        self.owner = owner
        self.project_id = project_id
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class ListBusinessResponseBodyData(TeaModel):
    def __init__(
        self,
        business: List[ListBusinessResponseBodyDataBusiness] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.business = business
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.business:
            for k in self.business:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Business'] = []
        if self.business is not None:
            for k in self.business:
                result['Business'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.business = []
        if m.get('Business') is not None:
            for k in m.get('Business'):
                temp_model = ListBusinessResponseBodyDataBusiness()
                self.business.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListBusinessResponseBody(TeaModel):
    def __init__(
        self,
        data: ListBusinessResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListBusinessResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCatalogsRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        types: List[str] = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListCatalogsShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        types_shrink: str = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListCatalogsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        catalogs: List[Catalog] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.catalogs = catalogs
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.catalogs:
            for k in self.catalogs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Catalogs'] = []
        if self.catalogs is not None:
            for k in self.catalogs:
                result['Catalogs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.catalogs = []
        if m.get('Catalogs') is not None:
            for k in m.get('Catalogs'):
                temp_model = Catalog()
                self.catalogs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCatalogsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListCatalogsResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListCatalogsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCatalogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCatalogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCatalogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCertificatesRequest(TeaModel):
    def __init__(
        self,
        create_user: str = None,
        end_create_time: int = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        start_create_time: int = None,
    ):
        # The ID of the user who created the certificate files.
        self.create_user = create_user
        # The time when the certificate file was created. You can call this operation to query the files that are created before the time. Unit: milliseconds.
        self.end_create_time = end_create_time
        # The name of the certificate file. Fuzzy match by file name is supported.
        self.name = name
        # The order in which you want to sort the certificate files. Valid values: Desc: descending order ASC: ascending order Default value: Asc
        self.order = order
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The ID of the workspace to which the certificate file belongs.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The field used to sort the certificate files. Valid values: CreateTime Id Name Default value: Id
        self.sort_by = sort_by
        # The time when the certificate file was created. You can call this operation to query the files that are created after the time. Unit: milliseconds.
        self.start_create_time = start_create_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.end_create_time is not None:
            result['EndCreateTime'] = self.end_create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_create_time is not None:
            result['StartCreateTime'] = self.start_create_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('EndCreateTime') is not None:
            self.end_create_time = m.get('EndCreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartCreateTime') is not None:
            self.start_create_time = m.get('StartCreateTime')
        return self


class ListCertificatesResponseBodyPagingInfoCertificates(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        file_size_in_bytes: int = None,
        id: int = None,
        name: str = None,
    ):
        # The time when the certificate file was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who created the certificate file.
        self.create_user = create_user
        # The description.
        self.description = description
        # The size of the certificate file, in bytes.
        self.file_size_in_bytes = file_size_in_bytes
        # The ID of the certificate file.
        self.id = id
        # The name of the certificate file.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.file_size_in_bytes is not None:
            result['FileSizeInBytes'] = self.file_size_in_bytes
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileSizeInBytes') is not None:
            self.file_size_in_bytes = m.get('FileSizeInBytes')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListCertificatesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        certificates: List[ListCertificatesResponseBodyPagingInfoCertificates] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The certificate files.
        self.certificates = certificates
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.certificates:
            for k in self.certificates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Certificates'] = []
        if self.certificates is not None:
            for k in self.certificates:
                result['Certificates'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.certificates = []
        if m.get('Certificates') is not None:
            for k in m.get('Certificates'):
                temp_model = ListCertificatesResponseBodyPagingInfoCertificates()
                self.certificates.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCertificatesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListCertificatesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListCertificatesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCertificatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCertificatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCertificatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListColumnsRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        sort_by: str = None,
        table_id: str = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.sort_by = sort_by
        # This parameter is required.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListColumnsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        columns: List[Column] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.columns = columns
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = Column()
                self.columns.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListColumnsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListColumnsResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListColumnsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCrawlerTypesResponseBody(TeaModel):
    def __init__(
        self,
        crawler_types: List[CrawlerType] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.crawler_types = crawler_types
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.crawler_types:
            for k in self.crawler_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CrawlerTypes'] = []
        if self.crawler_types is not None:
            for k in self.crawler_types:
                result['CrawlerTypes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.crawler_types = []
        if m.get('CrawlerTypes') is not None:
            for k in m.get('CrawlerTypes'):
                temp_model = CrawlerType()
                self.crawler_types.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCrawlerTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCrawlerTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCrawlerTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIAlarmRulesRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        job_id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The ID of the alert rule. If you leave this parameter empty, all alert rules of the task are queried.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the task for which alert rules are configured.
        self.job_id = job_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        # The alert notification methods.
        self.channels = channels
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The recipient type. Valid values: AliyunUid, DingToken, FeishuToken, and WebHookUrl.
        self.receiver_type = receiver_type
        # The recipient.
        # 
        # *   If the value of the ReceiverType parameter is AliyunUid, the value of this parameter is the Alibaba Cloud account ID of a user.
        # *   If the value of the ReceiverType parameter is DingToken, the value of this parameter is the token of a DingTalk chatbot.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        mute_interval: int = None,
        notification_channels: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers] = None,
    ):
        # This parameter is deprecated and replaced by the MuteInterval parameter.
        self.inhibition_interval = inhibition_interval
        # The duration of the alert suppression interval. Unit: minutes.
        self.mute_interval = mute_interval
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The settings of alert notification recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        if self.mute_interval is not None:
            result['MuteInterval'] = self.mute_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        if m.get('MuteInterval') is not None:
            self.mute_interval = m.get('MuteInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        ddl_types: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        # This parameter is deprecated and replaced by the DdlTypes parameter.
        self.ddl_report_tags = ddl_report_tags
        # The types of DDL operations for which the alert rule takes effect. This parameter is returned only if the MetricType parameter is set to DdlReport.
        self.ddl_types = ddl_types
        # The time interval for alert calculation. Unit: minutes.
        self.duration = duration
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity
        # The alert threshold.
        # 
        # *   If the alert rule is for task status, no threshold is used.
        # *   If the alert rule is for failovers, the threshold is the number of failovers.
        # *   If the alert rule is for latency, the threshold is the latency duration, in seconds.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.ddl_types is not None:
            result['DdlTypes'] = self.ddl_types
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('DdlTypes') is not None:
            self.ddl_types = m.get('DdlTypes')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        id: int = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings = None,
        trigger_conditions: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions] = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The description of the alert rule.
        self.description = description
        # Indicates whether the alert rule is enabled. Valid values: True and False.
        self.enabled = enabled
        # The ID of the alert rule.
        self.id = id
        # The metric type in the alert rule. Valid values:
        # 
        # *   Heartbeat
        # *   FailoverCount
        # *   Delay
        # *   DdlReport
        # *   ResourceUtilization
        self.metric_type = metric_type
        # The name of the alert rule.
        self.name = name
        # The alert notification method and recipient settings.
        self.notification_settings = notification_settings
        # The conditions that are used to trigger the alert rule.
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRulesTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class ListDIAlarmRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_alarm_rules: List[ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The alert rules.
        self.dijob_alarm_rules = dijob_alarm_rules
        # The page number. Pages start from page 1.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dijob_alarm_rules:
            for k in self.dijob_alarm_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobAlarmRules'] = []
        if self.dijob_alarm_rules is not None:
            for k in self.dijob_alarm_rules:
                result['DIJobAlarmRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijob_alarm_rules = []
        if m.get('DIJobAlarmRules') is not None:
            for k in m.get('DIJobAlarmRules'):
                temp_model = ListDIAlarmRulesResponseBodyPagingInfoDIJobAlarmRules()
                self.dijob_alarm_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIAlarmRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIAlarmRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIAlarmRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIAlarmRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIAlarmRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIAlarmRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobEventsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        event_type: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
    ):
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The type of event that you want to query. Valid values: Failover, Alarm, and DDL.
        # 
        # This parameter is required.
        self.event_type = event_type
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobEventsResponseBodyPagingInfoDIJobEvent(TeaModel):
    def __init__(
        self,
        action: str = None,
        channels: str = None,
        create_time: str = None,
        detail: str = None,
        dst_sql: str = None,
        dst_table: str = None,
        failover_message: str = None,
        id: str = None,
        severity: str = None,
        src_sql: str = None,
        src_table: str = None,
        status: str = None,
        type: str = None,
    ):
        # The processing result of the DDL event. Valid values: Critical, Ignore, Normal, and Warning.
        self.action = action
        # The alert notification method. Valid values: Phone, Mail, Sms, Ding, and Webhook.
        self.channels = channels
        # The time when the event was created.
        self.create_time = create_time
        # The alert details.
        self.detail = detail
        # The DDL statement of the destination table.
        self.dst_sql = dst_sql
        # The name of the destination table.
        self.dst_table = dst_table
        # The error logs for failovers.
        self.failover_message = failover_message
        # The event ID.
        self.id = id
        # The severity level of the alert. Valid values: Warning and Critical.
        self.severity = severity
        # The DDL statement of the source table.
        self.src_sql = src_sql
        # The name of the source table.
        self.src_table = src_table
        # The sending status of an alert notification. Valid values: Success, Fail, and Silence.
        self.status = status
        # The type of the alert event.
        # 
        # *   Heartbeat
        # *   Delay
        # *   FailoverCount
        # *   DdlReport
        # *   ResourceUtilization
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.dst_sql is not None:
            result['DstSql'] = self.dst_sql
        if self.dst_table is not None:
            result['DstTable'] = self.dst_table
        if self.failover_message is not None:
            result['FailoverMessage'] = self.failover_message
        if self.id is not None:
            result['Id'] = self.id
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.src_sql is not None:
            result['SrcSql'] = self.src_sql
        if self.src_table is not None:
            result['SrcTable'] = self.src_table
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('DstSql') is not None:
            self.dst_sql = m.get('DstSql')
        if m.get('DstTable') is not None:
            self.dst_table = m.get('DstTable')
        if m.get('FailoverMessage') is not None:
            self.failover_message = m.get('FailoverMessage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('SrcSql') is not None:
            self.src_sql = m.get('SrcSql')
        if m.get('SrcTable') is not None:
            self.src_table = m.get('SrcTable')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDIJobEventsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijob_event: List[ListDIJobEventsResponseBodyPagingInfoDIJobEvent] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The events returned. The value of this parameter is an array.
        self.dijob_event = dijob_event
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dijob_event:
            for k in self.dijob_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobEvent'] = []
        if self.dijob_event is not None:
            for k in self.dijob_event:
                result['DIJobEvent'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijob_event = []
        if m.get('DIJobEvent') is not None:
            for k in m.get('DIJobEvent'):
                temp_model = ListDIJobEventsResponseBodyPagingInfoDIJobEvent()
                self.dijob_event.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobEventsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobEventsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobEventsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobMetricsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        metric_name: List[str] = None,
        start_time: int = None,
    ):
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The metrics that you want to query.
        # 
        # This parameter is required.
        self.metric_name = metric_name
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobMetricsShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        end_time: int = None,
        metric_name_shrink: str = None,
        start_time: int = None,
    ):
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The end of the time range to query.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The metrics that you want to query.
        # 
        # This parameter is required.
        self.metric_name_shrink = metric_name_shrink
        # The beginning of the time range to query.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.metric_name_shrink is not None:
            result['MetricName'] = self.metric_name_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MetricName') is not None:
            self.metric_name_shrink = m.get('MetricName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: float = None,
    ):
        # The point in time at which data is sampled based on the metric.
        self.time = time
        # The sample value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDIJobMetricsResponseBodyPagingInfoJobMetrics(TeaModel):
    def __init__(
        self,
        name: str = None,
        series_list: List[ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList] = None,
    ):
        # The name of the metric.
        self.name = name
        # The metric data.
        self.series_list = series_list

    def validate(self):
        if self.series_list:
            for k in self.series_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['SeriesList'] = []
        if self.series_list is not None:
            for k in self.series_list:
                result['SeriesList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.series_list = []
        if m.get('SeriesList') is not None:
            for k in m.get('SeriesList'):
                temp_model = ListDIJobMetricsResponseBodyPagingInfoJobMetricsSeriesList()
                self.series_list.append(temp_model.from_map(k))
        return self


class ListDIJobMetricsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        job_metrics: List[ListDIJobMetricsResponseBodyPagingInfoJobMetrics] = None,
    ):
        # The metrics returned.
        self.job_metrics = job_metrics

    def validate(self):
        if self.job_metrics:
            for k in self.job_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobMetrics'] = []
        if self.job_metrics is not None:
            for k in self.job_metrics:
                result['JobMetrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_metrics = []
        if m.get('JobMetrics') is not None:
            for k in m.get('JobMetrics'):
                temp_model = ListDIJobMetricsResponseBodyPagingInfoJobMetrics()
                self.job_metrics.append(temp_model.from_map(k))
        return self


class ListDIJobMetricsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobMetricsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobMetricsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobRunDetailsRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        instance_id: int = None,
        page_number: int = None,
        page_size: int = None,
        source_data_source_name: str = None,
        source_database_name: str = None,
        source_schema_name: str = None,
        source_table_name: str = None,
    ):
        # The ID of the synchronization task.
        # 
        # This parameter is required.
        self.dijob_id = dijob_id
        # The instance ID.
        self.instance_id = instance_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The name of the source.
        self.source_data_source_name = source_data_source_name
        # The name of the database in the source.
        self.source_database_name = source_database_name
        # The name of the schema of the source.
        self.source_schema_name = source_schema_name
        # The name of the table in the source.
        self.source_table_name = source_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.source_data_source_name is not None:
            result['SourceDataSourceName'] = self.source_data_source_name
        if self.source_database_name is not None:
            result['SourceDatabaseName'] = self.source_database_name
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SourceDataSourceName') is not None:
            self.source_data_source_name = m.get('SourceDataSourceName')
        if m.get('SourceDatabaseName') is not None:
            self.source_database_name = m.get('SourceDatabaseName')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        return self


class ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos(TeaModel):
    def __init__(
        self,
        destination_database_name: str = None,
        destination_datasource_name: str = None,
        destination_schema_name: str = None,
        destination_table_name: str = None,
        full_migration_error_message: str = None,
        full_migration_status: str = None,
        offline_error_records: int = None,
        offline_total_bytes: int = None,
        offline_total_records: int = None,
        realtime_migration_error_message: str = None,
        realtime_migration_status: str = None,
        source_database_name: str = None,
        source_datasource_name: str = None,
        source_schema_name: str = None,
        source_table_name: str = None,
        structure_migration_error_message: str = None,
        structure_migration_status: str = None,
    ):
        # The name of the database in the destination.
        self.destination_database_name = destination_database_name
        # The name of the destination.
        self.destination_datasource_name = destination_datasource_name
        # The name of the schema of the destination.
        self.destination_schema_name = destination_schema_name
        # The name of the table in the destination.
        self.destination_table_name = destination_table_name
        # The error message that is returned if an error occurs during full batch synchronization. If no error occurs, no value is returned for this parameter.
        self.full_migration_error_message = full_migration_error_message
        # The status of full batch synchronization.
        self.full_migration_status = full_migration_status
        # The total number of errors that occur during full synchronization.
        self.offline_error_records = offline_error_records
        # The total number of bytes that are synchronized during full synchronization.
        self.offline_total_bytes = offline_total_bytes
        # The total number of data records that are synchronized during full synchronization.
        self.offline_total_records = offline_total_records
        # The error message that is returned if an error occurs during real-time synchronization. If no error occurs, no value is returned for this parameter.
        self.realtime_migration_error_message = realtime_migration_error_message
        # The status of real-time synchronization.
        self.realtime_migration_status = realtime_migration_status
        # The name of the database in the source.
        self.source_database_name = source_database_name
        # The name of the source.
        self.source_datasource_name = source_datasource_name
        # The name of the schema of the source.
        self.source_schema_name = source_schema_name
        # The name of the table in the source.
        self.source_table_name = source_table_name
        # The error message that is returned if an error occurs during schema synchronization. If no error occurs, no value is returned for this parameter.
        self.structure_migration_error_message = structure_migration_error_message
        # The synchronization status of the schema.
        self.structure_migration_status = structure_migration_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_database_name is not None:
            result['DestinationDatabaseName'] = self.destination_database_name
        if self.destination_datasource_name is not None:
            result['DestinationDatasourceName'] = self.destination_datasource_name
        if self.destination_schema_name is not None:
            result['DestinationSchemaName'] = self.destination_schema_name
        if self.destination_table_name is not None:
            result['DestinationTableName'] = self.destination_table_name
        if self.full_migration_error_message is not None:
            result['FullMigrationErrorMessage'] = self.full_migration_error_message
        if self.full_migration_status is not None:
            result['FullMigrationStatus'] = self.full_migration_status
        if self.offline_error_records is not None:
            result['OfflineErrorRecords'] = self.offline_error_records
        if self.offline_total_bytes is not None:
            result['OfflineTotalBytes'] = self.offline_total_bytes
        if self.offline_total_records is not None:
            result['OfflineTotalRecords'] = self.offline_total_records
        if self.realtime_migration_error_message is not None:
            result['RealtimeMigrationErrorMessage'] = self.realtime_migration_error_message
        if self.realtime_migration_status is not None:
            result['RealtimeMigrationStatus'] = self.realtime_migration_status
        if self.source_database_name is not None:
            result['SourceDatabaseName'] = self.source_database_name
        if self.source_datasource_name is not None:
            result['SourceDatasourceName'] = self.source_datasource_name
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.structure_migration_error_message is not None:
            result['StructureMigrationErrorMessage'] = self.structure_migration_error_message
        if self.structure_migration_status is not None:
            result['StructureMigrationStatus'] = self.structure_migration_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDatabaseName') is not None:
            self.destination_database_name = m.get('DestinationDatabaseName')
        if m.get('DestinationDatasourceName') is not None:
            self.destination_datasource_name = m.get('DestinationDatasourceName')
        if m.get('DestinationSchemaName') is not None:
            self.destination_schema_name = m.get('DestinationSchemaName')
        if m.get('DestinationTableName') is not None:
            self.destination_table_name = m.get('DestinationTableName')
        if m.get('FullMigrationErrorMessage') is not None:
            self.full_migration_error_message = m.get('FullMigrationErrorMessage')
        if m.get('FullMigrationStatus') is not None:
            self.full_migration_status = m.get('FullMigrationStatus')
        if m.get('OfflineErrorRecords') is not None:
            self.offline_error_records = m.get('OfflineErrorRecords')
        if m.get('OfflineTotalBytes') is not None:
            self.offline_total_bytes = m.get('OfflineTotalBytes')
        if m.get('OfflineTotalRecords') is not None:
            self.offline_total_records = m.get('OfflineTotalRecords')
        if m.get('RealtimeMigrationErrorMessage') is not None:
            self.realtime_migration_error_message = m.get('RealtimeMigrationErrorMessage')
        if m.get('RealtimeMigrationStatus') is not None:
            self.realtime_migration_status = m.get('RealtimeMigrationStatus')
        if m.get('SourceDatabaseName') is not None:
            self.source_database_name = m.get('SourceDatabaseName')
        if m.get('SourceDatasourceName') is not None:
            self.source_datasource_name = m.get('SourceDatasourceName')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('StructureMigrationErrorMessage') is not None:
            self.structure_migration_error_message = m.get('StructureMigrationErrorMessage')
        if m.get('StructureMigrationStatus') is not None:
            self.structure_migration_status = m.get('StructureMigrationStatus')
        return self


class ListDIJobRunDetailsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        job_run_infos: List[ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The running information about the synchronization task.
        self.job_run_infos = job_run_infos
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.job_run_infos:
            for k in self.job_run_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobRunInfos'] = []
        if self.job_run_infos is not None:
            for k in self.job_run_infos:
                result['JobRunInfos'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job_run_infos = []
        if m.get('JobRunInfos') is not None:
            for k in m.get('JobRunInfos'):
                temp_model = ListDIJobRunDetailsResponseBodyPagingInfoJobRunInfos()
                self.job_run_infos.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobRunDetailsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobRunDetailsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobRunDetailsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobRunDetailsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobRunDetailsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobRunDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDIJobsRequest(TeaModel):
    def __init__(
        self,
        destination_data_source_type: str = None,
        migration_type: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        source_data_source_type: str = None,
    ):
        # The destination type. Valid values: Hologres, OSS-HDFS, OSS, MaxCompute, Loghub, STARROCKS, Datahub, ANALYTICDB_FOR_MYSQL, Kafka, and Hive. If you do not configure this parameter, the API operation queries synchronization tasks that use all type of destinations.
        self.destination_data_source_type = destination_data_source_type
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
        # *   RealtimeIncremental: real-time incremental synchronization
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        # *   FullAndOfflineIncremental: one-time full synchronization and batch incremental synchronization
        self.migration_type = migration_type
        # The name of the export task.
        # 
        # The name of each export task must be unique. You must make sure that the names of the export tasks in the current workspace are unique.
        self.name = name
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The source type. Valid values: PolarDB, MySQL, Kafka, Loghub, Hologres, Oracle, OceanBase, MongoDB, RedShift, Hive, SqlServer, Doris, and ClickHouse. If you do not configure this parameter, the API operation queries synchronization tasks that use all types of sources.
        self.source_data_source_type = source_data_source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        return self


class ListDIJobsResponseBodyPagingInfoDIJobs(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        destination_data_source_type: str = None,
        id: int = None,
        job_name: str = None,
        job_status: str = None,
        migration_type: str = None,
        project_id: int = None,
        source_data_source_type: str = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The destination type. Valid values: Hologres, OSS-HDFS, OSS, MaxCompute, Loghub, STARROCKS, DataHub, ANALYTICDB_FOR_MYSQL, Kafka, and Hive.
        self.destination_data_source_type = destination_data_source_type
        # The ID of the synchronization task.
        self.id = id
        # The name of the synchronization task.
        self.job_name = job_name
        # The status of the synchronization task. Valid values:
        # 
        # *   Finished
        # *   Initialized
        # *   Stopped
        # *   Failed
        # *   Running
        # *   Stopping
        self.job_status = job_status
        # The synchronization type. Valid values:
        # 
        # *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
        # *   RealtimeIncremental: real-time incremental synchronization
        # *   Full: full synchronization
        # *   OfflineIncremental: batch incremental synchronization
        # *   FullAndOfflineIncremental: one-time full synchronization and batch incremental synchronization
        self.migration_type = migration_type
        # The ID of the DataWorks workspace to which the synchronization task belongs.
        self.project_id = project_id
        # The source type. Valid values: PolarDB, MySQL, Kafka, Loghub, Hologres, Oracle, OceanBase, MongoDB, RedShift, Hive, SqlServer, Doris, and ClickHouse. If you do not configure this parameter, the API operation returns synchronization tasks that use all types of sources.
        self.source_data_source_type = source_data_source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.destination_data_source_type is not None:
            result['DestinationDataSourceType'] = self.destination_data_source_type
        if self.id is not None:
            result['Id'] = self.id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.source_data_source_type is not None:
            result['SourceDataSourceType'] = self.source_data_source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('DestinationDataSourceType') is not None:
            self.destination_data_source_type = m.get('DestinationDataSourceType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SourceDataSourceType') is not None:
            self.source_data_source_type = m.get('SourceDataSourceType')
        return self


class ListDIJobsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        dijobs: List[ListDIJobsResponseBodyPagingInfoDIJobs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The synchronization tasks returned.
        self.dijobs = dijobs
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dijobs:
            for k in self.dijobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DIJobs'] = []
        if self.dijobs is not None:
            for k in self.dijobs:
                result['DIJobs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dijobs = []
        if m.get('DIJobs') is not None:
            for k in m.get('DIJobs'):
                temp_model = ListDIJobsResponseBodyPagingInfoDIJobs()
                self.dijobs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDIJobsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDIJobsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDIJobsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDIJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDIJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDIJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataAssetTagsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        key: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The type of the tag. Valid values:
        # 
        # *   Normal
        # *   System
        self.category = category
        # The tag key.
        self.key = key
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.key is not None:
            result['Key'] = self.key
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListDataAssetTagsResponseBodyPagingInfoDataAssetTags(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        key: str = None,
        managers: List[str] = None,
        modify_time: int = None,
        modify_user: str = None,
        value_type: str = None,
        values: List[str] = None,
    ):
        # The type of the tag.
        # 
        # Valid values:
        # 
        # *   Normal
        # *   System
        self.category = category
        # The time when the tag was created.
        self.create_time = create_time
        # The creator of the tag.
        self.create_user = create_user
        # The description of the tag.
        self.description = description
        # The tag key.
        self.key = key
        # The tag administrators.
        self.managers = managers
        # The time when the tag was last modified.
        self.modify_time = modify_time
        # The user who last modified the tag.
        self.modify_user = modify_user
        # The type of the tag value.
        self.value_type = value_type
        # The tag values.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.managers is not None:
            result['Managers'] = self.managers
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Managers') is not None:
            self.managers = m.get('Managers')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class ListDataAssetTagsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_asset_tags: List[ListDataAssetTagsResponseBodyPagingInfoDataAssetTags] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The tags.
        self.data_asset_tags = data_asset_tags
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_asset_tags:
            for k in self.data_asset_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataAssetTags'] = []
        if self.data_asset_tags is not None:
            for k in self.data_asset_tags:
                result['DataAssetTags'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_asset_tags = []
        if m.get('DataAssetTags') is not None:
            for k in m.get('DataAssetTags'):
                temp_model = ListDataAssetTagsResponseBodyPagingInfoDataAssetTags()
                self.data_asset_tags.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataAssetTagsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataAssetTagsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataAssetTagsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataAssetTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataAssetTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataAssetTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataAssetsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # The tag key can be up to 64 characters in length and can contain letters, digits, and the following characters: `-@#*<>|[]()+=&%$!~`. It cannot start with `dw:`.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataAssetsRequest(TeaModel):
    def __init__(
        self,
        data_asset_ids: List[str] = None,
        data_asset_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        tags: List[ListDataAssetsRequestTags] = None,
    ):
        # The data asset IDs.
        self.data_asset_ids = data_asset_ids
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that are added to data assets. This parameter specifies a filter condition.
        # 
        # *   You can specify multiple tags, which are in the logical OR relation. For example, you can query the data assets that contain one of the following tags: `["key1:v1", "key2:v1", "key3:v1"]`.
        # *   If you do not configure this parameter, tag-based filtering is not performed.
        # 
        # This parameter is required.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_asset_ids is not None:
            result['DataAssetIds'] = self.data_asset_ids
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListDataAssetsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListDataAssetsShrinkRequest(TeaModel):
    def __init__(
        self,
        data_asset_ids_shrink: str = None,
        data_asset_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        tags_shrink: str = None,
    ):
        # The data asset IDs.
        self.data_asset_ids_shrink = data_asset_ids_shrink
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that are added to data assets. This parameter specifies a filter condition.
        # 
        # *   You can specify multiple tags, which are in the logical OR relation. For example, you can query the data assets that contain one of the following tags: `["key1:v1", "key2:v1", "key3:v1"]`.
        # *   If you do not configure this parameter, tag-based filtering is not performed.
        # 
        # This parameter is required.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_asset_ids_shrink is not None:
            result['DataAssetIds'] = self.data_asset_ids_shrink
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids_shrink = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings(TeaModel):
    def __init__(
        self,
        auto_trace_enabled: bool = None,
        creator: str = None,
        data_asset_id: str = None,
        key: str = None,
        tag_source: str = None,
        value: str = None,
    ):
        # Indicates whether the lineage-based automatic backtrack feature is enabled for the mapping.
        self.auto_trace_enabled = auto_trace_enabled
        # The creator of the mapping between the data asset and the tag.
        self.creator = creator
        # The data asset ID.
        self.data_asset_id = data_asset_id
        # The tag key.
        self.key = key
        # The way in which the mapping between the data asset and the tag is created. Valid values:
        # 
        # *   System
        # *   UserDefined
        self.tag_source = tag_source
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_trace_enabled is not None:
            result['AutoTraceEnabled'] = self.auto_trace_enabled
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_asset_id is not None:
            result['DataAssetId'] = self.data_asset_id
        if self.key is not None:
            result['Key'] = self.key
        if self.tag_source is not None:
            result['TagSource'] = self.tag_source
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoTraceEnabled') is not None:
            self.auto_trace_enabled = m.get('AutoTraceEnabled')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataAssetId') is not None:
            self.data_asset_id = m.get('DataAssetId')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('TagSource') is not None:
            self.tag_source = m.get('TagSource')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataAssetsResponseBodyPagingInfoDataAssets(TeaModel):
    def __init__(
        self,
        data_asset_tag_mappings: List[ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings] = None,
        env_type: str = None,
        id: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # The mappings between data assets and tags.
        self.data_asset_tag_mappings = data_asset_tag_mappings
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The data asset ID.
        self.id = id
        # The name of the data asset.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        self.type = type

    def validate(self):
        if self.data_asset_tag_mappings:
            for k in self.data_asset_tag_mappings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataAssetTagMappings'] = []
        if self.data_asset_tag_mappings is not None:
            for k in self.data_asset_tag_mappings:
                result['DataAssetTagMappings'].append(k.to_map() if k else None)
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_asset_tag_mappings = []
        if m.get('DataAssetTagMappings') is not None:
            for k in m.get('DataAssetTagMappings'):
                temp_model = ListDataAssetsResponseBodyPagingInfoDataAssetsDataAssetTagMappings()
                self.data_asset_tag_mappings.append(temp_model.from_map(k))
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataAssetsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_assets: List[ListDataAssetsResponseBodyPagingInfoDataAssets] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The data assets.
        self.data_assets = data_assets
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_assets:
            for k in self.data_assets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataAssets'] = []
        if self.data_assets is not None:
            for k in self.data_assets:
                result['DataAssets'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_assets = []
        if m.get('DataAssets') is not None:
            for k in m.get('DataAssets'):
                temp_model = ListDataAssetsResponseBodyPagingInfoDataAssets()
                self.data_assets.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataAssetsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataAssetsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataAssetsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityEvaluationTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        bizdate_from: str = None,
        bizdate_to: str = None,
        create_time_from: int = None,
        create_time_to: int = None,
        data_quality_evaluation_task_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
        trigger_client: str = None,
        trigger_client_id: str = None,
    ):
        # The start time of the data quality monitoring task.
        self.bizdate_from = bizdate_from
        # The end time of the data quality monitoring task.
        self.bizdate_to = bizdate_to
        # The earliest start time at which the instances are generated.
        self.create_time_from = create_time_from
        # The latest start time at which the instances are generated.
        self.create_time_to = create_time_to
        # The ID of the data quality monitoring task.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The name of the trigger module of the instance.
        self.trigger_client = trigger_client
        # The ID of the instance that is generated by the task.
        self.trigger_client_id = trigger_client_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate_from is not None:
            result['BizdateFrom'] = self.bizdate_from
        if self.bizdate_to is not None:
            result['BizdateTo'] = self.bizdate_to
        if self.create_time_from is not None:
            result['CreateTimeFrom'] = self.create_time_from
        if self.create_time_to is not None:
            result['CreateTimeTo'] = self.create_time_to
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.trigger_client is not None:
            result['TriggerClient'] = self.trigger_client
        if self.trigger_client_id is not None:
            result['TriggerClientId'] = self.trigger_client_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizdateFrom') is not None:
            self.bizdate_from = m.get('BizdateFrom')
        if m.get('BizdateTo') is not None:
            self.bizdate_to = m.get('BizdateTo')
        if m.get('CreateTimeFrom') is not None:
            self.create_time_from = m.get('CreateTimeFrom')
        if m.get('CreateTimeTo') is not None:
            self.create_time_to = m.get('CreateTimeTo')
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TriggerClient') is not None:
            self.trigger_client = m.get('TriggerClient')
        if m.get('TriggerClientId') is not None:
            self.trigger_client_id = m.get('TriggerClientId')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The trigger configuration of the callback event.
        self.condition = condition
        # The type of the callback event. Valid values:
        # 
        # *   BlockTaskInstance. The value indicates that an auto triggered node is blocked.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The extended information in the JSON format. For example, the DingTalk chatbot can remind all members in a DingTalk group by using the at sign (@).
        self.extension = extension
        # The type of the alert recipient. Valid values:
        # 
        # *   AliUid: Alibaba Cloud account ID
        # *   WebhookUrl: URL of a custom webhook
        # *   DingdingUrl: DingTalk chatbot URL
        # *   FeishuUrl: Lark chatbot URL
        # *   WeixinUrl: WeCom chatbot URL
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications(TeaModel):
    def __init__(
        self,
        nofitication_receivers: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers] = None,
        notification_channels: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels] = None,
    ):
        # The alert recipients.
        self.nofitication_receivers = nofitication_receivers
        # The alert notification methods.
        self.notification_channels = notification_channels

    def validate(self):
        if self.nofitication_receivers:
            for k in self.nofitication_receivers:
                if k:
                    k.validate()
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NofiticationReceivers'] = []
        if self.nofitication_receivers is not None:
            for k in self.nofitication_receivers:
                result['NofiticationReceivers'].append(k.to_map() if k else None)
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nofitication_receivers = []
        if m.get('NofiticationReceivers') is not None:
            for k in m.get('NofiticationReceivers'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNofiticationReceivers()
                self.nofitication_receivers.append(temp_model.from_map(k))
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications] = None,
    ):
        # The trigger condition of the alert notification.
        self.condition = condition
        # The configurations for the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of the auto triggered nodes of which the instances are successfully run.
        self.task_ids = task_ids
        # The trigger condition of the task. Valid values:
        # 
        # *   ByScheduledTaskInstance. The value indicates that the task is triggered when the instance of an auto triggered node is successfully run.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask(TeaModel):
    def __init__(
        self,
        description: str = None,
        hooks: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks] = None,
        id: int = None,
        name: str = None,
        notifications: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget = None,
        trigger: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger = None,
    ):
        # The description of the task.
        self.description = description
        # The callback configurations of the task during the instance lifecycle. Blocking an auto triggered node is a type of callback event. Only this type is supported.
        self.hooks = hooks
        # The task ID.
        self.id = id
        # The name of the monitor.
        # 
        # This parameter is required.
        self.name = name
        # The configurations for alert notifications.
        self.notifications = notifications
        # The workspace ID.
        self.project_id = project_id
        # The configuration of the data source. The value of the queue field is default, and that of the sqlEngine field can be set to SPARK_SQL, KYUUBI, PRESTO_SQL, or HIVE_SQL. The value default indicates the YARN queue for E-MapReduce (EMR) tasks.
        self.runtime_conf = runtime_conf
        # The monitored object of the task.
        self.target = target
        # The trigger configuration of the task.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        finish_time: int = None,
        id: int = None,
        parameters: str = None,
        project_id: int = None,
        status: str = None,
        task: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask = None,
        trigger_context: str = None,
    ):
        # The time at which the instance was generated.
        self.create_time = create_time
        # The time at which the instance finished running.
        self.finish_time = finish_time
        # The ID of the instance.
        self.id = id
        # The parameters configured for the instance.
        self.parameters = parameters
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The status of the instance. Valid values:
        # 
        # *   Running
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status
        # The snapshot of the configurations for the task when the task starts.
        self.task = task
        # The information about the trigger module of the instance.
        self.trigger_context = trigger_context

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.id is not None:
            result['Id'] = self.id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task is not None:
            result['Task'] = self.task.to_map()
        if self.trigger_context is not None:
            result['TriggerContext'] = self.trigger_context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Task') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstancesTask()
            self.task = temp_model.from_map(m['Task'])
        if m.get('TriggerContext') is not None:
            self.trigger_context = m.get('TriggerContext')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_instances: List[ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The instances generated by the task.
        self.data_quality_evaluation_task_instances = data_quality_evaluation_task_instances
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_evaluation_task_instances:
            for k in self.data_quality_evaluation_task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityEvaluationTaskInstances'] = []
        if self.data_quality_evaluation_task_instances is not None:
            for k in self.data_quality_evaluation_task_instances:
                result['DataQualityEvaluationTaskInstances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_evaluation_task_instances = []
        if m.get('DataQualityEvaluationTaskInstances') is not None:
            for k in m.get('DataQualityEvaluationTaskInstances'):
                temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfoDataQualityEvaluationTaskInstances()
                self.data_quality_evaluation_task_instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityEvaluationTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityEvaluationTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityEvaluationTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityEvaluationTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityEvaluationTasksRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
    ):
        # The name of the data quality monitoring task. Fuzzy match is supported.
        self.name = name
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table in Data Map.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The trigger configuration of the callback event.
        self.condition = condition
        # The type of the callback event. Valid values:
        # 
        # *   BlockTaskInstance. The value indicates that an auto triggered node is blocked.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The extended information in the JSON format. For example, the DingTalk chatbot can remind all members in a DingTalk group by using the at sign (@).
        self.extension = extension
        # The type of the alert recipient. Valid values:
        # 
        # *   AliUid: Alibaba Cloud account ID
        # *   WebhookUrl: URL of a custom webhook
        # *   DingdingUrl: DingTalk chatbot URL
        # *   FeishuUrl: Lark chatbot URL
        # *   WeixinUrl: WeCom chatbot URL
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The alert recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications] = None,
    ):
        # The trigger condition of the alert notification.
        self.condition = condition
        # The configurations for the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of the auto triggered nodes of which the instances are successfully run. This parameter takes effect only if the Type parameter is set to ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger condition of the task. Valid values:
        # 
        # *   ByScheduledTaskInstance. The value indicates that the task is triggered when the instance of an auto triggered node is successfully run.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        hooks: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks] = None,
        id: int = None,
        name: str = None,
        notifications: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget = None,
        trigger: ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger = None,
    ):
        self.data_source_id = data_source_id
        # The description of the data quality monitoring task. The description can be up to 65,535 characters in length.
        self.description = description
        # The callback configurations of the task during the instance lifecycle. Blocking an auto triggered node is a type of callback event. Only this type is supported.
        self.hooks = hooks
        # The ID of the data quality monitoring task.
        self.id = id
        # The name of the data quality monitoring task. The name can be up to 255 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # The configurations for alert notifications.
        self.notifications = notifications
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The configuration of the data source. The value of the queue field is default, and that of the sqlEngine field can be set to SPARK_SQL, KYUUBI, PRESTO_SQL, or HIVE_SQL. The value default indicates the YARN queue for E-MapReduce (EMR) tasks.
        self.runtime_conf = runtime_conf
        # The monitored object of the task.
        self.target = target
        # The trigger configuration of the task.
        self.trigger = trigger

    def validate(self):
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListDataQualityEvaluationTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_tasks: List[ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The data quality monitoring tasks.
        self.data_quality_evaluation_tasks = data_quality_evaluation_tasks
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_evaluation_tasks:
            for k in self.data_quality_evaluation_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityEvaluationTasks'] = []
        if self.data_quality_evaluation_tasks is not None:
            for k in self.data_quality_evaluation_tasks:
                result['DataQualityEvaluationTasks'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_evaluation_tasks = []
        if m.get('DataQualityEvaluationTasks') is not None:
            for k in m.get('DataQualityEvaluationTasks'):
                temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfoDataQualityEvaluationTasks()
                self.data_quality_evaluation_tasks.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityEvaluationTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityEvaluationTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityEvaluationTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityEvaluationTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityEvaluationTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityResultsRequest(TeaModel):
    def __init__(
        self,
        bizdate_from: str = None,
        bizdate_to: str = None,
        create_time_from: int = None,
        create_time_to: int = None,
        data_quality_evaluation_task_id: int = None,
        data_quality_evaluation_task_instance_id: int = None,
        data_quality_rule_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
    ):
        # The beginning of the time range to query.
        self.bizdate_from = bizdate_from
        # The end of the time range to query.
        self.bizdate_to = bizdate_to
        # The earliest time when the data quality check result was generated.
        self.create_time_from = create_time_from
        # The latest time when the data quality check result was generated.
        self.create_time_to = create_time_to
        # The ID of the data quality monitoring task.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The ID of the instance generated by the check.
        self.data_quality_evaluation_task_instance_id = data_quality_evaluation_task_instance_id
        # The ID of the data quality monitoring rule.
        self.data_quality_rule_id = data_quality_rule_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate_from is not None:
            result['BizdateFrom'] = self.bizdate_from
        if self.bizdate_to is not None:
            result['BizdateTo'] = self.bizdate_to
        if self.create_time_from is not None:
            result['CreateTimeFrom'] = self.create_time_from
        if self.create_time_to is not None:
            result['CreateTimeTo'] = self.create_time_to
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.data_quality_evaluation_task_instance_id is not None:
            result['DataQualityEvaluationTaskInstanceId'] = self.data_quality_evaluation_task_instance_id
        if self.data_quality_rule_id is not None:
            result['DataQualityRuleId'] = self.data_quality_rule_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizdateFrom') is not None:
            self.bizdate_from = m.get('BizdateFrom')
        if m.get('BizdateTo') is not None:
            self.bizdate_to = m.get('BizdateTo')
        if m.get('CreateTimeFrom') is not None:
            self.create_time_from = m.get('CreateTimeFrom')
        if m.get('CreateTimeTo') is not None:
            self.create_time_to = m.get('CreateTimeTo')
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('DataQualityEvaluationTaskInstanceId') is not None:
            self.data_quality_evaluation_task_instance_id = m.get('DataQualityEvaluationTaskInstanceId')
        if m.get('DataQualityRuleId') is not None:
            self.data_quality_rule_id = m.get('DataQualityRuleId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails(TeaModel):
    def __init__(
        self,
        checked_value: str = None,
        referenced_value: str = None,
        status: str = None,
    ):
        # The value that is used for comparison with the threshold.
        self.checked_value = checked_value
        # The value that is calculated based on sample data. The value serves as a baseline value during the calculation of the value of the CheckedValue parameter.
        self.referenced_value = referenced_value
        # The comparison result between the value of CheckedValue and the threshold. Valid values:
        # 
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checked_value is not None:
            result['CheckedValue'] = self.checked_value
        if self.referenced_value is not None:
            result['ReferencedValue'] = self.referenced_value
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckedValue') is not None:
            self.checked_value = m.get('CheckedValue')
        if m.get('ReferencedValue') is not None:
            self.referenced_value = m.get('ReferencedValue')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical = None,
        expected: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected = None,
        warned: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference samples and perform aggregate operations on the reference values. In this example, an expression is used to indicate the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If the rule is defined by custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The ID of the table in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule(TeaModel):
    def __init__(
        self,
        checking_config: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig = None,
        severity: str = None,
        target: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        self.id = id
        # The name of the rule. The name can be up to 255 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   High
        # *   Normal
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        # The code of the template that is referenced when you create a rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRuleTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class ListDataQualityResultsResponseBodyPagingInfoDataQualityResults(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        details: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails] = None,
        id: int = None,
        rule: ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule = None,
        sample: str = None,
        status: str = None,
        task_instance_id: int = None,
    ):
        # The time when the data quality check result was generated.
        self.create_time = create_time
        # The information about the data quality check.
        self.details = details
        # The ID of the check result.
        self.id = id
        # The snapshot of the rule configuration when the check starts.
        self.rule = rule
        # The sample values used for the check.
        self.sample = sample
        # The status of the check result. Valid values:
        # 
        # *   Running
        # *   Error
        # *   Passed
        # *   Warned
        # *   Critical
        self.status = status
        # The ID of the instance generated by the check.
        self.task_instance_id = task_instance_id

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()
        if self.rule:
            self.rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        if self.sample is not None:
            result['Sample'] = self.sample
        if self.status is not None:
            result['Status'] = self.status
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Rule') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResultsRule()
            self.rule = temp_model.from_map(m['Rule'])
        if m.get('Sample') is not None:
            self.sample = m.get('Sample')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        return self


class ListDataQualityResultsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_results: List[ListDataQualityResultsResponseBodyPagingInfoDataQualityResults] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The data quality check results.
        self.data_quality_results = data_quality_results
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_results:
            for k in self.data_quality_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityResults'] = []
        if self.data_quality_results is not None:
            for k in self.data_quality_results:
                result['DataQualityResults'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_results = []
        if m.get('DataQualityResults') is not None:
            for k in m.get('DataQualityResults'):
                temp_model = ListDataQualityResultsResponseBodyPagingInfoDataQualityResults()
                self.data_quality_results.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityResultsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityResultsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityResultsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityResultsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityResultsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityResultsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityRuleTemplatesRequest(TeaModel):
    def __init__(
        self,
        creation_source: str = None,
        directory_path: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
    ):
        # The source of the template. This parameter is required. Valid values:
        # 
        # *   System
        # *   UserDefined
        self.creation_source = creation_source
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. If you want to query a system template, set this parameter to the name of the system template. Fuzzy match is supported.
        self.name = name
        # The number of entries per page. Default value: 10.
        self.page_number = page_number
        # The page number. Default value: 1.
        self.page_size = page_size
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_source is not None:
            result['CreationSource'] = self.creation_source
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreationSource') is not None:
            self.creation_source = m.get('CreationSource')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        type: str = None,
    ):
        # Some types of thresholds need to query some reference samples, and then summarize the values of the reference samples to obtain the threshold for comparison. Here, an expression is used to represent the query method of the reference samples.
        self.referenced_samples_filter = referenced_samples_filter
        # Threshold Calculation method
        # - Fixed
        # - Fluctation
        # - FluctationDiscreate
        # - Auto
        # - Average
        # - Variance
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        setting_config: str = None,
    ):
        # The name of the sampled metric.
        # - Count: number of table rows
        # - Min: minimum value of the field
        # - Max: The maximum value of the field.
        # - Avg: field mean
        # - DistinctCount: number of unique field values
        # - DistinctPercent: the ratio of the number of unique field values to the number of data rows.
        # - DuplicatedCount: number of duplicate field values
        # - DuplicatedPercent: the ratio of the number of duplicate field values to the number of data rows.
        # - TableSize: table size
        # - NullValueCount: number of rows with empty fields
        # - NullValuePercent: the proportion of fields that are empty.
        # - GroupCount: aggregate each value by field value and the corresponding number of data rows
        # - CountNotIn: the enumerated value does not match the number of rows.
        # - CountDistinctNotIn: the number of unique values that the enumerated values do not match.
        # - UserDefinedSql: use custom SQL to collect samples
        self.metric = metric
        # Parameters required for sample collection
        self.metric_parameters = metric_parameters
        # Before executing the sample statement, insert some runtime parameter setting statements, which can be up to 1000 characters in length. Currently, only MaxCompute are supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates(TeaModel):
    def __init__(
        self,
        checking_config: ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig = None,
        code: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config: ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig = None,
        visible_scope: str = None,
    ):
        # Sample verification settings
        self.checking_config = checking_config
        # Rule template Code
        self.code = code
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # DataWorks workspace ID
        self.project_id = project_id
        # Settings required for sample collection
        self.sampling_config = sampling_config
        # Available range of templates:
        # - Tenant: all tenants are available
        # - Project: only available in the current Project
        self.visible_scope = visible_scope

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.visible_scope is not None:
            result['VisibleScope'] = self.visible_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplatesSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('VisibleScope') is not None:
            self.visible_scope = m.get('VisibleScope')
        return self


class ListDataQualityRuleTemplatesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_rule_templates: List[ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The templates.
        self.data_quality_rule_templates = data_quality_rule_templates
        # Page number
        self.page_number = page_number
        # Page size
        self.page_size = page_size
        # Total number of entries
        self.total_count = total_count

    def validate(self):
        if self.data_quality_rule_templates:
            for k in self.data_quality_rule_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityRuleTemplates'] = []
        if self.data_quality_rule_templates is not None:
            for k in self.data_quality_rule_templates:
                result['DataQualityRuleTemplates'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_rule_templates = []
        if m.get('DataQualityRuleTemplates') is not None:
            for k in m.get('DataQualityRuleTemplates'):
                temp_model = ListDataQualityRuleTemplatesResponseBodyPagingInfoDataQualityRuleTemplates()
                self.data_quality_rule_templates.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityRuleTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityRuleTemplatesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityRuleTemplatesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityRuleTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityRuleTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityRuleTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataQualityRulesRequest(TeaModel):
    def __init__(
        self,
        data_quality_evaluation_task_id: int = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        table_guid: str = None,
    ):
        # The ID of the data quality monitoring task that is associated with the rule.
        self.data_quality_evaluation_task_id = data_quality_evaluation_task_id
        # The name of the rule. Fuzzy match is supported.
        self.name = name
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 200.
        self.page_size = page_size
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The ID of the table that is limited by the rule in Data Map.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_evaluation_task_id is not None:
            result['DataQualityEvaluationTaskId'] = self.data_quality_evaluation_task_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityEvaluationTaskId') is not None:
            self.data_quality_evaluation_task_id = m.get('DataQualityEvaluationTaskId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical = None,
        expected: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected = None,
        warned: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference values. In this example, an expression is used to indicate the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If the rule is defined by custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the percentage of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values in the field.
        # *   DuplicatedPercent: the percentage of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field is set to null.
        # *   NullValuePercent: the percentage of the number of rows in which the field is set to null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that the data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        table_guid: str = None,
        type: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   emr
        # *   cdh
        # *   hologres
        # *   analyticdb_for_postgresql
        # *   analyticdb_for_mysql
        # *   starrocks
        self.database_type = database_type
        # The ID of the table that is limited by the rule in Data Map.
        self.table_guid = table_guid
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataQualityRulesResponseBodyPagingInfoDataQualityRules(TeaModel):
    def __init__(
        self,
        checking_config: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig = None,
        severity: str = None,
        target: ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Indicates whether the rule is enabled.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        self.id = id
        # The rule name.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The settings for sampling.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The monitored object of the rule.
        self.target = target
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Target') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRulesTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class ListDataQualityRulesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_quality_rules: List[ListDataQualityRulesResponseBodyPagingInfoDataQualityRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The rules.
        self.data_quality_rules = data_quality_rules
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_quality_rules:
            for k in self.data_quality_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityRules'] = []
        if self.data_quality_rules is not None:
            for k in self.data_quality_rules:
                result['DataQualityRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_rules = []
        if m.get('DataQualityRules') is not None:
            for k in m.get('DataQualityRules'):
                temp_model = ListDataQualityRulesResponseBodyPagingInfoDataQualityRules()
                self.data_quality_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataQualityRulesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataQualityRulesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataQualityRulesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataQualityRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataQualityRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataQualityRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourceSharedRulesRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        target_project_id: int = None,
    ):
        # The data source ID.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # The ID of the workspace to which the data source is shared. You cannot share the data source to the workspace with which the data source is associated.
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class ListDataSourceSharedRulesResponseBodyDataSourceSharedRules(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        data_source_id: int = None,
        env_type: str = None,
        id: int = None,
        shared_data_source_name: str = None,
        shared_user: str = None,
        source_project_id: int = None,
        target_project_id: int = None,
    ):
        # The time when the rule was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who creates the rule.
        self.create_user = create_user
        # The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
        self.data_source_id = data_source_id
        # The environment to which the target data source belongs. The values are as follows:
        # - Dev: the development environment.
        # - Prod: the production environment.
        self.env_type = env_type
        # The rule ID.
        self.id = id
        # The name of the data source in the destination workspace.
        self.shared_data_source_name = shared_data_source_name
        # The user in the workspace to which the data source is shared. If the data source is shared to the entire workspace, this parameter is left empty.
        self.shared_user = shared_user
        # The ID of the workspace with which the data source is associated.
        self.source_project_id = source_project_id
        # The ID of the workspace to which the data source is shared.
        self.target_project_id = target_project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.shared_data_source_name is not None:
            result['SharedDataSourceName'] = self.shared_data_source_name
        if self.shared_user is not None:
            result['SharedUser'] = self.shared_user
        if self.source_project_id is not None:
            result['SourceProjectId'] = self.source_project_id
        if self.target_project_id is not None:
            result['TargetProjectId'] = self.target_project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('SharedDataSourceName') is not None:
            self.shared_data_source_name = m.get('SharedDataSourceName')
        if m.get('SharedUser') is not None:
            self.shared_user = m.get('SharedUser')
        if m.get('SourceProjectId') is not None:
            self.source_project_id = m.get('SourceProjectId')
        if m.get('TargetProjectId') is not None:
            self.target_project_id = m.get('TargetProjectId')
        return self


class ListDataSourceSharedRulesResponseBody(TeaModel):
    def __init__(
        self,
        data_source_shared_rules: List[ListDataSourceSharedRulesResponseBodyDataSourceSharedRules] = None,
        request_id: str = None,
    ):
        # The sharing rules of the data source.
        self.data_source_shared_rules = data_source_shared_rules
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data_source_shared_rules:
            for k in self.data_source_shared_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSourceSharedRules'] = []
        if self.data_source_shared_rules is not None:
            for k in self.data_source_shared_rules:
                result['DataSourceSharedRules'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source_shared_rules = []
        if m.get('DataSourceSharedRules') is not None:
            for k in m.get('DataSourceSharedRules'):
                temp_model = ListDataSourceSharedRulesResponseBodyDataSourceSharedRules()
                self.data_source_shared_rules.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataSourceSharedRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataSourceSharedRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourceSharedRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourcesRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        tags: str = None,
        types: List[str] = None,
    ):
        # The environment in which the data sources are used. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The name of the data source. Fuzzy match by data source name is supported.
        self.name = name
        # The order in which you want to sort the data sources. Valid values:
        # 
        # *   Desc: descending order
        # *   Asc: ascending order
        # 
        # Default value: Desc
        self.order = order
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The field that you want to use to sort the data sources. Valid values:
        # 
        # *   CreateTime
        # *   Id
        # *   Name
        # 
        # Default value: CreateTime
        self.sort_by = sort_by
        # The tag of the data source. This parameter specifies a filter condition.
        # 
        # *   You can specify multiple tags, which are in the logical AND relation. For example, you can query the data sources that contain the following tags: `["tag1", "tag2", "tag3"]`.
        # *   If you do not configure this parameter, tag-based filtering is not performed. You can specify up to 10 tags.
        self.tags = tags
        # The data source types. This parameter specifies a filter condition. You can specify multiple data source types.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListDataSourcesShrinkRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        tags: str = None,
        types_shrink: str = None,
    ):
        # The environment in which the data sources are used. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The name of the data source. Fuzzy match by data source name is supported.
        self.name = name
        # The order in which you want to sort the data sources. Valid values:
        # 
        # *   Desc: descending order
        # *   Asc: ascending order
        # 
        # Default value: Desc
        self.order = order
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The field that you want to use to sort the data sources. Valid values:
        # 
        # *   CreateTime
        # *   Id
        # *   Name
        # 
        # Default value: CreateTime
        self.sort_by = sort_by
        # The tag of the data source. This parameter specifies a filter condition.
        # 
        # *   You can specify multiple tags, which are in the logical AND relation. For example, you can query the data sources that contain the following tags: `["tag1", "tag2", "tag3"]`.
        # *   If you do not configure this parameter, tag-based filtering is not performed. You can specify up to 10 tags.
        self.tags = tags
        # The data source types. This parameter specifies a filter condition. You can specify multiple data source types.
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource(TeaModel):
    def __init__(
        self,
        connection_properties: Any = None,
        connection_properties_mode: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        qualified_name: str = None,
    ):
        # The connection configurations of the data source, including the connection address, access identity, and environment information. The envType parameter specifies the environment in which the data source is used. Valid values of the envType parameter:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        # 
        # The parameters that you need to configure for the data source vary based on the mode in which the data source is added. For more information, see [Data source connection information (ConnectionProperties)](https://help.aliyun.com/document_detail/2852465.html).
        self.connection_properties = connection_properties
        # The mode in which the data source is added. The mode varies based on the data source type. Valid values:
        # 
        # *   InstanceMode: instance mode
        # *   UrlMode: connection string mode
        self.connection_properties_mode = connection_properties_mode
        # The time when the data source was added. This value is a UNIX timestamp.
        self.create_time = create_time
        # The ID of the user who adds the data source.
        self.create_user = create_user
        # The description of the data source.
        self.description = description
        # The ID of the data source.
        self.id = id
        # The time when the data source was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The ID of the user who modifies the data source.
        self.modify_user = modify_user
        # The unique business key of the data source. For example, the unique business key of a Hologres data source is in the `${tenantOwnerId}:${regionId}:${type}:${instanceId}:${database}` format.
        self.qualified_name = qualified_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.qualified_name is not None:
            result['QualifiedName'] = self.qualified_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('QualifiedName') is not None:
            self.qualified_name = m.get('QualifiedName')
        return self


class ListDataSourcesResponseBodyPagingInfoDataSources(TeaModel):
    def __init__(
        self,
        data_source: List[ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource] = None,
        name: str = None,
        type: str = None,
    ):
        # The data sources. Each element is the information of a single data source with a unique data source ID.
        self.data_source = data_source
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        if self.data_source:
            for k in self.data_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSource'] = []
        if self.data_source is not None:
            for k in self.data_source:
                result['DataSource'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source = []
        if m.get('DataSource') is not None:
            for k in m.get('DataSource'):
                temp_model = ListDataSourcesResponseBodyPagingInfoDataSourcesDataSource()
                self.data_source.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDataSourcesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        data_sources: List[ListDataSourcesResponseBodyPagingInfoDataSources] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The data source groups. Each element in the array indicates a data source group. Each data source group contains data sources in the development environment (if any) and the production environment.
        self.data_sources = data_sources
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.data_sources:
            for k in self.data_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSources'] = []
        if self.data_sources is not None:
            for k in self.data_sources:
                result['DataSources'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_sources = []
        if m.get('DataSources') is not None:
            for k in m.get('DataSources'):
                temp_model = ListDataSourcesResponseBodyPagingInfoDataSources()
                self.data_sources.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataSourcesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDataSourcesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDataSourcesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDataSourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataSourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabasesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListDatabasesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        databases: List[Database] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.databases = databases
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = Database()
                self.databases.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDatabasesResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDatabasesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDeploymentPackageFilesRequest(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        change_type: int = None,
        commit_from: str = None,
        commit_to: str = None,
        commit_user_id: str = None,
        file_ids: List[str] = None,
        file_name: str = None,
        file_type: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        solution_id: int = None,
    ):
        # The workflow ID. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the workflow ID by name.
        self.business_id = business_id
        # The change type. Valid values:
        # 
        # *   0: addition
        # *   1: update
        # *   2: deletion
        self.change_type = change_type
        # The start date for committing. Specify the date in the yyyy-MM-dd format.
        self.commit_from = commit_from
        # The end date (included) for committing. Specify the date in the yyyy-MM-dd format.
        self.commit_to = commit_to
        # The ID of the user who commits the file.
        self.commit_user_id = commit_user_id
        # The IDs of the files to be queried.
        self.file_ids = file_ids
        # The name of the file.
        self.file_name = file_name
        # The type of the code for the file.
        # 
        # The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html). You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
        self.file_type = file_type
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The solution ID.
        self.solution_id = solution_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.commit_from is not None:
            result['CommitFrom'] = self.commit_from
        if self.commit_to is not None:
            result['CommitTo'] = self.commit_to
        if self.commit_user_id is not None:
            result['CommitUserId'] = self.commit_user_id
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.solution_id is not None:
            result['SolutionId'] = self.solution_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('CommitFrom') is not None:
            self.commit_from = m.get('CommitFrom')
        if m.get('CommitTo') is not None:
            self.commit_to = m.get('CommitTo')
        if m.get('CommitUserId') is not None:
            self.commit_user_id = m.get('CommitUserId')
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SolutionId') is not None:
            self.solution_id = m.get('SolutionId')
        return self


class ListDeploymentPackageFilesShrinkRequest(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        change_type: int = None,
        commit_from: str = None,
        commit_to: str = None,
        commit_user_id: str = None,
        file_ids_shrink: str = None,
        file_name: str = None,
        file_type: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        solution_id: int = None,
    ):
        # The workflow ID. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the workflow ID by name.
        self.business_id = business_id
        # The change type. Valid values:
        # 
        # *   0: addition
        # *   1: update
        # *   2: deletion
        self.change_type = change_type
        # The start date for committing. Specify the date in the yyyy-MM-dd format.
        self.commit_from = commit_from
        # The end date (included) for committing. Specify the date in the yyyy-MM-dd format.
        self.commit_to = commit_to
        # The ID of the user who commits the file.
        self.commit_user_id = commit_user_id
        # The IDs of the files to be queried.
        self.file_ids_shrink = file_ids_shrink
        # The name of the file.
        self.file_name = file_name
        # The type of the code for the file.
        # 
        # The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html). You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
        self.file_type = file_type
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The solution ID.
        self.solution_id = solution_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.commit_from is not None:
            result['CommitFrom'] = self.commit_from
        if self.commit_to is not None:
            result['CommitTo'] = self.commit_to
        if self.commit_user_id is not None:
            result['CommitUserId'] = self.commit_user_id
        if self.file_ids_shrink is not None:
            result['FileIds'] = self.file_ids_shrink
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.solution_id is not None:
            result['SolutionId'] = self.solution_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('CommitFrom') is not None:
            self.commit_from = m.get('CommitFrom')
        if m.get('CommitTo') is not None:
            self.commit_to = m.get('CommitTo')
        if m.get('CommitUserId') is not None:
            self.commit_user_id = m.get('CommitUserId')
        if m.get('FileIds') is not None:
            self.file_ids_shrink = m.get('FileIds')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SolutionId') is not None:
            self.solution_id = m.get('SolutionId')
        return self


class ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles(TeaModel):
    def __init__(
        self,
        change_type: int = None,
        comment: str = None,
        commit_time: str = None,
        commit_user: str = None,
        commit_user_name: str = None,
        file_id: int = None,
        file_name: str = None,
        file_type: int = None,
        file_version: int = None,
        id: int = None,
        is_same_as_production_version: bool = None,
        node_configuration: str = None,
        node_id: int = None,
        project_id: int = None,
        smoke_test_status: str = None,
        status: int = None,
        tenant_id: int = None,
        use_type: str = None,
    ):
        # The change type, which is an integer. Valid values:
        # 
        # *   0: addition
        # *   1: update
        # *   2: deletion
        self.change_type = change_type
        # The comment for committing.
        self.comment = comment
        # The time for committing.
        self.commit_time = commit_time
        # The ID of the Alibaba Cloud account used by the user who committed the file.
        self.commit_user = commit_user
        # The name of the Alibaba Cloud account used by the user who committed the file.
        self.commit_user_name = commit_user_name
        # The file ID.
        self.file_id = file_id
        # The name of the file of the current version.
        self.file_name = file_name
        # The file type. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
        self.file_type = file_type
        # The file version.
        self.file_version = file_version
        # The unique ID.
        self.id = id
        # Indicates whether the version is a version in the production environment of the scheduling system.
        self.is_same_as_production_version = is_same_as_production_version
        # The scheduling property configurations of the node that corresponds to the file, which is a JSON string.
        self.node_configuration = node_configuration
        # The ID of the auto triggered node that corresponds to the file.
        self.node_id = node_id
        # The workspace ID.
        self.project_id = project_id
        # The test status in the development environment.
        self.smoke_test_status = smoke_test_status
        # The status of the code for the file of the current version. Valid values:
        # 
        # *   10: committing
        # *   11: committed to the development environment of the scheduling system
        # *   20: review passed
        # *   21: review failed
        # *   80: deployment package creation succeeded
        # *   100: deploying
        # *   101: deployed to the production environment
        # *   200: cancelled
        self.status = status
        # The DataWorks tenant ID.
        self.tenant_id = tenant_id
        # The module to which the file belongs. Valid values:
        # 
        # *   NORMAL: The file is used for DataStudio.
        # *   MANUAL: The file is used for a manually triggered node.
        # *   MANUAL_BIZ: The file is used for a manually triggered workflow.
        # *   SKIP: The file is used for a dry-run node in DataStudio.
        # *   ADHOCQUERY: The file is used for an ad hoc query.
        # *   COMPONENT: The file is used for a script template.
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.commit_time is not None:
            result['CommitTime'] = self.commit_time
        if self.commit_user is not None:
            result['CommitUser'] = self.commit_user
        if self.commit_user_name is not None:
            result['CommitUserName'] = self.commit_user_name
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_version is not None:
            result['FileVersion'] = self.file_version
        if self.id is not None:
            result['Id'] = self.id
        if self.is_same_as_production_version is not None:
            result['IsSameAsProductionVersion'] = self.is_same_as_production_version
        if self.node_configuration is not None:
            result['NodeConfiguration'] = self.node_configuration
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.smoke_test_status is not None:
            result['SmokeTestStatus'] = self.smoke_test_status
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CommitTime') is not None:
            self.commit_time = m.get('CommitTime')
        if m.get('CommitUser') is not None:
            self.commit_user = m.get('CommitUser')
        if m.get('CommitUserName') is not None:
            self.commit_user_name = m.get('CommitUserName')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileVersion') is not None:
            self.file_version = m.get('FileVersion')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsSameAsProductionVersion') is not None:
            self.is_same_as_production_version = m.get('IsSameAsProductionVersion')
        if m.get('NodeConfiguration') is not None:
            self.node_configuration = m.get('NodeConfiguration')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SmokeTestStatus') is not None:
            self.smoke_test_status = m.get('SmokeTestStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class ListDeploymentPackageFilesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        deployment_package_files: List[ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The details of the versions of the files to be deployed.
        self.deployment_package_files = deployment_package_files
        # The page number. Pages start from page 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.deployment_package_files:
            for k in self.deployment_package_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeploymentPackageFiles'] = []
        if self.deployment_package_files is not None:
            for k in self.deployment_package_files:
                result['DeploymentPackageFiles'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployment_package_files = []
        if m.get('DeploymentPackageFiles') is not None:
            for k in m.get('DeploymentPackageFiles'):
                temp_model = ListDeploymentPackageFilesResponseBodyPagingInfoDeploymentPackageFiles()
                self.deployment_package_files.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDeploymentPackageFilesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDeploymentPackageFilesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDeploymentPackageFilesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDeploymentPackageFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDeploymentPackageFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDeploymentPackageFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDeploymentPackagesRequest(TeaModel):
    def __init__(
        self,
        creator: str = None,
        end_create_time: int = None,
        end_execute_time: int = None,
        executor: str = None,
        keyword: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        project_identifier: str = None,
        status: int = None,
    ):
        self.creator = creator
        self.end_create_time = end_create_time
        self.end_execute_time = end_execute_time
        self.executor = executor
        self.keyword = keyword
        self.page_number = page_number
        self.page_size = page_size
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.end_create_time is not None:
            result['EndCreateTime'] = self.end_create_time
        if self.end_execute_time is not None:
            result['EndExecuteTime'] = self.end_execute_time
        if self.executor is not None:
            result['Executor'] = self.executor
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('EndCreateTime') is not None:
            self.end_create_time = m.get('EndCreateTime')
        if m.get('EndExecuteTime') is not None:
            self.end_execute_time = m.get('EndExecuteTime')
        if m.get('Executor') is not None:
            self.executor = m.get('Executor')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDeploymentPackagesResponseBodyDataDeployments(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator: str = None,
        error_message: str = None,
        execute_time: int = None,
        executor: str = None,
        id: int = None,
        name: str = None,
        status: int = None,
    ):
        self.create_time = create_time
        self.creator = creator
        self.error_message = error_message
        self.execute_time = execute_time
        self.executor = executor
        self.id = id
        self.name = name
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.executor is not None:
            result['Executor'] = self.executor
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Executor') is not None:
            self.executor = m.get('Executor')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDeploymentPackagesResponseBodyData(TeaModel):
    def __init__(
        self,
        deployments: List[ListDeploymentPackagesResponseBodyDataDeployments] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.deployments = deployments
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.deployments:
            for k in self.deployments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Deployments'] = []
        if self.deployments is not None:
            for k in self.deployments:
                result['Deployments'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.deployments = []
        if m.get('Deployments') is not None:
            for k in m.get('Deployments'):
                temp_model = ListDeploymentPackagesResponseBodyDataDeployments()
                self.deployments.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDeploymentPackagesResponseBody(TeaModel):
    def __init__(
        self,
        data: ListDeploymentPackagesResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListDeploymentPackagesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDeploymentPackagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDeploymentPackagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDeploymentPackagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDownstreamTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource = None,
        description: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime = None,
        runtime_resource: ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment in which the data source is used. Valid values:
        # 
        # *   Dev
        # *   Prod
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the cycle. This parameter indicates the cycle of the task instance on the current day.
        self.period_number = period_number
        # The priority of the task. Minimum value: 1. Maximum value: 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        # *   WaitTrigger: The instance is waiting to be triggered by external scheduling systems.
        self.status = status
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        # 
        # Note: The value of this parameter is rounded up by hour.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   Normal
        # *   Manual
        # *   SmokeTest
        # *   SupplementData
        # *   ManualWorkflow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstanceRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances(TeaModel):
    def __init__(
        self,
        dependency_type: str = None,
        task_instance: ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance = None,
    ):
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal
        # *   CrossCycle
        self.dependency_type = dependency_type
        # The information about a task instance.
        self.task_instance = task_instance

    def validate(self):
        if self.task_instance:
            self.task_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependency_type is not None:
            result['DependencyType'] = self.dependency_type
        if self.task_instance is not None:
            result['TaskInstance'] = self.task_instance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DependencyType') is not None:
            self.dependency_type = m.get('DependencyType')
        if m.get('TaskInstance') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstancesTaskInstance()
            self.task_instance = temp_model.from_map(m['TaskInstance'])
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        step_type: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment in which the data source is used. Valid values:
        # 
        # *   Dev
        # *   Prod
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the cycle. This parameter indicates the cycle of the task instance on the current day.
        self.period_number = period_number
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. This parameter is deprecated and replaced by the EnvType parameter. Valid values:
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode.
        # 
        # Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether it is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether it is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The information about the resource group with which the instance is associated.
        self.runtime_resource = runtime_resource
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        # *   WaitTrigger: The instance is waiting to be triggered by external scheduling systems.
        self.status = status
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.step_type = step_type
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        # 
        # Note: The value of this parameter is rounded up by hour.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The method to trigger instance scheduling.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance.
        # 
        # Valid values:
        # 
        # *   SmokeTest
        # *   SupplementData
        # *   Manual
        # *   ManualWorkflow
        # *   Normal
        # *   ManualFlow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListDownstreamTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        downstream_task_instances: List[ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances] = None,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
    ):
        # The descendant instances.
        self.downstream_task_instances = downstream_task_instances
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The instances. This parameter is deprecated and replaced by the DownstreamTaskInstances parameter.
        self.task_instances = task_instances
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.downstream_task_instances:
            for k in self.downstream_task_instances:
                if k:
                    k.validate()
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DownstreamTaskInstances'] = []
        if self.downstream_task_instances is not None:
            for k in self.downstream_task_instances:
                result['DownstreamTaskInstances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.downstream_task_instances = []
        if m.get('DownstreamTaskInstances') is not None:
            for k in m.get('DownstreamTaskInstances'):
                temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoDownstreamTaskInstances()
                self.downstream_task_instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDownstreamTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDownstreamTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDownstreamTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDownstreamTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDownstreamTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDownstreamTasksRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource = None,
        timeout: int = None,
        trigger: ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8.
        self.priority = priority
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether it is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks(TeaModel):
    def __init__(
        self,
        dependency_type: str = None,
        task: ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask = None,
    ):
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.dependency_type = dependency_type
        # The information about the task.
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependency_type is not None:
            result['DependencyType'] = self.dependency_type
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DependencyType') is not None:
            self.dependency_type = m.get('DependencyType')
        if m.get('Task') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoDownstreamTasksTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression of the task. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDownstreamTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListDownstreamTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        step_type: str = None,
        timeout: int = None,
        trigger: ListDownstreamTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. This parameter is deprecated and replaced by the EnvType parameter.
        # 
        # Valid values:
        # 
        # *   Prod
        # *   Dev
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode.
        # 
        # Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether it is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether it is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.step_type = step_type
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The method to trigger task scheduling.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListDownstreamTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        downstream_tasks: List[ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks] = None,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListDownstreamTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
    ):
        # The descendant tasks.
        self.downstream_tasks = downstream_tasks
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The tasks. This parameter is deprecated and replaced by the DownstreamTasks parameter.
        self.tasks = tasks
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.downstream_tasks:
            for k in self.downstream_tasks:
                if k:
                    k.validate()
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DownstreamTasks'] = []
        if self.downstream_tasks is not None:
            for k in self.downstream_tasks:
                result['DownstreamTasks'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.downstream_tasks = []
        if m.get('DownstreamTasks') is not None:
            for k in m.get('DownstreamTasks'):
                temp_model = ListDownstreamTasksResponseBodyPagingInfoDownstreamTasks()
                self.downstream_tasks.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListDownstreamTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDownstreamTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListDownstreamTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListDownstreamTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDownstreamTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDownstreamTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDownstreamTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEntitiesInMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        entity_description: str = None,
        entity_name: str = None,
        entity_type: str = None,
        id: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        sort_by: str = None,
    ):
        self.entity_description = entity_description
        self.entity_name = entity_name
        self.entity_type = entity_type
        # This parameter is required.
        self.id = id
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_description is not None:
            result['EntityDescription'] = self.entity_description
        if self.entity_name is not None:
            result['EntityName'] = self.entity_name
        if self.entity_type is not None:
            result['EntityType'] = self.entity_type
        if self.id is not None:
            result['Id'] = self.id
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityDescription') is not None:
            self.entity_description = m.get('EntityDescription')
        if m.get('EntityName') is not None:
            self.entity_name = m.get('EntityName')
        if m.get('EntityType') is not None:
            self.entity_type = m.get('EntityType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: int = None,
        description: str = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        type: str = None,
    ):
        self.comment = comment
        self.create_time = create_time
        self.description = description
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEntitiesInMetaCollectionResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        entities: List[ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.entities = entities
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.entities:
            for k in self.entities:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Entities'] = []
        if self.entities is not None:
            for k in self.entities:
                result['Entities'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.entities = []
        if m.get('Entities') is not None:
            for k in m.get('Entities'):
                temp_model = ListEntitiesInMetaCollectionResponseBodyPagingInfoEntities()
                self.entities.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListEntitiesInMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListEntitiesInMetaCollectionResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListEntitiesInMetaCollectionResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEntitiesInMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEntitiesInMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEntitiesInMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFileVersionsRequest(TeaModel):
    def __init__(
        self,
        file_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.file_id = file_id
        self.page_number = page_number
        self.page_size = page_size
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class ListFileVersionsResponseBodyDataFileVersions(TeaModel):
    def __init__(
        self,
        change_type: str = None,
        comment: str = None,
        commit_time: int = None,
        commit_user: str = None,
        file_content: str = None,
        file_name: str = None,
        file_property_content: str = None,
        file_version: int = None,
        is_current_prod: bool = None,
        node_content: str = None,
        node_id: int = None,
        status: str = None,
        use_type: str = None,
    ):
        self.change_type = change_type
        self.comment = comment
        self.commit_time = commit_time
        self.commit_user = commit_user
        self.file_content = file_content
        self.file_name = file_name
        self.file_property_content = file_property_content
        self.file_version = file_version
        self.is_current_prod = is_current_prod
        self.node_content = node_content
        self.node_id = node_id
        self.status = status
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_type is not None:
            result['ChangeType'] = self.change_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.commit_time is not None:
            result['CommitTime'] = self.commit_time
        if self.commit_user is not None:
            result['CommitUser'] = self.commit_user
        if self.file_content is not None:
            result['FileContent'] = self.file_content
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_property_content is not None:
            result['FilePropertyContent'] = self.file_property_content
        if self.file_version is not None:
            result['FileVersion'] = self.file_version
        if self.is_current_prod is not None:
            result['IsCurrentProd'] = self.is_current_prod
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.status is not None:
            result['Status'] = self.status
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeType') is not None:
            self.change_type = m.get('ChangeType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CommitTime') is not None:
            self.commit_time = m.get('CommitTime')
        if m.get('CommitUser') is not None:
            self.commit_user = m.get('CommitUser')
        if m.get('FileContent') is not None:
            self.file_content = m.get('FileContent')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FilePropertyContent') is not None:
            self.file_property_content = m.get('FilePropertyContent')
        if m.get('FileVersion') is not None:
            self.file_version = m.get('FileVersion')
        if m.get('IsCurrentProd') is not None:
            self.is_current_prod = m.get('IsCurrentProd')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class ListFileVersionsResponseBodyData(TeaModel):
    def __init__(
        self,
        file_versions: List[ListFileVersionsResponseBodyDataFileVersions] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.file_versions = file_versions
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.file_versions:
            for k in self.file_versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileVersions'] = []
        if self.file_versions is not None:
            for k in self.file_versions:
                result['FileVersions'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_versions = []
        if m.get('FileVersions') is not None:
            for k in m.get('FileVersions'):
                temp_model = ListFileVersionsResponseBodyDataFileVersions()
                self.file_versions.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFileVersionsResponseBody(TeaModel):
    def __init__(
        self,
        data: ListFileVersionsResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListFileVersionsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListFileVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFileVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFileVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFilesRequest(TeaModel):
    def __init__(
        self,
        commit_status: int = None,
        exact_file_name: str = None,
        file_folder_path: str = None,
        file_id_in: str = None,
        file_types: str = None,
        keyword: str = None,
        last_edit_user: str = None,
        need_absolute_folder_path: bool = None,
        need_content: bool = None,
        node_id: int = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        project_identifier: str = None,
        use_type: str = None,
    ):
        self.commit_status = commit_status
        self.exact_file_name = exact_file_name
        self.file_folder_path = file_folder_path
        self.file_id_in = file_id_in
        self.file_types = file_types
        self.keyword = keyword
        self.last_edit_user = last_edit_user
        self.need_absolute_folder_path = need_absolute_folder_path
        self.need_content = need_content
        self.node_id = node_id
        self.owner = owner
        self.page_number = page_number
        self.page_size = page_size
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_status is not None:
            result['CommitStatus'] = self.commit_status
        if self.exact_file_name is not None:
            result['ExactFileName'] = self.exact_file_name
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_id_in is not None:
            result['FileIdIn'] = self.file_id_in
        if self.file_types is not None:
            result['FileTypes'] = self.file_types
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.last_edit_user is not None:
            result['LastEditUser'] = self.last_edit_user
        if self.need_absolute_folder_path is not None:
            result['NeedAbsoluteFolderPath'] = self.need_absolute_folder_path
        if self.need_content is not None:
            result['NeedContent'] = self.need_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommitStatus') is not None:
            self.commit_status = m.get('CommitStatus')
        if m.get('ExactFileName') is not None:
            self.exact_file_name = m.get('ExactFileName')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileIdIn') is not None:
            self.file_id_in = m.get('FileIdIn')
        if m.get('FileTypes') is not None:
            self.file_types = m.get('FileTypes')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('LastEditUser') is not None:
            self.last_edit_user = m.get('LastEditUser')
        if m.get('NeedAbsoluteFolderPath') is not None:
            self.need_absolute_folder_path = m.get('NeedAbsoluteFolderPath')
        if m.get('NeedContent') is not None:
            self.need_content = m.get('NeedContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class ListFilesResponseBodyDataFiles(TeaModel):
    def __init__(
        self,
        absolute_folder_path: str = None,
        auto_parsing: bool = None,
        biz_id: int = None,
        business_id: int = None,
        commit_status: int = None,
        connection_name: str = None,
        content: str = None,
        create_time: int = None,
        create_user: str = None,
        current_version: int = None,
        file_description: str = None,
        file_folder_id: str = None,
        file_id: int = None,
        file_name: str = None,
        file_type: int = None,
        is_max_compute: bool = None,
        last_edit_time: int = None,
        last_edit_user: str = None,
        node_id: int = None,
        owner: str = None,
        parent_id: int = None,
        use_type: str = None,
    ):
        self.absolute_folder_path = absolute_folder_path
        self.auto_parsing = auto_parsing
        self.biz_id = biz_id
        self.business_id = business_id
        self.commit_status = commit_status
        self.connection_name = connection_name
        self.content = content
        self.create_time = create_time
        self.create_user = create_user
        self.current_version = current_version
        self.file_description = file_description
        self.file_folder_id = file_folder_id
        self.file_id = file_id
        self.file_name = file_name
        self.file_type = file_type
        self.is_max_compute = is_max_compute
        self.last_edit_time = last_edit_time
        self.last_edit_user = last_edit_user
        self.node_id = node_id
        self.owner = owner
        self.parent_id = parent_id
        self.use_type = use_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.absolute_folder_path is not None:
            result['AbsoluteFolderPath'] = self.absolute_folder_path
        if self.auto_parsing is not None:
            result['AutoParsing'] = self.auto_parsing
        if self.biz_id is not None:
            result['BizId'] = self.biz_id
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.commit_status is not None:
            result['CommitStatus'] = self.commit_status
        if self.connection_name is not None:
            result['ConnectionName'] = self.connection_name
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.current_version is not None:
            result['CurrentVersion'] = self.current_version
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_id is not None:
            result['FileFolderId'] = self.file_folder_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.is_max_compute is not None:
            result['IsMaxCompute'] = self.is_max_compute
        if self.last_edit_time is not None:
            result['LastEditTime'] = self.last_edit_time
        if self.last_edit_user is not None:
            result['LastEditUser'] = self.last_edit_user
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.use_type is not None:
            result['UseType'] = self.use_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbsoluteFolderPath') is not None:
            self.absolute_folder_path = m.get('AbsoluteFolderPath')
        if m.get('AutoParsing') is not None:
            self.auto_parsing = m.get('AutoParsing')
        if m.get('BizId') is not None:
            self.biz_id = m.get('BizId')
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('CommitStatus') is not None:
            self.commit_status = m.get('CommitStatus')
        if m.get('ConnectionName') is not None:
            self.connection_name = m.get('ConnectionName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('CurrentVersion') is not None:
            self.current_version = m.get('CurrentVersion')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderId') is not None:
            self.file_folder_id = m.get('FileFolderId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IsMaxCompute') is not None:
            self.is_max_compute = m.get('IsMaxCompute')
        if m.get('LastEditTime') is not None:
            self.last_edit_time = m.get('LastEditTime')
        if m.get('LastEditUser') is not None:
            self.last_edit_user = m.get('LastEditUser')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('UseType') is not None:
            self.use_type = m.get('UseType')
        return self


class ListFilesResponseBodyData(TeaModel):
    def __init__(
        self,
        files: List[ListFilesResponseBodyDataFiles] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.files = files
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.files:
            for k in self.files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Files'] = []
        if self.files is not None:
            for k in self.files:
                result['Files'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.files = []
        if m.get('Files') is not None:
            for k in m.get('Files'):
                temp_model = ListFilesResponseBodyDataFiles()
                self.files.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFilesResponseBody(TeaModel):
    def __init__(
        self,
        data: ListFilesResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListFilesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFoldersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        parent_folder_path: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        # This parameter is required.
        self.parent_folder_path = parent_folder_path
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_folder_path is not None:
            result['ParentFolderPath'] = self.parent_folder_path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentFolderPath') is not None:
            self.parent_folder_path = m.get('ParentFolderPath')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class ListFoldersResponseBodyDataFolders(TeaModel):
    def __init__(
        self,
        folder_id: str = None,
        folder_path: str = None,
    ):
        self.folder_id = folder_id
        self.folder_path = folder_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.folder_path is not None:
            result['FolderPath'] = self.folder_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('FolderPath') is not None:
            self.folder_path = m.get('FolderPath')
        return self


class ListFoldersResponseBodyData(TeaModel):
    def __init__(
        self,
        folders: List[ListFoldersResponseBodyDataFolders] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.folders = folders
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.folders:
            for k in self.folders:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Folders'] = []
        if self.folders is not None:
            for k in self.folders:
                result['Folders'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.folders = []
        if m.get('Folders') is not None:
            for k in m.get('Folders'):
                temp_model = ListFoldersResponseBodyDataFolders()
                self.folders.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFoldersResponseBody(TeaModel):
    def __init__(
        self,
        data: ListFoldersResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListFoldersResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListFoldersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFoldersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFoldersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFunctionsRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        # The ID of the owner of the UDF. This parameter specifies a filter condition.
        self.owner = owner
        # The page number. Default value: 1. Minimum value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The user-defined function (UDF) type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   Math: mathematical operation function
        # *   Aggregate: aggregate function
        # *   String: string processing function
        # *   Date: date function
        # *   Analytic: window function
        # *   Other: other functions
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # The ID of the resource group used when you run the UDF.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListFunctionsResponseBodyPagingInfoFunctionsScript(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        runtime: ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListFunctionsResponseBodyPagingInfoFunctions(TeaModel):
    def __init__(
        self,
        arm_resource: str = None,
        class_name: str = None,
        command_description: str = None,
        create_time: int = None,
        data_source: ListFunctionsResponseBodyPagingInfoFunctionsDataSource = None,
        database_name: str = None,
        description: str = None,
        embedded_code: str = None,
        embedded_code_type: str = None,
        embedded_resource_type: str = None,
        example_description: str = None,
        file_resource: str = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        parameter_description: str = None,
        project_id: int = None,
        return_value_description: str = None,
        runtime_resource: ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource = None,
        script: ListFunctionsResponseBodyPagingInfoFunctionsScript = None,
        type: str = None,
    ):
        # The file resources in an Advanced RISC Machines (ARM) cluster.
        self.arm_resource = arm_resource
        # The fully qualified class name of the UDF.
        self.class_name = class_name
        # The description of the command.
        self.command_description = command_description
        # The time when the UDF was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The data source information about the UDF.
        self.data_source = data_source
        # The name of the database. This parameter is returned for E-MapReduce (EMR) functions.
        self.database_name = database_name
        # The overall description of the UDF.
        self.description = description
        # The code of the embedded UDF.
        self.embedded_code = embedded_code
        # The type of the nested code.
        # 
        # Valid values:
        # 
        # *   Python2
        # *   Python3
        # *   Java8
        # *   Java11
        # *   Java17
        self.embedded_code_type = embedded_code_type
        # The type of the nested resource.
        # 
        # Valid values:
        # 
        # *   File: general resources
        # *   Embedded: embedded resources
        self.embedded_resource_type = embedded_resource_type
        # The description of the example.
        self.example_description = example_description
        # The files resources.
        self.file_resource = file_resource
        # The ID of the UDF.
        self.id = id
        # The time when the UDF was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the UDF.
        self.name = name
        # The owner of the UDF.
        self.owner = owner
        # The description of the parameter.
        self.parameter_description = parameter_description
        # The ID of the workspace to which the UDF belongs.
        self.project_id = project_id
        # The description of the return value.
        self.return_value_description = return_value_description
        # The information about the resource group used when you run the UDF.
        self.runtime_resource = runtime_resource
        # The script information about the UDF.
        self.script = script
        # The UDF type.
        # 
        # Valid values:
        # 
        # *   Math: mathematical operation function
        # *   Aggregate: aggregate function
        # *   String: string processing function
        # *   Date: date function
        # *   Analytic: window function
        # *   Other: other functions
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arm_resource is not None:
            result['ArmResource'] = self.arm_resource
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.command_description is not None:
            result['CommandDescription'] = self.command_description
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.description is not None:
            result['Description'] = self.description
        if self.embedded_code is not None:
            result['EmbeddedCode'] = self.embedded_code
        if self.embedded_code_type is not None:
            result['EmbeddedCodeType'] = self.embedded_code_type
        if self.embedded_resource_type is not None:
            result['EmbeddedResourceType'] = self.embedded_resource_type
        if self.example_description is not None:
            result['ExampleDescription'] = self.example_description
        if self.file_resource is not None:
            result['FileResource'] = self.file_resource
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameter_description is not None:
            result['ParameterDescription'] = self.parameter_description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.return_value_description is not None:
            result['ReturnValueDescription'] = self.return_value_description
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmResource') is not None:
            self.arm_resource = m.get('ArmResource')
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CommandDescription') is not None:
            self.command_description = m.get('CommandDescription')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EmbeddedCode') is not None:
            self.embedded_code = m.get('EmbeddedCode')
        if m.get('EmbeddedCodeType') is not None:
            self.embedded_code_type = m.get('EmbeddedCodeType')
        if m.get('EmbeddedResourceType') is not None:
            self.embedded_resource_type = m.get('EmbeddedResourceType')
        if m.get('ExampleDescription') is not None:
            self.example_description = m.get('ExampleDescription')
        if m.get('FileResource') is not None:
            self.file_resource = m.get('FileResource')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParameterDescription') is not None:
            self.parameter_description = m.get('ParameterDescription')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ReturnValueDescription') is not None:
            self.return_value_description = m.get('ReturnValueDescription')
        if m.get('RuntimeResource') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfoFunctionsScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListFunctionsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        functions: List[ListFunctionsResponseBodyPagingInfoFunctions] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The UDFs.
        self.functions = functions
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.functions:
            for k in self.functions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Functions'] = []
        if self.functions is not None:
            for k in self.functions:
                result['Functions'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.functions = []
        if m.get('Functions') is not None:
            for k in m.get('Functions'):
                temp_model = ListFunctionsResponseBodyPagingInfoFunctions()
                self.functions.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFunctionsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListFunctionsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListFunctionsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFunctionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFunctionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFunctionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLineageRelationshipsRequest(TeaModel):
    def __init__(
        self,
        dst_entity_id: str = None,
        dst_entity_name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        sort_by: str = None,
        src_entity_id: str = None,
        src_entity_name: str = None,
    ):
        # This parameter is required.
        self.dst_entity_id = dst_entity_id
        self.dst_entity_name = dst_entity_name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.sort_by = sort_by
        # This parameter is required.
        self.src_entity_id = src_entity_id
        self.src_entity_name = src_entity_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_entity_id is not None:
            result['DstEntityId'] = self.dst_entity_id
        if self.dst_entity_name is not None:
            result['DstEntityName'] = self.dst_entity_name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.src_entity_id is not None:
            result['SrcEntityId'] = self.src_entity_id
        if self.src_entity_name is not None:
            result['SrcEntityName'] = self.src_entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstEntityId') is not None:
            self.dst_entity_id = m.get('DstEntityId')
        if m.get('DstEntityName') is not None:
            self.dst_entity_name = m.get('DstEntityName')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SrcEntityId') is not None:
            self.src_entity_id = m.get('SrcEntityId')
        if m.get('SrcEntityName') is not None:
            self.src_entity_name = m.get('SrcEntityName')
        return self


class ListLineageRelationshipsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        lineage_relationships: List[LineageRelationship] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.lineage_relationships = lineage_relationships
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.lineage_relationships:
            for k in self.lineage_relationships:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LineageRelationships'] = []
        if self.lineage_relationships is not None:
            for k in self.lineage_relationships:
                result['LineageRelationships'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.lineage_relationships = []
        if m.get('LineageRelationships') is not None:
            for k in m.get('LineageRelationships'):
                temp_model = LineageRelationship()
                self.lineage_relationships.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLineageRelationshipsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListLineageRelationshipsResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListLineageRelationshipsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLineageRelationshipsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLineageRelationshipsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLineageRelationshipsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLineagesRequest(TeaModel):
    def __init__(
        self,
        dst_entity_id: str = None,
        dst_entity_name: str = None,
        need_attach_relationship: bool = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        sort_by: str = None,
        src_entity_id: str = None,
        src_entity_name: str = None,
    ):
        self.dst_entity_id = dst_entity_id
        self.dst_entity_name = dst_entity_name
        self.need_attach_relationship = need_attach_relationship
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.sort_by = sort_by
        self.src_entity_id = src_entity_id
        self.src_entity_name = src_entity_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_entity_id is not None:
            result['DstEntityId'] = self.dst_entity_id
        if self.dst_entity_name is not None:
            result['DstEntityName'] = self.dst_entity_name
        if self.need_attach_relationship is not None:
            result['NeedAttachRelationship'] = self.need_attach_relationship
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.src_entity_id is not None:
            result['SrcEntityId'] = self.src_entity_id
        if self.src_entity_name is not None:
            result['SrcEntityName'] = self.src_entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstEntityId') is not None:
            self.dst_entity_id = m.get('DstEntityId')
        if m.get('DstEntityName') is not None:
            self.dst_entity_name = m.get('DstEntityName')
        if m.get('NeedAttachRelationship') is not None:
            self.need_attach_relationship = m.get('NeedAttachRelationship')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('SrcEntityId') is not None:
            self.src_entity_id = m.get('SrcEntityId')
        if m.get('SrcEntityName') is not None:
            self.src_entity_name = m.get('SrcEntityName')
        return self


class ListLineagesResponseBodyPagingInfoLineages(TeaModel):
    def __init__(
        self,
        dst_entity: LineageEntity = None,
        relationships: List[LineageRelationship] = None,
        src_entity: LineageEntity = None,
    ):
        self.dst_entity = dst_entity
        self.relationships = relationships
        self.src_entity = src_entity

    def validate(self):
        if self.dst_entity:
            self.dst_entity.validate()
        if self.relationships:
            for k in self.relationships:
                if k:
                    k.validate()
        if self.src_entity:
            self.src_entity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_entity is not None:
            result['DstEntity'] = self.dst_entity.to_map()
        result['Relationships'] = []
        if self.relationships is not None:
            for k in self.relationships:
                result['Relationships'].append(k.to_map() if k else None)
        if self.src_entity is not None:
            result['SrcEntity'] = self.src_entity.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstEntity') is not None:
            temp_model = LineageEntity()
            self.dst_entity = temp_model.from_map(m['DstEntity'])
        self.relationships = []
        if m.get('Relationships') is not None:
            for k in m.get('Relationships'):
                temp_model = LineageRelationship()
                self.relationships.append(temp_model.from_map(k))
        if m.get('SrcEntity') is not None:
            temp_model = LineageEntity()
            self.src_entity = temp_model.from_map(m['SrcEntity'])
        return self


class ListLineagesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        lineages: List[ListLineagesResponseBodyPagingInfoLineages] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.lineages = lineages
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.lineages:
            for k in self.lineages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Lineages'] = []
        if self.lineages is not None:
            for k in self.lineages:
                result['Lineages'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.lineages = []
        if m.get('Lineages') is not None:
            for k in m.get('Lineages'):
                temp_model = ListLineagesResponseBodyPagingInfoLineages()
                self.lineages.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLineagesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListLineagesResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListLineagesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLineagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLineagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLineagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMetaCollectionsRequest(TeaModel):
    def __init__(
        self,
        administrator: str = None,
        create_user: str = None,
        description: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_id: str = None,
        sort_by: str = None,
        type: str = None,
    ):
        self.administrator = administrator
        self.create_user = create_user
        self.description = description
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.parent_id = parent_id
        self.sort_by = sort_by
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrator is not None:
            result['Administrator'] = self.administrator
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrator') is not None:
            self.administrator = m.get('Administrator')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMetaCollectionsResponseBodyDataMetaCollections(TeaModel):
    def __init__(
        self,
        administrators: List[str] = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        id: str = None,
        modify_time: int = None,
        name: str = None,
        parent_id: str = None,
        type: str = None,
    ):
        self.administrators = administrators
        self.create_time = create_time
        self.create_user = create_user
        self.description = description
        self.id = id
        self.modify_time = modify_time
        self.name = name
        self.parent_id = parent_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators is not None:
            result['Administrators'] = self.administrators
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators = m.get('Administrators')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMetaCollectionsResponseBodyData(TeaModel):
    def __init__(
        self,
        meta_collections: List[ListMetaCollectionsResponseBodyDataMetaCollections] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        self.meta_collections = meta_collections
        self.page_number = page_number
        self.page_size = page_size
        self.total_count = total_count

    def validate(self):
        if self.meta_collections:
            for k in self.meta_collections:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetaCollections'] = []
        if self.meta_collections is not None:
            for k in self.meta_collections:
                result['MetaCollections'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.meta_collections = []
        if m.get('MetaCollections') is not None:
            for k in m.get('MetaCollections'):
                temp_model = ListMetaCollectionsResponseBodyDataMetaCollections()
                self.meta_collections.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMetaCollectionsResponseBody(TeaModel):
    def __init__(
        self,
        data: ListMetaCollectionsResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListMetaCollectionsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMetaCollectionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMetaCollectionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMetaCollectionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNetworksRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        resource_group_id: str = None,
        sort_by: str = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   Id (Desc/Asc): the network ID
        # *   Status (Desc/Asc): the network status
        # *   CreateUser (Desc/Asc): the user who created the network
        # *   CreateTime (Desc/Asc): the time when the network was created
        # 
        # Default value: CreateTime Asc.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListNetworksResponseBodyPagingInfoNetworkList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        create_user: str = None,
        id: int = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        status: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The time when the network resource was created. The value is a 64-bit timestamp.
        self.create_time = create_time
        # The ID of the user who creates the network resource.
        self.create_user = create_user
        # The network ID.
        self.id = id
        # The ID of the serverless resource group.
        self.resource_group_id = resource_group_id
        # The security group ID.
        self.security_group_id = security_group_id
        # The status of the network resource. Valid values: Pending, Creating, Running, Deleting, and Deleted.
        self.status = status
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id
        # The VSwitch ID.
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class ListNetworksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        network_list: List[ListNetworksResponseBodyPagingInfoNetworkList] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The network resources of the serverless resource group.
        self.network_list = network_list
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.network_list:
            for k in self.network_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkList'] = []
        if self.network_list is not None:
            for k in self.network_list:
                result['NetworkList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.network_list = []
        if m.get('NetworkList') is not None:
            for k in m.get('NetworkList'):
                temp_model = ListNetworksResponseBodyPagingInfoNetworkList()
                self.network_list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNetworksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListNetworksResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListNetworksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListNetworksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNetworksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNetworksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodeDependenciesRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: int = None,
        name: str = None,
        node: ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable. Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable. Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesInputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs] = None,
        tables: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables] = None,
        variables: List[ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node to which the variable belongs.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: int = None,
        name: str = None,
        node: ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable. Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable. Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesOutputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs] = None,
        tables: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables] = None,
        variables: List[ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish node types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesScript(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        runtime: ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesStrategy(TeaModel):
    def __init__(
        self,
        instance_mode: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        timeout: int = None,
    ):
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The rerun interval after a failure. Unit: milliseconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   Allowed
        # *   Denied
        # *   FailureAllowed
        self.rerun_mode = rerun_mode
        # The number of reruns after a failure.
        self.rerun_times = rerun_times
        # The timeout period. Unit: milliseconds.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodesTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        id: int = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression for scheduling.
        self.cron = cron
        # The end time of the validity period of the scheduling. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.end_time = end_time
        # The trigger ID.
        self.id = id
        # The start time of the validity period of the scheduling. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The type of the trigger.
        # 
        # Valid values:
        # 
        # *   Scheduler
        # *   Manual
        # *   Streaming
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodeDependenciesResponseBodyPagingInfoNodes(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListNodeDependenciesResponseBodyPagingInfoNodesDataSource = None,
        description: str = None,
        id: int = None,
        inputs: ListNodeDependenciesResponseBodyPagingInfoNodesInputs = None,
        modify_time: int = None,
        name: str = None,
        outputs: ListNodeDependenciesResponseBodyPagingInfoNodesOutputs = None,
        owner: str = None,
        project_id: int = None,
        recurrence: str = None,
        runtime_resource: ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource = None,
        script: ListNodeDependenciesResponseBodyPagingInfoNodesScript = None,
        strategy: ListNodeDependenciesResponseBodyPagingInfoNodesStrategy = None,
        tags: List[ListNodeDependenciesResponseBodyPagingInfoNodesTags] = None,
        task_id: int = None,
        trigger: ListNodeDependenciesResponseBodyPagingInfoNodesTrigger = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The description of the node.
        self.description = description
        # The ID of the node.
        self.id = id
        # The input of the node.
        self.inputs = inputs
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The output of the node.
        self.outputs = outputs
        # The owner of the node.
        self.owner = owner
        # The ID of the workspace to which the node belongs.
        self.project_id = project_id
        # The scheduling type.
        # 
        # Valid values:
        # 
        # *   Normal: Nodes are scheduled as expected.
        # *   Pause: Nodes are paused, and the running of their descendant nodes is blocked.
        # *   Skip: Nodes are dry run. The system does not actually run the nodes but directly prompts that the nodes are successfully run. The running duration of the nodes is 0 seconds. In addition, the nodes do not occupy resources or block the running of their descendant nodes.
        self.recurrence = recurrence
        # The information about the resource group.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The scheduling policy.
        self.strategy = strategy
        # The tags. This parameter is not in use.
        self.tags = tags
        # The scheduling task ID.
        self.task_id = task_id
        # The trigger.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.strategy:
            self.strategy.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RuntimeResource') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Strategy') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Trigger') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfoNodesTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListNodeDependenciesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        nodes: List[ListNodeDependenciesResponseBodyPagingInfoNodes] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The descendant nodes.
        self.nodes = nodes
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = ListNodeDependenciesResponseBodyPagingInfoNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodeDependenciesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListNodeDependenciesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListNodeDependenciesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListNodeDependenciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodeDependenciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodeDependenciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNodesRequest(TeaModel):
    def __init__(
        self,
        container_id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        recurrence: str = None,
        rerun_mode: str = None,
        scene: str = None,
    ):
        # The container ID. This parameter specifies a filter condition.
        self.container_id = container_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The scheduling type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   Normal: Nodes are scheduled as expected.
        # *   Pause: Nodes are paused, and the running of their descendant nodes is blocked.
        # *   Skip: Nodes are dry run. The system does not actually run the nodes but directly prompts that the nodes are successfully run. The running duration of the nodes is 0 seconds. In addition, the nodes do not occupy resources or block the running of their descendant nodes.
        self.recurrence = recurrence
        # The rerun mode. Valid values:
        # 
        # *   Allowed: The nodes can be rerun regardless of whether they are successfully run or fail to run.
        # *   FailureAllowed: The nodes can be rerun only after they fail to run.
        # *   Denied: The nodes cannot be rerun regardless of whether they are successfully run or fail to run.
        self.rerun_mode = rerun_mode
        # The scene of the node. This parameter determines the location of the node.
        # 
        # Valid values:
        # 
        # *   DataworksProject
        # *   DataworksManualWorkflow
        # *   DataworksManualTask
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class ListNodesResponseBodyPagingInfoNodesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodesResponseBodyPagingInfoNodesInputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: int = None,
        name: str = None,
        node: ListNodesResponseBodyPagingInfoNodesInputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable. Valid values:
        # 
        # *   WorkSpace
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        self.scope = scope
        # The type of the variable. Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesInputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesInputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs] = None,
        tables: List[ListNodesResponseBodyPagingInfoNodesInputsTables] = None,
        variables: List[ListNodesResponseBodyPagingInfoNodesInputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs(TeaModel):
    def __init__(
        self,
        data: str = None,
    ):
        # The node output.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsTables(TeaModel):
    def __init__(
        self,
        guid: str = None,
    ):
        # The table ID.
        self.guid = guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.guid is not None:
            result['Guid'] = self.guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Guid') is not None:
            self.guid = m.get('Guid')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The output of the node.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputsVariables(TeaModel):
    def __init__(
        self,
        artifact_type: str = None,
        id: int = None,
        name: str = None,
        node: ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode = None,
        scope: str = None,
        type: str = None,
        value: str = None,
    ):
        # The artifact type.
        self.artifact_type = artifact_type
        # The variable ID.
        self.id = id
        # The name of the variable.
        self.name = name
        # The node to which the variable belongs.
        self.node = node
        # The scope of the variable. Valid values:
        # 
        # *   NodeParameter
        # *   NodeContext
        # *   Workflow
        # *   Workspace
        self.scope = scope
        # The type of the variable. Valid values:
        # 
        # *   NoKvVariableExpression
        # *   Constant
        # *   PassThrough
        # *   System
        # *   NodeOutput
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        if self.node:
            self.node.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.artifact_type is not None:
            result['ArtifactType'] = self.artifact_type
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.node is not None:
            result['Node'] = self.node.to_map()
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArtifactType') is not None:
            self.artifact_type = m.get('ArtifactType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Node') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesOutputsVariablesNode()
            self.node = temp_model.from_map(m['Node'])
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesOutputs(TeaModel):
    def __init__(
        self,
        node_outputs: List[ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs] = None,
        tables: List[ListNodesResponseBodyPagingInfoNodesOutputsTables] = None,
        variables: List[ListNodesResponseBodyPagingInfoNodesOutputsVariables] = None,
    ):
        # The node outputs.
        self.node_outputs = node_outputs
        # The tables.
        self.tables = tables
        # The variables.
        self.variables = variables

    def validate(self):
        if self.node_outputs:
            for k in self.node_outputs:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeOutputs'] = []
        if self.node_outputs is not None:
            for k in self.node_outputs:
                result['NodeOutputs'].append(k.to_map() if k else None)
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_outputs = []
        if m.get('NodeOutputs') is not None:
            for k in m.get('NodeOutputs'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsNodeOutputs()
                self.node_outputs.append(temp_model.from_map(k))
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsTables()
                self.tables.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = ListNodesResponseBodyPagingInfoNodesOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListNodesResponseBodyPagingInfoNodesRuntimeResource(TeaModel):
    def __init__(
        self,
        resource_group: str = None,
        resource_group_id: str = None,
    ):
        self.resource_group = resource_group
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group is not None:
            result['ResourceGroup'] = self.resource_group
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroup') is not None:
            self.resource_group = m.get('ResourceGroup')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListNodesResponseBodyPagingInfoNodesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish node types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListNodesResponseBodyPagingInfoNodesScript(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        runtime: ListNodesResponseBodyPagingInfoNodesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListNodesResponseBodyPagingInfoNodesStrategy(TeaModel):
    def __init__(
        self,
        instance_mode: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        timeout: int = None,
    ):
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The rerun interval. Unit: milliseconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   Allowed
        # *   Denied
        # *   FailureAllowed
        self.rerun_mode = rerun_mode
        # The number of reruns.
        self.rerun_times = rerun_times
        # The timeout period.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class ListNodesResponseBodyPagingInfoNodesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNodesResponseBodyPagingInfoNodesTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        id: int = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression for scheduling.
        self.cron = cron
        # The end time of the validity period of the trigger.
        self.end_time = end_time
        # The trigger ID.
        self.id = id
        # The start time of the validity period of the trigger.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The type of the trigger.
        # 
        # Valid values:
        # 
        # *   Scheduler
        # *   Manual
        # *   Steaming
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListNodesResponseBodyPagingInfoNodes(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListNodesResponseBodyPagingInfoNodesDataSource = None,
        description: str = None,
        id: int = None,
        inputs: ListNodesResponseBodyPagingInfoNodesInputs = None,
        modify_time: int = None,
        name: str = None,
        outputs: ListNodesResponseBodyPagingInfoNodesOutputs = None,
        owner: str = None,
        project_id: int = None,
        recurrence: str = None,
        runtime_resource: ListNodesResponseBodyPagingInfoNodesRuntimeResource = None,
        script: ListNodesResponseBodyPagingInfoNodesScript = None,
        strategy: ListNodesResponseBodyPagingInfoNodesStrategy = None,
        tags: List[ListNodesResponseBodyPagingInfoNodesTags] = None,
        task_id: int = None,
        trigger: ListNodesResponseBodyPagingInfoNodesTrigger = None,
    ):
        # The time when the node was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The description of the node.
        self.description = description
        # The ID of the node.
        self.id = id
        # The input of the node.
        self.inputs = inputs
        # The time when the node was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the node.
        self.name = name
        # The output of the node.
        self.outputs = outputs
        # The owner of the node.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        self.project_id = project_id
        # The scheduling type.
        # 
        # Valid values:
        # 
        # *   Normal: The node is scheduled as expected.
        # *   Pause: The node is paused, and the running of its descendant nodes is blocked.
        # *   Skip: The node is dry run. The system does not actually run the node but directly prompts that the node is successfully run. The running duration of the node is 0 seconds. In addition, the node does not occupy resources or block the running of its descendant nodes.
        self.recurrence = recurrence
        # The information about the resource group.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The scheduling policy.
        self.strategy = strategy
        # The tags. This parameter is not in use.
        self.tags = tags
        # The scheduling task ID.
        self.task_id = task_id
        # The trigger.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.strategy:
            self.strategy.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.strategy is not None:
            result['Strategy'] = self.strategy.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('RuntimeResource') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Strategy') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesStrategy()
            self.strategy = temp_model.from_map(m['Strategy'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListNodesResponseBodyPagingInfoNodesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Trigger') is not None:
            temp_model = ListNodesResponseBodyPagingInfoNodesTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListNodesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        nodes: List[ListNodesResponseBodyPagingInfoNodes] = None,
        page_number: str = None,
        page_size: str = None,
        total_count: str = None,
    ):
        # The nodes.
        self.nodes = nodes
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = ListNodesResponseBodyPagingInfoNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListNodesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListNodesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListNodesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPartitionsRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        sort_by: str = None,
        table_id: str = None,
    ):
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        self.sort_by = sort_by
        # This parameter is required.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListPartitionsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        partition_list: List[Partition] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.partition_list = partition_list
        self.total_count = total_count

    def validate(self):
        if self.partition_list:
            for k in self.partition_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PartitionList'] = []
        if self.partition_list is not None:
            for k in self.partition_list:
                result['PartitionList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.partition_list = []
        if m.get('PartitionList') is not None:
            for k in m.get('PartitionList'):
                temp_model = Partition()
                self.partition_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPartitionsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListPartitionsResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListPartitionsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListPartitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPartitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPartitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineRunItemsRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        pipeline_run_id: str = None,
        project_id: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.pipeline_run_id = pipeline_run_id
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pipeline_run_id is not None:
            result['PipelineRunId'] = self.pipeline_run_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PipelineRunId') is not None:
            self.pipeline_run_id = m.get('PipelineRunId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        message: str = None,
        modify_time: int = None,
        name: str = None,
        spec: str = None,
        status: str = None,
        type: str = None,
        version: int = None,
    ):
        # 
        self.create_time = create_time
        self.id = id
        # 
        self.message = message
        # 
        self.modify_time = modify_time
        self.name = name
        self.spec = spec
        # 
        self.status = status
        self.type = type
        # Id
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPipelineRunItemsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        pipeline_run_items: List[ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.pipeline_run_items = pipeline_run_items
        self.total_count = total_count

    def validate(self):
        if self.pipeline_run_items:
            for k in self.pipeline_run_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PipelineRunItems'] = []
        if self.pipeline_run_items is not None:
            for k in self.pipeline_run_items:
                result['PipelineRunItems'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.pipeline_run_items = []
        if m.get('PipelineRunItems') is not None:
            for k in m.get('PipelineRunItems'):
                temp_model = ListPipelineRunItemsResponseBodyPagingInfoPipelineRunItems()
                self.pipeline_run_items.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPipelineRunItemsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListPipelineRunItemsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListPipelineRunItemsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPipelineRunItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineRunItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineRunItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineRunsRequest(TeaModel):
    def __init__(
        self,
        creator: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        status: str = None,
    ):
        # The ID of the user who creates the processes. This parameter specifies a filter condition.
        self.creator = creator
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The status of the processes. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   Init
        # *   Running
        # *   Success
        # *   Fail
        # *   Termination
        # *   Cancel
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages(TeaModel):
    def __init__(
        self,
        code: str = None,
        description: str = None,
        detail: Dict[str, Any] = None,
        message: str = None,
        name: str = None,
        status: str = None,
        step: int = None,
        type: str = None,
    ):
        # The code of the stage.
        self.code = code
        # The description of the stage.
        self.description = description
        # The additional information about the stage.
        self.detail = detail
        # The error message returned during the stage.
        self.message = message
        # The name of the stage.
        self.name = name
        # The status of the stage.
        # 
        # Valid values:
        # 
        # *   Init
        # *   Running
        # *   Success
        # *   Fail
        # *   Termination
        # *   Cancel
        self.status = status
        # The step number of the stage.
        self.step = step
        # The type of the stage. This parameter indicates the operation type in the stage.
        # 
        # Valid values:
        # 
        # *   Deploy
        # *   Check
        # *   Offline
        # *   Build
        # *   Delete
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.description is not None:
            result['Description'] = self.description
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.message is not None:
            result['Message'] = self.message
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.step is not None:
            result['Step'] = self.step
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPipelineRunsResponseBodyPagingInfoPipelineRuns(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator: str = None,
        id: str = None,
        message: str = None,
        modify_time: int = None,
        project_id: int = None,
        stages: List[ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages] = None,
        status: str = None,
    ):
        # The time when the process was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The creator of the process.
        self.creator = creator
        # The process ID.
        self.id = id
        # The error message returned during the stage.
        self.message = message
        # The time when the process was modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The stages of the process.
        self.stages = stages
        # The status of the process.
        # 
        # Valid values:
        # 
        # *   Init
        # *   Running
        # *   Success
        # *   Fail
        # *   Termination
        # *   Cancel
        self.status = status

    def validate(self):
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['Stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.stages = []
        if m.get('Stages') is not None:
            for k in m.get('Stages'):
                temp_model = ListPipelineRunsResponseBodyPagingInfoPipelineRunsStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPipelineRunsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        pipeline_runs: List[ListPipelineRunsResponseBodyPagingInfoPipelineRuns] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The processes.
        self.pipeline_runs = pipeline_runs
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.pipeline_runs:
            for k in self.pipeline_runs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PipelineRuns'] = []
        if self.pipeline_runs is not None:
            for k in self.pipeline_runs:
                result['PipelineRuns'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.pipeline_runs = []
        if m.get('PipelineRuns') is not None:
            for k in m.get('PipelineRuns'):
                temp_model = ListPipelineRunsResponseBodyPagingInfoPipelineRuns()
                self.pipeline_runs.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPipelineRunsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListPipelineRunsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListPipelineRunsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPipelineRunsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineRunsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineRunsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectMembersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        role_codes: List[str] = None,
        user_ids: List[str] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        self.role_codes = role_codes
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class ListProjectMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_ids_shrink: str = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        self.role_codes_shrink = role_codes_shrink
        # The IDs of the accounts used by the members in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the IDs of the accounts used by the members in the workspace.
        self.user_ids_shrink = user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        return self


class ListProjectMembersResponseBodyPagingInfoProjectMembersRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        type: str = None,
    ):
        # The code of the role.
        self.code = code
        # The name of the role.
        self.name = name
        # The type of the role. Valid values:
        # 
        # *   UserCustom: user-defined role
        # *   System: system role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectMembersResponseBodyPagingInfoProjectMembers(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        roles: List[ListProjectMembersResponseBodyPagingInfoProjectMembersRoles] = None,
        status: str = None,
        user_id: str = None,
    ):
        # The ID of the DataWorks workspace.
        self.project_id = project_id
        # The roles that are assigned to the member.
        self.roles = roles
        # The status of the member. Valid values:
        # 
        # *   Normal
        # *   Forbidden
        self.status = status
        # The ID of the account used by the member.
        self.user_id = user_id

    def validate(self):
        if self.roles:
            for k in self.roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Roles'] = []
        if self.roles is not None:
            for k in self.roles:
                result['Roles'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.roles = []
        if m.get('Roles') is not None:
            for k in m.get('Roles'):
                temp_model = ListProjectMembersResponseBodyPagingInfoProjectMembersRoles()
                self.roles.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListProjectMembersResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        project_members: List[ListProjectMembersResponseBodyPagingInfoProjectMembers] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The members in the workspace.
        self.project_members = project_members
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.project_members:
            for k in self.project_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProjectMembers'] = []
        if self.project_members is not None:
            for k in self.project_members:
                result['ProjectMembers'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.project_members = []
        if m.get('ProjectMembers') is not None:
            for k in m.get('ProjectMembers'):
                temp_model = ListProjectMembersResponseBodyPagingInfoProjectMembers()
                self.project_members.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectMembersResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectMembersResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectMembersResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectRolesRequest(TeaModel):
    def __init__(
        self,
        codes: List[str] = None,
        names: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        # The codes of roles in the DataWorks workspace.
        self.codes = codes
        # The names of roles in the DataWorks workspace.
        self.names = names
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The type of the role. Valid values:
        # 
        # *   UserCustom: user-defined role
        # *   System: system role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codes is not None:
            result['Codes'] = self.codes
        if self.names is not None:
            result['Names'] = self.names
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codes') is not None:
            self.codes = m.get('Codes')
        if m.get('Names') is not None:
            self.names = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        codes_shrink: str = None,
        names_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        # The codes of roles in the DataWorks workspace.
        self.codes_shrink = codes_shrink
        # The names of roles in the DataWorks workspace.
        self.names_shrink = names_shrink
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The type of the role. Valid values:
        # 
        # *   UserCustom: user-defined role
        # *   System: system role
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codes_shrink is not None:
            result['Codes'] = self.codes_shrink
        if self.names_shrink is not None:
            result['Names'] = self.names_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codes') is not None:
            self.codes_shrink = m.get('Codes')
        if m.get('Names') is not None:
            self.names_shrink = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesResponseBodyPagingInfoProjectRoles(TeaModel):
    def __init__(
        self,
        code: str = None,
        name: str = None,
        project_id: int = None,
        type: str = None,
    ):
        # The code of the role in the DataWorks workspace.
        self.code = code
        # The name of the role.
        self.name = name
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The type of the role in the DataWorks workspace.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListProjectRolesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: str = None,
        page_size: str = None,
        project_roles: List[ListProjectRolesResponseBodyPagingInfoProjectRoles] = None,
        total_count: str = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The roles in the DataWorks workspace.
        self.project_roles = project_roles
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.project_roles:
            for k in self.project_roles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProjectRoles'] = []
        if self.project_roles is not None:
            for k in self.project_roles:
                result['ProjectRoles'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.project_roles = []
        if m.get('ProjectRoles') is not None:
            for k in m.get('ProjectRoles'):
                temp_model = ListProjectRolesResponseBodyPagingInfoProjectRoles()
                self.project_roles.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectRolesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectRolesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectsRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListProjectsRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListProjectsRequestAliyunResourceTags] = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        ids: List[int] = None,
        names: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspaces belong. You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) and go to the Resource Group page to query the ID.
        # 
        # This parameter is used to query the information about workspaces that belong to a specific resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # Specifies whether the development environment is enabled. Valid values:
        # 
        # *   true: The development environment is enabled. In this case, the development environment is isolated from the production environment in a workspace.
        # *   false: The development environment is disabled. In this case, only the production environment is used in a workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Specifies whether the Develop role is disabled. Valid values:
        # 
        # *   false (default)
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The IDs of the DataWorks workspaces.
        self.ids = ids
        # The names of the DataWorks workspaces.
        self.names = names
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # Specifies whether scheduling of Platform for AI (PAI) tasks is enabled. Valid values:
        # 
        # *   true: Scheduling of PAI tasks is enabled. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: Scheduling of PAI tasks is disabled.
        self.pai_task_enabled = pai_task_enabled
        # The status of the workspaces. Valid values:
        # 
        # *   Available
        # *   Initializing
        # *   InitFailed
        # *   Forbidden
        # *   Deleting
        # *   DeleteFailed
        # *   Frozen
        # *   Updating
        # *   UpdateFailed
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.names is not None:
            result['Names'] = self.names
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListProjectsRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Names') is not None:
            self.names = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        ids_shrink: str = None,
        names_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspaces belong. You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) and go to the Resource Group page to query the ID.
        # 
        # This parameter is used to query the information about workspaces that belong to a specific resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        # Specifies whether the development environment is enabled. Valid values:
        # 
        # *   true: The development environment is enabled. In this case, the development environment is isolated from the production environment in a workspace.
        # *   false: The development environment is disabled. In this case, only the production environment is used in a workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Specifies whether the Develop role is disabled. Valid values:
        # 
        # *   false (default)
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The IDs of the DataWorks workspaces.
        self.ids_shrink = ids_shrink
        # The names of the DataWorks workspaces.
        self.names_shrink = names_shrink
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # Specifies whether scheduling of Platform for AI (PAI) tasks is enabled. Valid values:
        # 
        # *   true: Scheduling of PAI tasks is enabled. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: Scheduling of PAI tasks is disabled.
        self.pai_task_enabled = pai_task_enabled
        # The status of the workspaces. Valid values:
        # 
        # *   Available
        # *   Initializing
        # *   InitFailed
        # *   Forbidden
        # *   Deleting
        # *   DeleteFailed
        # *   Frozen
        # *   Updating
        # *   UpdateFailed
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.names_shrink is not None:
            result['Names'] = self.names_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Names') is not None:
            self.names_shrink = m.get('Names')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListProjectsResponseBodyPagingInfoProjects(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags] = None,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        name: str = None,
        owner: str = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The ID of the Alibaba Cloud resource group to which the workspace belongs.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The tags.
        self.aliyun_resource_tags = aliyun_resource_tags
        # The description of the workspace.
        self.description = description
        # Indicates whether the development environment is enabled. Valid values:
        # 
        # *   true: The development environment is enabled. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: The development environment is disabled. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Indicates whether the Develop role is disabled. Valid values:
        # 
        # *   false (default)
        # *   true
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        self.display_name = display_name
        # The workspace ID.
        self.id = id
        # The name of the workspace.
        self.name = name
        # The ID of the Alibaba Cloud account to which the workspace belongs.
        self.owner = owner
        # Indicates whether scheduling of PAI tasks is enabled. Valid values:
        # 
        # *   true: Scheduling of PAI tasks is enabled. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: Scheduling of PAI tasks is disabled.
        self.pai_task_enabled = pai_task_enabled
        # The status of the workspace. Valid values:
        # 
        # *   Available
        # *   Initializing
        # *   InitFailed
        # *   Forbidden
        # *   Deleting
        # *   DeleteFailed
        # *   Frozen
        # *   Updating
        # *   UpdateFailed
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListProjectsResponseBodyPagingInfoProjectsAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListProjectsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        projects: List[ListProjectsResponseBodyPagingInfoProjects] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The workspaces.
        self.projects = projects
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.projects:
            for k in self.projects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Projects'] = []
        if self.projects is not None:
            for k in self.projects:
                result['Projects'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.projects = []
        if m.get('Projects') is not None:
            for k in m.get('Projects'):
                temp_model = ListProjectsResponseBodyPagingInfoProjects()
                self.projects.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProjectsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListProjectsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListProjectsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListProjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourceGroupsRequestAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # Tag Key
        self.key = key
        # Tag Value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListResourceGroupsRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListResourceGroupsRequestAliyunResourceTags] = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        payment_type: str = None,
        project_id: int = None,
        resource_group_types: List[str] = None,
        sort_by: str = None,
        statuses: List[str] = None,
    ):
        # Alibaba Cloud Resource Group ID
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # Alibaba Cloud tag list
        self.aliyun_resource_tags = aliyun_resource_tags
        # The name of a resource group, which is used for fuzzy match.
        self.name = name
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The billing method of resource groups. Valid values:
        # 
        # *   PrePaid
        # *   PostPaid
        self.payment_type = payment_type
        # The ID of the DataWorks workspace.
        self.project_id = project_id
        # The types of resource groups to query. If you do not configure this parameter, only serverless resource groups are returned by default.
        self.resource_group_types = resource_group_types
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   Id (Desc/Asc): the resource group ID
        # *   Name (Desc/Asc): the name of the resource group
        # *   Remark (Desc/Asc): the remarks of the resource group
        # *   Type (Desc/Asc): the type of the resource group
        # *   Status (Desc/Asc): the status of the resource group
        # *   Spec (Desc/Asc): the specifications of the resource group
        # *   CreateUser (Desc/Asc): the creator of the resource group
        # *   CreateTime (Desc/Asc): the time when the resource group is created
        # 
        # Default value: CreateTime Asc
        self.sort_by = sort_by
        # The statuses of resource groups.
        self.statuses = statuses

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_types is not None:
            result['ResourceGroupTypes'] = self.resource_group_types
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListResourceGroupsRequestAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupTypes') is not None:
            self.resource_group_types = m.get('ResourceGroupTypes')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        return self


class ListResourceGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags_shrink: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        payment_type: str = None,
        project_id: int = None,
        resource_group_types_shrink: str = None,
        sort_by: str = None,
        statuses_shrink: str = None,
    ):
        # Alibaba Cloud Resource Group ID
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # Alibaba Cloud tag list
        self.aliyun_resource_tags_shrink = aliyun_resource_tags_shrink
        # The name of a resource group, which is used for fuzzy match.
        self.name = name
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The billing method of resource groups. Valid values:
        # 
        # *   PrePaid
        # *   PostPaid
        self.payment_type = payment_type
        # The ID of the DataWorks workspace.
        self.project_id = project_id
        # The types of resource groups to query. If you do not configure this parameter, only serverless resource groups are returned by default.
        self.resource_group_types_shrink = resource_group_types_shrink
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   Id (Desc/Asc): the resource group ID
        # *   Name (Desc/Asc): the name of the resource group
        # *   Remark (Desc/Asc): the remarks of the resource group
        # *   Type (Desc/Asc): the type of the resource group
        # *   Status (Desc/Asc): the status of the resource group
        # *   Spec (Desc/Asc): the specifications of the resource group
        # *   CreateUser (Desc/Asc): the creator of the resource group
        # *   CreateTime (Desc/Asc): the time when the resource group is created
        # 
        # Default value: CreateTime Asc
        self.sort_by = sort_by
        # The statuses of resource groups.
        self.statuses_shrink = statuses_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.aliyun_resource_tags_shrink is not None:
            result['AliyunResourceTags'] = self.aliyun_resource_tags_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_types_shrink is not None:
            result['ResourceGroupTypes'] = self.resource_group_types_shrink
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.statuses_shrink is not None:
            result['Statuses'] = self.statuses_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('AliyunResourceTags') is not None:
            self.aliyun_resource_tags_shrink = m.get('AliyunResourceTags')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupTypes') is not None:
            self.resource_group_types_shrink = m.get('ResourceGroupTypes')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Statuses') is not None:
            self.statuses_shrink = m.get('Statuses')
        return self


class ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # Tag Key
        self.key = key
        # Tag Value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec(TeaModel):
    def __init__(
        self,
        amount: int = None,
        standard: str = None,
    ):
        # Quantity
        self.amount = amount
        # Specification details
        self.standard = standard

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.standard is not None:
            result['Standard'] = self.standard
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Standard') is not None:
            self.standard = m.get('Standard')
        return self


class ListResourceGroupsResponseBodyPagingInfoResourceGroupList(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        aliyun_resource_tags: List[ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags] = None,
        create_time: int = None,
        create_user: str = None,
        default_vpc_id: str = None,
        default_vswicth_id: str = None,
        id: str = None,
        name: str = None,
        order_instance_id: str = None,
        payment_type: str = None,
        remark: str = None,
        resource_group_type: str = None,
        spec: ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec = None,
        status: str = None,
    ):
        # Alibaba Cloud Resource Group ID
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # Alibaba Cloud tag list
        self.aliyun_resource_tags = aliyun_resource_tags
        # The creation time, which is a 64-bit timestamp.
        self.create_time = create_time
        # The ID of the user who created the resource group.
        self.create_user = create_user
        # Default VPC ID bound to a common resource group
        self.default_vpc_id = default_vpc_id
        # The default switch ID bound to the common resource group.
        self.default_vswicth_id = default_vswicth_id
        # Unique identifier of a resource group
        self.id = id
        # The name of the resource group.
        self.name = name
        # The order instance ID of the resource group.
        self.order_instance_id = order_instance_id
        # The billing method of the resource group. Valid values: PrePaid and PostPaid. The value PrePaid indicates the subscription billing method, and the value PostPaid indicates the pay-as-you-go billing method.
        self.payment_type = payment_type
        # Remarks for resource groups
        self.remark = remark
        # The type of the resource group. Valid values:
        # 
        # *   CommonV2: serverless resource group
        # *   ExclusiveDataIntegration: exclusive resource group for Data Integration
        # *   ExclusiveScheduler: exclusive resource group for scheduling
        # *   ExclusiveDataService: exclusive resource group for DataService Studio
        self.resource_group_type = resource_group_type
        # Resource Group specifications
        self.spec = spec
        # The status of the resource group. Valid values:
        # 
        # *   Normal: The resource group is running or in use.
        # *   Stop: The resource group is expired.
        # *   Deleted: The resource group is released or destroyed.
        # *   Creating: The resource group is being created.
        # *   CreateFailed: The resource group fails to be created.
        # *   Updating: The resource group is being scaled in or out, or the configurations of the resource group are being changed.
        # *   UpdateFailed: The resource group fails to be scaled out or upgraded.
        # *   Deleting: The resource group is being released or destroyed.
        # *   DeleteFailed: The resource group fails to be released or destroyed.
        # *   Timeout: The operations that are performed on the resource group time out.
        # *   Freezed: The resource group is frozen.
        # *   Starting: The resource group is being started.
        self.status = status

    def validate(self):
        if self.aliyun_resource_tags:
            for k in self.aliyun_resource_tags:
                if k:
                    k.validate()
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        result['AliyunResourceTags'] = []
        if self.aliyun_resource_tags is not None:
            for k in self.aliyun_resource_tags:
                result['AliyunResourceTags'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.default_vpc_id is not None:
            result['DefaultVpcId'] = self.default_vpc_id
        if self.default_vswicth_id is not None:
            result['DefaultVswicthId'] = self.default_vswicth_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.order_instance_id is not None:
            result['OrderInstanceId'] = self.order_instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.resource_group_type is not None:
            result['ResourceGroupType'] = self.resource_group_type
        if self.spec is not None:
            result['Spec'] = self.spec.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        self.aliyun_resource_tags = []
        if m.get('AliyunResourceTags') is not None:
            for k in m.get('AliyunResourceTags'):
                temp_model = ListResourceGroupsResponseBodyPagingInfoResourceGroupListAliyunResourceTags()
                self.aliyun_resource_tags.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DefaultVpcId') is not None:
            self.default_vpc_id = m.get('DefaultVpcId')
        if m.get('DefaultVswicthId') is not None:
            self.default_vswicth_id = m.get('DefaultVswicthId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderInstanceId') is not None:
            self.order_instance_id = m.get('OrderInstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('ResourceGroupType') is not None:
            self.resource_group_type = m.get('ResourceGroupType')
        if m.get('Spec') is not None:
            temp_model = ListResourceGroupsResponseBodyPagingInfoResourceGroupListSpec()
            self.spec = temp_model.from_map(m['Spec'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListResourceGroupsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        resource_group_list: List[ListResourceGroupsResponseBodyPagingInfoResourceGroupList] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The resource groups returned.
        self.resource_group_list = resource_group_list
        # All data entries
        self.total_count = total_count

    def validate(self):
        if self.resource_group_list:
            for k in self.resource_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ResourceGroupList'] = []
        if self.resource_group_list is not None:
            for k in self.resource_group_list:
                result['ResourceGroupList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.resource_group_list = []
        if m.get('ResourceGroupList') is not None:
            for k in m.get('ResourceGroupList'):
                temp_model = ListResourceGroupsResponseBodyPagingInfoResourceGroupList()
                self.resource_group_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListResourceGroupsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListResourceGroupsResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListResourceGroupsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListResourceGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourceGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourceGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourcesRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        # The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page.
        self.owner = owner
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The resource type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   Python
        # *   Jar
        # *   Archive
        # *   File
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfoResourcesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
    ):
        # The name of the data source.
        self.name = name
        # The type of the data source.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfoResourcesScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command used to distinguish file resource types.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListResourcesResponseBodyPagingInfoResourcesScript(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        runtime: ListResourcesResponseBodyPagingInfoResourcesScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListResourcesResponseBodyPagingInfoResources(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        data_source: ListResourcesResponseBodyPagingInfoResourcesDataSource = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        script: ListResourcesResponseBodyPagingInfoResourcesScript = None,
        source_path: str = None,
        source_type: str = None,
        target_path: str = None,
        target_type: str = None,
        type: str = None,
    ):
        # The time when the file resource was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The information about the data source.
        self.data_source = data_source
        # The ID of the file resource.
        self.id = id
        # The times when the file resource was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the file resource.
        self.name = name
        # The owner of the file resource.
        self.owner = owner
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        self.project_id = project_id
        # The script information.
        self.script = script
        # The path of the source of the file resource. If the SourecType parameter is set to Local, this parameter is left empty.
        self.source_path = source_path
        # The storage type of the source of the file resource.
        # 
        # Valid values:
        # 
        # *   Local
        # *   Oss
        self.source_type = source_type
        # The storage path of the destination of the file resource.
        self.target_path = target_path
        # The storage type of the destination of the file resource.
        # 
        # Valid values:
        # 
        # *   Gateway
        # *   Oss
        # *   Hdfs
        self.target_type = target_type
        # The type of the file resource.
        # 
        # Valid values:
        # 
        # *   Python
        # *   Jar
        # *   Archive
        # *   File
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.source_path is not None:
            result['SourcePath'] = self.source_path
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_path is not None:
            result['TargetPath'] = self.target_path
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataSource') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Script') is not None:
            temp_model = ListResourcesResponseBodyPagingInfoResourcesScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('SourcePath') is not None:
            self.source_path = m.get('SourcePath')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetPath') is not None:
            self.target_path = m.get('TargetPath')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListResourcesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        resources: List[ListResourcesResponseBodyPagingInfoResources] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The file resources.
        self.resources = resources
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = ListResourcesResponseBodyPagingInfoResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListResourcesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListResourcesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListResourcesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRoutesRequest(TeaModel):
    def __init__(
        self,
        network_id: int = None,
        page_number: int = None,
        page_size: int = None,
        resource_group_id: str = None,
        sort_by: str = None,
    ):
        # The network ID.
        self.network_id = network_id
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   Id (Desc/Asc): the route ID
        # *   DestinationCidr (Desc/Asc): the destination CIDR block of the route
        # *   CreateTime (Desc/Asc): the time when the route is created
        # 
        # Default value: CreateTime Asc.
        self.sort_by = sort_by

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListRoutesResponseBodyPagingInfoRouteList(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        destination_cidr: str = None,
        id: int = None,
        network_id: int = None,
        resource_group_id: str = None,
        resource_id: str = None,
    ):
        # The creation time, which is a 64-bit timestamp.
        self.create_time = create_time
        # Route destination CIDR
        self.destination_cidr = destination_cidr
        # Route ID
        self.id = id
        # Network Resource ID
        self.network_id = network_id
        # Unique identifier of the resource group to which it belongs
        self.resource_group_id = resource_group_id
        # Unique identifier of network resource
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        if self.network_id is not None:
            result['NetworkId'] = self.network_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NetworkId') is not None:
            self.network_id = m.get('NetworkId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class ListRoutesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        route_list: List[ListRoutesResponseBodyPagingInfoRouteList] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The list of network resource routing information obtained.
        self.route_list = route_list
        # All data entries
        self.total_count = total_count

    def validate(self):
        if self.route_list:
            for k in self.route_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RouteList'] = []
        if self.route_list is not None:
            for k in self.route_list:
                result['RouteList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.route_list = []
        if m.get('RouteList') is not None:
            for k in m.get('RouteList'):
                temp_model = ListRoutesResponseBodyPagingInfoRouteList()
                self.route_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListRoutesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListRoutesResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListRoutesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListRoutesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRoutesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRoutesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSchemasRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        types: List[str] = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListSchemasShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        types_shrink: str = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.types_shrink is not None:
            result['Types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Types') is not None:
            self.types_shrink = m.get('Types')
        return self


class ListSchemasResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        schemas: List[Schema] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.schemas = schemas
        self.total_count = total_count

    def validate(self):
        if self.schemas:
            for k in self.schemas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Schemas'] = []
        if self.schemas is not None:
            for k in self.schemas:
                result['Schemas'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.schemas = []
        if m.get('Schemas') is not None:
            for k in m.get('Schemas'):
                temp_model = Schema()
                self.schemas.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSchemasResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListSchemasResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListSchemasResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSchemasResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSchemasResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSchemasResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTablesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        table_types: List[str] = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.table_types = table_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.table_types is not None:
            result['TableTypes'] = self.table_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TableTypes') is not None:
            self.table_types = m.get('TableTypes')
        return self


class ListTablesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        order: str = None,
        page_number: int = None,
        page_size: int = None,
        parent_meta_entity_id: str = None,
        sort_by: str = None,
        table_types_shrink: str = None,
    ):
        self.comment = comment
        self.name = name
        self.order = order
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.parent_meta_entity_id = parent_meta_entity_id
        self.sort_by = sort_by
        self.table_types_shrink = table_types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_meta_entity_id is not None:
            result['ParentMetaEntityId'] = self.parent_meta_entity_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.table_types_shrink is not None:
            result['TableTypes'] = self.table_types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentMetaEntityId') is not None:
            self.parent_meta_entity_id = m.get('ParentMetaEntityId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TableTypes') is not None:
            self.table_types_shrink = m.get('TableTypes')
        return self


class ListTablesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tables: List[Table] = None,
        total_count: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.tables = tables
        self.total_count = total_count

    def validate(self):
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = Table()
                self.tables.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTablesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTablesResponseBodyPagingInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.paging_info = paging_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTablesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskInstanceOperationLogsRequest(TeaModel):
    def __init__(
        self,
        date: int = None,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The operation date, accurate to the day. The default value is the current day. You can query only the operation logs generated within the previous 31 days. This value is a UNIX timestamp.
        self.date = date
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        operation_content: str = None,
        operation_seq: int = None,
        task_instance_id: int = None,
        user: str = None,
    ):
        # The time when the operation log was generated.
        self.create_time = create_time
        # The operation content.
        self.operation_content = operation_content
        # The serial number of the operation.
        self.operation_seq = operation_seq
        # The ID of the instance on which the operation was performed.
        self.task_instance_id = task_instance_id
        # The account ID of the operator.
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.operation_content is not None:
            result['OperationContent'] = self.operation_content
        if self.operation_seq is not None:
            result['OperationSeq'] = self.operation_seq
        if self.task_instance_id is not None:
            result['TaskInstanceId'] = self.task_instance_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('OperationContent') is not None:
            self.operation_content = m.get('OperationContent')
        if m.get('OperationSeq') is not None:
            self.operation_seq = m.get('OperationSeq')
        if m.get('TaskInstanceId') is not None:
            self.task_instance_id = m.get('TaskInstanceId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListTaskInstanceOperationLogsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        operation_logs: List[ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The operation logs.
        self.operation_logs = operation_logs
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.operation_logs:
            for k in self.operation_logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLogs'] = []
        if self.operation_logs is not None:
            for k in self.operation_logs:
                result['OperationLogs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.operation_logs = []
        if m.get('OperationLogs') is not None:
            for k in m.get('OperationLogs'):
                temp_model = ListTaskInstanceOperationLogsResponseBodyPagingInfoOperationLogs()
                self.operation_logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskInstanceOperationLogsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskInstanceOperationLogsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskInstanceOperationLogsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskInstanceOperationLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskInstanceOperationLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskInstanceOperationLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        bizdate: int = None,
        id: int = None,
        ids: List[int] = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        status: str = None,
        task_id: int = None,
        task_ids: List[int] = None,
        task_name: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
    ):
        # The data timestamp. The value of this parameter is 00:00:00 of the day before the scheduling time of the instance. The value is a UNIX timestamp. Unit: milliseconds. Example: 1743350400000.
        # 
        # This parameter is required.
        self.bizdate = bizdate
        # The ID of the instance. The instance may be rerun. If the instance is rerun and you configure this parameter, the system returns the historical information of the instance, including the rerun information. You can use the RunNumber parameter to distinguish each entry in the historical information.
        self.id = id
        # The IDs of the instances. You can query multiple instances at a time by instance ID.
        self.ids = ids
        # The account ID of the task owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The information about the resource group. Set this parameter to the identifier of a resource group for scheduling.
        self.runtime_resource = runtime_resource
        # The field used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   `TriggerTime (Desc/Asc)`
        # 
        # *   `StartedTime (Desc/Asc)`
        # 
        # *   `FinishedTime (Desc/Asc)`
        # 
        # *   `CreateTime (Desc/Asc)`
        # 
        # *   `Id (Desc/Asc)`
        # 
        #     Default value: `Id Desc`.
        self.sort_by = sort_by
        self.status = status
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The IDs of the tasks. You can query multiple instances at a time by task ID.
        self.task_ids = task_ids
        # The name of the task. Fuzzy match is supported.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   SmokeTest
        # *   Manual
        # *   SupplementData
        # *   ManualWorkflow
        # *   Normal
        self.workflow_instance_type = workflow_instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.id is not None:
            result['Id'] = self.id
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        return self


class ListTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        bizdate: int = None,
        id: int = None,
        ids_shrink: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        status: str = None,
        task_id: int = None,
        task_ids_shrink: str = None,
        task_name: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
    ):
        # The data timestamp. The value of this parameter is 00:00:00 of the day before the scheduling time of the instance. The value is a UNIX timestamp. Unit: milliseconds. Example: 1743350400000.
        # 
        # This parameter is required.
        self.bizdate = bizdate
        # The ID of the instance. The instance may be rerun. If the instance is rerun and you configure this parameter, the system returns the historical information of the instance, including the rerun information. You can use the RunNumber parameter to distinguish each entry in the historical information.
        self.id = id
        # The IDs of the instances. You can query multiple instances at a time by instance ID.
        self.ids_shrink = ids_shrink
        # The account ID of the task owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The information about the resource group. Set this parameter to the identifier of a resource group for scheduling.
        self.runtime_resource = runtime_resource
        # The field used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   `TriggerTime (Desc/Asc)`
        # 
        # *   `StartedTime (Desc/Asc)`
        # 
        # *   `FinishedTime (Desc/Asc)`
        # 
        # *   `CreateTime (Desc/Asc)`
        # 
        # *   `Id (Desc/Asc)`
        # 
        #     Default value: `Id Desc`.
        self.sort_by = sort_by
        self.status = status
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The IDs of the tasks. You can query multiple instances at a time by task ID.
        self.task_ids_shrink = task_ids_shrink
        # The name of the task. Fuzzy match is supported.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   SmokeTest
        # *   Manual
        # *   SupplementData
        # *   ManualWorkflow
        # *   Normal
        self.workflow_instance_type = workflow_instance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.id is not None:
            result['Id'] = self.id
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of CUs configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the user who creates the instance.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the user who modifies the instance.
        self.modify_user = modify_user
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the cycle. This parameter indicates the cycle of the task instance on the current day.
        self.period_number = period_number
        # The priority of the task. Minimum value: 1. Maximum value: 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The rerun mode
        # 
        # Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times the task is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The information about the resource group with which the instance is associated.
        self.runtime_resource = runtime_resource
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance.
        # 
        # Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        # 
        # Note: The value of this parameter is rounded up by hour.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance.
        # 
        # Valid values:
        # 
        # *   SmokeTest
        # *   SupplementData
        # *   Manual
        # *   ManualWorkflow
        # *   Normal
        # *   ManualFlow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The instances.
        self.task_instances = task_instances
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskOperationLogsRequest(TeaModel):
    def __init__(
        self,
        date: int = None,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        # The operation date, accurate to the day. The default value is the current day. You can query only the operation logs generated within the previous 31 days.
        self.date = date
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListTaskOperationLogsResponseBodyPagingInfoOperationLogs(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        operation_content: str = None,
        operation_seq: int = None,
        task_id: int = None,
        user: str = None,
    ):
        # The time when the operation log was generated.
        self.create_time = create_time
        # The operation content.
        self.operation_content = operation_content
        # The serial number of the operation.
        self.operation_seq = operation_seq
        # The ID of the task on which the operation was performed.
        self.task_id = task_id
        # The account ID of the operator.
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.operation_content is not None:
            result['OperationContent'] = self.operation_content
        if self.operation_seq is not None:
            result['OperationSeq'] = self.operation_seq
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('OperationContent') is not None:
            self.operation_content = m.get('OperationContent')
        if m.get('OperationSeq') is not None:
            self.operation_seq = m.get('OperationSeq')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListTaskOperationLogsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        operation_logs: List[ListTaskOperationLogsResponseBodyPagingInfoOperationLogs] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The operation logs.
        self.operation_logs = operation_logs
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.operation_logs:
            for k in self.operation_logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLogs'] = []
        if self.operation_logs is not None:
            for k in self.operation_logs:
                result['OperationLogs'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.operation_logs = []
        if m.get('OperationLogs') is not None:
            for k in m.get('OperationLogs'):
                temp_model = ListTaskOperationLogsResponseBodyPagingInfoOperationLogs()
                self.operation_logs.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskOperationLogsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTaskOperationLogsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTaskOperationLogsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTaskOperationLogsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskOperationLogsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskOperationLogsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTasksRequest(TeaModel):
    def __init__(
        self,
        ids: List[int] = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
    ):
        # The ID of the task.
        self.ids = ids
        # The name of the task. Fuzzy match is supported.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The information about the resource group. Set this parameter to the ID of a resource group for scheduling.
        self.runtime_resource = runtime_resource
        # The field that is used to sort tasks. This parameter is configured in the format of "Sorting field Sorting order". You can set the sorting order to Desc or Asc. If you do not specify the sorting order, Asc is used by default. Valid values:
        # 
        # *   `ModifyTime (Desc/Asc)`
        # 
        # *   `CreateTime (Desc/Asc)`
        # 
        # *   `Id (Desc/Asc)`
        # 
        #     Default value: `Id Desc`.
        self.sort_by = sort_by
        # The type of the task. Valid values:
        # 
        # *   ODPS_SQL
        # *   SPARK
        # *   PY_ODPS
        # *   PY_ODPS3
        # *   ODPS_SCRIPT
        # *   ODPS_MR
        # *   COMPONENT_SQL
        # *   EMR_HIVE
        # *   EMR_MR
        # *   EMR_SPARK_SQL
        # *   EMR_SPARK
        # *   EMR_SHELL
        # *   EMR_PRESTO
        # *   EMR_IMPALA
        # *   SPARK_STREAMING
        # *   EMR_KYUUBI
        # *   EMR_TRINO
        # *   HOLOGRES_SQL
        # *   HOLOGRES_SYNC_DDL
        # *   HOLOGRES_SYNC_DATA
        self.task_type = task_type
        # The running mode of the task after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        ids_shrink: str = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
        project_id: int = None,
        runtime_resource: str = None,
        sort_by: str = None,
        task_type: str = None,
        trigger_recurrence: str = None,
        trigger_type: str = None,
        workflow_id: int = None,
    ):
        # The ID of the task.
        self.ids_shrink = ids_shrink
        # The name of the task. Fuzzy match is supported.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The information about the resource group. Set this parameter to the ID of a resource group for scheduling.
        self.runtime_resource = runtime_resource
        # The field that is used to sort tasks. This parameter is configured in the format of "Sorting field Sorting order". You can set the sorting order to Desc or Asc. If you do not specify the sorting order, Asc is used by default. Valid values:
        # 
        # *   `ModifyTime (Desc/Asc)`
        # 
        # *   `CreateTime (Desc/Asc)`
        # 
        # *   `Id (Desc/Asc)`
        # 
        #     Default value: `Id Desc`.
        self.sort_by = sort_by
        # The type of the task. Valid values:
        # 
        # *   ODPS_SQL
        # *   SPARK
        # *   PY_ODPS
        # *   PY_ODPS3
        # *   ODPS_SCRIPT
        # *   ODPS_MR
        # *   COMPONENT_SQL
        # *   EMR_HIVE
        # *   EMR_MR
        # *   EMR_SPARK_SQL
        # *   EMR_SPARK
        # *   EMR_SHELL
        # *   EMR_PRESTO
        # *   EMR_IMPALA
        # *   SPARK_STREAMING
        # *   EMR_KYUUBI
        # *   EMR_TRINO
        # *   HOLOGRES_SQL
        # *   HOLOGRES_SYNC_DDL
        # *   HOLOGRES_SYNC_DATA
        self.task_type = task_type
        # The running mode of the task after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression of the task. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        script_parameters: str = None,
        timeout: int = None,
        trigger: ListTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The task ID.
        self.id = id
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace.
        # 
        # Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode.
        # 
        # Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether it is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The list of script parameters.
        self.script_parameters = script_parameters
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The method to trigger task scheduling.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script_parameters is not None:
            result['ScriptParameters'] = self.script_parameters
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('ScriptParameters') is not None:
            self.script_parameters = m.get('ScriptParameters')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The tasks.
        self.tasks = tasks
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUpstreamTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource = None,
        description: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime = None,
        runtime_resource: ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        step_type: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the period. Indicates which cycle of the day the task instance is in.
        self.period_number = period_number
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.step_type = step_type
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   SmokeTest
        # *   SupplementData
        # *   Manual
        # *   ManualWorkflow
        # *   Normal
        # *   ManualFlow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstancesRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime(TeaModel):
    def __init__(
        self,
        gateway: str = None,
        process_id: str = None,
    ):
        # The host for running.
        self.gateway = gateway
        # The instance run ID.
        self.process_id = process_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway is not None:
            result['Gateway'] = self.gateway
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Gateway') is not None:
            self.gateway = m.get('Gateway')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        bizdate: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource = None,
        description: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        owner: str = None,
        period_number: int = None,
        priority: int = None,
        project_id: int = None,
        rerun_mode: str = None,
        run_number: int = None,
        runtime: ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime = None,
        runtime_resource: ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource = None,
        started_time: int = None,
        status: str = None,
        task_id: int = None,
        task_name: str = None,
        task_type: str = None,
        timeout: int = None,
        trigger_recurrence: str = None,
        trigger_time: int = None,
        trigger_type: str = None,
        workflow_id: int = None,
        workflow_instance_id: int = None,
        workflow_instance_type: str = None,
        workflow_name: str = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The data timestamp.
        self.bizdate = bizdate
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description.
        self.description = description
        # The environment in which the data source is used. Valid values:
        # 
        # *   Dev
        # *   Prod
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The account ID of the task owner.
        self.owner = owner
        # The sequence number of the cycle. This parameter indicates the cycle of the task instance on the current day.
        self.period_number = period_number
        # The priority of the task. Minimum value: 1. Maximum value: 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The workspace ID.
        self.project_id = project_id
        # The rerun mode.
        self.rerun_mode = rerun_mode
        # The number of times the instance is run. By default, the value starts from 1.
        self.run_number = run_number
        # The runtime information about the instance.
        self.runtime = runtime
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        # *   WaitTrigger: The instance is waiting to be triggered by external scheduling systems.
        self.status = status
        # The ID of the task for which the instance is generated.
        self.task_id = task_id
        # The name of the task for which the instance is generated.
        self.task_name = task_name
        # The type of the task for which the instance is generated.
        self.task_type = task_type
        # The timeout period of task running. Unit: seconds.
        # 
        # Note: The value of this parameter is rounded up by hour.
        self.timeout = timeout
        # The running mode of the instance after it is triggered. This parameter takes effect only if the TriggerType parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.trigger_recurrence = trigger_recurrence
        # The scheduling time.
        self.trigger_time = trigger_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.trigger_type = trigger_type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id
        # The workflow instance ID.
        self.workflow_instance_id = workflow_instance_id
        # The type of the workflow instance. Valid values:
        # 
        # *   Normal
        # *   Manual
        # *   SmokeTest
        # *   SupplementData
        # *   ManualWorkflow
        self.workflow_instance_type = workflow_instance_type
        # The name of the workflow to which the instance belongs.
        self.workflow_name = workflow_name

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime:
            self.runtime.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.bizdate is not None:
            result['Bizdate'] = self.bizdate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.period_number is not None:
            result['PeriodNumber'] = self.period_number
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.run_number is not None:
            result['RunNumber'] = self.run_number
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_recurrence is not None:
            result['TriggerRecurrence'] = self.trigger_recurrence
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_instance_type is not None:
            result['WorkflowInstanceType'] = self.workflow_instance_type
        if self.workflow_name is not None:
            result['WorkflowName'] = self.workflow_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('Bizdate') is not None:
            self.bizdate = m.get('Bizdate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PeriodNumber') is not None:
            self.period_number = m.get('PeriodNumber')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RunNumber') is not None:
            self.run_number = m.get('RunNumber')
        if m.get('Runtime') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstanceRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TriggerRecurrence') is not None:
            self.trigger_recurrence = m.get('TriggerRecurrence')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowInstanceType') is not None:
            self.workflow_instance_type = m.get('WorkflowInstanceType')
        if m.get('WorkflowName') is not None:
            self.workflow_name = m.get('WorkflowName')
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances(TeaModel):
    def __init__(
        self,
        dependency_type: str = None,
        task_instance: ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance = None,
    ):
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal
        # *   CrossCycle
        self.dependency_type = dependency_type
        # The information about a task instance.
        self.task_instance = task_instance

    def validate(self):
        if self.task_instance:
            self.task_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependency_type is not None:
            result['DependencyType'] = self.dependency_type
        if self.task_instance is not None:
            result['TaskInstance'] = self.task_instance.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DependencyType') is not None:
            self.dependency_type = m.get('DependencyType')
        if m.get('TaskInstance') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstancesTaskInstance()
            self.task_instance = temp_model.from_map(m['TaskInstance'])
        return self


class ListUpstreamTaskInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_instances: List[ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances] = None,
        total_count: int = None,
        upstream_task_instances: List[ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The instances. This parameter is deprecated and replaced by the UpstreamTaskInstances parameter.
        self.task_instances = task_instances
        # The total number of entries returned.
        self.total_count = total_count
        # The ancestor instances.
        self.upstream_task_instances = upstream_task_instances

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()
        if self.upstream_task_instances:
            for k in self.upstream_task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['UpstreamTaskInstances'] = []
        if self.upstream_task_instances is not None:
            for k in self.upstream_task_instances:
                result['UpstreamTaskInstances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.upstream_task_instances = []
        if m.get('UpstreamTaskInstances') is not None:
            for k in m.get('UpstreamTaskInstances'):
                temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfoUpstreamTaskInstances()
                self.upstream_task_instances.append(temp_model.from_map(k))
        return self


class ListUpstreamTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListUpstreamTaskInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUpstreamTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUpstreamTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUpstreamTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUpstreamTasksRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        page_number: int = None,
        page_size: int = None,
        project_env: str = None,
    ):
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.project_env = project_env

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasksTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression of the task. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler.
        # 
        # Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The trigger type.
        # 
        # Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListUpstreamTasksResponseBodyPagingInfoTasks(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTasksResponseBodyPagingInfoTasksDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_env: str = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource = None,
        step_type: str = None,
        timeout: int = None,
        trigger: ListUpstreamTasksResponseBodyPagingInfoTasksTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8. A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The environment of the workspace. This parameter is deprecated and replaced by the EnvType parameter.
        # 
        # Valid values:
        # 
        # *   Prod
        # *   Dev
        self.project_env = project_env
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode.
        # 
        # Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether it is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether it is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.step_type = step_type
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The method to trigger task scheduling.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_env is not None:
            result['ProjectEnv'] = self.project_env
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.step_type is not None:
            result['StepType'] = self.step_type
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectEnv') is not None:
            self.project_env = m.get('ProjectEnv')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('StepType') is not None:
            self.step_type = m.get('StepType')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        timezone: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The time zone.
        self.timezone = timezone
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timezone is not None:
            result['Timezone'] = self.timezone
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timezone') is not None:
            self.timezone = m.get('Timezone')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask(TeaModel):
    def __init__(
        self,
        baseline_id: int = None,
        create_time: int = None,
        create_user: str = None,
        data_source: ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        priority: int = None,
        project_id: int = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource = None,
        timeout: int = None,
        trigger: ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The baseline ID.
        self.baseline_id = baseline_id
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The information about the associated data source.
        self.data_source = data_source
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID.
        self.id = id
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the task.
        self.name = name
        # The account ID of the task owner.
        self.owner = owner
        # The priority of the task. Valid values: 1 to 8.
        self.priority = priority
        # The workspace ID.
        self.project_id = project_id
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        self.runtime_resource = runtime_resource
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        self.trigger = trigger
        # The type of the task.
        self.type = type
        # The ID of the workflow to which the task belongs.
        self.workflow_id = workflow_id

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_id is not None:
            result['BaselineId'] = self.baseline_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaselineId') is not None:
            self.baseline_id = m.get('BaselineId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DataSource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTaskTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks(TeaModel):
    def __init__(
        self,
        dependency_type: str = None,
        task: ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask = None,
    ):
        # The scheduling dependency type. Valid values:
        # 
        # *   Normal: same-cycle scheduling dependency
        # *   CrossCycle: cross-cycle scheduling dependency
        self.dependency_type = dependency_type
        # The information about the task.
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependency_type is not None:
            result['DependencyType'] = self.dependency_type
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DependencyType') is not None:
            self.dependency_type = m.get('DependencyType')
        if m.get('Task') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfoUpstreamTasksTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class ListUpstreamTasksResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tasks: List[ListUpstreamTasksResponseBodyPagingInfoTasks] = None,
        total_count: int = None,
        upstream_tasks: List[ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The tasks. This parameter is deprecated and replaced by the UpstreamTasks parameter.
        self.tasks = tasks
        # The total number of entries returned.
        self.total_count = total_count
        # The ancestor tasks.
        self.upstream_tasks = upstream_tasks

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()
        if self.upstream_tasks:
            for k in self.upstream_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['UpstreamTasks'] = []
        if self.upstream_tasks is not None:
            for k in self.upstream_tasks:
                result['UpstreamTasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = ListUpstreamTasksResponseBodyPagingInfoTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.upstream_tasks = []
        if m.get('UpstreamTasks') is not None:
            for k in m.get('UpstreamTasks'):
                temp_model = ListUpstreamTasksResponseBodyPagingInfoUpstreamTasks()
                self.upstream_tasks.append(temp_model.from_map(k))
        return self


class ListUpstreamTasksResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListUpstreamTasksResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListUpstreamTasksResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUpstreamTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUpstreamTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUpstreamTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkflowDefinitionsRequest(TeaModel):
    def __init__(
        self,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        type: str = None,
    ):
        # The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page.
        self.owner = owner
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The workflow type. This parameter specifies a filter condition.
        # 
        # Valid values:
        # 
        # *   CycleWorkflow
        # *   ManualWorkflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # The command.
        self.command = command

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        runtime: ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime = None,
    ):
        # The script ID.
        self.id = id
        # The script path.
        self.path = path
        # The runtime.
        self.runtime = runtime

    def validate(self):
        if self.runtime:
            self.runtime.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.runtime is not None:
            result['Runtime'] = self.runtime.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Runtime') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScriptRuntime()
            self.runtime = temp_model.from_map(m['Runtime'])
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        description: str = None,
        id: int = None,
        modify_time: int = None,
        name: str = None,
        owner: str = None,
        project_id: int = None,
        script: ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript = None,
        type: str = None,
    ):
        # The time when the workflow was created. This value is a UNIX timestamp.
        self.create_time = create_time
        # The description of the workflow.
        self.description = description
        # The ID of the workflow.
        self.id = id
        # The time when the workflow was last modified. This value is a UNIX timestamp.
        self.modify_time = modify_time
        # The name of the workflow.
        self.name = name
        # The owner.
        self.owner = owner
        # The ID of the DataWorks workspace to which the workflow belongs.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The script information.
        self.script = script
        # The type of the workflow.
        # 
        # Valid values:
        # 
        # *   CycleWorkflow
        # *   ManualWorkflow
        self.type = type

    def validate(self):
        if self.script:
            self.script.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.script is not None:
            result['Script'] = self.script.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Script') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitionsScript()
            self.script = temp_model.from_map(m['Script'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListWorkflowDefinitionsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
        workflow_definitions: List[ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count
        # The workflows.
        self.workflow_definitions = workflow_definitions

    def validate(self):
        if self.workflow_definitions:
            for k in self.workflow_definitions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WorkflowDefinitions'] = []
        if self.workflow_definitions is not None:
            for k in self.workflow_definitions:
                result['WorkflowDefinitions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.workflow_definitions = []
        if m.get('WorkflowDefinitions') is not None:
            for k in m.get('WorkflowDefinitions'):
                temp_model = ListWorkflowDefinitionsResponseBodyPagingInfoWorkflowDefinitions()
                self.workflow_definitions.append(temp_model.from_map(k))
        return self


class ListWorkflowDefinitionsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListWorkflowDefinitionsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListWorkflowDefinitionsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListWorkflowDefinitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkflowDefinitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkflowDefinitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkflowInstancesRequest(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        ids: List[int] = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The data timestamp. The value of this parameter is 00:00:00 of the day before the scheduling time of the instance. The value is a UNIX timestamp. Unit: milliseconds. Example: 1743350400000.
        # 
        # This parameter is required.
        self.biz_date = biz_date
        # The IDs of the workflow instances. You can query multiple instances at a time by instance ID.
        self.ids = ids
        # The instance name. Fuzzy match is supported.
        self.name = name
        # The account ID of the workflow instance owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   TriggerTime (Desc/Asc)
        # *   StartedTime (Desc/Asc)
        # *   FinishedTime (Desc/Asc)
        # *   CreateTime (Desc/Asc)
        # *   Id (Desc/Asc)
        # 
        # Default value: Id Desc.
        self.sort_by = sort_by
        # The type of the workflow instance. Valid values:
        # 
        # *   Normal
        # *   Manual
        # *   SmokeTest
        # *   SupplementData
        # *   ManualWorkflow
        self.type = type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListWorkflowInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        ids_shrink: str = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        type: str = None,
        workflow_id: int = None,
    ):
        # The data timestamp. The value of this parameter is 00:00:00 of the day before the scheduling time of the instance. The value is a UNIX timestamp. Unit: milliseconds. Example: 1743350400000.
        # 
        # This parameter is required.
        self.biz_date = biz_date
        # The IDs of the workflow instances. You can query multiple instances at a time by instance ID.
        self.ids_shrink = ids_shrink
        # The instance name. Fuzzy match is supported.
        self.name = name
        # The account ID of the workflow instance owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The fields used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   TriggerTime (Desc/Asc)
        # *   StartedTime (Desc/Asc)
        # *   FinishedTime (Desc/Asc)
        # *   CreateTime (Desc/Asc)
        # *   Id (Desc/Asc)
        # 
        # Default value: Id Desc.
        self.sort_by = sort_by
        # The type of the workflow instance. Valid values:
        # 
        # *   Normal
        # *   Manual
        # *   SmokeTest
        # *   SupplementData
        # *   ManualWorkflow
        self.type = type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances(TeaModel):
    def __init__(
        self,
        biz_date: int = None,
        create_time: int = None,
        create_user: str = None,
        env_type: str = None,
        finished_time: int = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        project_id: int = None,
        started_time: int = None,
        status: str = None,
        type: str = None,
        workflow_id: int = None,
    ):
        self.biz_date = biz_date
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The time when the instance finished running.
        self.finished_time = finished_time
        # The workflow instance ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name of the workflow instance.
        self.name = name
        # The workspace ID.
        self.project_id = project_id
        # The time when the instance started to run.
        self.started_time = started_time
        # The status of the workflow instance. Valid values:
        # 
        # *   NotRun: The instance is not run.
        # *   Running: The instance is running.
        # *   WaitTime: The instance is waiting for the scheduling time to arrive.
        # *   CheckingCondition: Branch conditions are being checked for the instance.
        # *   WaitResource: The instance is waiting for resources.
        # *   Failure: The instance fails to be run.
        # *   Success: The instance is successfully run.
        # *   Checking: Data quality is being checked for the instance.
        self.status = status
        self.type = type
        # The ID of the workflow to which the instance belongs.
        self.workflow_id = workflow_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_date is not None:
            result['BizDate'] = self.biz_date
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.started_time is not None:
            result['StartedTime'] = self.started_time
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.workflow_id is not None:
            result['WorkflowId'] = self.workflow_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizDate') is not None:
            self.biz_date = m.get('BizDate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('StartedTime') is not None:
            self.started_time = m.get('StartedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkflowId') is not None:
            self.workflow_id = m.get('WorkflowId')
        return self


class ListWorkflowInstancesResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
        workflow_instances: List[ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count
        # The workflow instances.
        self.workflow_instances = workflow_instances

    def validate(self):
        if self.workflow_instances:
            for k in self.workflow_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['WorkflowInstances'] = []
        if self.workflow_instances is not None:
            for k in self.workflow_instances:
                result['WorkflowInstances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.workflow_instances = []
        if m.get('WorkflowInstances') is not None:
            for k in m.get('WorkflowInstances'):
                temp_model = ListWorkflowInstancesResponseBodyPagingInfoWorkflowInstances()
                self.workflow_instances.append(temp_model.from_map(k))
        return self


class ListWorkflowInstancesResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListWorkflowInstancesResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListWorkflowInstancesResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListWorkflowInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkflowInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkflowInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkflowsRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        ids: List[int] = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        trigger_type: str = None,
    ):
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The IDs of the workflows. You can query multiple workflows at a time by workflow ID.
        self.ids = ids
        # The name of the workflow. Fuzzy match is supported.
        self.name = name
        # The account ID of the workflow owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The field used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   ModifyTime (Desc/Asc)
        # *   CreateTime (Desc/Asc)
        # *   Id (Desc/Asc)
        # 
        # Default value: Id Desc.
        self.sort_by = sort_by
        # The trigger type. Valid values:
        # 
        # *   Scheduler
        # *   Manual
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListWorkflowsShrinkRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        ids_shrink: str = None,
        name: str = None,
        owner: str = None,
        page_number: int = None,
        page_size: int = None,
        project_id: int = None,
        sort_by: str = None,
        trigger_type: str = None,
    ):
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The IDs of the workflows. You can query multiple workflows at a time by workflow ID.
        self.ids_shrink = ids_shrink
        # The name of the workflow. Fuzzy match is supported.
        self.name = name
        # The account ID of the workflow owner.
        self.owner = owner
        # The page number. Pages start from page 1. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        self.page_size = page_size
        # The workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The field used for sorting. Fields such as TriggerTime and StartedTime are supported. The value of this parameter is in the Sort field + Sort by (Desc/Asc) format. By default, results are sorted in ascending order. Valid values:
        # 
        # *   ModifyTime (Desc/Asc)
        # *   CreateTime (Desc/Asc)
        # *   Id (Desc/Asc)
        # 
        # Default value: Id Desc.
        self.sort_by = sort_by
        # The trigger type. Valid values:
        # 
        # *   Scheduler
        # *   Manual
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.end_time = end_time
        # The running mode of the workflow after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListWorkflowsResponseBodyPagingInfoWorkflows(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        create_time: int = None,
        create_user: str = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        modify_time: int = None,
        modify_user: str = None,
        name: str = None,
        owner: str = None,
        parameters: str = None,
        project_id: int = None,
        trigger: ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger = None,
    ):
        # The unique code of the client. This parameter is used to create a workflow asynchronously and implement the idempotence of the workflow. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The creation time.
        self.create_time = create_time
        # The account ID of the creator.
        self.create_user = create_user
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The workflow ID.
        self.id = id
        # The modification time.
        self.modify_time = modify_time
        # The account ID of the modifier.
        self.modify_user = modify_user
        # The name.
        self.name = name
        # The account ID of the owner.
        self.owner = owner
        # The parameters.
        self.parameters = parameters
        # The workspace ID.
        self.project_id = project_id
        # The trigger method.
        self.trigger = trigger

    def validate(self):
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.modify_user is not None:
            result['ModifyUser'] = self.modify_user
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('ModifyUser') is not None:
            self.modify_user = m.get('ModifyUser')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Trigger') is not None:
            temp_model = ListWorkflowsResponseBodyPagingInfoWorkflowsTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class ListWorkflowsResponseBodyPagingInfo(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
        workflows: List[ListWorkflowsResponseBodyPagingInfoWorkflows] = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count
        # The workflows.
        self.workflows = workflows

    def validate(self):
        if self.workflows:
            for k in self.workflows:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['Workflows'] = []
        if self.workflows is not None:
            for k in self.workflows:
                result['Workflows'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.workflows = []
        if m.get('Workflows') is not None:
            for k in m.get('Workflows'):
                temp_model = ListWorkflowsResponseBodyPagingInfoWorkflows()
                self.workflows.append(temp_model.from_map(k))
        return self


class ListWorkflowsResponseBody(TeaModel):
    def __init__(
        self,
        paging_info: ListWorkflowsResponseBodyPagingInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.paging_info = paging_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.paging_info:
            self.paging_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.paging_info is not None:
            result['PagingInfo'] = self.paging_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PagingInfo') is not None:
            temp_model = ListWorkflowsResponseBodyPagingInfo()
            self.paging_info = temp_model.from_map(m['PagingInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListWorkflowsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkflowsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkflowsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveFunctionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        project_id: int = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the UDF. You do not need to specify a UDF name in the path.
        # 
        # For example, if you want to move the test UDF to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
        # 
        # This parameter indicates the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveNodeRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        project_id: int = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the node. You do not need to specify a node name in the path.
        # 
        # For example, if you want to move the test node to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveResourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        project_id: int = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the file resource. You do not need to specify a file resource name in the path.
        # 
        # For example, if you want to move the test file resource to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
        # 
        # You can use this parameter to specify the DataWorks workspace on which you want to perform the API operation.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        path: str = None,
        project_id: int = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The path to which you want to move the workflow. You do not need to specify a workflow name in the path.
        # 
        # For example, if you want to move the test workflow to root/demo/test, you must set this parameter to root/demo.
        # 
        # This parameter is required.
        self.path = path
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID. This parameter indicates the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.path is not None:
            result['Path'] = self.path
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MoveWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveEntityFromMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        meta_collection_id: str = None,
    ):
        self.id = id
        self.meta_collection_id = meta_collection_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.meta_collection_id is not None:
            result['MetaCollectionId'] = self.meta_collection_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetaCollectionId') is not None:
            self.meta_collection_id = m.get('MetaCollectionId')
        return self


class RemoveEntityFromMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveEntityFromMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveEntityFromMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveEntityFromMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTaskInstanceDependenciesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        id: int = None,
        upstream_task_instance_ids: List[int] = None,
    ):
        # The remarks.
        self.comment = comment
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The IDs of ancestor instances of the instance
        self.upstream_task_instance_ids = upstream_task_instance_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.id is not None:
            result['Id'] = self.id
        if self.upstream_task_instance_ids is not None:
            result['UpstreamTaskInstanceIds'] = self.upstream_task_instance_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('UpstreamTaskInstanceIds') is not None:
            self.upstream_task_instance_ids = m.get('UpstreamTaskInstanceIds')
        return self


class RemoveTaskInstanceDependenciesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        id: int = None,
        upstream_task_instance_ids_shrink: str = None,
    ):
        # The remarks.
        self.comment = comment
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The IDs of ancestor instances of the instance
        self.upstream_task_instance_ids_shrink = upstream_task_instance_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.id is not None:
            result['Id'] = self.id
        if self.upstream_task_instance_ids_shrink is not None:
            result['UpstreamTaskInstanceIds'] = self.upstream_task_instance_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('UpstreamTaskInstanceIds') is not None:
            self.upstream_task_instance_ids_shrink = m.get('UpstreamTaskInstanceIds')
        return self


class RemoveTaskInstanceDependenciesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveTaskInstanceDependenciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveTaskInstanceDependenciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTaskInstanceDependenciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameFunctionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        project_id: int = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameNodeRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        project_id: int = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameResourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        project_id: int = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenameWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        project_id: int = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The new name.
        # 
        # This parameter is required.
        self.name = name
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RenameWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RenameWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenameWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenameWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RerunTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class RerunTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class RerunTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class RerunTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RerunTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RerunTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class ResumeTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class ResumeTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class ResumeTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeMemberProjectRolesRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes: List[str] = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to revoke from the member in the workspace.
        # 
        # This parameter is required.
        self.role_codes = role_codes
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes is not None:
            result['RoleCodes'] = self.role_codes
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeMemberProjectRolesShrinkRequest(TeaModel):
    def __init__(
        self,
        project_id: int = None,
        role_codes_shrink: str = None,
        user_id: str = None,
    ):
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The codes of the roles in the workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2853930.html) operation to query the codes of all roles in the workspace.
        # 
        # You must configure this parameter to specify the roles that you want to revoke from the member in the workspace.
        # 
        # This parameter is required.
        self.role_codes_shrink = role_codes_shrink
        # The ID of the account used by the member in the workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/product/ms_menu), choose More > Management Center in the left-side navigation pane, select the desired workspace on the Management Center page, and then click Go to Management Center. In the left-side navigation pane of the SettingCenter page, click Tenant Members and Roles. On the Tenant Members and Roles page, view the ID of the account used by the member in the workspace.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.role_codes_shrink is not None:
            result['RoleCodes'] = self.role_codes_shrink
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RoleCodes') is not None:
            self.role_codes_shrink = m.get('RoleCodes')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeMemberProjectRolesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeMemberProjectRolesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeMemberProjectRolesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeMemberProjectRolesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetSuccessTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class SetSuccessTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class SetSuccessTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class SetSuccessTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetSuccessTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetSuccessTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartDIJobRequestRealtimeStartSettingsFailoverSettings(TeaModel):
    def __init__(
        self,
        interval: int = None,
        upper_limit: int = None,
    ):
        # This parameter is deprecated. Use advanced parameters for failover settings when you create a task.
        self.interval = interval
        # This parameter is deprecated. Use advanced parameters for failover settings when you create a task.
        self.upper_limit = upper_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.upper_limit is not None:
            result['UpperLimit'] = self.upper_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('UpperLimit') is not None:
            self.upper_limit = m.get('UpperLimit')
        return self


class StartDIJobRequestRealtimeStartSettings(TeaModel):
    def __init__(
        self,
        failover_settings: StartDIJobRequestRealtimeStartSettingsFailoverSettings = None,
        start_time: int = None,
    ):
        # This parameter is deprecated. Use advanced parameters for failover settings when you create a task.
        self.failover_settings = failover_settings
        # The start time.
        self.start_time = start_time

    def validate(self):
        if self.failover_settings:
            self.failover_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failover_settings is not None:
            result['FailoverSettings'] = self.failover_settings.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailoverSettings') is not None:
            temp_model = StartDIJobRequestRealtimeStartSettingsFailoverSettings()
            self.failover_settings = temp_model.from_map(m['FailoverSettings'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class StartDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        force_to_rerun: bool = None,
        id: int = None,
        realtime_start_settings: StartDIJobRequestRealtimeStartSettings = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # Specifies whether to forcefully rerun all synchronization steps. If you do not configure this parameter, the system does not perform the forcible rerun operation.
        # 
        # *   If the system does not perform the forcible rerun operation, only the steps that are not run start to run.
        # *   If the system performs the forcible rerun operation, all steps start to rerun.
        self.force_to_rerun = force_to_rerun
        # The ID of the synchronization task.
        self.id = id
        # The settings for starting real-time synchronization.
        # 
        #     {
        #       "StartTime":1663765058
        #     }
        self.realtime_start_settings = realtime_start_settings

    def validate(self):
        if self.realtime_start_settings:
            self.realtime_start_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.force_to_rerun is not None:
            result['ForceToRerun'] = self.force_to_rerun
        if self.id is not None:
            result['Id'] = self.id
        if self.realtime_start_settings is not None:
            result['RealtimeStartSettings'] = self.realtime_start_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ForceToRerun') is not None:
            self.force_to_rerun = m.get('ForceToRerun')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RealtimeStartSettings') is not None:
            temp_model = StartDIJobRequestRealtimeStartSettings()
            self.realtime_start_settings = temp_model.from_map(m['RealtimeStartSettings'])
        return self


class StartDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        force_to_rerun: bool = None,
        id: int = None,
        realtime_start_settings_shrink: str = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # Specifies whether to forcefully rerun all synchronization steps. If you do not configure this parameter, the system does not perform the forcible rerun operation.
        # 
        # *   If the system does not perform the forcible rerun operation, only the steps that are not run start to run.
        # *   If the system performs the forcible rerun operation, all steps start to rerun.
        self.force_to_rerun = force_to_rerun
        # The ID of the synchronization task.
        self.id = id
        # The settings for starting real-time synchronization.
        # 
        #     {
        #       "StartTime":1663765058
        #     }
        self.realtime_start_settings_shrink = realtime_start_settings_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.force_to_rerun is not None:
            result['ForceToRerun'] = self.force_to_rerun
        if self.id is not None:
            result['Id'] = self.id
        if self.realtime_start_settings_shrink is not None:
            result['RealtimeStartSettings'] = self.realtime_start_settings_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('ForceToRerun') is not None:
            self.force_to_rerun = m.get('ForceToRerun')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RealtimeStartSettings') is not None:
            self.realtime_start_settings_shrink = m.get('RealtimeStartSettings')
        return self


class StartDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartWorkflowInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # The remarks.
        self.comment = comment
        # The IDs of workflow instances.
        # 
        # This parameter is required.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class StartWorkflowInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # The remarks.
        self.comment = comment
        # The IDs of workflow instances.
        # 
        # This parameter is required.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class StartWorkflowInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The workflow instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class StartWorkflowInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartWorkflowInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartWorkflowInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        id: int = None,
        instance_id: int = None,
    ):
        # This parameter is deprecated and is replaced by the Id parameter.
        self.dijob_id = dijob_id
        # The ID of the synchronization task.
        self.id = id
        # The instance ID.
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class StopDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class StopTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class StopTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class StopTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopWorkflowInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # The remarks.
        self.comment = comment
        # The workflow instance IDs.
        # 
        # This parameter is required.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class StopWorkflowInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # The remarks.
        self.comment = comment
        # The workflow instance IDs.
        # 
        # This parameter is required.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class StopWorkflowInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The workflow instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class StopWorkflowInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopWorkflowInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopWorkflowInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitFileRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        file_id: int = None,
        project_id: int = None,
        project_identifier: str = None,
        skip_all_deploy_file_extensions: bool = None,
    ):
        self.comment = comment
        # This parameter is required.
        self.file_id = file_id
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.skip_all_deploy_file_extensions = skip_all_deploy_file_extensions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.skip_all_deploy_file_extensions is not None:
            result['SkipAllDeployFileExtensions'] = self.skip_all_deploy_file_extensions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('SkipAllDeployFileExtensions') is not None:
            self.skip_all_deploy_file_extensions = m.get('SkipAllDeployFileExtensions')
        return self


class SubmitFileResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids: List[int] = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids = ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class SuspendTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        ids_shrink: str = None,
    ):
        # Remarks.
        self.comment = comment
        # The ID list of the task instance.
        self.ids_shrink = ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.ids_shrink is not None:
            result['Ids'] = self.ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Ids') is not None:
            self.ids_shrink = m.get('Ids')
        return self


class SuspendTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class SuspendTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagDataAssetsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagDataAssetsRequest(TeaModel):
    def __init__(
        self,
        auto_trace_enabled: bool = None,
        data_asset_ids: List[str] = None,
        data_asset_type: str = None,
        env_type: str = None,
        project_id: int = None,
        tags: List[TagDataAssetsRequestTags] = None,
    ):
        # Specifies whether to enable lineage-based automatic backtracking.
        self.auto_trace_enabled = auto_trace_enabled
        # The data asset IDs.
        # 
        # This parameter is required.
        self.data_asset_ids = data_asset_ids
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        # 
        # This parameter is required.
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that you want to add to data assets.
        # 
        # This parameter is required.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_trace_enabled is not None:
            result['AutoTraceEnabled'] = self.auto_trace_enabled
        if self.data_asset_ids is not None:
            result['DataAssetIds'] = self.data_asset_ids
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoTraceEnabled') is not None:
            self.auto_trace_enabled = m.get('AutoTraceEnabled')
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = TagDataAssetsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class TagDataAssetsShrinkRequest(TeaModel):
    def __init__(
        self,
        auto_trace_enabled: bool = None,
        data_asset_ids_shrink: str = None,
        data_asset_type: str = None,
        env_type: str = None,
        project_id: int = None,
        tags_shrink: str = None,
    ):
        # Specifies whether to enable lineage-based automatic backtracking.
        self.auto_trace_enabled = auto_trace_enabled
        # The data asset IDs.
        # 
        # This parameter is required.
        self.data_asset_ids_shrink = data_asset_ids_shrink
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        # 
        # This parameter is required.
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that you want to add to data assets.
        # 
        # This parameter is required.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_trace_enabled is not None:
            result['AutoTraceEnabled'] = self.auto_trace_enabled
        if self.data_asset_ids_shrink is not None:
            result['DataAssetIds'] = self.data_asset_ids_shrink
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoTraceEnabled') is not None:
            self.auto_trace_enabled = m.get('AutoTraceEnabled')
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids_shrink = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class TagDataAssetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TagDataAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagDataAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagDataAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestDataSourceConnectivityRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        project_id: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the data source for which you want to test the network connectivity.
        # 
        # This parameter is required.
        self.data_source_id = data_source_id
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The resource group ID.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class TestDataSourceConnectivityResponseBodyConnectivityDetailLogs(TeaModel):
    def __init__(
        self,
        code: str = None,
        end_time: int = None,
        message: str = None,
        start_time: int = None,
    ):
        # The code of the test item.
        self.code = code
        # The end time of a step.
        self.end_time = end_time
        # The name of the step.
        self.message = message
        # The start time of a step.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.message is not None:
            result['Message'] = self.message
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class TestDataSourceConnectivityResponseBodyConnectivity(TeaModel):
    def __init__(
        self,
        connect_message: str = None,
        connect_state: str = None,
        detail_logs: List[TestDataSourceConnectivityResponseBodyConnectivityDetailLogs] = None,
    ):
        # The error message returned if the connectivity test fails. No such a message is returned if the connectivity test is successful.
        self.connect_message = connect_message
        # The result of the connectivity test. Valid values: Connectable: The network can be connected. ConfigError: The network can be connected, but the configurations are incorrect. Unreachable: The network cannot be connected. Unsupport: An error is reported due to other causes. For example, the desired resource group is being initialized.
        self.connect_state = connect_state
        # The detailed logs of each step in the connectivity test.
        self.detail_logs = detail_logs

    def validate(self):
        if self.detail_logs:
            for k in self.detail_logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_message is not None:
            result['ConnectMessage'] = self.connect_message
        if self.connect_state is not None:
            result['ConnectState'] = self.connect_state
        result['DetailLogs'] = []
        if self.detail_logs is not None:
            for k in self.detail_logs:
                result['DetailLogs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectMessage') is not None:
            self.connect_message = m.get('ConnectMessage')
        if m.get('ConnectState') is not None:
            self.connect_state = m.get('ConnectState')
        self.detail_logs = []
        if m.get('DetailLogs') is not None:
            for k in m.get('DetailLogs'):
                temp_model = TestDataSourceConnectivityResponseBodyConnectivityDetailLogs()
                self.detail_logs.append(temp_model.from_map(k))
        return self


class TestDataSourceConnectivityResponseBody(TeaModel):
    def __init__(
        self,
        connectivity: TestDataSourceConnectivityResponseBodyConnectivity = None,
        request_id: str = None,
    ):
        # The details of the connectivity test.
        self.connectivity = connectivity
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.connectivity:
            self.connectivity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connectivity is not None:
            result['Connectivity'] = self.connectivity.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Connectivity') is not None:
            temp_model = TestDataSourceConnectivityResponseBodyConnectivity()
            self.connectivity = temp_model.from_map(m['Connectivity'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TestDataSourceConnectivityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestDataSourceConnectivityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestDataSourceConnectivityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TriggerSchedulerTaskInstanceRequest(TeaModel):
    def __init__(
        self,
        env_type: str = None,
        task_id: int = None,
        trigger_time: int = None,
    ):
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id
        # The time defined by the HTTP Trigger node. This value is a UNIX timestamp.
        # 
        # This parameter is required.
        self.trigger_time = trigger_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trigger_time is not None:
            result['TriggerTime'] = self.trigger_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TriggerTime') is not None:
            self.trigger_time = m.get('TriggerTime')
        return self


class TriggerSchedulerTaskInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TriggerSchedulerTaskInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TriggerSchedulerTaskInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TriggerSchedulerTaskInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnTagDataAssetsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UnTagDataAssetsRequest(TeaModel):
    def __init__(
        self,
        data_asset_ids: List[str] = None,
        data_asset_type: str = None,
        env_type: str = None,
        project_id: int = None,
        tags: List[UnTagDataAssetsRequestTags] = None,
    ):
        # The data asset IDs.
        # 
        # This parameter is required.
        self.data_asset_ids = data_asset_ids
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        # 
        # This parameter is required.
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that you want to remove.
        # 
        # This parameter is required.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_asset_ids is not None:
            result['DataAssetIds'] = self.data_asset_ids
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UnTagDataAssetsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class UnTagDataAssetsShrinkRequest(TeaModel):
    def __init__(
        self,
        data_asset_ids_shrink: str = None,
        data_asset_type: str = None,
        env_type: str = None,
        project_id: int = None,
        tags_shrink: str = None,
    ):
        # The data asset IDs.
        # 
        # This parameter is required.
        self.data_asset_ids_shrink = data_asset_ids_shrink
        # The type of the data asset. Valid values:
        # 
        # *   ACS::DataWorks::Table
        # *   ACS::DataWorks::Task
        # 
        # This parameter is required.
        self.data_asset_type = data_asset_type
        # The environment of the workspace to which the data asset belongs. Valid values:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        self.env_type = env_type
        # The DataWorks workspace ID.
        self.project_id = project_id
        # The tags that you want to remove.
        # 
        # This parameter is required.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_asset_ids_shrink is not None:
            result['DataAssetIds'] = self.data_asset_ids_shrink
        if self.data_asset_type is not None:
            result['DataAssetType'] = self.data_asset_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataAssetIds') is not None:
            self.data_asset_ids_shrink = m.get('DataAssetIds')
        if m.get('DataAssetType') is not None:
            self.data_asset_type = m.get('DataAssetType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class UnTagDataAssetsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnTagDataAssetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnTagDataAssetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnTagDataAssetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertRuleRequestNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The additional configuration of the alert recipient. If the ReceiverType parameter is set to DingdingUrl, you can set this parameter to {"atAll":true} to remind all members in a DingTalk group.
        self.extension = extension
        # The type of the alert recipient. Valid valves:
        # 
        # *   AliUid: Alibaba Cloud account ID.
        # *   Shift Schedules: the personnel in a shift schedule.
        # *   TaskOwner: the task owner. The task owner can receive custom alerts and event alerts.
        # *   Owner: the baseline owner. The baseline owner can receive baseline alerts.
        # *   WebhookUrl: URL of a custom webhook.
        # *   DingdingUrl: DingTalk webhook URL.
        # *   FeishuUrl: Lark webhook URL.
        # *   WeixinUrl: WeCom webhook URL.
        self.receiver_type = receiver_type
        # The alert recipients.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class UpdateAlertRuleRequestNotification(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        interval_in_minutes: int = None,
        maximum: int = None,
        receivers: List[UpdateAlertRuleRequestNotificationReceivers] = None,
        silence_end_time: str = None,
        silence_start_time: str = None,
    ):
        # The alert notification channels.
        self.channels = channels
        # The interval at which an alert notification is sent. Unit: minutes. Valid values: [5,10000].
        self.interval_in_minutes = interval_in_minutes
        # The maximum number of times an alert notification can be sent within a calendar day. Valid values: [1, 10000].
        self.maximum = maximum
        # The alert recipients.
        self.receivers = receivers
        # The end time for silence. The time is in the HH:mm:ss format.
        self.silence_end_time = silence_end_time
        # The start time for silence. The time is in the HH:mm:ss format.
        self.silence_start_time = silence_start_time

    def validate(self):
        if self.receivers:
            for k in self.receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.interval_in_minutes is not None:
            result['IntervalInMinutes'] = self.interval_in_minutes
        if self.maximum is not None:
            result['Maximum'] = self.maximum
        result['Receivers'] = []
        if self.receivers is not None:
            for k in self.receivers:
                result['Receivers'].append(k.to_map() if k else None)
        if self.silence_end_time is not None:
            result['SilenceEndTime'] = self.silence_end_time
        if self.silence_start_time is not None:
            result['SilenceStartTime'] = self.silence_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('IntervalInMinutes') is not None:
            self.interval_in_minutes = m.get('IntervalInMinutes')
        if m.get('Maximum') is not None:
            self.maximum = m.get('Maximum')
        self.receivers = []
        if m.get('Receivers') is not None:
            for k in m.get('Receivers'):
                temp_model = UpdateAlertRuleRequestNotificationReceivers()
                self.receivers.append(temp_model.from_map(k))
        if m.get('SilenceEndTime') is not None:
            self.silence_end_time = m.get('SilenceEndTime')
        if m.get('SilenceStartTime') is not None:
            self.silence_start_time = m.get('SilenceStartTime')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime(TeaModel):
    def __init__(
        self,
        cycle_id: int = None,
        time: str = None,
    ):
        # The ID of the scheduling cycle of the instance. Valid values: [1,288].
        self.cycle_id = cycle_id
        # The latest completion time of the instance within the scheduling cycle. The time is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_id is not None:
            result['CycleId'] = self.cycle_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleId') is not None:
            self.cycle_id = m.get('CycleId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished(TeaModel):
    def __init__(
        self,
        cycle_and_time: List[UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime] = None,
    ):
        # The configurations of the scheduling cycle and timeout period of the instance.
        self.cycle_and_time = cycle_and_time

    def validate(self):
        if self.cycle_and_time:
            for k in self.cycle_and_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CycleAndTime'] = []
        if self.cycle_and_time is not None:
            for k in self.cycle_and_time:
                result['CycleAndTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cycle_and_time = []
        if m.get('CycleAndTime') is not None:
            for k in m.get('CycleAndTime'):
                temp_model = UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinishedCycleAndTime()
                self.cycle_and_time.append(temp_model.from_map(k))
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionError(TeaModel):
    def __init__(
        self,
        auto_rerun_alert_enabled: bool = None,
        stream_task_ids: List[int] = None,
    ):
        # Specifies whether to trigger an alert if a batch synchronization task is automatically rerun upon a failure.
        self.auto_rerun_alert_enabled = auto_rerun_alert_enabled
        # The IDs of the real-time computing tasks. This parameter is required when you monitor real-time computing tasks.
        self.stream_task_ids = stream_task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rerun_alert_enabled is not None:
            result['AutoRerunAlertEnabled'] = self.auto_rerun_alert_enabled
        if self.stream_task_ids is not None:
            result['StreamTaskIds'] = self.stream_task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRerunAlertEnabled') is not None:
            self.auto_rerun_alert_enabled = m.get('AutoRerunAlertEnabled')
        if m.get('StreamTaskIds') is not None:
            self.stream_task_ids = m.get('StreamTaskIds')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount(TeaModel):
    def __init__(
        self,
        count: int = None,
    ):
        # The maximum number of instances on which an error occurs. Valid values: [1,10000].
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage(TeaModel):
    def __init__(
        self,
        percentage: int = None,
    ):
        # The maximum percentage of instances on which an error occurs in the workspace to the total number of instances. Valid values: [1-100].
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate(TeaModel):
    def __init__(
        self,
        percentage: int = None,
        trend: str = None,
    ):
        # The maximum percentage of fluctuation in the number of auto triggered node instances that are generated in your workspace. Valid values: [1-100].
        self.percentage = percentage
        # The way in which the number of auto triggered node instances that are generated in your workspace fluctuates. Valid values:
        # 
        # *   abs: the absolute value. The number of instances increases or decreases.
        # *   increase: The number of instances increases.
        # *   decrease: The number of instances decreases.
        self.trend = trend

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.trend is not None:
            result['Trend'] = self.trend
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Trend') is not None:
            self.trend = m.get('Trend')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionTimeout(TeaModel):
    def __init__(
        self,
        timeout_in_minutes: int = None,
    ):
        # The timeout period. Unit: minutes.
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class UpdateAlertRuleRequestTriggerConditionExtensionUnFinished(TeaModel):
    def __init__(
        self,
        un_finished_time: str = None,
    ):
        # The latest completion time of the instance. The period is in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
        self.un_finished_time = un_finished_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.un_finished_time is not None:
            result['UnFinishedTime'] = self.un_finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UnFinishedTime') is not None:
            self.un_finished_time = m.get('UnFinishedTime')
        return self


class UpdateAlertRuleRequestTriggerConditionExtension(TeaModel):
    def __init__(
        self,
        cycle_unfinished: UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished = None,
        error: UpdateAlertRuleRequestTriggerConditionExtensionError = None,
        instance_error_count: UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount = None,
        instance_error_percentage: UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage = None,
        instance_transfer_fluctuate: UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate = None,
        timeout: UpdateAlertRuleRequestTriggerConditionExtensionTimeout = None,
        un_finished: UpdateAlertRuleRequestTriggerConditionExtensionUnFinished = None,
    ):
        # The configuration for an alert of the CycleUnfinished type.
        self.cycle_unfinished = cycle_unfinished
        # The configuration for an alert of the Error type.
        self.error = error
        # The configuration for an alert of the InstanceErrorCount type.
        self.instance_error_count = instance_error_count
        # The configuration for an alert of the InstanceErrorPercentage type.
        self.instance_error_percentage = instance_error_percentage
        # The configuration for an alert of the InstanceTransferFluctuate type.
        self.instance_transfer_fluctuate = instance_transfer_fluctuate
        # The configuration for an alert of the Timeout type.
        self.timeout = timeout
        # The configuration for an alert of the UnFinished type.
        self.un_finished = un_finished

    def validate(self):
        if self.cycle_unfinished:
            self.cycle_unfinished.validate()
        if self.error:
            self.error.validate()
        if self.instance_error_count:
            self.instance_error_count.validate()
        if self.instance_error_percentage:
            self.instance_error_percentage.validate()
        if self.instance_transfer_fluctuate:
            self.instance_transfer_fluctuate.validate()
        if self.timeout:
            self.timeout.validate()
        if self.un_finished:
            self.un_finished.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_unfinished is not None:
            result['CycleUnfinished'] = self.cycle_unfinished.to_map()
        if self.error is not None:
            result['Error'] = self.error.to_map()
        if self.instance_error_count is not None:
            result['InstanceErrorCount'] = self.instance_error_count.to_map()
        if self.instance_error_percentage is not None:
            result['InstanceErrorPercentage'] = self.instance_error_percentage.to_map()
        if self.instance_transfer_fluctuate is not None:
            result['InstanceTransferFluctuate'] = self.instance_transfer_fluctuate.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout.to_map()
        if self.un_finished is not None:
            result['UnFinished'] = self.un_finished.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleUnfinished') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionCycleUnfinished()
            self.cycle_unfinished = temp_model.from_map(m['CycleUnfinished'])
        if m.get('Error') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionError()
            self.error = temp_model.from_map(m['Error'])
        if m.get('InstanceErrorCount') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorCount()
            self.instance_error_count = temp_model.from_map(m['InstanceErrorCount'])
        if m.get('InstanceErrorPercentage') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceErrorPercentage()
            self.instance_error_percentage = temp_model.from_map(m['InstanceErrorPercentage'])
        if m.get('InstanceTransferFluctuate') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionInstanceTransferFluctuate()
            self.instance_transfer_fluctuate = temp_model.from_map(m['InstanceTransferFluctuate'])
        if m.get('Timeout') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionTimeout()
            self.timeout = temp_model.from_map(m['Timeout'])
        if m.get('UnFinished') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtensionUnFinished()
            self.un_finished = temp_model.from_map(m['UnFinished'])
        return self


class UpdateAlertRuleRequestTriggerConditionTarget(TeaModel):
    def __init__(
        self,
        allow_tasks: List[int] = None,
        ids: List[int] = None,
        type: str = None,
    ):
        # The nodes that are not to be monitored.
        self.allow_tasks = allow_tasks
        # The IDs of monitored objects.
        self.ids = ids
        # The type of the monitored objects. Valid values:
        # 
        # *   Task: node
        # *   Baseline: baseline
        # *   project: workspace
        # *   BizProcess: workflow
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_tasks is not None:
            result['AllowTasks'] = self.allow_tasks
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowTasks') is not None:
            self.allow_tasks = m.get('AllowTasks')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateAlertRuleRequestTriggerCondition(TeaModel):
    def __init__(
        self,
        extension: UpdateAlertRuleRequestTriggerConditionExtension = None,
        target: UpdateAlertRuleRequestTriggerConditionTarget = None,
        type: str = None,
    ):
        # The extended information about the rule. This parameter is required for specific types of alerts.
        self.extension = extension
        # The monitored objects.
        self.target = target
        # The alert type. Valid values:
        # 
        # *   Finished: An instance is successfully run.
        # *   UnFinished: An instance does not finish running before a specified point in time.
        # *   Error: An error occurs on an instance.
        # *   CycleUnfinished: An instance does not finish running as expected within a specific cycle.
        # *   Timeout: An instance times out.
        # *   InstanceTransferComplete: An instance is generated by the auto triggered node.
        # *   InstanceTransferFluctuate: The number of generated instances fluctuates.
        # *   ExhaustedError: An error persists after an instance is automatically rerun.
        # *   InstanceKeyword: An instance with errors contains specified keywords.
        # *   InstanceErrorCount: The number of instances on which an error occurs reaches a specified threshold.
        # *   InstanceErrorPercentage: The proportion of instances on which an error occurs in the workspace to the total number of instances reaches a specified threshold.
        # *   ResourceGroupPercentage: The usage rate of the resource group reaches a specified threshold.
        # *   ResourceGroupWaitCount: The number of instances that are waiting for resources in the resource group reaches a specified threshold.
        self.type = type

    def validate(self):
        if self.extension:
            self.extension.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension.to_map()
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionExtension()
            self.extension = temp_model.from_map(m['Extension'])
        if m.get('Target') is not None:
            temp_model = UpdateAlertRuleRequestTriggerConditionTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification: UpdateAlertRuleRequestNotification = None,
        owner: str = None,
        trigger_condition: UpdateAlertRuleRequestTriggerCondition = None,
    ):
        # Specifies whether to enable the rule.
        self.enabled = enabled
        # The rule ID.
        self.id = id
        # The name of the rule.
        self.name = name
        # The configuration for the alert notification.
        self.notification = notification
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The alert triggering condition.
        self.trigger_condition = trigger_condition

    def validate(self):
        if self.notification:
            self.notification.validate()
        if self.trigger_condition:
            self.trigger_condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition is not None:
            result['TriggerCondition'] = self.trigger_condition.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            temp_model = UpdateAlertRuleRequestNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            temp_model = UpdateAlertRuleRequestTriggerCondition()
            self.trigger_condition = temp_model.from_map(m['TriggerCondition'])
        return self


class UpdateAlertRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        id: int = None,
        name: str = None,
        notification_shrink: str = None,
        owner: str = None,
        trigger_condition_shrink: str = None,
    ):
        # Specifies whether to enable the rule.
        self.enabled = enabled
        # The rule ID.
        self.id = id
        # The name of the rule.
        self.name = name
        # The configuration for the alert notification.
        self.notification_shrink = notification_shrink
        # The ID of the Alibaba Cloud account used by the owner of the rule.
        self.owner = owner
        # The alert triggering condition.
        self.trigger_condition_shrink = trigger_condition_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_shrink is not None:
            result['Notification'] = self.notification_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.trigger_condition_shrink is not None:
            result['TriggerCondition'] = self.trigger_condition_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notification') is not None:
            self.notification_shrink = m.get('Notification')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('TriggerCondition') is not None:
            self.trigger_condition_shrink = m.get('TriggerCondition')
        return self


class UpdateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateBusinessRequest(TeaModel):
    def __init__(
        self,
        business_id: int = None,
        business_name: str = None,
        description: str = None,
        owner: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.business_id = business_id
        self.business_name = business_name
        self.description = description
        self.owner = owner
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_id is not None:
            result['BusinessId'] = self.business_id
        if self.business_name is not None:
            result['BusinessName'] = self.business_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessId') is not None:
            self.business_id = m.get('BusinessId')
        if m.get('BusinessName') is not None:
            self.business_name = m.get('BusinessName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class UpdateBusinessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateBusinessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateBusinessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateBusinessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateColumnBusinessMetadataRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpdateColumnBusinessMetadataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateColumnBusinessMetadataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateColumnBusinessMetadataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateColumnBusinessMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
        severity: str = None,
    ):
        # The alert notification method. Valid values:
        # 
        # *   Mail
        # *   Phone
        # *   Sms
        # *   Ding
        self.channels = channels
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers(TeaModel):
    def __init__(
        self,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The recipient type. Valid values: AliyunUid, DingToken, FeishuToken, and WebHookUrl.
        self.receiver_type = receiver_type
        # The recipient.
        # 
        # *   If the ReceiverType parameter is set to AliyunUid, set this parameter to the Alibaba Cloud account ID of a user.
        # *   If the ReceiverType parameter is set to DingToken, set this parameter to the token of a DingTalk chatbot.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class UpdateDIAlarmRuleRequestNotificationSettings(TeaModel):
    def __init__(
        self,
        inhibition_interval: int = None,
        mute_interval: int = None,
        notification_channels: List[UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels] = None,
        notification_receivers: List[UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers] = None,
    ):
        # This parameter is deprecated and replaced by the MuteInterval parameter.
        self.inhibition_interval = inhibition_interval
        # The duration of the alert suppression interval. Default value: 5. Unit: minutes.
        self.mute_interval = mute_interval
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The settings of alert notification recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.inhibition_interval is not None:
            result['InhibitionInterval'] = self.inhibition_interval
        if self.mute_interval is not None:
            result['MuteInterval'] = self.mute_interval
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InhibitionInterval') is not None:
            self.inhibition_interval = m.get('InhibitionInterval')
        if m.get('MuteInterval') is not None:
            self.mute_interval = m.get('MuteInterval')
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class UpdateDIAlarmRuleRequestTriggerConditions(TeaModel):
    def __init__(
        self,
        ddl_report_tags: List[str] = None,
        ddl_types: List[str] = None,
        duration: int = None,
        severity: str = None,
        threshold: int = None,
    ):
        # This parameter is deprecated and replaced by the DdlTypes parameter.
        self.ddl_report_tags = ddl_report_tags
        # The types of DDL operations for which the alert rule takes effect.
        self.ddl_types = ddl_types
        # The time interval for alert calculation. Unit: minutes.
        self.duration = duration
        # The severity level. Valid values:
        # 
        # *   Warning
        # *   Critical
        self.severity = severity
        # The alert threshold.
        # 
        # *   If the alert rule is for task status, you do not need to specify a threshold.
        # *   If the alert rule is for failovers, you must specify the number of failovers.
        # *   If the alert rule is for latency, you must specify the latency duration, in seconds.
        self.threshold = threshold

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddl_report_tags is not None:
            result['DdlReportTags'] = self.ddl_report_tags
        if self.ddl_types is not None:
            result['DdlTypes'] = self.ddl_types
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DdlReportTags') is not None:
            self.ddl_report_tags = m.get('DdlReportTags')
        if m.get('DdlTypes') is not None:
            self.ddl_types = m.get('DdlTypes')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class UpdateDIAlarmRuleRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        id: int = None,
        metric_type: str = None,
        name: str = None,
        notification_settings: UpdateDIAlarmRuleRequestNotificationSettings = None,
        trigger_conditions: List[UpdateDIAlarmRuleRequestTriggerConditions] = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The description of the alert rule.
        self.description = description
        # Specifies whether to enable the alert rule. By default, the alert rule is disabled.
        self.enabled = enabled
        # The alert rule Id
        self.id = id
        # The metric type in the alert rule. Valid values:
        # 
        # *   Heartbeat
        # *   FailoverCount
        # *   Delay
        # *   DdlReport
        # *   ResourceUtilization
        self.metric_type = metric_type
        # The name of the alert rule.
        self.name = name
        # The alert notification settings.
        self.notification_settings = notification_settings
        # The conditions that can trigger the alert rule.
        self.trigger_conditions = trigger_conditions

    def validate(self):
        if self.notification_settings:
            self.notification_settings.validate()
        if self.trigger_conditions:
            for k in self.trigger_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings is not None:
            result['NotificationSettings'] = self.notification_settings.to_map()
        result['TriggerConditions'] = []
        if self.trigger_conditions is not None:
            for k in self.trigger_conditions:
                result['TriggerConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            temp_model = UpdateDIAlarmRuleRequestNotificationSettings()
            self.notification_settings = temp_model.from_map(m['NotificationSettings'])
        self.trigger_conditions = []
        if m.get('TriggerConditions') is not None:
            for k in m.get('TriggerConditions'):
                temp_model = UpdateDIAlarmRuleRequestTriggerConditions()
                self.trigger_conditions.append(temp_model.from_map(k))
        return self


class UpdateDIAlarmRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        dialarm_rule_id: int = None,
        dijob_id: int = None,
        description: str = None,
        enabled: bool = None,
        id: int = None,
        metric_type: str = None,
        name: str = None,
        notification_settings_shrink: str = None,
        trigger_conditions_shrink: str = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dialarm_rule_id = dialarm_rule_id
        # The ID of the synchronization task.
        self.dijob_id = dijob_id
        # The description of the alert rule.
        self.description = description
        # Specifies whether to enable the alert rule. By default, the alert rule is disabled.
        self.enabled = enabled
        # The alert rule Id
        self.id = id
        # The metric type in the alert rule. Valid values:
        # 
        # *   Heartbeat
        # *   FailoverCount
        # *   Delay
        # *   DdlReport
        # *   ResourceUtilization
        self.metric_type = metric_type
        # The name of the alert rule.
        self.name = name
        # The alert notification settings.
        self.notification_settings_shrink = notification_settings_shrink
        # The conditions that can trigger the alert rule.
        self.trigger_conditions_shrink = trigger_conditions_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialarm_rule_id is not None:
            result['DIAlarmRuleId'] = self.dialarm_rule_id
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.id is not None:
            result['Id'] = self.id
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.name is not None:
            result['Name'] = self.name
        if self.notification_settings_shrink is not None:
            result['NotificationSettings'] = self.notification_settings_shrink
        if self.trigger_conditions_shrink is not None:
            result['TriggerConditions'] = self.trigger_conditions_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIAlarmRuleId') is not None:
            self.dialarm_rule_id = m.get('DIAlarmRuleId')
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotificationSettings') is not None:
            self.notification_settings_shrink = m.get('NotificationSettings')
        if m.get('TriggerConditions') is not None:
            self.trigger_conditions_shrink = m.get('TriggerConditions')
        return self


class UpdateDIAlarmRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDIAlarmRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDIAlarmRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDIAlarmRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDIJobRequestJobSettingsColumnDataTypeSettings(TeaModel):
    def __init__(
        self,
        destination_data_type: str = None,
        source_data_type: str = None,
    ):
        # The data type of the destination field. Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.destination_data_type = destination_data_type
        # The data type of the source field. Valid values: Valid values: bigint, boolean, string, text, datetime, timestamp, decimal, and binary. Different types of data sources support different data types.
        self.source_data_type = source_data_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_data_type is not None:
            result['DestinationDataType'] = self.destination_data_type
        if self.source_data_type is not None:
            result['SourceDataType'] = self.source_data_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationDataType') is not None:
            self.destination_data_type = m.get('DestinationDataType')
        if m.get('SourceDataType') is not None:
            self.source_data_type = m.get('SourceDataType')
        return self


class UpdateDIJobRequestJobSettingsCycleScheduleSettings(TeaModel):
    def __init__(
        self,
        schedule_parameters: str = None,
    ):
        # The scheduling parameters.
        self.schedule_parameters = schedule_parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.schedule_parameters is not None:
            result['ScheduleParameters'] = self.schedule_parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScheduleParameters') is not None:
            self.schedule_parameters = m.get('ScheduleParameters')
        return self


class UpdateDIJobRequestJobSettingsDdlHandlingSettings(TeaModel):
    def __init__(
        self,
        action: str = None,
        type: str = None,
    ):
        # The processing policy. Valid values:
        # 
        # *   Ignore: ignores a DDL message.
        # *   Critical: reports an error for a DDL message.
        # *   Normal: normally processes a DDL message.
        self.action = action
        # The type of the DDL operation. Valid values:
        # 
        # *   RenameColumn
        # *   ModifyColumn
        # *   CreateTable
        # *   TruncateTable
        # *   DropTable
        # *   DropColumn
        # *   AddColumn
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDIJobRequestJobSettingsRuntimeSettings(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the configuration item. Valid values:
        # 
        # *   src.offline.datasource.max.connection: specifies the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
        # *   dst.offline.truncate: specifies whether to clear the destination table before data writing.
        # *   runtime.offline.speed.limit.enable: specifies whether throttling is enabled for a batch synchronization task.
        # *   runtime.offline.concurrent: specifies the maximum number of parallel threads that are allowed for a batch synchronization task.
        # *   runtime.enable.auto.create.schema: specifies whether schemas are automatically created in the destination of a synchronization task.
        # *   runtime.realtime.concurrent: specifies the maximum number of parallel threads that are allowed for a real-time synchronization task.
        # *   runtime.realtime.failover.minute.dataxcdc: specifies the maximum waiting duration before a synchronization task retries the next restart if the previous restart fails after failover occurs. Unit: minutes.
        # *   runtime.realtime.failover.times.dataxcdc: specifies the maximum number of failures that are allowed for restarting a synchronization task after failovers occur.
        self.name = name
        # The value of the configuration item.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDIJobRequestJobSettings(TeaModel):
    def __init__(
        self,
        channel_settings: str = None,
        column_data_type_settings: List[UpdateDIJobRequestJobSettingsColumnDataTypeSettings] = None,
        cycle_schedule_settings: UpdateDIJobRequestJobSettingsCycleScheduleSettings = None,
        ddl_handling_settings: List[UpdateDIJobRequestJobSettingsDdlHandlingSettings] = None,
        runtime_settings: List[UpdateDIJobRequestJobSettingsRuntimeSettings] = None,
    ):
        # The channel control settings for the synchronization task. You can configure special channel control settings for the following synchronization links: data synchronization between Hologres data sources and data synchronization from Hologres to Kafka.
        # 
        # 1.  Holo2Kafka
        # 
        # *   Example: {"destinationChannelSettings":{"kafkaClientProperties":[{"key":"linger.ms","value":"100"}],"keyColumns":["col3"],"writeMode":"canal"}}
        # *   kafkaClientProperties: the parameters related to a Kafka producer, which are used when you read data from a Kafka data source.
        # *   keyColumns: the names of Kafka columns to which you want to write data.
        # *   writeMode: the writing format. Valid values: json and canal.
        # 
        # 2.  Holo2Holo
        # 
        # *   Example: {"destinationChannelSettings":{"conflictMode":"replace","dynamicColumnAction":"replay","writeMode":"replay"}}
        # *   conflictMode: the policy used to handle a conflict that occurs during data writing to Hologres. Valid values: replace and ignore.
        # *   writeMode: the mode in which you want to write data to Hologres. Valid values: replay and insert.
        # *   dynamicColumnAction: the mode in which you want to write data to dynamic columns in a Hologres table. Valid values: replay, insert, and ignore.
        self.channel_settings = channel_settings
        # The data type mappings between source fields and destination fields.
        # 
        # >  "ColumnDataTypeSettings":[ { "SourceDataType":"Bigint", "DestinationDataType":"Text" } ]
        self.column_data_type_settings = column_data_type_settings
        # The settings for periodic scheduling.
        self.cycle_schedule_settings = cycle_schedule_settings
        # The processing settings for DDL messages.
        # 
        # >  "DDLHandlingSettings":[ { "Type":"Insert", "Action":"Normal" } ]
        self.ddl_handling_settings = ddl_handling_settings
        # The runtime settings.
        self.runtime_settings = runtime_settings

    def validate(self):
        if self.column_data_type_settings:
            for k in self.column_data_type_settings:
                if k:
                    k.validate()
        if self.cycle_schedule_settings:
            self.cycle_schedule_settings.validate()
        if self.ddl_handling_settings:
            for k in self.ddl_handling_settings:
                if k:
                    k.validate()
        if self.runtime_settings:
            for k in self.runtime_settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_settings is not None:
            result['ChannelSettings'] = self.channel_settings
        result['ColumnDataTypeSettings'] = []
        if self.column_data_type_settings is not None:
            for k in self.column_data_type_settings:
                result['ColumnDataTypeSettings'].append(k.to_map() if k else None)
        if self.cycle_schedule_settings is not None:
            result['CycleScheduleSettings'] = self.cycle_schedule_settings.to_map()
        result['DdlHandlingSettings'] = []
        if self.ddl_handling_settings is not None:
            for k in self.ddl_handling_settings:
                result['DdlHandlingSettings'].append(k.to_map() if k else None)
        result['RuntimeSettings'] = []
        if self.runtime_settings is not None:
            for k in self.runtime_settings:
                result['RuntimeSettings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelSettings') is not None:
            self.channel_settings = m.get('ChannelSettings')
        self.column_data_type_settings = []
        if m.get('ColumnDataTypeSettings') is not None:
            for k in m.get('ColumnDataTypeSettings'):
                temp_model = UpdateDIJobRequestJobSettingsColumnDataTypeSettings()
                self.column_data_type_settings.append(temp_model.from_map(k))
        if m.get('CycleScheduleSettings') is not None:
            temp_model = UpdateDIJobRequestJobSettingsCycleScheduleSettings()
            self.cycle_schedule_settings = temp_model.from_map(m['CycleScheduleSettings'])
        self.ddl_handling_settings = []
        if m.get('DdlHandlingSettings') is not None:
            for k in m.get('DdlHandlingSettings'):
                temp_model = UpdateDIJobRequestJobSettingsDdlHandlingSettings()
                self.ddl_handling_settings.append(temp_model.from_map(k))
        self.runtime_settings = []
        if m.get('RuntimeSettings') is not None:
            for k in m.get('RuntimeSettings'):
                temp_model = UpdateDIJobRequestJobSettingsRuntimeSettings()
                self.runtime_settings.append(temp_model.from_map(k))
        return self


class UpdateDIJobRequestResourceSettingsOfflineResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of compute units (CUs) in the resource group for Data Integration that are used for batch synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for Data Integration used for batch synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettingsRealtimeResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for Data Integration that are used for real-time synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for Data Integration used for real-time synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettingsScheduleResourceSettings(TeaModel):
    def __init__(
        self,
        requested_cu: float = None,
        resource_group_identifier: str = None,
    ):
        # The number of CUs in the resource group for scheduling that are used for batch synchronization.
        self.requested_cu = requested_cu
        # The name of the resource group for scheduling used for batch synchronization.
        self.resource_group_identifier = resource_group_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.requested_cu is not None:
            result['RequestedCu'] = self.requested_cu
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestedCu') is not None:
            self.requested_cu = m.get('RequestedCu')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        return self


class UpdateDIJobRequestResourceSettings(TeaModel):
    def __init__(
        self,
        offline_resource_settings: UpdateDIJobRequestResourceSettingsOfflineResourceSettings = None,
        realtime_resource_settings: UpdateDIJobRequestResourceSettingsRealtimeResourceSettings = None,
        schedule_resource_settings: UpdateDIJobRequestResourceSettingsScheduleResourceSettings = None,
    ):
        # The resource used for batch synchronization.
        self.offline_resource_settings = offline_resource_settings
        # The resource used for real-time synchronization.
        self.realtime_resource_settings = realtime_resource_settings
        # The resource used for scheduling.
        self.schedule_resource_settings = schedule_resource_settings

    def validate(self):
        if self.offline_resource_settings:
            self.offline_resource_settings.validate()
        if self.realtime_resource_settings:
            self.realtime_resource_settings.validate()
        if self.schedule_resource_settings:
            self.schedule_resource_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_resource_settings is not None:
            result['OfflineResourceSettings'] = self.offline_resource_settings.to_map()
        if self.realtime_resource_settings is not None:
            result['RealtimeResourceSettings'] = self.realtime_resource_settings.to_map()
        if self.schedule_resource_settings is not None:
            result['ScheduleResourceSettings'] = self.schedule_resource_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OfflineResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsOfflineResourceSettings()
            self.offline_resource_settings = temp_model.from_map(m['OfflineResourceSettings'])
        if m.get('RealtimeResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsRealtimeResourceSettings()
            self.realtime_resource_settings = temp_model.from_map(m['RealtimeResourceSettings'])
        if m.get('ScheduleResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettingsScheduleResourceSettings()
            self.schedule_resource_settings = temp_model.from_map(m['ScheduleResourceSettings'])
        return self


class UpdateDIJobRequestTableMappingsSourceObjectSelectionRules(TeaModel):
    def __init__(
        self,
        action: str = None,
        expression: str = None,
        expression_type: str = None,
        object_type: str = None,
    ):
        # The operation that is performed to select objects. Valid values: Include and Exclude.
        self.action = action
        # The expression.
        self.expression = expression
        # The expression type. Valid values: Exact and Regex.
        self.expression_type = expression_type
        # The object type. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.object_type = object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_type is not None:
            result['ExpressionType'] = self.expression_type
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionType') is not None:
            self.expression_type = m.get('ExpressionType')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        return self


class UpdateDIJobRequestTableMappingsTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        self.rule_action_type = rule_action_type
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which you want to perform the action. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class UpdateDIJobRequestTableMappings(TeaModel):
    def __init__(
        self,
        source_object_selection_rules: List[UpdateDIJobRequestTableMappingsSourceObjectSelectionRules] = None,
        transformation_rules: List[UpdateDIJobRequestTableMappingsTransformationRules] = None,
    ):
        # The list of rules that you want to use to select synchronization objects in the source.
        self.source_object_selection_rules = source_object_selection_rules
        # The transformation rules that you want to apply to the synchronization objects selected from the source.
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.source_object_selection_rules:
            for k in self.source_object_selection_rules:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SourceObjectSelectionRules'] = []
        if self.source_object_selection_rules is not None:
            for k in self.source_object_selection_rules:
                result['SourceObjectSelectionRules'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.source_object_selection_rules = []
        if m.get('SourceObjectSelectionRules') is not None:
            for k in m.get('SourceObjectSelectionRules'):
                temp_model = UpdateDIJobRequestTableMappingsSourceObjectSelectionRules()
                self.source_object_selection_rules.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = UpdateDIJobRequestTableMappingsTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class UpdateDIJobRequestTransformationRules(TeaModel):
    def __init__(
        self,
        rule_action_type: str = None,
        rule_expression: str = None,
        rule_name: str = None,
        rule_target_type: str = None,
    ):
        # The action type. Valid values:
        # 
        # *   DefinePrimaryKey
        # *   Rename
        # *   AddColumn
        # *   HandleDml
        # *   DefineIncrementalCondition
        # *   DefineCycleScheduleSettings
        # *   DefinePartitionKey
        self.rule_action_type = rule_action_type
        # The expression of the rule. The expression must be a JSON string.
        # 
        # 1.  Example of a renaming rule
        # 
        # *   Example: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922" }
        # *   expression: the expression of the renaming rule. You can use the following variables in an expression: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} specifies the name of the source. ${srcDatabaseName} specifies the name of a source database. ${srcTableName} specifies the name of a source table.
        # 
        # 2.  Example of a column addition rule
        # 
        # *   Example: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}
        # *   If you do not configure such a rule, no fields are added to the destination and no values are assigned by default.
        # *   columnName: the name of the field that is added.
        # *   columnValueType: the value type of the field. Valid values: Constant and Variable.
        # *   columnValue: the value of the field. If the columnValueType parameter is set to Constant, set the columnValue parameter to a constant of the STRING data type. If the columnValueType parameter is set to Variable, set the columnValue parameter to a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME specifies the execution time. DB_NAME_SRC specifies the name of a source database. DATASOURCE_NAME_SRC specifies the name of the source. TABLE_NAME_SRC specifies the name of a source table. DB_NAME_DEST specifies the name of a destination database. DATASOURCE_NAME_DEST specifies the name of the destination. TABLE_NAME_DEST specifies the name of a destination table. DB_NAME_SRC_TRANSED specifies the database name obtained after a transformation.
        # 
        # 3.  Example of a rule used to specify primary key fields for a destination table
        # 
        # *   Example: {"columns":["ukcolumn1","ukcolumn2"]}
        # *   If you do not configure such a rule, the primary key fields in the mapped source table are used for the destination table by default.
        # *   If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # *   If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
        # 
        # 4.  Example of a rule used to process DML messages
        # 
        # *   Example: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}
        # *   If you do not configure such a rule, the default processing policy for messages generated for insert, update, and delete operations is Normal.
        # *   dmlType: the DML operation. Valid values: Insert, Update, and Delete.
        # *   dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. You can set the dmlAction parameter to Filter only when the dmlType parameter is set to Update or Delete.
        # *   filterCondition: the condition used to filter DML messages. This parameter is required only when the dmlAction parameter is set to Filter.
        # 
        # 5.  Example of a rule used to perform incremental synchronization
        # 
        # *   Example: {"where":"id > 0"}
        # *   You can configure such a rule to perform incremental synchronization.
        # 
        # 6.  Example of a rule used to configure scheduling parameters for an auto triggered task
        # 
        # *   Example: {"cronExpress":" \\* \\* \\* \\* \\* \\*", "cycleType":"1"}
        # *   You can configure such a rule to configure scheduling parameters for an auto triggered task.
        # 
        # 7.  Example of a rule used to specify a partition key
        # 
        # *   Example: {"columns":["id"]}
        # *   You can configure such a rule to specify a partition key.
        self.rule_expression = rule_expression
        # The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
        self.rule_name = rule_name
        # The type of the object on which you want to perform the action. Valid values:
        # 
        # *   Table
        # *   Schema
        # *   Database
        self.rule_target_type = rule_target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_action_type is not None:
            result['RuleActionType'] = self.rule_action_type
        if self.rule_expression is not None:
            result['RuleExpression'] = self.rule_expression
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_target_type is not None:
            result['RuleTargetType'] = self.rule_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleActionType') is not None:
            self.rule_action_type = m.get('RuleActionType')
        if m.get('RuleExpression') is not None:
            self.rule_expression = m.get('RuleExpression')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleTargetType') is not None:
            self.rule_target_type = m.get('RuleTargetType')
        return self


class UpdateDIJobRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        description: str = None,
        id: int = None,
        job_settings: UpdateDIJobRequestJobSettings = None,
        project_id: int = None,
        resource_settings: UpdateDIJobRequestResourceSettings = None,
        table_mappings: List[UpdateDIJobRequestTableMappings] = None,
        transformation_rules: List[UpdateDIJobRequestTransformationRules] = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The description of the synchronization task.
        self.description = description
        # The ID of the synchronization task.
        self.id = id
        # The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
        self.job_settings = job_settings
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the operation is applied.
        self.project_id = project_id
        # The resource settings.
        self.resource_settings = resource_settings
        # The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
        # 
        # >  [ { "SourceObjectSelectionRules":[ { "ObjectType":"Database", "Action":"Include", "ExpressionType":"Exact", "Expression":"biz_db" }, { "ObjectType":"Schema", "Action":"Include", "ExpressionType":"Exact", "Expression":"s1" }, { "ObjectType":"Table", "Action":"Include", "ExpressionType":"Exact", "Expression":"table1" } ], "TransformationRuleNames":[ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema" } ] } ]
        self.table_mappings = table_mappings
        # The list of transformation rules for objects involved in the synchronization task.
        # 
        # >  [ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema", "RuleExpression":"{"expression":"${srcDatasoureName}_${srcDatabaseName}"}" } ]
        self.transformation_rules = transformation_rules

    def validate(self):
        if self.job_settings:
            self.job_settings.validate()
        if self.resource_settings:
            self.resource_settings.validate()
        if self.table_mappings:
            for k in self.table_mappings:
                if k:
                    k.validate()
        if self.transformation_rules:
            for k in self.transformation_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.job_settings is not None:
            result['JobSettings'] = self.job_settings.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings is not None:
            result['ResourceSettings'] = self.resource_settings.to_map()
        result['TableMappings'] = []
        if self.table_mappings is not None:
            for k in self.table_mappings:
                result['TableMappings'].append(k.to_map() if k else None)
        result['TransformationRules'] = []
        if self.transformation_rules is not None:
            for k in self.transformation_rules:
                result['TransformationRules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JobSettings') is not None:
            temp_model = UpdateDIJobRequestJobSettings()
            self.job_settings = temp_model.from_map(m['JobSettings'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            temp_model = UpdateDIJobRequestResourceSettings()
            self.resource_settings = temp_model.from_map(m['ResourceSettings'])
        self.table_mappings = []
        if m.get('TableMappings') is not None:
            for k in m.get('TableMappings'):
                temp_model = UpdateDIJobRequestTableMappings()
                self.table_mappings.append(temp_model.from_map(k))
        self.transformation_rules = []
        if m.get('TransformationRules') is not None:
            for k in m.get('TransformationRules'):
                temp_model = UpdateDIJobRequestTransformationRules()
                self.transformation_rules.append(temp_model.from_map(k))
        return self


class UpdateDIJobShrinkRequest(TeaModel):
    def __init__(
        self,
        dijob_id: int = None,
        description: str = None,
        id: int = None,
        job_settings_shrink: str = None,
        project_id: int = None,
        resource_settings_shrink: str = None,
        table_mappings_shrink: str = None,
        transformation_rules_shrink: str = None,
    ):
        # This parameter is deprecated. Use the Id parameter instead.
        self.dijob_id = dijob_id
        # The description of the synchronization task.
        self.description = description
        # The ID of the synchronization task.
        self.id = id
        # The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
        self.job_settings_shrink = job_settings_shrink
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
        # 
        # You must configure this parameter to specify the DataWorks workspace to which the operation is applied.
        self.project_id = project_id
        # The resource settings.
        self.resource_settings_shrink = resource_settings_shrink
        # The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
        # 
        # >  [ { "SourceObjectSelectionRules":[ { "ObjectType":"Database", "Action":"Include", "ExpressionType":"Exact", "Expression":"biz_db" }, { "ObjectType":"Schema", "Action":"Include", "ExpressionType":"Exact", "Expression":"s1" }, { "ObjectType":"Table", "Action":"Include", "ExpressionType":"Exact", "Expression":"table1" } ], "TransformationRuleNames":[ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema" } ] } ]
        self.table_mappings_shrink = table_mappings_shrink
        # The list of transformation rules for objects involved in the synchronization task.
        # 
        # >  [ { "RuleName":"my_database_rename_rule", "RuleActionType":"Rename", "RuleTargetType":"Schema", "RuleExpression":"{"expression":"${srcDatasoureName}_${srcDatabaseName}"}" } ]
        self.transformation_rules_shrink = transformation_rules_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dijob_id is not None:
            result['DIJobId'] = self.dijob_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.job_settings_shrink is not None:
            result['JobSettings'] = self.job_settings_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_settings_shrink is not None:
            result['ResourceSettings'] = self.resource_settings_shrink
        if self.table_mappings_shrink is not None:
            result['TableMappings'] = self.table_mappings_shrink
        if self.transformation_rules_shrink is not None:
            result['TransformationRules'] = self.transformation_rules_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DIJobId') is not None:
            self.dijob_id = m.get('DIJobId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JobSettings') is not None:
            self.job_settings_shrink = m.get('JobSettings')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceSettings') is not None:
            self.resource_settings_shrink = m.get('ResourceSettings')
        if m.get('TableMappings') is not None:
            self.table_mappings_shrink = m.get('TableMappings')
        if m.get('TransformationRules') is not None:
            self.transformation_rules_shrink = m.get('TransformationRules')
        return self


class UpdateDIJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDIJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDIJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDIJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataAssetTagRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        managers: List[str] = None,
        values: List[str] = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag administrators.
        self.managers = managers
        # The tag values.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.managers is not None:
            result['Managers'] = self.managers
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Managers') is not None:
            self.managers = m.get('Managers')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class UpdateDataAssetTagShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        managers_shrink: str = None,
        values_shrink: str = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag administrators.
        self.managers_shrink = managers_shrink
        # The tag values.
        self.values_shrink = values_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.managers_shrink is not None:
            result['Managers'] = self.managers_shrink
        if self.values_shrink is not None:
            result['Values'] = self.values_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Managers') is not None:
            self.managers_shrink = m.get('Managers')
        if m.get('Values') is not None:
            self.values_shrink = m.get('Values')
        return self


class UpdateDataAssetTagResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataAssetTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataAssetTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataAssetTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # If the template specified by the TemplateCode parameter is about fluctuation, you must use an expression to represent the threshold for fluctuation. Examples:
        # 
        # *   $checkValue > 0.01
        # *   $checkValue < -0.01
        # *   abs($checkValue) > 0.01
        # 
        # If the template specified by the TemplateCode parameter is about fixed value, you can also use an expression to represent the threshold. If you configure the Expression, Operator, and Value parameters for the threshold at the same time, the Expression parameter takes precedence over the Operator and Value parameters.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical = None,
        expected: UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected = None,
        warned: UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain specific types of thresholds, you must query reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fluctation
        # *   Auto
        # *   FluctationDiscreate
        # *   Average
        # *   Fixed
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If you define the rule by using custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: specifies that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class UpdateDataQualityEvaluationTaskRequestDataQualityRules(TeaModel):
    def __init__(
        self,
        checking_config: UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers] = None,
        id: int = None,
        name: str = None,
        sampling_config: UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig = None,
        severity: str = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule.
        self.description = description
        # Specifies whether to enable the rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to query the ID of the monitoring rule.
        self.id = id
        # The name of the monitoring rule.
        self.name = name
        # The parameters required for sampling.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SamplingConfig') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRulesSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class UpdateDataQualityEvaluationTaskRequestHooks(TeaModel):
    def __init__(
        self,
        condition: str = None,
        type: str = None,
    ):
        # The hook trigger condition. When this condition is met, the hook action is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The hook type. Valid values:
        # 
        # *   BlockTaskInstance: Blocks the running of scheduling tasks.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels(TeaModel):
    def __init__(
        self,
        channels: List[str] = None,
    ):
        # The alert notification methods.
        self.channels = channels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        return self


class UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers(TeaModel):
    def __init__(
        self,
        extension: str = None,
        receiver_type: str = None,
        receiver_values: List[str] = None,
    ):
        # The additional parameters that are required when alerts are sent. The parameters are JSON-formatted strings. The following keys are supported:
        # 
        # *   atAll: specifies that all members in a group are mentioned when alerts are sent by using DingTalk. This parameter is valid only if you set ReceiverType to DingdingUrl.
        self.extension = extension
        # The type of the alert recipient.
        # 
        # Valid values:
        # 
        # *   WebhookUrl
        # *   FeishuUrl
        # *   DingdingUrl
        # *   WeixinUrl
        # *   AliUid
        self.receiver_type = receiver_type
        # The alert recipient.
        self.receiver_values = receiver_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.receiver_type is not None:
            result['ReceiverType'] = self.receiver_type
        if self.receiver_values is not None:
            result['ReceiverValues'] = self.receiver_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('ReceiverType') is not None:
            self.receiver_type = m.get('ReceiverType')
        if m.get('ReceiverValues') is not None:
            self.receiver_values = m.get('ReceiverValues')
        return self


class UpdateDataQualityEvaluationTaskRequestNotificationsNotifications(TeaModel):
    def __init__(
        self,
        notification_channels: List[UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels] = None,
        notification_receivers: List[UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers] = None,
    ):
        # The alert notification methods.
        self.notification_channels = notification_channels
        # The configurations of alert recipients.
        self.notification_receivers = notification_receivers

    def validate(self):
        if self.notification_channels:
            for k in self.notification_channels:
                if k:
                    k.validate()
        if self.notification_receivers:
            for k in self.notification_receivers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationChannels'] = []
        if self.notification_channels is not None:
            for k in self.notification_channels:
                result['NotificationChannels'].append(k.to_map() if k else None)
        result['NotificationReceivers'] = []
        if self.notification_receivers is not None:
            for k in self.notification_receivers:
                result['NotificationReceivers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_channels = []
        if m.get('NotificationChannels') is not None:
            for k in m.get('NotificationChannels'):
                temp_model = UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationChannels()
                self.notification_channels.append(temp_model.from_map(k))
        self.notification_receivers = []
        if m.get('NotificationReceivers') is not None:
            for k in m.get('NotificationReceivers'):
                temp_model = UpdateDataQualityEvaluationTaskRequestNotificationsNotificationsNotificationReceivers()
                self.notification_receivers.append(temp_model.from_map(k))
        return self


class UpdateDataQualityEvaluationTaskRequestNotifications(TeaModel):
    def __init__(
        self,
        condition: str = None,
        notifications: List[UpdateDataQualityEvaluationTaskRequestNotificationsNotifications] = None,
    ):
        # The notification trigger condition. When this condition is met, the alert notification is triggered. Only two conditional expressions are supported:
        # 
        # *   Specify only one group of rule strength type and rule check status, such as `${severity} == "High" AND ${status} == "Critical"`. In this expression, the hook trigger condition is met if severity is High and status is Critical.
        # *   Specify multiple groups of rule strength types and rule check status, such as `(${severity} == "High" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Critical") OR (${severity} == "Normal" AND ${status} == "Error")`. In this expression, the hook trigger condition is met if severity is High and status is Critical, severity is Normal and status is Critical, or severity is Normal and status is Error. The enumeration of severity in a conditional expression is the same as the enumeration of severity in DataQualityRule. The enumeration of status in a conditional expression is the same as the enumeration of status in DataQualityResult.
        self.condition = condition
        # The configurations of the alert notification.
        self.notifications = notifications

    def validate(self):
        if self.notifications:
            for k in self.notifications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['Condition'] = self.condition
        result['Notifications'] = []
        if self.notifications is not None:
            for k in self.notifications:
                result['Notifications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        self.notifications = []
        if m.get('Notifications') is not None:
            for k in m.get('Notifications'):
                temp_model = UpdateDataQualityEvaluationTaskRequestNotificationsNotifications()
                self.notifications.append(temp_model.from_map(k))
        return self


class UpdateDataQualityEvaluationTaskRequestTarget(TeaModel):
    def __init__(
        self,
        database_type: str = None,
        partition_spec: str = None,
        table_guid: str = None,
    ):
        # The type of the database to which the table belongs. Valid values:
        # 
        # *   maxcompute
        # *   hologres
        # *   cdh
        # *   analyticdb_for_mysql
        # *   starrocks
        # *   emr
        # *   analyticdb_for_postgresql
        self.database_type = database_type
        # The configuration of the partitioned table.
        self.partition_spec = partition_spec
        # The ID of the table in Data Map.
        self.table_guid = table_guid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_type is not None:
            result['DatabaseType'] = self.database_type
        if self.partition_spec is not None:
            result['PartitionSpec'] = self.partition_spec
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseType') is not None:
            self.database_type = m.get('DatabaseType')
        if m.get('PartitionSpec') is not None:
            self.partition_spec = m.get('PartitionSpec')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        return self


class UpdateDataQualityEvaluationTaskRequestTrigger(TeaModel):
    def __init__(
        self,
        task_ids: List[int] = None,
        type: str = None,
    ):
        # The IDs of scheduling tasks. This parameter is valid only if you set Type to ByScheduledTaskInstance.
        self.task_ids = task_ids
        # The trigger type of the monitor. Valid values:
        # 
        # *   ByScheduledTaskInstance: The monitor is triggered by the associated scheduling tasks.
        # *   ByManual: The monitor is manually triggered.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityEvaluationTaskRequest(TeaModel):
    def __init__(
        self,
        data_quality_rules: List[UpdateDataQualityEvaluationTaskRequestDataQualityRules] = None,
        data_source_id: int = None,
        description: str = None,
        hooks: List[UpdateDataQualityEvaluationTaskRequestHooks] = None,
        id: int = None,
        name: str = None,
        notifications: UpdateDataQualityEvaluationTaskRequestNotifications = None,
        project_id: int = None,
        runtime_conf: str = None,
        target: UpdateDataQualityEvaluationTaskRequestTarget = None,
        trigger: UpdateDataQualityEvaluationTaskRequestTrigger = None,
    ):
        # The list of monitoring rules that are associated with the monitor.
        self.data_quality_rules = data_quality_rules
        # The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
        self.data_source_id = data_source_id
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks = hooks
        # The ID of the monitor.
        # 
        # This parameter is required.
        self.id = id
        # The name of the monitor.
        self.name = name
        # The configurations of alert notifications.
        self.notifications = notifications
        # The ID of the DataWorks workspace.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The extended configurations in JSON-formatted strings. You can use this parameter only for monitors that are used to monitor the quality of E-MapReduce (EMR) data.
        # 
        # *   queue: The Yarn queue used when a monitor checks the quality of EMR data. By default, the queue configured for the current workspace is used.
        # 
        # *   sqlEngine: The SQL engine used when a monitor checks the quality of EMR data.
        # 
        #     *   HIVE_SQL
        #     *   SPARK_SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the data quality monitoring task.
        self.target = target
        # The trigger configuration of the monitor.
        self.trigger = trigger

    def validate(self):
        if self.data_quality_rules:
            for k in self.data_quality_rules:
                if k:
                    k.validate()
        if self.hooks:
            for k in self.hooks:
                if k:
                    k.validate()
        if self.notifications:
            self.notifications.validate()
        if self.target:
            self.target.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataQualityRules'] = []
        if self.data_quality_rules is not None:
            for k in self.data_quality_rules:
                result['DataQualityRules'].append(k.to_map() if k else None)
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        result['Hooks'] = []
        if self.hooks is not None:
            for k in self.hooks:
                result['Hooks'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications is not None:
            result['Notifications'] = self.notifications.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target is not None:
            result['Target'] = self.target.to_map()
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_quality_rules = []
        if m.get('DataQualityRules') is not None:
            for k in m.get('DataQualityRules'):
                temp_model = UpdateDataQualityEvaluationTaskRequestDataQualityRules()
                self.data_quality_rules.append(temp_model.from_map(k))
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.hooks = []
        if m.get('Hooks') is not None:
            for k in m.get('Hooks'):
                temp_model = UpdateDataQualityEvaluationTaskRequestHooks()
                self.hooks.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestNotifications()
            self.notifications = temp_model.from_map(m['Notifications'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestTarget()
            self.target = temp_model.from_map(m['Target'])
        if m.get('Trigger') is not None:
            temp_model = UpdateDataQualityEvaluationTaskRequestTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class UpdateDataQualityEvaluationTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        data_quality_rules_shrink: str = None,
        data_source_id: int = None,
        description: str = None,
        hooks_shrink: str = None,
        id: int = None,
        name: str = None,
        notifications_shrink: str = None,
        project_id: int = None,
        runtime_conf: str = None,
        target_shrink: str = None,
        trigger_shrink: str = None,
    ):
        # The list of monitoring rules that are associated with the monitor.
        self.data_quality_rules_shrink = data_quality_rules_shrink
        # The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
        self.data_source_id = data_source_id
        # The description of the monitor.
        self.description = description
        # The hook.
        self.hooks_shrink = hooks_shrink
        # The ID of the monitor.
        # 
        # This parameter is required.
        self.id = id
        # The name of the monitor.
        self.name = name
        # The configurations of alert notifications.
        self.notifications_shrink = notifications_shrink
        # The ID of the DataWorks workspace.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The extended configurations in JSON-formatted strings. You can use this parameter only for monitors that are used to monitor the quality of E-MapReduce (EMR) data.
        # 
        # *   queue: The Yarn queue used when a monitor checks the quality of EMR data. By default, the queue configured for the current workspace is used.
        # 
        # *   sqlEngine: The SQL engine used when a monitor checks the quality of EMR data.
        # 
        #     *   HIVE_SQL
        #     *   SPARK_SQL
        self.runtime_conf = runtime_conf
        # The monitored object of the data quality monitoring task.
        self.target_shrink = target_shrink
        # The trigger configuration of the monitor.
        self.trigger_shrink = trigger_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_quality_rules_shrink is not None:
            result['DataQualityRules'] = self.data_quality_rules_shrink
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.hooks_shrink is not None:
            result['Hooks'] = self.hooks_shrink
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.notifications_shrink is not None:
            result['Notifications'] = self.notifications_shrink
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.runtime_conf is not None:
            result['RuntimeConf'] = self.runtime_conf
        if self.target_shrink is not None:
            result['Target'] = self.target_shrink
        if self.trigger_shrink is not None:
            result['Trigger'] = self.trigger_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataQualityRules') is not None:
            self.data_quality_rules_shrink = m.get('DataQualityRules')
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Hooks') is not None:
            self.hooks_shrink = m.get('Hooks')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Notifications') is not None:
            self.notifications_shrink = m.get('Notifications')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RuntimeConf') is not None:
            self.runtime_conf = m.get('RuntimeConf')
        if m.get('Target') is not None:
            self.target_shrink = m.get('Target')
        if m.get('Trigger') is not None:
            self.trigger_shrink = m.get('Trigger')
        return self


class UpdateDataQualityEvaluationTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataQualityEvaluationTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataQualityEvaluationTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataQualityEvaluationTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # The volatility type rule must use an expression to represent the volatility threshold. For example:
        # 
        # - Fluctuation rise greater than 0.01: $checkValue > 0.01
        # - Fluctuation drop greater than 0.01:$checkValue < -0.01
        # - Absolute volatility: abs($checkValue) > 0.01
        # 
        # You can also use expressions to configure thresholds for fixed-Value rules. If you configure them at the same time, the expression priority is higher than Operator and Value.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # The volatility type rule must use an expression to represent the volatility threshold. For example:
        # 
        # - Fluctuation rise greater than 0.01: $checkValue > 0.01
        # - Fluctuation drop greater than 0.01:$checkValue < -0.01
        # - Absolute volatility: abs($checkValue) > 0.01
        # 
        # You can also use expressions to configure thresholds for fixed-Value rules. If you configure them at the same time, the expression priority is higher than Operator and Value.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned(TeaModel):
    def __init__(
        self,
        expression: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The threshold expression.
        # 
        # The volatility type rule must use an expression to represent the volatility threshold. For example:
        # 
        # - Fluctuation rise greater than 0.01: $checkValue > 0.01
        # - Fluctuation drop greater than 0.01:$checkValue < -0.01
        # - Absolute volatility: abs($checkValue) > 0.01
        # 
        # You can also use expressions to configure thresholds for fixed-Value rules. If you configure them at the same time, the expression priority is higher than Operator and Value.
        self.expression = expression
        # The comparison operator. Valid values:
        # 
        # *   \\>
        # *   \\>=\
        # *   <
        # *   <=\
        # *   !=\
        # *   \\=\
        self.operator = operator
        # The threshold value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateDataQualityRuleRequestCheckingConfigThresholds(TeaModel):
    def __init__(
        self,
        critical: UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical = None,
        expected: UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected = None,
        warned: UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned = None,
    ):
        # The threshold settings for critical alerts.
        self.critical = critical
        # The expected threshold setting.
        self.expected = expected
        # The threshold settings for normal alerts.
        self.warned = warned

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.expected:
            self.expected.validate()
        if self.warned:
            self.warned.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.expected is not None:
            result['Expected'] = self.expected.to_map()
        if self.warned is not None:
            result['Warned'] = self.warned.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = UpdateDataQualityRuleRequestCheckingConfigThresholdsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Expected') is not None:
            temp_model = UpdateDataQualityRuleRequestCheckingConfigThresholdsExpected()
            self.expected = temp_model.from_map(m['Expected'])
        if m.get('Warned') is not None:
            temp_model = UpdateDataQualityRuleRequestCheckingConfigThresholdsWarned()
            self.warned = temp_model.from_map(m['Warned'])
        return self


class UpdateDataQualityRuleRequestCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        thresholds: UpdateDataQualityRuleRequestCheckingConfigThresholds = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The threshold settings.
        self.thresholds = thresholds
        # The threshold calculation method. Valid values:
        # 
        # *   Fixed
        # *   Fluctation
        # *   FluctationDiscreate
        # *   Auto
        # *   Average
        # *   Variance
        self.type = type

    def validate(self):
        if self.thresholds:
            self.thresholds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.thresholds is not None:
            result['Thresholds'] = self.thresholds.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Thresholds') is not None:
            temp_model = UpdateDataQualityRuleRequestCheckingConfigThresholds()
            self.thresholds = temp_model.from_map(m['Thresholds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityRuleRequestErrorHandlers(TeaModel):
    def __init__(
        self,
        error_data_filter: str = None,
        type: str = None,
    ):
        # The SQL statement that is used to filter failed tasks. If the rule is defined by custom SQL statements, you must specify an SQL statement to filter failed tasks.
        self.error_data_filter = error_data_filter
        # The type of the operation. Valid values:
        # 
        # *   SaveErrorData
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_data_filter is not None:
            result['ErrorDataFilter'] = self.error_data_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDataFilter') is not None:
            self.error_data_filter = m.get('ErrorDataFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityRuleRequestSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        sampling_filter: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. You can leave this parameter empty if you use a rule template. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to filter unnecessary data during sampling. The statements can be up to 16,777,215 characters in length.
        self.sampling_filter = sampling_filter
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.sampling_filter is not None:
            result['SamplingFilter'] = self.sampling_filter
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SamplingFilter') is not None:
            self.sampling_filter = m.get('SamplingFilter')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class UpdateDataQualityRuleRequest(TeaModel):
    def __init__(
        self,
        checking_config: UpdateDataQualityRuleRequestCheckingConfig = None,
        description: str = None,
        enabled: bool = None,
        error_handlers: List[UpdateDataQualityRuleRequestErrorHandlers] = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config: UpdateDataQualityRuleRequestSamplingConfig = None,
        severity: str = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Specifies whether to enable the rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers = error_handlers
        # The rule ID.
        # 
        # This parameter is required.
        self.id = id
        # The name of the rule. The name can be up to 255 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.error_handlers:
            for k in self.error_handlers:
                if k:
                    k.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['ErrorHandlers'] = []
        if self.error_handlers is not None:
            for k in self.error_handlers:
                result['ErrorHandlers'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = UpdateDataQualityRuleRequestCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.error_handlers = []
        if m.get('ErrorHandlers') is not None:
            for k in m.get('ErrorHandlers'):
                temp_model = UpdateDataQualityRuleRequestErrorHandlers()
                self.error_handlers.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = UpdateDataQualityRuleRequestSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class UpdateDataQualityRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        checking_config_shrink: str = None,
        description: str = None,
        enabled: bool = None,
        error_handlers_shrink: str = None,
        id: int = None,
        name: str = None,
        project_id: int = None,
        sampling_config_shrink: str = None,
        severity: str = None,
        template_code: str = None,
    ):
        # The check settings for sample data.
        self.checking_config_shrink = checking_config_shrink
        # The description of the rule. The description can be up to 500 characters in length.
        self.description = description
        # Specifies whether to enable the rule.
        self.enabled = enabled
        # The operations that you can perform after the rule-based check fails.
        self.error_handlers_shrink = error_handlers_shrink
        # The rule ID.
        # 
        # This parameter is required.
        self.id = id
        # The name of the rule. The name can be up to 255 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config_shrink = sampling_config_shrink
        # The strength of the rule. Valid values:
        # 
        # *   Normal
        # *   High
        self.severity = severity
        # The ID of the template used by the rule.
        self.template_code = template_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config_shrink is not None:
            result['CheckingConfig'] = self.checking_config_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.error_handlers_shrink is not None:
            result['ErrorHandlers'] = self.error_handlers_shrink
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config_shrink is not None:
            result['SamplingConfig'] = self.sampling_config_shrink
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.template_code is not None:
            result['TemplateCode'] = self.template_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            self.checking_config_shrink = m.get('CheckingConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('ErrorHandlers') is not None:
            self.error_handlers_shrink = m.get('ErrorHandlers')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            self.sampling_config_shrink = m.get('SamplingConfig')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('TemplateCode') is not None:
            self.template_code = m.get('TemplateCode')
        return self


class UpdateDataQualityRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataQualityRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataQualityRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataQualityRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataQualityRuleTemplateRequestCheckingConfig(TeaModel):
    def __init__(
        self,
        referenced_samples_filter: str = None,
        type: str = None,
    ):
        # The method that is used to query the referenced samples. To obtain some types of thresholds, you need to query reference samples and perform aggregate operations on the reference values. In this example, an expression is used to specify the query method of referenced samples.
        self.referenced_samples_filter = referenced_samples_filter
        # The type of the monitored object. Valid values:
        # 
        # *   Table
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referenced_samples_filter is not None:
            result['ReferencedSamplesFilter'] = self.referenced_samples_filter
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ReferencedSamplesFilter') is not None:
            self.referenced_samples_filter = m.get('ReferencedSamplesFilter')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDataQualityRuleTemplateRequestSamplingConfig(TeaModel):
    def __init__(
        self,
        metric: str = None,
        metric_parameters: str = None,
        setting_config: str = None,
    ):
        # The metrics used for sampling. Valid values:
        # 
        # *   Count: the number of rows in the table.
        # *   Min: the minimum value of the field.
        # *   Max: the maximum value of the field.
        # *   Avg: the average value of the field.
        # *   DistinctCount: the number of unique values of the field after deduplication.
        # *   DistinctPercent: the proportion of the number of unique values of the field after deduplication to the number of rows in the table.
        # *   DuplicatedCount: the number of duplicated values of the field.
        # *   DuplicatedPercent: the proportion of the number of duplicated values of the field to the number of rows in the table.
        # *   TableSize: the table size.
        # *   NullValueCount: the number of rows in which the field value is null.
        # *   NullValuePercent: the proportion of the number of rows in which the field value is null to the number of rows in the table.
        # *   GroupCount: the field value and the number of rows for each field value.
        # *   CountNotIn: the number of rows in which the field values are different from the referenced values that you specified in the rule.
        # *   CountDistinctNotIn: the number of unique values that are different from the referenced values that you specified in the rule after deduplication.
        # *   UserDefinedSql: indicates that data is sampled by executing custom SQL statements.
        self.metric = metric
        # The parameters required for sampling.
        self.metric_parameters = metric_parameters
        # The statements that are used to configure the parameters required for sampling before you execute the sampling statements. The statements can be up to 1,000 characters in length. Only the MaxCompute database is supported.
        self.setting_config = setting_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.metric_parameters is not None:
            result['MetricParameters'] = self.metric_parameters
        if self.setting_config is not None:
            result['SettingConfig'] = self.setting_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('MetricParameters') is not None:
            self.metric_parameters = m.get('MetricParameters')
        if m.get('SettingConfig') is not None:
            self.setting_config = m.get('SettingConfig')
        return self


class UpdateDataQualityRuleTemplateRequest(TeaModel):
    def __init__(
        self,
        checking_config: UpdateDataQualityRuleTemplateRequestCheckingConfig = None,
        code: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config: UpdateDataQualityRuleTemplateRequestSamplingConfig = None,
    ):
        # The check settings for sample data.
        self.checking_config = checking_config
        # The code for the template.
        # 
        # This parameter is required.
        self.code = code
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config = sampling_config

    def validate(self):
        if self.checking_config:
            self.checking_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config is not None:
            result['CheckingConfig'] = self.checking_config.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config is not None:
            result['SamplingConfig'] = self.sampling_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            temp_model = UpdateDataQualityRuleTemplateRequestCheckingConfig()
            self.checking_config = temp_model.from_map(m['CheckingConfig'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            temp_model = UpdateDataQualityRuleTemplateRequestSamplingConfig()
            self.sampling_config = temp_model.from_map(m['SamplingConfig'])
        return self


class UpdateDataQualityRuleTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        checking_config_shrink: str = None,
        code: str = None,
        directory_path: str = None,
        name: str = None,
        project_id: int = None,
        sampling_config_shrink: str = None,
    ):
        # The check settings for sample data.
        self.checking_config_shrink = checking_config_shrink
        # The code for the template.
        # 
        # This parameter is required.
        self.code = code
        # The directory in which the template is stored. Slashes (/) are used to separate directory levels. The name of each directory level can be up to 1,024 characters in length. It cannot contain whitespace characters or slashes (/).
        self.directory_path = directory_path
        # The name of the template. The name can be up to 512 characters in length and can contain digits, letters, and punctuation marks.
        self.name = name
        # This parameter is required.
        self.project_id = project_id
        # The sampling settings.
        self.sampling_config_shrink = sampling_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checking_config_shrink is not None:
            result['CheckingConfig'] = self.checking_config_shrink
        if self.code is not None:
            result['Code'] = self.code
        if self.directory_path is not None:
            result['DirectoryPath'] = self.directory_path
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.sampling_config_shrink is not None:
            result['SamplingConfig'] = self.sampling_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckingConfig') is not None:
            self.checking_config_shrink = m.get('CheckingConfig')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DirectoryPath') is not None:
            self.directory_path = m.get('DirectoryPath')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('SamplingConfig') is not None:
            self.sampling_config_shrink = m.get('SamplingConfig')
        return self


class UpdateDataQualityRuleTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataQualityRuleTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataQualityRuleTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataQualityRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataSourceRequest(TeaModel):
    def __init__(
        self,
        connection_properties: str = None,
        connection_properties_mode: str = None,
        description: str = None,
        id: int = None,
        project_id: int = None,
    ):
        # The connection configurations of the data source, including the connection address, access identity, and environment information. The envType parameter specifies the environment in which the data source is used. Valid values of the envType parameter:
        # 
        # *   Dev: development environment
        # *   Prod: production environment
        # 
        # The parameters that you need to configure to the data source vary based on the mode in which the data source is added. For more information, see [Data source connection information (ConnectionProperties)](https://help.aliyun.com/document_detail/2852465.html).
        # 
        # This parameter is required.
        self.connection_properties = connection_properties
        # The mode in which the data source is added. The mode varies based on the data source type. Valid values:
        # 
        # *   InstanceMode: instance mode
        # *   UrlMode: connection string mode
        self.connection_properties_mode = connection_properties_mode
        # The description of the data source. The description cannot exceed 3,000 characters in length.
        self.description = description
        # The data source ID.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID.
        # 
        # This parameter is required.
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_properties is not None:
            result['ConnectionProperties'] = self.connection_properties
        if self.connection_properties_mode is not None:
            result['ConnectionPropertiesMode'] = self.connection_properties_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionProperties') is not None:
            self.connection_properties = m.get('ConnectionProperties')
        if m.get('ConnectionPropertiesMode') is not None:
            self.connection_properties_mode = m.get('ConnectionPropertiesMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class UpdateDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Whether the data source has been modified:
        # 
        # - true: Yes
        # - false: no
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFileRequest(TeaModel):
    def __init__(
        self,
        advanced_settings: str = None,
        apply_schedule_immediately: bool = None,
        auto_parsing: bool = None,
        auto_rerun_interval_millis: int = None,
        auto_rerun_times: int = None,
        connection_name: str = None,
        content: str = None,
        cron_express: str = None,
        cycle_type: str = None,
        dependent_node_id_list: str = None,
        dependent_type: str = None,
        end_effect_date: int = None,
        file_description: str = None,
        file_folder_path: str = None,
        file_id: int = None,
        file_name: str = None,
        ignore_parent_skip_running_property: bool = None,
        image_id: str = None,
        input_list: str = None,
        input_parameters: str = None,
        output_list: str = None,
        output_parameters: str = None,
        owner: str = None,
        para_value: str = None,
        project_id: int = None,
        project_identifier: str = None,
        rerun_mode: str = None,
        resource_group_identifier: str = None,
        scheduler_type: str = None,
        start_effect_date: int = None,
        start_immediately: bool = None,
        stop: bool = None,
        timeout: int = None,
    ):
        self.advanced_settings = advanced_settings
        self.apply_schedule_immediately = apply_schedule_immediately
        self.auto_parsing = auto_parsing
        self.auto_rerun_interval_millis = auto_rerun_interval_millis
        self.auto_rerun_times = auto_rerun_times
        self.connection_name = connection_name
        self.content = content
        self.cron_express = cron_express
        self.cycle_type = cycle_type
        self.dependent_node_id_list = dependent_node_id_list
        self.dependent_type = dependent_type
        self.end_effect_date = end_effect_date
        self.file_description = file_description
        self.file_folder_path = file_folder_path
        # This parameter is required.
        self.file_id = file_id
        self.file_name = file_name
        self.ignore_parent_skip_running_property = ignore_parent_skip_running_property
        self.image_id = image_id
        self.input_list = input_list
        self.input_parameters = input_parameters
        self.output_list = output_list
        self.output_parameters = output_parameters
        self.owner = owner
        self.para_value = para_value
        self.project_id = project_id
        self.project_identifier = project_identifier
        self.rerun_mode = rerun_mode
        self.resource_group_identifier = resource_group_identifier
        self.scheduler_type = scheduler_type
        self.start_effect_date = start_effect_date
        self.start_immediately = start_immediately
        self.stop = stop
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_settings is not None:
            result['AdvancedSettings'] = self.advanced_settings
        if self.apply_schedule_immediately is not None:
            result['ApplyScheduleImmediately'] = self.apply_schedule_immediately
        if self.auto_parsing is not None:
            result['AutoParsing'] = self.auto_parsing
        if self.auto_rerun_interval_millis is not None:
            result['AutoRerunIntervalMillis'] = self.auto_rerun_interval_millis
        if self.auto_rerun_times is not None:
            result['AutoRerunTimes'] = self.auto_rerun_times
        if self.connection_name is not None:
            result['ConnectionName'] = self.connection_name
        if self.content is not None:
            result['Content'] = self.content
        if self.cron_express is not None:
            result['CronExpress'] = self.cron_express
        if self.cycle_type is not None:
            result['CycleType'] = self.cycle_type
        if self.dependent_node_id_list is not None:
            result['DependentNodeIdList'] = self.dependent_node_id_list
        if self.dependent_type is not None:
            result['DependentType'] = self.dependent_type
        if self.end_effect_date is not None:
            result['EndEffectDate'] = self.end_effect_date
        if self.file_description is not None:
            result['FileDescription'] = self.file_description
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.ignore_parent_skip_running_property is not None:
            result['IgnoreParentSkipRunningProperty'] = self.ignore_parent_skip_running_property
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.input_list is not None:
            result['InputList'] = self.input_list
        if self.input_parameters is not None:
            result['InputParameters'] = self.input_parameters
        if self.output_list is not None:
            result['OutputList'] = self.output_list
        if self.output_parameters is not None:
            result['OutputParameters'] = self.output_parameters
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.para_value is not None:
            result['ParaValue'] = self.para_value
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.resource_group_identifier is not None:
            result['ResourceGroupIdentifier'] = self.resource_group_identifier
        if self.scheduler_type is not None:
            result['SchedulerType'] = self.scheduler_type
        if self.start_effect_date is not None:
            result['StartEffectDate'] = self.start_effect_date
        if self.start_immediately is not None:
            result['StartImmediately'] = self.start_immediately
        if self.stop is not None:
            result['Stop'] = self.stop
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdvancedSettings') is not None:
            self.advanced_settings = m.get('AdvancedSettings')
        if m.get('ApplyScheduleImmediately') is not None:
            self.apply_schedule_immediately = m.get('ApplyScheduleImmediately')
        if m.get('AutoParsing') is not None:
            self.auto_parsing = m.get('AutoParsing')
        if m.get('AutoRerunIntervalMillis') is not None:
            self.auto_rerun_interval_millis = m.get('AutoRerunIntervalMillis')
        if m.get('AutoRerunTimes') is not None:
            self.auto_rerun_times = m.get('AutoRerunTimes')
        if m.get('ConnectionName') is not None:
            self.connection_name = m.get('ConnectionName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CronExpress') is not None:
            self.cron_express = m.get('CronExpress')
        if m.get('CycleType') is not None:
            self.cycle_type = m.get('CycleType')
        if m.get('DependentNodeIdList') is not None:
            self.dependent_node_id_list = m.get('DependentNodeIdList')
        if m.get('DependentType') is not None:
            self.dependent_type = m.get('DependentType')
        if m.get('EndEffectDate') is not None:
            self.end_effect_date = m.get('EndEffectDate')
        if m.get('FileDescription') is not None:
            self.file_description = m.get('FileDescription')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('IgnoreParentSkipRunningProperty') is not None:
            self.ignore_parent_skip_running_property = m.get('IgnoreParentSkipRunningProperty')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InputList') is not None:
            self.input_list = m.get('InputList')
        if m.get('InputParameters') is not None:
            self.input_parameters = m.get('InputParameters')
        if m.get('OutputList') is not None:
            self.output_list = m.get('OutputList')
        if m.get('OutputParameters') is not None:
            self.output_parameters = m.get('OutputParameters')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ParaValue') is not None:
            self.para_value = m.get('ParaValue')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('ResourceGroupIdentifier') is not None:
            self.resource_group_identifier = m.get('ResourceGroupIdentifier')
        if m.get('SchedulerType') is not None:
            self.scheduler_type = m.get('SchedulerType')
        if m.get('StartEffectDate') is not None:
            self.start_effect_date = m.get('StartEffectDate')
        if m.get('StartImmediately') is not None:
            self.start_immediately = m.get('StartImmediately')
        if m.get('Stop') is not None:
            self.stop = m.get('Stop')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFolderRequest(TeaModel):
    def __init__(
        self,
        folder_id: str = None,
        folder_name: str = None,
        project_id: int = None,
        project_identifier: str = None,
    ):
        # This parameter is required.
        self.folder_id = folder_id
        # This parameter is required.
        self.folder_name = folder_name
        self.project_id = project_id
        self.project_identifier = project_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['FolderId'] = self.folder_id
        if self.folder_name is not None:
            result['FolderName'] = self.folder_name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderId') is not None:
            self.folder_id = m.get('FolderId')
        if m.get('FolderName') is not None:
            self.folder_name = m.get('FolderName')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        return self


class UpdateFolderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateFolderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFolderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFolderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFunctionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        spec: str = None,
    ):
        # The ID of the UDF.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the UDF. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateFunctionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # true
        # 
        # false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIDEEventResultRequest(TeaModel):
    def __init__(
        self,
        check_result: str = None,
        check_result_tip: str = None,
        extension_code: str = None,
        message_id: str = None,
    ):
        self.check_result = check_result
        self.check_result_tip = check_result_tip
        self.extension_code = extension_code
        # UUID
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result is not None:
            result['CheckResult'] = self.check_result
        if self.check_result_tip is not None:
            result['CheckResultTip'] = self.check_result_tip
        if self.extension_code is not None:
            result['ExtensionCode'] = self.extension_code
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckResult') is not None:
            self.check_result = m.get('CheckResult')
        if m.get('CheckResultTip') is not None:
            self.check_result_tip = m.get('CheckResultTip')
        if m.get('ExtensionCode') is not None:
            self.extension_code = m.get('ExtensionCode')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class UpdateIDEEventResultResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateIDEEventResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIDEEventResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIDEEventResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMetaCollectionRequest(TeaModel):
    def __init__(
        self,
        administrators: List[str] = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.administrators = administrators
        self.description = description
        # This parameter is required.
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators is not None:
            result['Administrators'] = self.administrators
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators = m.get('Administrators')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateMetaCollectionShrinkRequest(TeaModel):
    def __init__(
        self,
        administrators_shrink: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.administrators_shrink = administrators_shrink
        self.description = description
        # This parameter is required.
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators_shrink is not None:
            result['Administrators'] = self.administrators_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators_shrink = m.get('Administrators')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateMetaCollectionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMetaCollectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMetaCollectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMetaCollectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNodeRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        spec: str = None,
    ):
        # The ID of the node.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # { "title": "CycleWorkflow Schema", "description": "the JSON schema that is used to configure the auto triggered workflow and nodes in the workflow", "type": "object", "required": [ "version", "kind", "spec" ], "properties": { "version": { "type": "string", "const": "1.1.0", "description": "the schema version. The value is fixed to 1.1.0" }, "kind": { "type": "string", "enum": [ "Workflow", "Node" ], "description": "the resource type" }, "spec": { "type": "object", "description": "the key configurations of the workflow", "required": [ "nodes" ], "properties": { "nodes": { "type": "array", "description": "the nodes in the workflow", "items": { "type": "object", "required": [ "name", "script" ], "properties": { "recurrence": { "type": "string", "enum": [ "Normal", "Pause", "Skip", "NoneAuto" ], "description": "the running mode of the node. Valid values: Normal, Pause, Skip, and NoneAuto" }, "id": { "type": "string", "description": "the node ID" }, "timeout": { "type": "integer", "minimum": 0, "description": "the timeout period. Unit: seconds" }, "instanceMode": { "type": "string", "enum": [ "T+1", "Immediately" ], "description": "the instance generation mode. Valid values: T+1 and Immediately" }, "rerunMode": { "type": "string", "enum": [ "Allowed", "Denied", "FailureAllowed" ], "description": "the rerun mode. Valid values: AllAllowed, Denied, and FailureAllowed" }, "rerunTimes": { "type": "integer", "minimum": 0, "description": "the maximum number of reruns allowed after a failure" }, "rerunInterval": { "type": "integer", "minimum": 0, "description": "the rerun interval. Unit: seconds" }, "datasource": { "type": "object", "description": "the configurations of the data source", "required": [ "name", "type" ], "properties": { "name": { "type": "string", "description": "the name of the data source" }, "type": { "type": "string", "enum": [ "odps" ], "description": "the type of the data source. Only MaxCompute data sources are supported" } } }, "script": { "type": "object", "description": "the script configurations of the node", "required": [ "path", "runtime" ], "properties": { "language": { "type": "string", "description": "the programming language of the script" }, "path": { "type": "string", "description": "the storage path of the script file. The storage path ends with the node name and does not require a file extension" }, "runtime": { "type": "object", "description": "the configurations of the runtime environment", "required": [ "command" ], "properties": { "command": { "type": "string", "enum": [ "ODPS_SQL" ], "Description": "the command" }, "cu": { "type": "string", "description": "the unit of the computing resource" } } } } }, "trigger": { "type": "object", "description": "the configurations of the node trigger", "required": [ "type" ], "properties": { "type": { "type": "string", "enum": [ "Scheduler", "Manual", "Streaming", "None" ], "description": "the trigger type. Valid values: Scheduler, Manual, Streaming, and None" }, "cron": { "type": "string", "description": "the cron expression, which is suitable for only auto triggered nodes" }, "startTime": { "type": "string", "format": "yyyy-MM-dd hh:mm:ss", "description": "the start time for scheduling" }, "endTime": { "type": "string", "format": "yyyy-MM-dd hh:mm:ss", "description": "the end time for scheduling" } } }, "runtimeResource": { "type": "object", "description": "the resource configurations for running", "required": [ "resourceGroup" ], "properties": { "resourceGroup": { "type": "string", "description": "the name of the resource group" } } }, "name": { "type": "string", "description": "the name of the node" }, "owner": { "type": "string", "description": "the node owner" }, "inputs": { "type": "object", "description": "the node input parameters", "properties": { "nodeOutputs": { "type": "array", "description": "the node dependencies", "items": { "type": "object", "required": [ "data" ], "properties": { "data": { "type": "string", "description": "the identifier of the node dependency" }, "refTableName": { "type": "string", "description": "the name of the table that is associated with the node. You must configure this parameter if the artifactType parameter is set to Table" }, "isDefault": { "type": "boolean", "description": "specifies whether the table is the default input table } } } } } }, "outputs": { "type": "object", "description": "the node output parameters", "properties": { "nodeOutputs": { "type": "array", "description": "the node dependencies", "items": { "type": "object", "required": [ "data" ], "properties": { "data": { "type": "string", "description": "the identifier of the node dependency" }, "refTableName": { "type": "string", "description": "the name of the table that is associated with the node. You must configure this parameter if the artifactType parameter is set to Table" }, "isDefault": { "type": "boolean", "description": "specifies whether the table is the default output table } } } } } } } } } } } } }
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateNodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateNodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProjectRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        dev_environment_enabled: bool = None,
        dev_role_disabled: bool = None,
        display_name: str = None,
        id: int = None,
        pai_task_enabled: bool = None,
        status: str = None,
    ):
        # The description of the workspace.
        self.description = description
        # Specifies whether to enable the development environment. Valid values:
        # 
        # *   true: enables the development environment. In this case, the development environment is isolated from the production environment in the workspace.
        # *   false: disables the development environment. In this case, only the production environment is used in the workspace.
        self.dev_environment_enabled = dev_environment_enabled
        # Specifies whether to disable the Develop role. Valid values:
        # 
        # *   false (default)
        # *   true
        # 
        # Note: If you disable the Develop role, you cannot assume the Develop role to develop nodes in workflows and edit node code. The Develop role cannot be enabled again after it is disabled.
        self.dev_role_disabled = dev_role_disabled
        # The display name of the workspace.
        self.display_name = display_name
        # The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://dataworks.console.aliyun.com/workspace/list) and go to the workspace management page to obtain the ID.
        # 
        # This parameter is used to determine the DataWorks workspaces used for this API call.
        # 
        # This parameter is required.
        self.id = id
        # Specifies whether to enable scheduling of Platform for AI (PAI) tasks. Valid values:
        # 
        # *   true: enables scheduling of PAI tasks. In this case, you can create a PAI node in a DataWorks workspace and configure scheduling properties for the node to implement periodic scheduling of PAI tasks.
        # *   false: disables scheduling of PAI tasks.
        self.pai_task_enabled = pai_task_enabled
        # Specifies whether to disable or enable the workspace. Valid values:
        # 
        # *   Available: enables the workspace.
        # *   Forbidden: disables the workspace.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_environment_enabled is not None:
            result['DevEnvironmentEnabled'] = self.dev_environment_enabled
        if self.dev_role_disabled is not None:
            result['DevRoleDisabled'] = self.dev_role_disabled
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.id is not None:
            result['Id'] = self.id
        if self.pai_task_enabled is not None:
            result['PaiTaskEnabled'] = self.pai_task_enabled
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevEnvironmentEnabled') is not None:
            self.dev_environment_enabled = m.get('DevEnvironmentEnabled')
        if m.get('DevRoleDisabled') is not None:
            self.dev_role_disabled = m.get('DevRoleDisabled')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PaiTaskEnabled') is not None:
            self.pai_task_enabled = m.get('PaiTaskEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdateProjectResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request. It is used to locate logs and troubleshoot problems.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateResourceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        resource_file: str = None,
        spec: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        self.resource_file = resource_file
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_file is not None:
            result['ResourceFile'] = self.resource_file
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceFile') is not None:
            self.resource_file = m.get('ResourceFile')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateResourceAdvanceRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        resource_file_object: BinaryIO = None,
        spec: str = None,
    ):
        # The ID of the file resource.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        self.resource_file_object = resource_file_object
        # The FlowSpec field information about the file resource. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.resource_file_object is not None:
            result['ResourceFile'] = self.resource_file_object
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ResourceFile') is not None:
            self.resource_file_object = m.get('ResourceFile')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateResourceGroupRequest(TeaModel):
    def __init__(
        self,
        aliyun_resource_group_id: str = None,
        id: str = None,
        name: str = None,
        remark: str = None,
    ):
        # The ID of the new Alibaba Cloud resource group.
        self.aliyun_resource_group_id = aliyun_resource_group_id
        # The ID of the resource group.
        # 
        # This parameter is required.
        self.id = id
        # The new name that you want to change for the resource group.
        self.name = name
        # The new remarks that you want to modify for the resource group.
        self.remark = remark

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_resource_group_id is not None:
            result['AliyunResourceGroupId'] = self.aliyun_resource_group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunResourceGroupId') is not None:
            self.aliyun_resource_group_id = m.get('AliyunResourceGroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class UpdateResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRouteRequest(TeaModel):
    def __init__(
        self,
        destination_cidr: str = None,
        id: int = None,
    ):
        # The destination CIDR block of the route that you want to update.
        # 
        # This parameter is required.
        self.destination_cidr = destination_cidr
        # The route ID of the network resource.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr is not None:
            result['DestinationCidr'] = self.destination_cidr
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationCidr') is not None:
            self.destination_cidr = m.get('DestinationCidr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class UpdateRouteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateRouteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRouteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRouteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTableBusinessMetadataRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        readme: str = None,
    ):
        # This parameter is required.
        self.id = id
        self.readme = readme

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.readme is not None:
            result['Readme'] = self.readme
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Readme') is not None:
            self.readme = m.get('Readme')
        return self


class UpdateTableBusinessMetadataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTableBusinessMetadataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTableBusinessMetadataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTableBusinessMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskRequestDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateTaskRequestDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: int = None,
    ):
        # The dependency type. Valid values:
        # 
        # *   CrossCycleDependsOnChildren: cross-cycle dependency on level-1 descendant nodes
        # *   CrossCycleDependsOnSelf: cross-cycle dependency on the current node
        # *   CrossCycleDependsOnOtherNode: cross-cycle dependency on other nodes
        # *   Normal: same-cycle scheduling dependency
        # 
        # This parameter is required.
        self.type = type
        # The identifier of the output of the ancestor task. This parameter is returned only if `same-cycle scheduling dependencies` and the node input are configured.
        self.upstream_output = upstream_output
        # The ancestor task ID. This parameter is returned only if `cross-cycle scheduling dependencies` or `same-cycle scheduling dependencies` and the node input are not configured.
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class UpdateTaskRequestInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        # 
        # This parameter is required.
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskRequestInputs(TeaModel):
    def __init__(
        self,
        variables: List[UpdateTaskRequestInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = UpdateTaskRequestInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class UpdateTaskRequestOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class UpdateTaskRequestOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        # 
        # This parameter is required.
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskRequestOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[UpdateTaskRequestOutputsTaskOutputs] = None,
        variables: List[UpdateTaskRequestOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = UpdateTaskRequestOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = UpdateTaskRequestOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class UpdateTaskRequestRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class UpdateTaskRequestScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class UpdateTaskRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskRequestTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        recurrence: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the`yyyy-mm-dd hh:mm:ss` format.
        self.end_time = end_time
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        self.recurrence = recurrence
        # The start time of the time range during which the task is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the`yyyy-mm-dd hh:mm:ss` format.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateTaskRequest(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        data_source: UpdateTaskRequestDataSource = None,
        dependencies: List[UpdateTaskRequestDependencies] = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        inputs: UpdateTaskRequestInputs = None,
        instance_mode: str = None,
        name: str = None,
        outputs: UpdateTaskRequestOutputs = None,
        owner: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: UpdateTaskRequestRuntimeResource = None,
        script: UpdateTaskRequestScript = None,
        tags: List[UpdateTaskRequestTags] = None,
        timeout: int = None,
        trigger: UpdateTaskRequestTrigger = None,
    ):
        # The unique code of the client. This code uniquely identifies a task. This parameter is used to create a task asynchronously and implement the idempotence of the task. If you do not specify this parameter when you create the task, the system automatically generates a unique code. The unique code is uniquely associated with the task ID. If you specify this parameter when you update or delete the task, the value of this parameter must be the unique code that is used to create the task.
        self.client_unique_code = client_unique_code
        # The information about the associated data source.
        self.data_source = data_source
        # The dependency information.
        self.dependencies = dependencies
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The input information.
        self.inputs = inputs
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The name.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the task owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        # 
        # This parameter is required.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        # 
        # This parameter is required.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The tags.
        self.tags = tags
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        # 
        # This parameter is required.
        self.trigger = trigger

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('DataSource') is not None:
            temp_model = UpdateTaskRequestDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = UpdateTaskRequestDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = UpdateTaskRequestInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = UpdateTaskRequestOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = UpdateTaskRequestRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = UpdateTaskRequestScript()
            self.script = temp_model.from_map(m['Script'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdateTaskRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = UpdateTaskRequestTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class UpdateTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        data_source_shrink: str = None,
        dependencies_shrink: str = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        inputs_shrink: str = None,
        instance_mode: str = None,
        name: str = None,
        outputs_shrink: str = None,
        owner: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource_shrink: str = None,
        script_shrink: str = None,
        tags_shrink: str = None,
        timeout: int = None,
        trigger_shrink: str = None,
    ):
        # The unique code of the client. This code uniquely identifies a task. This parameter is used to create a task asynchronously and implement the idempotence of the task. If you do not specify this parameter when you create the task, the system automatically generates a unique code. The unique code is uniquely associated with the task ID. If you specify this parameter when you update or delete the task, the value of this parameter must be the unique code that is used to create the task.
        self.client_unique_code = client_unique_code
        # The information about the associated data source.
        self.data_source_shrink = data_source_shrink
        # The dependency information.
        self.dependencies_shrink = dependencies_shrink
        # The description of the task.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The task ID.
        # 
        # This parameter is required.
        self.id = id
        # The input information.
        self.inputs_shrink = inputs_shrink
        # The instance generation mode. Valid values:
        # 
        # *   T+1
        # *   Immediately
        self.instance_mode = instance_mode
        # The name.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs_shrink = outputs_shrink
        # The account ID of the task owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        # 
        # This parameter is required.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        # 
        # This parameter is required.
        self.runtime_resource_shrink = runtime_resource_shrink
        # The script information.
        self.script_shrink = script_shrink
        # The tags.
        self.tags_shrink = tags_shrink
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        # 
        # This parameter is required.
        self.trigger_shrink = trigger_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.data_source_shrink is not None:
            result['DataSource'] = self.data_source_shrink
        if self.dependencies_shrink is not None:
            result['Dependencies'] = self.dependencies_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs_shrink is not None:
            result['Inputs'] = self.inputs_shrink
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs_shrink is not None:
            result['Outputs'] = self.outputs_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource_shrink is not None:
            result['RuntimeResource'] = self.runtime_resource_shrink
        if self.script_shrink is not None:
            result['Script'] = self.script_shrink
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger_shrink is not None:
            result['Trigger'] = self.trigger_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('DataSource') is not None:
            self.data_source_shrink = m.get('DataSource')
        if m.get('Dependencies') is not None:
            self.dependencies_shrink = m.get('Dependencies')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            self.inputs_shrink = m.get('Inputs')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            self.outputs_shrink = m.get('Outputs')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource_shrink = m.get('RuntimeResource')
        if m.get('Script') is not None:
            self.script_shrink = m.get('Script')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            self.trigger_shrink = m.get('Trigger')
        return self


class UpdateTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskInstancesRequestTaskInstancesDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateTaskInstancesRequestTaskInstances(TeaModel):
    def __init__(
        self,
        data_source: UpdateTaskInstancesRequestTaskInstancesDataSource = None,
        id: int = None,
        priority: int = None,
        runtime_resource: str = None,
    ):
        # The information about the associated data source.
        self.data_source = data_source
        # The instance ID.
        # 
        # This parameter is required.
        self.id = id
        # The priority of the instance. Valid values: 1, 3, 5, 7, and 8.
        # 
        # A larger value indicates a higher priority. Default value: 1.
        self.priority = priority
        # The resource group information. Set this parameter to the ID of a resource group for scheduling.
        self.runtime_resource = runtime_resource

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSource') is not None:
            temp_model = UpdateTaskInstancesRequestTaskInstancesDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RuntimeResource') is not None:
            self.runtime_resource = m.get('RuntimeResource')
        return self


class UpdateTaskInstancesRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        task_instances: List[UpdateTaskInstancesRequestTaskInstances] = None,
    ):
        # The remarks.
        self.comment = comment
        # The instances.
        self.task_instances = task_instances

    def validate(self):
        if self.task_instances:
            for k in self.task_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        result['TaskInstances'] = []
        if self.task_instances is not None:
            for k in self.task_instances:
                result['TaskInstances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        self.task_instances = []
        if m.get('TaskInstances') is not None:
            for k in m.get('TaskInstances'):
                temp_model = UpdateTaskInstancesRequestTaskInstances()
                self.task_instances.append(temp_model.from_map(k))
        return self


class UpdateTaskInstancesShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        task_instances_shrink: str = None,
    ):
        # The remarks.
        self.comment = comment
        # The instances.
        self.task_instances_shrink = task_instances_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.task_instances_shrink is not None:
            result['TaskInstances'] = self.task_instances_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('TaskInstances') is not None:
            self.task_instances_shrink = m.get('TaskInstances')
        return self


class UpdateTaskInstancesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success_info: Dict[str, SuccessInfoValue] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The result of the batch operation, which is in the MAP structure. The instance ID serves as a key, and the result serves as a value.
        self.success_info = success_info

    def validate(self):
        if self.success_info:
            for v in self.success_info.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessInfo'] = {}
        if self.success_info is not None:
            for k, v in self.success_info.items():
                result['SuccessInfo'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_info = {}
        if m.get('SuccessInfo') is not None:
            for k, v in m.get('SuccessInfo').items():
                temp_model = SuccessInfoValue()
                self.success_info[k] = temp_model.from_map(v)
        return self


class UpdateTaskInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUdfFileRequest(TeaModel):
    def __init__(
        self,
        class_name: str = None,
        cmd_description: str = None,
        example: str = None,
        file_folder_path: str = None,
        file_id: str = None,
        function_type: str = None,
        parameter_description: str = None,
        project_id: int = None,
        project_identifier: str = None,
        resources: str = None,
        return_value: str = None,
        udf_description: str = None,
    ):
        # This parameter is required.
        self.class_name = class_name
        self.cmd_description = cmd_description
        self.example = example
        self.file_folder_path = file_folder_path
        # This parameter is required.
        self.file_id = file_id
        # This parameter is required.
        self.function_type = function_type
        self.parameter_description = parameter_description
        self.project_id = project_id
        self.project_identifier = project_identifier
        # This parameter is required.
        self.resources = resources
        self.return_value = return_value
        self.udf_description = udf_description

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.cmd_description is not None:
            result['CmdDescription'] = self.cmd_description
        if self.example is not None:
            result['Example'] = self.example
        if self.file_folder_path is not None:
            result['FileFolderPath'] = self.file_folder_path
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.parameter_description is not None:
            result['ParameterDescription'] = self.parameter_description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_identifier is not None:
            result['ProjectIdentifier'] = self.project_identifier
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.return_value is not None:
            result['ReturnValue'] = self.return_value
        if self.udf_description is not None:
            result['UdfDescription'] = self.udf_description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CmdDescription') is not None:
            self.cmd_description = m.get('CmdDescription')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('FileFolderPath') is not None:
            self.file_folder_path = m.get('FileFolderPath')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('ParameterDescription') is not None:
            self.parameter_description = m.get('ParameterDescription')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectIdentifier') is not None:
            self.project_identifier = m.get('ProjectIdentifier')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('ReturnValue') is not None:
            self.return_value = m.get('ReturnValue')
        if m.get('UdfDescription') is not None:
            self.udf_description = m.get('UdfDescription')
        return self


class UpdateUdfFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.http_status_code = http_status_code
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateUdfFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUdfFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUdfFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkflowRequestDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: int = None,
    ):
        # The dependency type. Valid values:
        # 
        # *   CrossCycleDependsOnChildren: cross-cycle dependency on level-1 descendant nodes
        # *   CrossCycleDependsOnSelf: cross-cycle dependency on the current node
        # *   CrossCycleDependsOnOtherNode: cross-cycle dependency on other nodes
        # *   Normal: same-cycle scheduling dependency
        # 
        # This parameter is required.
        self.type = type
        # The identifier of the output of the ancestor task. This parameter is returned only if `same-cycle scheduling dependencies` and the node input are configured.
        self.upstream_output = upstream_output
        # The ancestor task ID. This parameter is returned only if `cross-cycle scheduling dependencies` or `same-cycle scheduling dependencies` and the node input are not configured.
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class UpdateWorkflowRequestOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class UpdateWorkflowRequestOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[UpdateWorkflowRequestOutputsTaskOutputs] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = UpdateWorkflowRequestOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        return self


class UpdateWorkflowRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateWorkflowRequestTasksDataSource(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the data source.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateWorkflowRequestTasksDependencies(TeaModel):
    def __init__(
        self,
        type: str = None,
        upstream_output: str = None,
        upstream_task_id: int = None,
    ):
        # The dependency type. Valid values:
        # 
        # *   CrossCycleDependsOnChildren: cross-cycle dependency on level-1 descendant nodes
        # *   CrossCycleDependsOnSelf: cross-cycle dependency on the current node
        # *   CrossCycleDependsOnOtherNode: cross-cycle dependency on other nodes
        # *   Normal: same-cycle scheduling dependency
        # 
        # This parameter is required.
        self.type = type
        # The identifier of the output of the ancestor task. This parameter is returned only if `same-cycle scheduling dependencies` and the node input are configured.
        self.upstream_output = upstream_output
        # The ancestor task ID. This parameter is returned only if `cross-cycle scheduling dependencies` or `same-cycle scheduling dependencies` and the node input are not configured.
        self.upstream_task_id = upstream_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        if self.upstream_output is not None:
            result['UpstreamOutput'] = self.upstream_output
        if self.upstream_task_id is not None:
            result['UpstreamTaskId'] = self.upstream_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpstreamOutput') is not None:
            self.upstream_output = m.get('UpstreamOutput')
        if m.get('UpstreamTaskId') is not None:
            self.upstream_task_id = m.get('UpstreamTaskId')
        return self


class UpdateWorkflowRequestTasksInputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        # 
        # This parameter is required.
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateWorkflowRequestTasksInputs(TeaModel):
    def __init__(
        self,
        variables: List[UpdateWorkflowRequestTasksInputsVariables] = None,
    ):
        # The variables.
        self.variables = variables

    def validate(self):
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = UpdateWorkflowRequestTasksInputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class UpdateWorkflowRequestTasksOutputsTaskOutputs(TeaModel):
    def __init__(
        self,
        output: str = None,
    ):
        # The identifier of the output.
        self.output = output

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            self.output = m.get('Output')
        return self


class UpdateWorkflowRequestTasksOutputsVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        value: str = None,
    ):
        # The name of the variable.
        self.name = name
        # The type. Valid values:
        # 
        # *   Constant: constant
        # *   PassThrough: node output
        # *   System: variable
        # *   NodeOutput: script output
        # 
        # This parameter is required.
        self.type = type
        # The value of the variable.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateWorkflowRequestTasksOutputs(TeaModel):
    def __init__(
        self,
        task_outputs: List[UpdateWorkflowRequestTasksOutputsTaskOutputs] = None,
        variables: List[UpdateWorkflowRequestTasksOutputsVariables] = None,
    ):
        # The task outputs.
        self.task_outputs = task_outputs
        # The variables.
        self.variables = variables

    def validate(self):
        if self.task_outputs:
            for k in self.task_outputs:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskOutputs'] = []
        if self.task_outputs is not None:
            for k in self.task_outputs:
                result['TaskOutputs'].append(k.to_map() if k else None)
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_outputs = []
        if m.get('TaskOutputs') is not None:
            for k in m.get('TaskOutputs'):
                temp_model = UpdateWorkflowRequestTasksOutputsTaskOutputs()
                self.task_outputs.append(temp_model.from_map(k))
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = UpdateWorkflowRequestTasksOutputsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class UpdateWorkflowRequestTasksRuntimeResource(TeaModel):
    def __init__(
        self,
        cu: str = None,
        image: str = None,
        resource_group_id: str = None,
    ):
        # The default number of compute units (CUs) configured for task running.
        self.cu = cu
        # The ID of the image configured for task running.
        self.image = image
        # The ID of the resource group for scheduling configured for task running.
        # 
        # This parameter is required.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cu is not None:
            result['Cu'] = self.cu
        if self.image is not None:
            result['Image'] = self.image
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cu') is not None:
            self.cu = m.get('Cu')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class UpdateWorkflowRequestTasksScript(TeaModel):
    def __init__(
        self,
        content: str = None,
        parameters: str = None,
    ):
        # The script content.
        self.content = content
        # The script parameters.
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class UpdateWorkflowRequestTasksTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        # 
        # This parameter is required.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateWorkflowRequestTasksTrigger(TeaModel):
    def __init__(
        self,
        recurrence: str = None,
        type: str = None,
    ):
        # The running mode of the task after it is triggered. This parameter takes effect only if the Type parameter is set to Scheduler. Valid values:
        # 
        # *   Pause
        # *   Skip
        # *   Normal
        # 
        # This parameter is required.
        self.recurrence = recurrence
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.recurrence is not None:
            result['Recurrence'] = self.recurrence
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Recurrence') is not None:
            self.recurrence = m.get('Recurrence')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateWorkflowRequestTasks(TeaModel):
    def __init__(
        self,
        base_line_id: int = None,
        client_unique_code: str = None,
        data_source: UpdateWorkflowRequestTasksDataSource = None,
        dependencies: List[UpdateWorkflowRequestTasksDependencies] = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        inputs: UpdateWorkflowRequestTasksInputs = None,
        name: str = None,
        outputs: UpdateWorkflowRequestTasksOutputs = None,
        owner: str = None,
        rerun_interval: int = None,
        rerun_mode: str = None,
        rerun_times: int = None,
        runtime_resource: UpdateWorkflowRequestTasksRuntimeResource = None,
        script: UpdateWorkflowRequestTasksScript = None,
        tags: List[UpdateWorkflowRequestTasksTags] = None,
        timeout: int = None,
        trigger: UpdateWorkflowRequestTasksTrigger = None,
        type: str = None,
    ):
        # The baseline ID.
        self.base_line_id = base_line_id
        # The unique code of the client. This parameter is used to create a task asynchronously and implement the idempotence of the task. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The information about the associated data source.
        self.data_source = data_source
        # The dependency information.
        self.dependencies = dependencies
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod
        # *   Dev
        self.env_type = env_type
        # The task ID. If you configure this parameter, full update is performed on the task. If you do not configure this parameter, another task is created.
        self.id = id
        # The input information.
        self.inputs = inputs
        # The name of the task.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The rerun interval. Unit: seconds.
        self.rerun_interval = rerun_interval
        # The rerun mode. Valid values:
        # 
        # *   AllDenied: The task cannot be rerun regardless of whether the task is successfully run or fails to run.
        # *   FailureAllowed: The task can be rerun only after it fails to run.
        # *   AllAllowed: The task can be rerun regardless of whether the task is successfully run or fails to run.
        # 
        # This parameter is required.
        self.rerun_mode = rerun_mode
        # The number of times that the task is rerun. This parameter takes effect only if the RerunMode parameter is set to AllAllowed or FailureAllowed.
        self.rerun_times = rerun_times
        # The configurations of the runtime environment, such as the resource group information.
        # 
        # This parameter is required.
        self.runtime_resource = runtime_resource
        # The script information.
        self.script = script
        # The tags.
        self.tags = tags
        # The timeout period of task running. Unit: seconds.
        self.timeout = timeout
        # The trigger method.
        # 
        # This parameter is required.
        self.trigger = trigger
        # The type of the task.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.data_source:
            self.data_source.validate()
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.inputs:
            self.inputs.validate()
        if self.outputs:
            self.outputs.validate()
        if self.runtime_resource:
            self.runtime_resource.validate()
        if self.script:
            self.script.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_line_id is not None:
            result['BaseLineId'] = self.base_line_id
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.inputs is not None:
            result['Inputs'] = self.inputs.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.rerun_interval is not None:
            result['RerunInterval'] = self.rerun_interval
        if self.rerun_mode is not None:
            result['RerunMode'] = self.rerun_mode
        if self.rerun_times is not None:
            result['RerunTimes'] = self.rerun_times
        if self.runtime_resource is not None:
            result['RuntimeResource'] = self.runtime_resource.to_map()
        if self.script is not None:
            result['Script'] = self.script.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseLineId') is not None:
            self.base_line_id = m.get('BaseLineId')
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('DataSource') is not None:
            temp_model = UpdateWorkflowRequestTasksDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = UpdateWorkflowRequestTasksDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Inputs') is not None:
            temp_model = UpdateWorkflowRequestTasksInputs()
            self.inputs = temp_model.from_map(m['Inputs'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = UpdateWorkflowRequestTasksOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RerunInterval') is not None:
            self.rerun_interval = m.get('RerunInterval')
        if m.get('RerunMode') is not None:
            self.rerun_mode = m.get('RerunMode')
        if m.get('RerunTimes') is not None:
            self.rerun_times = m.get('RerunTimes')
        if m.get('RuntimeResource') is not None:
            temp_model = UpdateWorkflowRequestTasksRuntimeResource()
            self.runtime_resource = temp_model.from_map(m['RuntimeResource'])
        if m.get('Script') is not None:
            temp_model = UpdateWorkflowRequestTasksScript()
            self.script = temp_model.from_map(m['Script'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdateWorkflowRequestTasksTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Trigger') is not None:
            temp_model = UpdateWorkflowRequestTasksTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateWorkflowRequestTrigger(TeaModel):
    def __init__(
        self,
        cron: str = None,
        end_time: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The CRON expression. This parameter takes effect only if the Type parameter is set to Scheduler.
        self.cron = cron
        # The end time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the `yyyy-mm-dd hh:mm:ss` format.
        self.end_time = end_time
        # The start time of the time range during which the workflow is periodically scheduled. This parameter takes effect only if the Type parameter is set to Scheduler. The value of this parameter is in the `yyyy-mm-dd hh:mm:ss` format.
        self.start_time = start_time
        # The trigger type. Valid values:
        # 
        # *   Scheduler: scheduling cycle-based trigger
        # *   Manual: manual trigger
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateWorkflowRequest(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        dependencies: List[UpdateWorkflowRequestDependencies] = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        name: str = None,
        outputs: UpdateWorkflowRequestOutputs = None,
        owner: str = None,
        parameters: str = None,
        tags: List[UpdateWorkflowRequestTags] = None,
        tasks: List[UpdateWorkflowRequestTasks] = None,
        trigger: UpdateWorkflowRequestTrigger = None,
    ):
        # The unique code of the client. This parameter is used to create a workflow asynchronously and implement the idempotence of the workflow. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The dependency information.
        self.dependencies = dependencies
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The workflow ID.
        # 
        # This parameter is required.
        self.id = id
        self.instance_mode = instance_mode
        # The name of the workflow.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs = outputs
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The parameters.
        self.parameters = parameters
        # The tags.
        self.tags = tags
        # The tasks.
        self.tasks = tasks
        # The trigger method.
        # 
        # This parameter is required.
        self.trigger = trigger

    def validate(self):
        if self.dependencies:
            for k in self.dependencies:
                if k:
                    k.validate()
        if self.outputs:
            self.outputs.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()
        if self.trigger:
            self.trigger.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        result['Dependencies'] = []
        if self.dependencies is not None:
            for k in self.dependencies:
                result['Dependencies'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs is not None:
            result['Outputs'] = self.outputs.to_map()
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        result['Tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['Tasks'].append(k.to_map() if k else None)
        if self.trigger is not None:
            result['Trigger'] = self.trigger.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        self.dependencies = []
        if m.get('Dependencies') is not None:
            for k in m.get('Dependencies'):
                temp_model = UpdateWorkflowRequestDependencies()
                self.dependencies.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            temp_model = UpdateWorkflowRequestOutputs()
            self.outputs = temp_model.from_map(m['Outputs'])
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdateWorkflowRequestTags()
                self.tags.append(temp_model.from_map(k))
        self.tasks = []
        if m.get('Tasks') is not None:
            for k in m.get('Tasks'):
                temp_model = UpdateWorkflowRequestTasks()
                self.tasks.append(temp_model.from_map(k))
        if m.get('Trigger') is not None:
            temp_model = UpdateWorkflowRequestTrigger()
            self.trigger = temp_model.from_map(m['Trigger'])
        return self


class UpdateWorkflowShrinkRequest(TeaModel):
    def __init__(
        self,
        client_unique_code: str = None,
        dependencies_shrink: str = None,
        description: str = None,
        env_type: str = None,
        id: int = None,
        instance_mode: str = None,
        name: str = None,
        outputs_shrink: str = None,
        owner: str = None,
        parameters: str = None,
        tags_shrink: str = None,
        tasks_shrink: str = None,
        trigger_shrink: str = None,
    ):
        # The unique code of the client. This parameter is used to create a workflow asynchronously and implement the idempotence of the workflow. If you do not specify this parameter when you create the workflow, the system automatically generates a unique code. The unique code is uniquely associated with the workflow ID. If you specify this parameter when you update or delete the workflow, the value of this parameter must be the unique code that is used to create the workflow.
        self.client_unique_code = client_unique_code
        # The dependency information.
        self.dependencies_shrink = dependencies_shrink
        # The description.
        self.description = description
        # The environment of the workspace. Valid values:
        # 
        # *   Prod: production environment
        # *   Dev: development environment
        self.env_type = env_type
        # The workflow ID.
        # 
        # This parameter is required.
        self.id = id
        self.instance_mode = instance_mode
        # The name of the workflow.
        # 
        # This parameter is required.
        self.name = name
        # The output information.
        self.outputs_shrink = outputs_shrink
        # The account ID of the owner.
        # 
        # This parameter is required.
        self.owner = owner
        # The parameters.
        self.parameters = parameters
        # The tags.
        self.tags_shrink = tags_shrink
        # The tasks.
        self.tasks_shrink = tasks_shrink
        # The trigger method.
        # 
        # This parameter is required.
        self.trigger_shrink = trigger_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_unique_code is not None:
            result['ClientUniqueCode'] = self.client_unique_code
        if self.dependencies_shrink is not None:
            result['Dependencies'] = self.dependencies_shrink
        if self.description is not None:
            result['Description'] = self.description
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_mode is not None:
            result['InstanceMode'] = self.instance_mode
        if self.name is not None:
            result['Name'] = self.name
        if self.outputs_shrink is not None:
            result['Outputs'] = self.outputs_shrink
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        if self.tasks_shrink is not None:
            result['Tasks'] = self.tasks_shrink
        if self.trigger_shrink is not None:
            result['Trigger'] = self.trigger_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientUniqueCode') is not None:
            self.client_unique_code = m.get('ClientUniqueCode')
        if m.get('Dependencies') is not None:
            self.dependencies_shrink = m.get('Dependencies')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceMode') is not None:
            self.instance_mode = m.get('InstanceMode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Outputs') is not None:
            self.outputs_shrink = m.get('Outputs')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        if m.get('Tasks') is not None:
            self.tasks_shrink = m.get('Tasks')
        if m.get('Trigger') is not None:
            self.trigger_shrink = m.get('Trigger')
        return self


class UpdateWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkflowDefinitionRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_id: int = None,
        spec: str = None,
    ):
        # The ID of the workflow.
        # 
        # This parameter is required.
        self.id = id
        # The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
        # 
        # This parameter is required.
        self.project_id = project_id
        # The FlowSpec field information about the workflow. For more information, see [FlowSpec](https://github.com/aliyun/dataworks-spec/blob/master/README_zh_CN.md).
        # 
        # This parameter is required.
        self.spec = spec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class UpdateWorkflowDefinitionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The request ID. You can locate logs and troubleshoot issues based on the ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateWorkflowDefinitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkflowDefinitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkflowDefinitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


