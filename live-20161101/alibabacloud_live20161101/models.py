# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class AppInfoDTOPlatforms(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        license_item_ids: List[str] = None,
        pkg_name: str = None,
        pkg_signature: str = None,
        platform_type: int = None,
        type: int = None,
    ):
        self.item_id = item_id
        self.license_item_ids = license_item_ids
        self.pkg_name = pkg_name
        self.pkg_signature = pkg_signature
        self.platform_type = platform_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.license_item_ids is not None:
            result['LicenseItemIds'] = self.license_item_ids
        if self.pkg_name is not None:
            result['PkgName'] = self.pkg_name
        if self.pkg_signature is not None:
            result['PkgSignature'] = self.pkg_signature
        if self.platform_type is not None:
            result['PlatformType'] = self.platform_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('LicenseItemIds') is not None:
            self.license_item_ids = m.get('LicenseItemIds')
        if m.get('PkgName') is not None:
            self.pkg_name = m.get('PkgName')
        if m.get('PkgSignature') is not None:
            self.pkg_signature = m.get('PkgSignature')
        if m.get('PlatformType') is not None:
            self.platform_type = m.get('PlatformType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AppInfoDTO(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        app_type: int = None,
        creation_time: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        item_id: str = None,
        modification_time: str = None,
        platforms: List[AppInfoDTOPlatforms] = None,
        user_id: int = None,
    ):
        self.app_name = app_name
        self.app_type = app_type
        self.creation_time = creation_time
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.item_id = item_id
        self.modification_time = modification_time
        self.platforms = platforms
        self.user_id = user_id

    def validate(self):
        if self.platforms:
            for k in self.platforms:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        result['Platforms'] = []
        if self.platforms is not None:
            for k in self.platforms:
                result['Platforms'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        self.platforms = []
        if m.get('Platforms') is not None:
            for k in m.get('Platforms'):
                temp_model = AppInfoDTOPlatforms()
                self.platforms.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LicenseInstanceAppDTOLicenseConfigs(TeaModel):
    def __init__(
        self,
        business_type: str = None,
        feature_ids: str = None,
        is_trial: bool = None,
        sdk_id: int = None,
        sdk_name: str = None,
        subscription: str = None,
        subscription_imp: str = None,
        subscription_pkg: str = None,
    ):
        self.business_type = business_type
        self.feature_ids = feature_ids
        self.is_trial = is_trial
        self.sdk_id = sdk_id
        self.sdk_name = sdk_name
        self.subscription = subscription
        self.subscription_imp = subscription_imp
        self.subscription_pkg = subscription_pkg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.feature_ids is not None:
            result['FeatureIds'] = self.feature_ids
        if self.is_trial is not None:
            result['IsTrial'] = self.is_trial
        if self.sdk_id is not None:
            result['SdkId'] = self.sdk_id
        if self.sdk_name is not None:
            result['SdkName'] = self.sdk_name
        if self.subscription is not None:
            result['Subscription'] = self.subscription
        if self.subscription_imp is not None:
            result['SubscriptionImp'] = self.subscription_imp
        if self.subscription_pkg is not None:
            result['SubscriptionPkg'] = self.subscription_pkg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('FeatureIds') is not None:
            self.feature_ids = m.get('FeatureIds')
        if m.get('IsTrial') is not None:
            self.is_trial = m.get('IsTrial')
        if m.get('SdkId') is not None:
            self.sdk_id = m.get('SdkId')
        if m.get('SdkName') is not None:
            self.sdk_name = m.get('SdkName')
        if m.get('Subscription') is not None:
            self.subscription = m.get('Subscription')
        if m.get('SubscriptionImp') is not None:
            self.subscription_imp = m.get('SubscriptionImp')
        if m.get('SubscriptionPkg') is not None:
            self.subscription_pkg = m.get('SubscriptionPkg')
        return self


class LicenseInstanceAppDTO(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        begin_on: str = None,
        contract_no: str = None,
        creation_time: str = None,
        expired_on: str = None,
        instance_id: str = None,
        item_id: str = None,
        license_configs: List[LicenseInstanceAppDTOLicenseConfigs] = None,
        modification_time: str = None,
        status: str = None,
        user_id: int = None,
    ):
        self.app_id = app_id
        self.begin_on = begin_on
        self.contract_no = contract_no
        self.creation_time = creation_time
        self.expired_on = expired_on
        self.instance_id = instance_id
        self.item_id = item_id
        self.license_configs = license_configs
        self.modification_time = modification_time
        self.status = status
        self.user_id = user_id

    def validate(self):
        if self.license_configs:
            for k in self.license_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.begin_on is not None:
            result['BeginOn'] = self.begin_on
        if self.contract_no is not None:
            result['ContractNo'] = self.contract_no
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.expired_on is not None:
            result['ExpiredOn'] = self.expired_on
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        result['LicenseConfigs'] = []
        if self.license_configs is not None:
            for k in self.license_configs:
                result['LicenseConfigs'].append(k.to_map() if k else None)
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BeginOn') is not None:
            self.begin_on = m.get('BeginOn')
        if m.get('ContractNo') is not None:
            self.contract_no = m.get('ContractNo')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ExpiredOn') is not None:
            self.expired_on = m.get('ExpiredOn')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        self.license_configs = []
        if m.get('LicenseConfigs') is not None:
            for k in m.get('LicenseConfigs'):
                temp_model = LicenseInstanceAppDTOLicenseConfigs()
                self.license_configs.append(temp_model.from_map(k))
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddCasterComponentRequest(TeaModel):
    def __init__(
        self,
        caption_layer_content: str = None,
        caster_id: str = None,
        component_layer: str = None,
        component_name: str = None,
        component_type: str = None,
        effect: str = None,
        html_layer_content: str = None,
        image_layer_content: str = None,
        layer_order: str = None,
        location_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        text_layer_content: str = None,
    ):
        # The information about the caption layer. This parameter contains the following fields:
        # 
        # >  This parameter is required when the ComponentType parameter is set to caption.
        # 
        # *   **SizeNormalized**: the normalized font size. The font size is set to font_size/output_height. The value range is `[0,1]` and accurate to two decimal places. If the font size calculated by the system based on the normalization method is greater than **1024**, **1024** is used.
        # *   **BorderWidthNormalized**: the normalized value of the text border width, which is calculated based on the size of the text, namely "BorderWidth/FontSize". The value range is `[0,1]` and accurate to two decimal places. If the value calculated according to the normalization method exceeds **16**, **16** is used. The default value is **0**.
        # *   **FontName**: the font name. For more information about the value, see **Font description**. The default font name is KaiTi.
        # *   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is not set. In this case, the color of the text border is transparent.
        # *   **LocationId**: the channel ID of the source subtitle.
        # *   **SourceLan**: the source language of the audio in the source video. Valid values: en, cn, es, and ru, which indicate English, Chinese, Spanish, and Russian respectively. Default value: cn.
        # *   **TargetLan**: the target audio language in the source video. If you do not specify this field, speech recognition is used. If you specify this field, translation is used. Valid values: en, cn, es, and ru, which indicate English, Chinese, Spanish, and Russian respectively. Default value: cn.
        # *   **ShowSourceLan**: specifies whether to display the source language. Valid values: true: displays the source language. false: hides the source language. Default value: false.
        # *   **Truncation**: specifies whether to allow caption truncation. Valid values: true: specifies that the caption can be truncated. false: specifies that the caption cannot be truncated. Default value: false.
        # *   **SourceLanPerLineWordCount**: the number of words displayed in each line when the subtitle is in the source language. Default value: 20.
        # *   **TargetLanPerLineWordCount**: the number of words displayed in each line when the subtitle is in the destination language. Default value: 20.
        # *   **SourceLanReservePages**: the number of lines reserved when the subtitle is in the source language. This field takes effect only when the Truncation field is set to true. Default value: 2.
        # *   **TargetLanReservePages**: the number of lines reserved when the subtitle is in the destination language. This field takes effect only when the Truncation field is set to true. Default value: 2.
        # 
        # The value is a JSON string. Use upper camel case for field names.
        self.caption_layer_content = caption_layer_content
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The information about the component layer, such as the size and layout. This parameter contains the following fields:
        # 
        # *   **HeightNormalized**: the normalized value of heights for the elements in the component layer
        # *   **WidthNormalized**: the normalized value of widths for the elements in the component layer
        # *   **PositionNormalized**: the normalized value of the coordinates of the component layer
        # *   **PositionRefer**: the reference coordinates of the component layer.
        # 
        # The value is a JSON string. Use upper camel case for field names.
        # 
        # This parameter is required.
        self.component_layer = component_layer
        # The component name. By default, the component name is the component ID.
        self.component_name = component_name
        # The component type. Valid values:
        # 
        # *   **text**: a text component. If you set ComponentType to text, you must also specify TextLayerContent.
        # *   **image**: an image component. If you set ComponentType to image, you must also specify ImageLayerContent.
        # *   **caption**: a caption component. If you set ComponentType to caption, you must also specify CaptionLayerContent.
        # 
        # This parameter is required.
        self.component_type = component_type
        # The effect of the component. Valid values:
        # 
        # *   **none (default)**\
        # *   **animateH**: horizontal scrolling
        # *   **animateV**: vertical scrolling
        self.effect = effect
        # The information about the HTML5 layer.
        self.html_layer_content = html_layer_content
        # The information about the image layer. This parameter contains the following fields:
        # 
        # >  This parameter is required when the ComponentType parameter is set to image.
        # 
        # MaterialId: the ID of the asset from the media asset library. The name that you set when you upload an asset is the ID of the asset.
        # 
        # The value is a JSON string. Use upper camel case for field names.
        self.image_layer_content = image_layer_content
        # The layer stacking order of the component. Valid values:
        # 
        # *   cover
        # *   background
        self.layer_order = layer_order
        # The location ID of the component. Each location ID can be assigned to only one component and must be in the RC[Number] format. The values specified by this parameter must be in ascending order, such as RC01 to RC99.
        # 
        # >  If the ComponentType parameter is set to caption, the LocationId parameter specifies the location ID of the video source referenced by the component.
        # 
        # This parameter is required.
        self.location_id = location_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The information about the text layer. This parameter contains the following fields:
        # 
        # >  This parameter is available and required only when the ComponentType parameter is set to text.
        # 
        # *   **SizeNormalized**: the normalized font size. The font size is set to font_size/output_height. The value range is `[0,1]`. If the font size calculated by the system based on the normalization method is greater than 1024, 1024 is used.
        # *   **BorderWidthNormalized**: the normalized value of the text border width. The normalized value is calculated based on the size of the text, that is, "BorderWidth/FontSize". The value range is `[0,1]`. If the value calculated based on the normalization method exceeds 16, 16 is used. The default value is 0.
        # *   **FontName**: the font name. For more information about the value, see **Font description**. The default value is KaiTi.
        # *   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is not set. In this case, the color of the text border is transparent.
        # *   **Text**: the content of the text. By default, this parameter is not set. In this case, the text contains no content.
        # *   **Color**: the color of the text. The default value is 0xff0000, which indicates that the text is in red.
        # 
        # The value is a JSON string. Use upper camel case for field names.
        self.text_layer_content = text_layer_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caption_layer_content is not None:
            result['CaptionLayerContent'] = self.caption_layer_content
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_layer is not None:
            result['ComponentLayer'] = self.component_layer
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.html_layer_content is not None:
            result['HtmlLayerContent'] = self.html_layer_content
        if self.image_layer_content is not None:
            result['ImageLayerContent'] = self.image_layer_content
        if self.layer_order is not None:
            result['LayerOrder'] = self.layer_order
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.text_layer_content is not None:
            result['TextLayerContent'] = self.text_layer_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptionLayerContent') is not None:
            self.caption_layer_content = m.get('CaptionLayerContent')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentLayer') is not None:
            self.component_layer = m.get('ComponentLayer')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('HtmlLayerContent') is not None:
            self.html_layer_content = m.get('HtmlLayerContent')
        if m.get('ImageLayerContent') is not None:
            self.image_layer_content = m.get('ImageLayerContent')
        if m.get('LayerOrder') is not None:
            self.layer_order = m.get('LayerOrder')
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TextLayerContent') is not None:
            self.text_layer_content = m.get('TextLayerContent')
        return self


class AddCasterComponentResponseBody(TeaModel):
    def __init__(
        self,
        component_id: str = None,
        request_id: str = None,
    ):
        # The component ID. The value can be used as the value of a request parameter to query, modify, or delete a production studio.
        self.component_id = component_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterComponentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterComponentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterComponentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterEpisodeRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: List[str] = None,
        end_time: str = None,
        episode_name: str = None,
        episode_type: str = None,
        owner_id: int = None,
        region_id: str = None,
        resource_id: str = None,
        start_time: str = None,
        switch_type: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The components. Components in the production studio are listed from the bottom to the top in an array.
        # 
        # If a component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the component ID.
        # 
        # *   This parameter takes effect and is required when the EpisodeType parameter is set to **Component**.
        # *   This parameter is optional when the EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.
        # 
        # >  The variable N specifies the sequence number of the component. For example, **ComponentId.1** specifies the ID of the first component and **ComponentId.2** specifies the ID of the second component.
        self.component_id = component_id
        # The time when the episode ends. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The name of the episode.
        self.episode_name = episode_name
        # The type of the episode. Valid values:
        # 
        # *   **Resource**: a video resource.
        # *   **Component**: a component.
        # 
        # This parameter is required.
        self.episode_type = episode_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the video resource.
        # 
        # >  This parameter takes effect and is required when the EpisodeType parameter is set to Resource.
        # 
        # \\
        # If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html) operation, check the value of the response parameter ResourceId to obtain the ID.
        self.resource_id = resource_id
        # The time when the episode starts. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The policy for switching episodes. Valid values:
        # 
        # *   **TimeFirst**: The episode starts when the preceding episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops.
        # *   **ContentFirst**: The episode starts and ends as scheduled.
        # 
        # This parameter takes effect only when the EpisodeType parameter is set to Resource.
        # 
        # >  This parameter must be set to TimeFirst when the video resource is a live stream.
        # 
        # This parameter is required.
        self.switch_type = switch_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_name is not None:
            result['EpisodeName'] = self.episode_name
        if self.episode_type is not None:
            result['EpisodeType'] = self.episode_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeName') is not None:
            self.episode_name = m.get('EpisodeName')
        if m.get('EpisodeType') is not None:
            self.episode_type = m.get('EpisodeType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class AddCasterEpisodeResponseBody(TeaModel):
    def __init__(
        self,
        episode_id: str = None,
        request_id: str = None,
    ):
        # The ID of the episode. You can use the ID as a request parameter in the API operation that is used to query the information about the episode list, modify the configurations of the episode, and delete the episode.
        self.episode_id = episode_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterEpisodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterEpisodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterEpisodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterEpisodeGroupRequestItem(TeaModel):
    def __init__(
        self,
        item_name: str = None,
        vod_url: str = None,
    ):
        # The name of the episode.
        self.item_name = item_name
        # The URL of the VOD file.
        # 
        # If you query the input sources of the production studio by calling the [DescribeCasterVideoResources](https://help.aliyun.com/document_detail/2848023.html) operation, check the value of the response parameter VodUrl to obtain the URL.
        # 
        # >  This parameter takes effect only when the input source is a video file that is not from the media library.\\
        # The video file can be in the MP4, FLV, or TS format.
        self.vod_url = vod_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        if self.vod_url is not None:
            result['VodUrl'] = self.vod_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        if m.get('VodUrl') is not None:
            self.vod_url = m.get('VodUrl')
        return self


class AddCasterEpisodeGroupRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        client_token: str = None,
        domain_name: str = None,
        item: List[AddCasterEpisodeGroupRequestItem] = None,
        owner_id: int = None,
        region_id: str = None,
        repeat_num: int = None,
        side_output_url: str = None,
        start_time: str = None,
    ):
        # The callback URL.
        # 
        # If you query the configurations of the production studio by calling the [DescribeCasterConfig](https://help.aliyun.com/document_detail/2848011.html) operation, check the value of the response parameter CallbackUrl to obtain the URL.
        # 
        # This parameter is required.
        self.callback_url = callback_url
        # The client token that is used to ensure the idempotence of the request.
        # 
        # You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The list of episodes.
        # 
        # This parameter is required.
        self.item = item
        self.owner_id = owner_id
        self.region_id = region_id
        # The number of times the episode list repeats after the first playback is complete. Valid values:
        # 
        # *   **0**: indicates that the episode list is played only once.
        # *   **-1**: indicates that the episode list is played in loop mode.
        # 
        # This parameter is required.
        self.repeat_num = repeat_num
        # The custom standby URL.
        # 
        # If this parameter is empty, the ingest address corresponding to the output address automatically generated by Alibaba Cloud will be used by default.
        # 
        # This parameter is required.
        self.side_output_url = side_output_url
        # The time when the episode list starts to play. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        result['Item'] = []
        if self.item is not None:
            for k in self.item:
                result['Item'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_num is not None:
            result['RepeatNum'] = self.repeat_num
        if self.side_output_url is not None:
            result['SideOutputUrl'] = self.side_output_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        self.item = []
        if m.get('Item') is not None:
            for k in m.get('Item'):
                temp_model = AddCasterEpisodeGroupRequestItem()
                self.item.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNum') is not None:
            self.repeat_num = m.get('RepeatNum')
        if m.get('SideOutputUrl') is not None:
            self.side_output_url = m.get('SideOutputUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class AddCasterEpisodeGroupResponseBodyItemIds(TeaModel):
    def __init__(
        self,
        item_id: List[str] = None,
    ):
        self.item_id = item_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        return self


class AddCasterEpisodeGroupResponseBody(TeaModel):
    def __init__(
        self,
        item_ids: AddCasterEpisodeGroupResponseBodyItemIds = None,
        program_id: str = None,
        request_id: str = None,
    ):
        # The IDs of the episodes.
        self.item_ids = item_ids
        # The ID of the episode list that was added. Record the ID as it can be used to manage the program being added.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.item_ids:
            self.item_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids.to_map()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemIds') is not None:
            temp_model = AddCasterEpisodeGroupResponseBodyItemIds()
            self.item_ids = temp_model.from_map(m['ItemIds'])
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterEpisodeGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterEpisodeGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterEpisodeGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterEpisodeGroupContentRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        content: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The client token that is used to ensure the idempotence of the request.
        # 
        # You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The information about the episode list. The value is a JSON string. Use upper camel case for fields of the string. This parameter contains the following fields:
        # 
        # *   **CallbackUrl**: the callback URL.
        # 
        # *   **SideOutputUrl**: the custom standby URL.
        # 
        # *   **RepeatNum**: the number of times the episode list repeats after the first playback is complete. A value of 0 indicates that the episode list is played only once. A value of -1 indicates that the episode list is played in loop mode.
        # 
        # *   **DomainName**: the domain name.
        # 
        # *   **StartTime**: the time when the episode list starts to play. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   **Items**: the information about the episode list. It is an array of ItemName and VodUrl.
        # 
        #     *   **ItemName**: the name of the episode.
        #     *   **VodUrl**: the URL of the VOD file. This field takes effect only when the video resource is a video file that is not from the media library. The video file must be in the MP4, FLV, or TS format.
        # 
        # This parameter is required.
        self.content = content
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.content is not None:
            result['Content'] = self.content
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddCasterEpisodeGroupContentResponseBodyItemIds(TeaModel):
    def __init__(
        self,
        item_id: List[str] = None,
    ):
        self.item_id = item_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        return self


class AddCasterEpisodeGroupContentResponseBody(TeaModel):
    def __init__(
        self,
        item_ids: AddCasterEpisodeGroupContentResponseBodyItemIds = None,
        program_id: str = None,
        request_id: str = None,
    ):
        # The IDs of the episodes.
        self.item_ids = item_ids
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to create or add episodes, remove episodes, query episodes, edit an episode list, delete an episode list, query the information about an episode list, start playing an episode list, or stop playing an episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.item_ids:
            self.item_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_ids is not None:
            result['ItemIds'] = self.item_ids.to_map()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemIds') is not None:
            temp_model = AddCasterEpisodeGroupContentResponseBodyItemIds()
            self.item_ids = temp_model.from_map(m['ItemIds'])
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterEpisodeGroupContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterEpisodeGroupContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterEpisodeGroupContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterLayoutRequestAudioLayer(TeaModel):
    def __init__(
        self,
        fixed_delay_duration: int = None,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # The fixed delay of audio layer N. You can use this parameter to synchronize the audio with subtitles. Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.
        self.fixed_delay_duration = fixed_delay_duration
        # The valid voice channels of audio layer N. Valid values:
        # 
        # *   **leftChannel**: the left channel.
        # *   **rightChannel**: the right channel.
        # *   **all**: both the left and right channels. This is the default value.
        self.valid_channel = valid_channel
        # The multiples of the original volume at which audio layer N plays audio streams. Valid values: **0 to 10.0**.
        # 
        # *   The default value **1.0** indicates that audio layer N plays audio streams at the original volume.
        # *   A value smaller than **1.0** indicates that audio layer N plays audio streams at a lower volume than the original one.
        # *   A value greater than **1.0** indicates that audio layer N plays audio streams at a higher volume than the original one.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class AddCasterLayoutRequestVideoLayer(TeaModel):
    def __init__(
        self,
        fill_mode: str = None,
        fixed_delay_duration: int = None,
        height_normalized: float = None,
        position_normalized: List[float] = None,
        position_refer: str = None,
        width_normalized: float = None,
    ):
        # The scaling mode of video layer N. Valid values:
        # 
        # *   **none**: The image is not scaled to fill in the specified layout section. Set video layer N based on the image size of the video resource. This is the default value.
        # *   **fit**: The image is scaled with the original aspect ratio to fill in the specified layout section. Set video layer N based on the section size. The image is centered in the layout section with the long side of the image equaling that of the section. If the aspect ratio of the image is inconsistent with that of the section, the short side of the image may be shorter than that of the section. The area outside the image displays the next video layer or the background if no next video layer exists. By default, the background color is black.
        self.fill_mode = fill_mode
        # The fixed delay of video layer N. You can use this parameter to synchronize the video with subtitles. Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.
        self.fixed_delay_duration = fixed_delay_duration
        # The normalized value of the height of the image of video layer N.
        # 
        # *   If the FillMode parameter of video layer N is set to none, the width of the video image is scaled based on this parameter. The default value is **0**, which indicates that the video image is displayed in the original size.
        # *   If the FillMode parameter of video layer N is set to fit, you must set this parameter to a value greater than **0**. In this case, the video image is scaled with the original aspect ratio to fill in the specified layout section based on this parameter.
        self.height_normalized = height_normalized
        # The normalized value of the `[x,y]` coordinates of video layer N in the production studio. The default coordinates are `[0,0]`.
        # 
        # >  The coordinates indicate the location of video layer N in the production studio. Set this parameter to the normalized value of the coordinates.
        self.position_normalized = position_normalized
        # The reference coordinates of video layer N in the production studio. Valid values:
        # 
        # *   **topLeft**: the upper-left corner. This is the default value.
        # *   **topRight**: the upper-right corner.
        # *   **bottomLeft**: the lower-left corner.
        # *   **bottomRight**: the lower-right corner.
        # *   **center**: the center position.
        # *   **topCenter**: the upper center position.
        # *   **bottomCenter**: the lower center position.
        # *   **leftCenter**: the left center position.
        # *   **rightCenter**: the right center position.
        self.position_refer = position_refer
        # The normalized value of the width of the image of video layer N.
        # 
        # *   If the FillMode parameter of video layer N is set to none, the height of the video image is scaled based on this parameter. The default value is **0**, which indicates that the video image is displayed in the original size.
        # *   If the FillMode parameter of video layer N is set to fit, you must set this parameter to a value greater than **0**. In this case, the video image is scaled with the original aspect ratio to fill in the specified layout section based on this parameter.
        self.width_normalized = width_normalized

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fill_mode is not None:
            result['FillMode'] = self.fill_mode
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.width_normalized is not None:
            result['WidthNormalized'] = self.width_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FillMode') is not None:
            self.fill_mode = m.get('FillMode')
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('WidthNormalized') is not None:
            self.width_normalized = m.get('WidthNormalized')
        return self


class AddCasterLayoutRequest(TeaModel):
    def __init__(
        self,
        audio_layer: List[AddCasterLayoutRequestAudioLayer] = None,
        blend_list: List[str] = None,
        caster_id: str = None,
        mix_list: List[str] = None,
        owner_id: int = None,
        region_id: str = None,
        video_layer: List[AddCasterLayoutRequestVideoLayer] = None,
    ):
        # Audio layout.
        # 
        # This parameter is required.
        self.audio_layer = audio_layer
        # The element represents the location ID of the video resource, i.e., LocationId. Refer to [Adding Video Source](https://help.aliyun.com/document_detail/60250.html) for LocationId, which corresponds in order with the VideoLayers elements.
        # 
        # This parameter is required.
        self.blend_list = blend_list
        # The ID of the production studio.
        # 
        # If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.
        # 
        # If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:
        # 
        # Production Studios > Production Studio Management
        # 
        # >  The CasterId is reflected in the Name column on the Production Studio Management page.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The element represents the location ID of the audio resource, i.e., LocationId.
        # LocationId is referred to in [Adding Video Source](https://help.aliyun.com/document_detail/60250.html), and corresponds in order with the AudioLayers elements.
        # 
        # This parameter is required.
        self.mix_list = mix_list
        self.owner_id = owner_id
        self.region_id = region_id
        # Video layout.
        # 
        # This parameter is required.
        self.video_layer = video_layer

    def validate(self):
        if self.audio_layer:
            for k in self.audio_layer:
                if k:
                    k.validate()
        if self.video_layer:
            for k in self.video_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioLayer'] = []
        if self.audio_layer is not None:
            for k in self.audio_layer:
                result['AudioLayer'].append(k.to_map() if k else None)
        if self.blend_list is not None:
            result['BlendList'] = self.blend_list
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.mix_list is not None:
            result['MixList'] = self.mix_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['VideoLayer'] = []
        if self.video_layer is not None:
            for k in self.video_layer:
                result['VideoLayer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_layer = []
        if m.get('AudioLayer') is not None:
            for k in m.get('AudioLayer'):
                temp_model = AddCasterLayoutRequestAudioLayer()
                self.audio_layer.append(temp_model.from_map(k))
        if m.get('BlendList') is not None:
            self.blend_list = m.get('BlendList')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('MixList') is not None:
            self.mix_list = m.get('MixList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.video_layer = []
        if m.get('VideoLayer') is not None:
            for k in m.get('VideoLayer'):
                temp_model = AddCasterLayoutRequestVideoLayer()
                self.video_layer.append(temp_model.from_map(k))
        return self


class AddCasterLayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        request_id: str = None,
    ):
        # The ID of the layout.
        # 
        # Record the ID as it can be used to manage the layout being created.
        self.layout_id = layout_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterProgramRequestEpisode(TeaModel):
    def __init__(
        self,
        component_id: List[str] = None,
        end_time: str = None,
        episode_name: str = None,
        episode_type: str = None,
        resource_id: str = None,
        start_time: str = None,
        switch_type: str = None,
    ):
        # The components. Components in the production studio are listed from the bottom to the top in an array.
        # 
        # >  This parameter is required and takes effect when the Episode.N.EpisodeType parameter is set to Component.
        # 
        # This parameter is optional when the Episode.N.EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.
        self.component_id = component_id
        # The end time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The name of the episode.
        self.episode_name = episode_name
        # The type of the episode.
        # 
        # *   **Resource**: a video resource If you set this parameter to Resource, you must specify the Episode.N.ResourceId and Episode.N.SwitchType parameters.
        # *   **Component**: a component If you set this parameter to Component, you must specify the Episode.N.ComponentId.N parameter.
        self.episode_type = episode_type
        # The ID of the video resource.
        # 
        # >  This parameter takes effect and is required when the Episode.N.EpisodeType parameter is set to Resource.
        # 
        # \\
        # This parameter is invalid if you set the Episode.N.EpisodeType parameter to **Component**.
        # 
        # If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/60250.html) operation, check the value of the response parameter ResourceId to obtain the ID.
        self.resource_id = resource_id
        # The start time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The policy for switching episodes. Valid values:
        # 
        # >  This parameter takes effect only when the Episode.N.EpisodeType parameter is set to Resource.
        # 
        # *   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
        # *   **ContentFirst**: The episode starts and ends as scheduled.
        self.switch_type = switch_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_name is not None:
            result['EpisodeName'] = self.episode_name
        if self.episode_type is not None:
            result['EpisodeType'] = self.episode_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeName') is not None:
            self.episode_name = m.get('EpisodeName')
        if m.get('EpisodeType') is not None:
            self.episode_type = m.get('EpisodeType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class AddCasterProgramRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episode: List[AddCasterProgramRequestEpisode] = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The information about episodes in the episode list.
        # 
        # This parameter is required.
        self.episode = episode
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        if self.episode:
            for k in self.episode:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        result['Episode'] = []
        if self.episode is not None:
            for k in self.episode:
                result['Episode'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        self.episode = []
        if m.get('Episode') is not None:
            for k in m.get('Episode'):
                temp_model = AddCasterProgramRequestEpisode()
                self.episode.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddCasterProgramResponseBodyEpisodeIdsEpisodeId(TeaModel):
    def __init__(
        self,
        episode_id: str = None,
    ):
        # The ID of the episode. You can use the ID as a request parameter in the API operation that is used to modify the episode list, query the information about the episode list, delete the episode, or modify the configurations of the episode.
        self.episode_id = episode_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        return self


class AddCasterProgramResponseBodyEpisodeIds(TeaModel):
    def __init__(
        self,
        episode_id: List[AddCasterProgramResponseBodyEpisodeIdsEpisodeId] = None,
    ):
        self.episode_id = episode_id

    def validate(self):
        if self.episode_id:
            for k in self.episode_id:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EpisodeId'] = []
        if self.episode_id is not None:
            for k in self.episode_id:
                result['EpisodeId'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.episode_id = []
        if m.get('EpisodeId') is not None:
            for k in m.get('EpisodeId'):
                temp_model = AddCasterProgramResponseBodyEpisodeIdsEpisodeId()
                self.episode_id.append(temp_model.from_map(k))
        return self


class AddCasterProgramResponseBody(TeaModel):
    def __init__(
        self,
        episode_ids: AddCasterProgramResponseBodyEpisodeIds = None,
        request_id: str = None,
    ):
        # The IDs of the episodes. The episode IDs are listed in the same order as specified by the variable N.
        self.episode_ids = episode_ids
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.episode_ids:
            self.episode_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.episode_ids is not None:
            result['EpisodeIds'] = self.episode_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EpisodeIds') is not None:
            temp_model = AddCasterProgramResponseBodyEpisodeIds()
            self.episode_ids = temp_model.from_map(m['EpisodeIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCasterProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCasterVideoResourceRequest(TeaModel):
    def __init__(
        self,
        begin_offset: int = None,
        caster_id: str = None,
        end_offset: int = None,
        fixed_delay_duration: int = None,
        image_id: str = None,
        image_url: str = None,
        live_stream_url: str = None,
        location_id: str = None,
        material_id: str = None,
        owner_id: int = None,
        pts_callback_interval: int = None,
        region_id: str = None,
        repeat_num: int = None,
        resource_name: str = None,
        vod_url: str = None,
    ):
        # The offset of the position where the system starts to read the video source. Unit: milliseconds.
        # 
        # **\
        # 
        # **Important** This parameter takes effect only if the video source is a file.
        # 
        # > A value greater than **0** specifies an offset from the first frame.
        self.begin_offset = begin_offset
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # > You can find the ID of the production studio in the Instance Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The offset of the position where the system stops reading the video source. Unit: milliseconds.
        # 
        # **\
        # 
        # **Important** This parameter takes effect only if the video source is a file.
        # 
        # *   A value greater than **0** specifies an offset from the first frame.
        # *   A value less than **0** specifies an offset from the last frame.
        self.end_offset = end_offset
        # The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles. Unit: milliseconds. Default value: 0. Valid values: `0 to 5000`.
        self.fixed_delay_duration = fixed_delay_duration
        # ID of the media library image material. 
        # >This parameter is only available and must be provided when the video source type is an image.
        self.image_id = image_id
        # Image material URL. 
        # >This parameter is available only when the video source type is an image and the image file has not been imported into the material library. Supports uploading images in jpg, png formats, with a maximum file size of 10MB.
        self.image_url = image_url
        # The streaming URL.
        # 
        # **\
        # 
        # **Important** This parameter is required if the video source is a live stream.
        # 
        # > Do not specify this parameter in the request if the video source is not a live stream.
        self.live_stream_url = live_stream_url
        # The ID that is used to identify the position of the video source.
        # 
        # Define the reference numbers in the layout. Each reference number is associated with only one resource. The value of this parameter must be in the RV[Number] format, where Number is `01 to 99`.
        self.location_id = location_id
        # The ID of the material from the media library.
        # 
        # **\
        # 
        # **Important** This parameter takes effect and is required only if the video source is a material.
        # 
        # If you query the configurations of the production studio by calling the [DescribeCasterConfig](https://help.aliyun.com/document_detail/60259.html) operation, obtain the value of the response parameter UrgentMaterialId.
        # 
        # > The value of the UrgentMaterialId parameter is the ID of the material from the media library.
        self.material_id = material_id
        self.owner_id = owner_id
        # The interval between presentation timestamp (PTS) callbacks. Unit: milliseconds.
        self.pts_callback_interval = pts_callback_interval
        self.region_id = region_id
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # **\
        # 
        # **Important** This parameter takes effect only if the video source is a file.
        # 
        # *   **0**: specifies that the video source is played only once. This is the default value.
        # *   **-1**: specifies that the video source is played in loop mode.
        self.repeat_num = repeat_num
        # The name of the video source.
        # 
        # This parameter is required.
        self.resource_name = resource_name
        # The URL of the VOD file.
        # 
        # **\
        # 
        # **Important** This parameter takes effect only if the video source is a file that is not from the media library.
        # 
        # > The VOD file must be in the MP4, FLV, or TS format.
        self.vod_url = vod_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_offset is not None:
            result['BeginOffset'] = self.begin_offset
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.end_offset is not None:
            result['EndOffset'] = self.end_offset
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.live_stream_url is not None:
            result['LiveStreamUrl'] = self.live_stream_url
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pts_callback_interval is not None:
            result['PtsCallbackInterval'] = self.pts_callback_interval
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_num is not None:
            result['RepeatNum'] = self.repeat_num
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.vod_url is not None:
            result['VodUrl'] = self.vod_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginOffset') is not None:
            self.begin_offset = m.get('BeginOffset')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EndOffset') is not None:
            self.end_offset = m.get('EndOffset')
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LiveStreamUrl') is not None:
            self.live_stream_url = m.get('LiveStreamUrl')
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PtsCallbackInterval') is not None:
            self.pts_callback_interval = m.get('PtsCallbackInterval')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNum') is not None:
            self.repeat_num = m.get('RepeatNum')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('VodUrl') is not None:
            self.vod_url = m.get('VodUrl')
        return self


class AddCasterVideoResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resource_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the resource. This parameter can be used as a request parameter in the API operation that you can call to delete the video source in the production studio or modify the video source in the production studio.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class AddCasterVideoResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCasterVideoResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCasterVideoResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddCustomLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        audio_bitrate: int = None,
        audio_channel_num: int = None,
        audio_codec: str = None,
        audio_profile: str = None,
        audio_rate: int = None,
        bitrate_with_source: str = None,
        de_interlaced: bool = None,
        domain: str = None,
        encrypt_parameters: str = None,
        ext_with_source: str = None,
        fps: int = None,
        fps_with_source: str = None,
        gop: str = None,
        height: int = None,
        kms_key_expire_interval: str = None,
        kms_key_id: str = None,
        kms_uid: str = None,
        lazy: str = None,
        owner_id: int = None,
        profile: int = None,
        region_id: str = None,
        res_with_source: str = None,
        template: str = None,
        template_type: str = None,
        video_bitrate: int = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: **1 to 1000**.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values:
        # 
        # *   **1**: mono.
        # *   **2**: binaural.
        self.audio_channel_num = audio_channel_num
        # The audio encoding format. Valid values:
        # 
        # *   **AAC**\
        # *   **MP3**\
        self.audio_codec = audio_codec
        # The audio encoding profile. Valid values:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        self.audio_profile = audio_profile
        # The audio sampling rate. Valid values: **22050 to 96000**.
        # 
        # 
        # >Notice: If you set AudioProfile to **aac_ld**, the audio sampling rate cannot exceed 44100.
        self.audio_rate = audio_rate
        # The source-based bitrate settings. This parameter takes precedence over other bitrate settings. The following fields must be included:
        # 
        # *   **UpLimit**: the maximum bitrate limit. Valid values: an integer from 128 to 10000. The value must be greater than the minimum bitrate.
        # *   **LowerLimit int** : the minimum bitrate rate. Valid values: an integer from 128 to 10000. The value must be smaller than the maximum bitrate.
        # *   **Factor**: The ratio of the output bitrate to the source bitrate. Valid values: 0.1 to 1. The value is accurate to one decimal place. A value of 1 indicates that the output video has the same bitrate as the source video.
        self.bitrate_with_source = bitrate_with_source
        self.de_interlaced = de_interlaced
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # Encryption configuration. In JSON format, the fields are explained as follows:
        # - **EncryptType**: Encryption type. Fixed value is aliyun.
        # - **KmsKeyID**: User KMS master key ID.
        # - **KmsKeyExpireInterval**: Key rotation period. Range: 60~3600, unit: seconds.
        # > If the EncryptParameters is configured, the KmsKeyID, KmsUID, and KmsKeyExpireInterval parameters cannot be empty
        self.encrypt_parameters = encrypt_parameters
        # Other source-based settings, including the following fields:
        # 
        # *   **KeyFrameOpen**: specifies whether to use the key frames of the source video. Valid values: yes or no.
        # *   **Copyts**: specifies whether to use the presentation time stamp (PTS) of the source video. Valid values: yes or no.
        # *   **SeiMode**: specifies whether to pass through supplemental enhancement information (SEI) messages. Valid values: 0, 1, and 2, where 0 specifies that no SEI messages are passed through, 1 specifies that part of SEI messages are passed through, and 2 specifies that all SEI messages are passed through.
        self.ext_with_source = ext_with_source
        # The frame rate of the output video. Unit: frames per second (FPS). Valid values: **1 to 60**.
        self.fps = fps
        # The source-based frame rate settings. This parameter takes precedence over other frame rate settings. The following fields must be included:
        # 
        # *   **UpLimit**: the maximum frame rate. Valid values: an integer from 1 to 60. The value must be greater than the minimum frame rate.
        # *   **LowerLimit**: the minimum frame rate. Valid values: an integer from 1 to 60. The value must be smaller than the maximum frame rate.
        self.fps_with_source = fps_with_source
        # The Group of Picture (GOP) size of the video. Unit: frames or seconds.
        # 
        # *   Unit: frames. Valid values: **1 to 3000**.
        # *   Unit: seconds. Valid value: **1 to 20**.
        self.gop = gop
        # The height of the output video. Unit: pixel. Valid values:
        # 
        # The value must comply with all the following rules:
        # 
        # *   **Height  100**: The height of the video is greater than or equal to 100 pixels.
        # *   **max(Height,Width)  2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
        # *   **min(Height,Width)  1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.
        # 
        # > The resolution of the output video that is transcoded by using the H.265 Narrowband HD transcoding template cannot exceed 1280  720 pixels.
        self.height = height
        # The rotation period of the CMK. Valid values: 60 to 3600. Unit: seconds.
        self.kms_key_expire_interval = kms_key_expire_interval
        # The ID of the customer master key (CMK) that you created in Key Management Service (KMS).
        self.kms_key_id = kms_key_id
        # The ID of your KMS account.
        self.kms_uid = kms_uid
        # Specifies whether to use the load-on-demand mechanism for transcoding. Valid values: yes and no. Default value: **yes**.
        self.lazy = lazy
        self.owner_id = owner_id
        # The video encoding profile. The profile defines a set of parameters that are used to encode a video. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values:
        # 
        # *   **1**: baseline. This value is suitable for mobile devices.
        # *   **2**: main. This value is suitable for standard-definition devices.
        # *   **3**: high. This value is suitable for high-definition devices.
        self.profile = profile
        self.region_id = region_id
        # The source-based resolution settings. This parameter takes precedence over other resolution settings. The following fields must be included:
        # 
        # *   **Type**: You can set this field to short, long, or screen. short specifies that the resolution of the output video is adapted to the shorter side, long specifies that the resolution of the output video is adapted to the longer side, and screen specifies that the output video has an adaptive resolution.
        # 
        # *   **Value**:
        # 
        #     *   Set this field to 360, 480, 540, 720, or 1080 if the Type field is set to short.
        #     *   Set this field to 640, 848, 960, 1280, or 1920 if the Type field is set to long.
        #     *   Set this field to 640\\*360, 848\\*480, 960\\*540, 1280\\*720, or 1920\\*1080 if the Type field is set to screen.
        self.res_with_source = res_with_source
        # The name of the custom transcoding template.
        # 
        # > The name can contain digits, letters, and hyphens (-), and must start with a letter or digit. The name must be different from the names of any default transcoding templates.
        # 
        # This parameter is required.
        self.template = template
        # The type of the custom transcoding template. Valid values:
        # 
        # *   **h264**: custom H.264 standard transcoding.
        # *   **h264-nbhd**: custom H.264 Narrowband HD transcoding.
        # *   **h265**: custom H.265 standard transcoding.
        # *   **h265-nbhd**: custom H.265 Narrowband HD transcoding.
        # *   **audio**: audio-only transcoding.
        # 
        # > If you set **TemplateType** to **h264**, **h264-nbhd**, **h265**, or **h265-nbhd**, the **Height**, **Width**, **FPS**, and **VideoBitrate** parameters are required.
        # 
        # This parameter is required.
        self.template_type = template_type
        # The bitrate of the output video. Unit: Kbit/s. Valid values: **1 to 6000**.
        # 
        # > The bitrate of the output video may not be the same as the value that you specify, but is as close to the value as possible, especially when the value is excessively large or small.
        self.video_bitrate = video_bitrate
        # The width of the output video. Unit: pixel. Valid values:
        # 
        # The value must comply with all the following rules:
        # 
        # *   **Width  100**: The width of the video is greater than or equal to 100 pixels.
        # *   **max(Height,Width)  2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
        # *   **min(Height,Width)  1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.
        # 
        # > The resolution of the output video that is transcoded by using the H.265 Narrowband HD transcoding template cannot exceed 1280  720 pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channel_num is not None:
            result['AudioChannelNum'] = self.audio_channel_num
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_profile is not None:
            result['AudioProfile'] = self.audio_profile
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.bitrate_with_source is not None:
            result['BitrateWithSource'] = self.bitrate_with_source
        if self.de_interlaced is not None:
            result['DeInterlaced'] = self.de_interlaced
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.encrypt_parameters is not None:
            result['EncryptParameters'] = self.encrypt_parameters
        if self.ext_with_source is not None:
            result['ExtWithSource'] = self.ext_with_source
        if self.fps is not None:
            result['FPS'] = self.fps
        if self.fps_with_source is not None:
            result['FpsWithSource'] = self.fps_with_source
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.kms_key_expire_interval is not None:
            result['KmsKeyExpireInterval'] = self.kms_key_expire_interval
        if self.kms_key_id is not None:
            result['KmsKeyID'] = self.kms_key_id
        if self.kms_uid is not None:
            result['KmsUID'] = self.kms_uid
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.res_with_source is not None:
            result['ResWithSource'] = self.res_with_source
        if self.template is not None:
            result['Template'] = self.template
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannelNum') is not None:
            self.audio_channel_num = m.get('AudioChannelNum')
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioProfile') is not None:
            self.audio_profile = m.get('AudioProfile')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('BitrateWithSource') is not None:
            self.bitrate_with_source = m.get('BitrateWithSource')
        if m.get('DeInterlaced') is not None:
            self.de_interlaced = m.get('DeInterlaced')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EncryptParameters') is not None:
            self.encrypt_parameters = m.get('EncryptParameters')
        if m.get('ExtWithSource') is not None:
            self.ext_with_source = m.get('ExtWithSource')
        if m.get('FPS') is not None:
            self.fps = m.get('FPS')
        if m.get('FpsWithSource') is not None:
            self.fps_with_source = m.get('FpsWithSource')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('KmsKeyExpireInterval') is not None:
            self.kms_key_expire_interval = m.get('KmsKeyExpireInterval')
        if m.get('KmsKeyID') is not None:
            self.kms_key_id = m.get('KmsKeyID')
        if m.get('KmsUID') is not None:
            self.kms_uid = m.get('KmsUID')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResWithSource') is not None:
            self.res_with_source = m.get('ResWithSource')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddCustomLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCustomLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddCustomLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCustomLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAIProduceRulesRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        description: str = None,
        domain: str = None,
        is_lazy: bool = None,
        live_template: str = None,
        owner_id: int = None,
        region_id: str = None,
        studio_name: str = None,
        subtitle_name: str = None,
        suffix: str = None,
    ):
        # The name of the application to which the live stream belongs. The name can be up to 256 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name must be the same as the application name in the ingest URL. Otherwise, the rule does not take effect.
        # 
        # This parameter is required.
        self.app = app
        # The description of the subtitle rule. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # Specifies whether to trigger the subtitle rule when stream pulling starts. Valid values:
        # 
        # *   true: generates live subtitles when stream pulling starts and stops generating live subtitles when no stream is pulled for 5 minutes. When stream pulling restarts, live subtitles are generated again.
        # *   false: generates live subtitles when stream ingest starts, regardless of whether stream pulling starts.
        self.is_lazy = is_lazy
        # The specification of the output subtitles. Valid values:
        # 
        # *   `lp_ld`: landscape low definition 360p (640360)
        # *   `lp_ld_v`: portrait low definition 360p (360640)
        # *   `lp_sd`: landscape standard definition 480p (854480)
        # *   `lp_sd_v`: portrait standard definition 480p (480854)
        # *   `lp_hd`: landscape high definition 720p (1280720)
        # *   `lp_hd_v`: portrait high definition 720p (7201280)
        # *   `lp_ud`: landscape ultra-high definition 1080p (19201080)
        # *   `lp_ud_v`: portrait ultra-high definition 1080p (10801920)
        # 
        # This parameter is required.
        self.live_template = live_template
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the virtual background template.
        self.studio_name = studio_name
        # The name of the subtitle template.
        self.subtitle_name = subtitle_name
        # The suffix to match.
        self.suffix = suffix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.is_lazy is not None:
            result['IsLazy'] = self.is_lazy
        if self.live_template is not None:
            result['LiveTemplate'] = self.live_template
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.suffix is not None:
            result['Suffix'] = self.suffix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IsLazy') is not None:
            self.is_lazy = m.get('IsLazy')
        if m.get('LiveTemplate') is not None:
            self.live_template = m.get('LiveTemplate')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Suffix') is not None:
            self.suffix = m.get('Suffix')
        return self


class AddLiveAIProduceRulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rules_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the subtitle rule.
        self.rules_id = rules_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        return self


class AddLiveAIProduceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAIProduceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAIProduceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAISubtitleRequest(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        bg_width_normalized: float = None,
        border_width_normalized: float = None,
        copy_from: str = None,
        description: str = None,
        dst_language: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size_normalized: float = None,
        height: str = None,
        max_lines: int = None,
        owner_id: int = None,
        position_normalized: List[float] = None,
        region_id: str = None,
        show_source_lan: bool = None,
        src_language: str = None,
        subtitle_name: str = None,
        width: str = None,
        word_per_line: int = None,
    ):
        # The background color of the subtitles, which is an RGBA value.
        self.bg_color = bg_color
        # The background size of the subtitles. Valid values: [0,1].
        self.bg_width_normalized = bg_width_normalized
        # The font weight. Valid values: [0,1].
        self.border_width_normalized = border_width_normalized
        # The subtitle template that you copy. Set the value to the name of the subtitle template.
        self.copy_from = copy_from
        # The custom description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The target language. Valid values:
        #  - en-US: English 
        # - zh-CN: Chinese 
        # - es-ES: Spanish 
        # - ru-RU: Russian
        self.dst_language = dst_language
        # The font color, which is an RGBA value.
        self.font_color = font_color
        # The font. Valid values:
        # - KaiTi (default)
        # - AlibabaPuHuiTi-Regular
        # - AlibabaPuHuiTi-Bold
        # - AlibabaPuHuiTi-Light
        # - NotoSansHans-Regular
        # - NotoSansHans-Bold
        # - NotoSansHans-Light
        self.font_name = font_name
        # The font size. Valid values: [0,1].
        # 
        # This parameter is required.
        self.font_size_normalized = font_size_normalized
        # The preview height. Unit: pixels.
        # The following specifications of preview width  preview height are supported: 
        # - Landscape low definition 360p (640360) 
        # - Portrait low definition 360p (360640)
        # - Landscape standard definition 480p (854480)
        # - Portrait standard definition 480p (480854)
        # - Landscape high definition 720p (1280720)
        # - Portrait high definition 720p (7201280)
        # - Landscape ultra-high definition 1080p (19201080)
        # - Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The number of displayed lines.
        self.max_lines = max_lines
        self.owner_id = owner_id
        # The position of the subtitles. The value is a pair of coordinates for which the origin of the x and y axes is the lower-left corner of the screen.
        # 
        # This parameter is required.
        self.position_normalized = position_normalized
        self.region_id = region_id
        # Specifies whether to display the source language. Default value: false.
        self.show_source_lan = show_source_lan
        # The source language. Valid values:
        #  - en-US: English 
        # - zh-CN: Chinese 
        # - ru-RU: Russian
        # 
        # This parameter is required.
        self.src_language = src_language
        # The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.
        # 
        # This parameter is required.
        self.subtitle_name = subtitle_name
        # The preview width. Unit: pixels.
        self.width = width
        # The number of words displayed per line. Valid values: integers from 1 to 500.
        # 
        # This parameter is required.
        self.word_per_line = word_per_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.bg_width_normalized is not None:
            result['BgWidthNormalized'] = self.bg_width_normalized
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.copy_from is not None:
            result['CopyFrom'] = self.copy_from
        if self.description is not None:
            result['Description'] = self.description
        if self.dst_language is not None:
            result['DstLanguage'] = self.dst_language
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size_normalized is not None:
            result['FontSizeNormalized'] = self.font_size_normalized
        if self.height is not None:
            result['Height'] = self.height
        if self.max_lines is not None:
            result['MaxLines'] = self.max_lines
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.src_language is not None:
            result['SrcLanguage'] = self.src_language
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.width is not None:
            result['Width'] = self.width
        if self.word_per_line is not None:
            result['WordPerLine'] = self.word_per_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BgWidthNormalized') is not None:
            self.bg_width_normalized = m.get('BgWidthNormalized')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('CopyFrom') is not None:
            self.copy_from = m.get('CopyFrom')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DstLanguage') is not None:
            self.dst_language = m.get('DstLanguage')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSizeNormalized') is not None:
            self.font_size_normalized = m.get('FontSizeNormalized')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxLines') is not None:
            self.max_lines = m.get('MaxLines')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SrcLanguage') is not None:
            self.src_language = m.get('SrcLanguage')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WordPerLine') is not None:
            self.word_per_line = m.get('WordPerLine')
        return self


class AddLiveAISubtitleShrinkRequest(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        bg_width_normalized: float = None,
        border_width_normalized: float = None,
        copy_from: str = None,
        description: str = None,
        dst_language: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size_normalized: float = None,
        height: str = None,
        max_lines: int = None,
        owner_id: int = None,
        position_normalized_shrink: str = None,
        region_id: str = None,
        show_source_lan: bool = None,
        src_language: str = None,
        subtitle_name: str = None,
        width: str = None,
        word_per_line: int = None,
    ):
        # The background color of the subtitles, which is an RGBA value.
        self.bg_color = bg_color
        # The background size of the subtitles. Valid values: [0,1].
        self.bg_width_normalized = bg_width_normalized
        # The font weight. Valid values: [0,1].
        self.border_width_normalized = border_width_normalized
        # The subtitle template that you copy. Set the value to the name of the subtitle template.
        self.copy_from = copy_from
        # The custom description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The target language. Valid values:
        #  - en-US: English 
        # - zh-CN: Chinese 
        # - es-ES: Spanish 
        # - ru-RU: Russian
        self.dst_language = dst_language
        # The font color, which is an RGBA value.
        self.font_color = font_color
        # The font. Valid values:
        # - KaiTi (default)
        # - AlibabaPuHuiTi-Regular
        # - AlibabaPuHuiTi-Bold
        # - AlibabaPuHuiTi-Light
        # - NotoSansHans-Regular
        # - NotoSansHans-Bold
        # - NotoSansHans-Light
        self.font_name = font_name
        # The font size. Valid values: [0,1].
        # 
        # This parameter is required.
        self.font_size_normalized = font_size_normalized
        # The preview height. Unit: pixels.
        # The following specifications of preview width  preview height are supported: 
        # - Landscape low definition 360p (640360) 
        # - Portrait low definition 360p (360640)
        # - Landscape standard definition 480p (854480)
        # - Portrait standard definition 480p (480854)
        # - Landscape high definition 720p (1280720)
        # - Portrait high definition 720p (7201280)
        # - Landscape ultra-high definition 1080p (19201080)
        # - Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The number of displayed lines.
        self.max_lines = max_lines
        self.owner_id = owner_id
        # The position of the subtitles. The value is a pair of coordinates for which the origin of the x and y axes is the lower-left corner of the screen.
        # 
        # This parameter is required.
        self.position_normalized_shrink = position_normalized_shrink
        self.region_id = region_id
        # Specifies whether to display the source language. Default value: false.
        self.show_source_lan = show_source_lan
        # The source language. Valid values:
        #  - en-US: English 
        # - zh-CN: Chinese 
        # - ru-RU: Russian
        # 
        # This parameter is required.
        self.src_language = src_language
        # The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.
        # 
        # This parameter is required.
        self.subtitle_name = subtitle_name
        # The preview width. Unit: pixels.
        self.width = width
        # The number of words displayed per line. Valid values: integers from 1 to 500.
        # 
        # This parameter is required.
        self.word_per_line = word_per_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.bg_width_normalized is not None:
            result['BgWidthNormalized'] = self.bg_width_normalized
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.copy_from is not None:
            result['CopyFrom'] = self.copy_from
        if self.description is not None:
            result['Description'] = self.description
        if self.dst_language is not None:
            result['DstLanguage'] = self.dst_language
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size_normalized is not None:
            result['FontSizeNormalized'] = self.font_size_normalized
        if self.height is not None:
            result['Height'] = self.height
        if self.max_lines is not None:
            result['MaxLines'] = self.max_lines
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.position_normalized_shrink is not None:
            result['PositionNormalized'] = self.position_normalized_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.src_language is not None:
            result['SrcLanguage'] = self.src_language
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.width is not None:
            result['Width'] = self.width
        if self.word_per_line is not None:
            result['WordPerLine'] = self.word_per_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BgWidthNormalized') is not None:
            self.bg_width_normalized = m.get('BgWidthNormalized')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('CopyFrom') is not None:
            self.copy_from = m.get('CopyFrom')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DstLanguage') is not None:
            self.dst_language = m.get('DstLanguage')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSizeNormalized') is not None:
            self.font_size_normalized = m.get('FontSizeNormalized')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxLines') is not None:
            self.max_lines = m.get('MaxLines')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PositionNormalized') is not None:
            self.position_normalized_shrink = m.get('PositionNormalized')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SrcLanguage') is not None:
            self.src_language = m.get('SrcLanguage')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WordPerLine') is not None:
            self.word_per_line = m.get('WordPerLine')
        return self


class AddLiveAISubtitleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subtitle_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the subtitle template.
        self.subtitle_id = subtitle_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        return self


class AddLiveAISubtitleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAISubtitleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAISubtitleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAppRecordConfigRequestRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.
        # 
        # > 
        # 
        # *   If a live stream is interrupted during a recording cycle but is resumed within the interruption duration threshold, the stream is recorded in the same recording before and after the interruption.
        # 
        # *   If a live stream is interrupted for longer than the interruption duration threshold, a new recording is generated.
        self.cycle_duration = cycle_duration
        # The recording format. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:
        # 
        # >  You need to specify at lease one of the RecordFormat and TranscodeRecordFormat parameters. If you set this parameter to m3u8 or cmaf, you must also specify the RecordFormat.N.SliceOssObjectPrefix and RecordFormat.N.SliceDuration parameters.
        # 
        # *   m3u8
        # *   flv
        # *   mp4
        # *   cmaf
        self.format = format
        # The naming format of a recording to store in OSS.
        # 
        # *   The name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
        # *   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration
        # The naming format of a segment.
        # 
        # >  This parameter is required only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # *   By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence} variables.
        # *   The segment name must contain the {UnixTimestamp} and {Sequence} variables.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class AddLiveAppRecordConfigRequestTranscodeRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The transcoded stream recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.
        self.cycle_duration = cycle_duration
        # The transcoded stream recording format. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:
        # 
        # >  If you set this parameter to m3u8 or cmaf, you must also specify the TranscodeRecordFormat.N.SliceOssObjectPrefix and TranscodeRecordFormat.N.SliceDuration parameters.
        # 
        # *   m3u8
        # *   flv
        # *   mp4
        # *   cmaf
        self.format = format
        # The naming format of a transcoded stream recording to store in OSS.
        # 
        # *   The name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
        # *   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a single segment in a transcoded stream recording. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration
        # The naming format of a segment in a transcoded stream recording.
        # 
        # >  This parameter is required only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # *   By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence} variables.
        # *   The segment name must contain the {UnixTimestamp} and {Sequence} variables.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class AddLiveAppRecordConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        delay_time: int = None,
        domain_name: str = None,
        end_time: str = None,
        on_demand: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        owner_id: int = None,
        record_format: List[AddLiveAppRecordConfigRequestRecordFormat] = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
        transcode_record_format: List[AddLiveAppRecordConfigRequestTranscodeRecordFormat] = None,
        transcode_templates: List[str] = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all applications, specify an asterisk (\\*) as the value.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Duration for stream concatenation. If the live streaming interruption exceeds the set concatenation duration, a new file will be generated. The concatenation duration can be set between 15 to 21600 seconds.
        self.delay_time = delay_time
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Recording end time. Format: <i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z (UTC time).
        # > The difference between EndTime and StartTime should not exceed 7 days; if it does, it will be calculated as 7 days. This is only valid for stream-level recording (when StreamName is not empty).
        self.end_time = end_time
        # Specifies whether to enable on-demand recording. Valid values:
        # 
        # *   **0**: disables on-demand recording.
        # *   **1**: enables on-demand recording by using the HTTP callback method.
        # *   **2**: enables on-demand recording by parsing the stream ingest parameters.
        # *   **7**: By default, ApsaraVideo Live does not automatically record live streams. You can call the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/2847882.html) operation to manually start or stop recording.
        # 
        # >  If you set the OnDemand parameter to **1**, you need to call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847891.html) operation to configure the OnDemandUrl parameter. Otherwise, ApsaraVideo Live does not perform on-demand recording.
        self.on_demand = on_demand
        # The name of the OSS bucket where live streaming recording files are stored. To store recorded files in OSS, you need to create an OSS bucket in advance. For creation method, please refer to [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        # 
        # This parameter is required.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket. 
        # To store live stream recordings in OSS, you need to create an OSS bucket in advance. For more information, see Configure OSS.
        # 
        # This parameter is required.
        self.oss_endpoint = oss_endpoint
        self.owner_id = owner_id
        # The recording details.
        self.record_format = record_format
        self.security_token = security_token
        # Start time of the recording. Format: <i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z (UTC time).
        # > The set time must be within 7 days of the actual streaming start time, and is only valid for stream-level recording (when StreamName is not empty).
        self.start_time = start_time
        # Stream broadcast name.
        self.stream_name = stream_name
        # The transcoded stream recording details.
        self.transcode_record_format = transcode_record_format
        # Transcoding stream recording template group.
        self.transcode_templates = transcode_templates

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()
        if self.transcode_record_format:
            for k in self.transcode_record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        result['TranscodeRecordFormat'] = []
        if self.transcode_record_format is not None:
            for k in self.transcode_record_format:
                result['TranscodeRecordFormat'].append(k.to_map() if k else None)
        if self.transcode_templates is not None:
            result['TranscodeTemplates'] = self.transcode_templates
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = AddLiveAppRecordConfigRequestRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        self.transcode_record_format = []
        if m.get('TranscodeRecordFormat') is not None:
            for k in m.get('TranscodeRecordFormat'):
                temp_model = AddLiveAppRecordConfigRequestTranscodeRecordFormat()
                self.transcode_record_format.append(temp_model.from_map(k))
        if m.get('TranscodeTemplates') is not None:
            self.transcode_templates = m.get('TranscodeTemplates')
        return self


class AddLiveAppRecordConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveAppRecordConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAppRecordConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAppRecordConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAppSnapshotConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        callback: str = None,
        domain_name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        overwrite_oss_object: str = None,
        owner_id: int = None,
        security_token: str = None,
        sequence_oss_object: str = None,
        time_interval: int = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The callback URL that is used to receive notifications about snapshot capture.
        self.callback = callback
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the OSS bucket.
        # 
        # After the configuration is complete, you can search for specific snapshots in the OSS console based on the callback information. You must create the OSS bucket in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        # 
        # This parameter is required.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        # 
        # After the configuration is complete, you can search for specific snapshots in the OSS console based on the callback information. You must configure the OSS endpoint in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        # 
        # This parameter is required.
        self.oss_endpoint = oss_endpoint
        # The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.
        # 
        # *   The name must be less than 256 bytes in length.
        # *   Only JPG images are supported.
        # *   The name can contain variables such as {AppName} and {StreamName}.
        self.overwrite_oss_object = overwrite_oss_object
        self.owner_id = owner_id
        self.security_token = security_token
        # The naming format of snapshots that are stored in sequence,
        # 
        # which means that a new snapshot does not overwrite the previous snapshot. You can call the [DescribeLiveStreamSnapshotInfo](https://help.aliyun.com/document_detail/2847902.html) operation to query the snapshots that were captured within a specific time period.
        # 
        # *   The name must be less than 256 bytes in length.
        # *   Only JPG images are supported.
        # *   The name can contain variables such as {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence}. The name must contain at least one of the {UnixTimestamp} and {Sequence} variables.
        self.sequence_oss_object = sequence_oss_object
        # The interval at which snapshots are captured. Unit: seconds. Valid values: **5 to 3600**.
        # 
        # This parameter is required.
        self.time_interval = time_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.overwrite_oss_object is not None:
            result['OverwriteOssObject'] = self.overwrite_oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.sequence_oss_object is not None:
            result['SequenceOssObject'] = self.sequence_oss_object
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OverwriteOssObject') is not None:
            self.overwrite_oss_object = m.get('OverwriteOssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('SequenceOssObject') is not None:
            self.sequence_oss_object = m.get('SequenceOssObject')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class AddLiveAppSnapshotConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveAppSnapshotConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAppSnapshotConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAppSnapshotConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAudioAuditConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        biz_type: str = None,
        domain_name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The application name is case-sensitive.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The business type. You can specify a model. The default value is the domain name.
        self.biz_type = biz_type
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the OSS bucket in which the recording is stored.
        self.oss_bucket = oss_bucket
        # The endpoint of OSS.
        self.oss_endpoint = oss_endpoint
        # The name of the recording stored in OSS.
        self.oss_object = oss_object
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. The stream name is case-sensitive.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddLiveAudioAuditConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveAudioAuditConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAudioAuditConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAudioAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveAudioAuditNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        callback: str = None,
        callback_template: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The callback URL. This URL is used to receive callback notifications about violations in audio.
        self.callback = callback
        # The callback template. Valid values:
        # 
        # *   **{DomainName}**: the streaming domain.
        # *   **{AppName}**: the name of the application to which the live stream belongs.
        # *   **{StreamName}**: the name of the live stream.
        # *   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
        # *   **{Result}**: the moderation results.
        self.callback_template = callback_template
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.callback_template is not None:
            result['CallbackTemplate'] = self.callback_template
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('CallbackTemplate') is not None:
            self.callback_template = m.get('CallbackTemplate')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddLiveAudioAuditNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveAudioAuditNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveAudioAuditNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveAudioAuditNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveCenterTransferRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        dst_url: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
        transfer_args: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The third-party URL to which the live stream is relayed. You can add only one URL.
        # 
        # >  The protocol that the URL uses must be the same as the protocol of the live stream. Only URLs over RTMP and SRT are supported.
        # 
        # This parameter is required.
        self.dst_url = dst_url
        # The end time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The end time must be later than the start time.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The validity period of stream relay. Valid values:
        # 
        # *   **always**: The stream can always be relayed.
        # *   **time**: The stream can be relayed in a specified time period.
        # 
        # >  If you set this parameter to **time**, **StartTime** and **EndTime** are required.
        # 
        # This parameter is required.
        self.transfer_args = transfer_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transfer_args is not None:
            result['TransferArgs'] = self.transfer_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TransferArgs') is not None:
            self.transfer_args = m.get('TransferArgs')
        return self


class AddLiveCenterTransferResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveCenterTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveCenterTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveCenterTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveDetectNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_url: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The callback URL that is used to receive callback notifications about violations, such as pornographic content and politically sensitive content, detected in live streams.
        # 
        # This parameter is required.
        self.notify_url = notify_url
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class AddLiveDetectNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveDetectNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveDetectNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveDetectNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveDomainRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddLiveDomainRequest(TeaModel):
    def __init__(
        self,
        check_url: str = None,
        domain_name: str = None,
        live_domain_type: str = None,
        owner_account: str = None,
        owner_id: int = None,
        region: str = None,
        resource_group_id: str = None,
        scope: str = None,
        security_token: str = None,
        tag: List[AddLiveDomainRequestTag] = None,
        top_level_domain: str = None,
    ):
        # The URL that is used for health checks.
        self.check_url = check_url
        # The ingest domain or streaming domain that you want to add. Wildcard domain names that start with a period (.) are supported.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The type of the domain name. Valid values:
        # 
        # *   **liveVideo**: streaming domain. This value is required if you set the DomainName parameter to a streaming domain.
        # *   **liveEdge**: ingest domain. This value is required if you set the DomainName parameter to an ingest domain.
        # 
        # This parameter is required.
        self.live_domain_type = live_domain_type
        self.owner_account = owner_account
        self.owner_id = owner_id
        # The region in which the domain name resides. Valid values:
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **cn-qingdao**: China (Qingdao)
        # *   **ap-southeast-1**: Singapore
        # *   **eu-central-1**: Germany (Frankfurt)
        # *   **ap-northeast-1**: Japan (Tokyo)
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        # 
        # >  Make sure that the settings of the Region and Scope parameters do not conflict with each other.
        # 
        # This parameter is required.
        self.region = region
        # The ID of the resource group. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).
        self.resource_group_id = resource_group_id
        # The edge group. This parameter is applicable to users of level 3 or higher in mainland China and users outside mainland China. Valid values:
        # 
        # *   **domestic**: mainland China. This is the default value.
        # *   **overseas**: outside mainland China.
        # *   **global**: regions in and outside mainland China.
        self.scope = scope
        self.security_token = security_token
        # The tags.
        self.tag = tag
        # The top-level domain name.
        self.top_level_domain = top_level_domain

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_url is not None:
            result['CheckUrl'] = self.check_url
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_domain_type is not None:
            result['LiveDomainType'] = self.live_domain_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.top_level_domain is not None:
            result['TopLevelDomain'] = self.top_level_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckUrl') is not None:
            self.check_url = m.get('CheckUrl')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveDomainType') is not None:
            self.live_domain_type = m.get('LiveDomainType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = AddLiveDomainRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TopLevelDomain') is not None:
            self.top_level_domain = m.get('TopLevelDomain')
        return self


class AddLiveDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveDomainMappingRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        pull_domain: str = None,
        push_domain: str = None,
        security_token: str = None,
    ):
        self.owner_id = owner_id
        # The streaming domain. The type of the domain name is **liveVideo**.
        # 
        # This parameter is required.
        self.pull_domain = pull_domain
        # The ingest domain. The type of the domain name is **liveEdge**.
        # 
        # This parameter is required.
        self.push_domain = push_domain
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pull_domain is not None:
            result['PullDomain'] = self.pull_domain
        if self.push_domain is not None:
            result['PushDomain'] = self.push_domain
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PullDomain') is not None:
            self.pull_domain = m.get('PullDomain')
        if m.get('PushDomain') is not None:
            self.push_domain = m.get('PushDomain')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class AddLiveDomainMappingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveDomainMappingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveDomainMappingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveDomainMappingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveDomainPlayMappingRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        play_domain: str = None,
        pull_domain: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The sub-streaming domain.
        # 
        # This parameter is required.
        self.play_domain = play_domain
        # The main streaming domain.
        # 
        # This parameter is required.
        self.pull_domain = pull_domain
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_domain is not None:
            result['PlayDomain'] = self.play_domain
        if self.pull_domain is not None:
            result['PullDomain'] = self.pull_domain
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayDomain') is not None:
            self.play_domain = m.get('PlayDomain')
        if m.get('PullDomain') is not None:
            self.pull_domain = m.get('PullDomain')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddLiveDomainPlayMappingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveDomainPlayMappingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveDomainPlayMappingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveDomainPlayMappingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveMessageGroupBandRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        banned_users: List[str] = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The users whom you want to mute.
        # 
        # This parameter is required.
        self.banned_users = banned_users
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.banned_users is not None:
            result['BannedUsers'] = self.banned_users
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BannedUsers') is not None:
            self.banned_users = m.get('BannedUsers')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class AddLiveMessageGroupBandShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        banned_users_shrink: str = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The users whom you want to mute.
        # 
        # This parameter is required.
        self.banned_users_shrink = banned_users_shrink
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.banned_users_shrink is not None:
            result['BannedUsers'] = self.banned_users_shrink
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BannedUsers') is not None:
            self.banned_users_shrink = m.get('BannedUsers')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class AddLiveMessageGroupBandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveMessageGroupBandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveMessageGroupBandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveMessageGroupBandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLivePackageConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        ignore_transcode: bool = None,
        owner_id: int = None,
        part_duration: int = None,
        protocol: str = None,
        region_id: str = None,
        segment_duration: int = None,
        segment_num: int = None,
        stream_name: str = None,
    ):
        # The application name. The value of this parameter must be the same as the application name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to ignore the transcoded stream. Valid values:
        # 
        # *   **true** (default)
        # *   **false**\
        self.ignore_transcode = ignore_transcode
        self.owner_id = owner_id
        # The part length. Unit: milliseconds.
        # 
        # *   If the value of SegmentDuration is 1, the valid values of this parameter are 100 to 500 and the default value of this parameter is 350.
        # *   If the value of SegmentDuration is 2, the valid values of this parameter are 100 to 1000 and the default value of this parameter is 700.
        # *   This parameter takes effect only if Protocol is set to LLHLS_TS or LLHLS_CMAF.
        self.part_duration = part_duration
        # The streaming protocol and encapsulation format. Valid values:
        # 
        # *   **HLS_CMAF**\
        # *   **LLHLS_TS** (low latency)
        # *   **LLHLS_CMAF** (low latency)
        # *   **DASH_CMAF**\
        # *   **HLSDASH_CMAF**\
        # 
        # This parameter is required.
        self.protocol = protocol
        self.region_id = region_id
        # The segment length. Unit: seconds.
        # 
        # *   If Protocol is set to HLS_CMAF: Valid values: 1 to 10. Default value: 5.
        # *   If Protocol is set to LLHLS_TS or LLHLS_CMAF: Valid values: 1 to 2. Default value: 1.
        self.segment_duration = segment_duration
        # The number of segments.
        # 
        # *   Valid values: 3 to 10.
        # *   Default value: 3.
        self.segment_num = segment_num
        # The stream name. The value of this parameter must be the same as the stream name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all streams.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ignore_transcode is not None:
            result['IgnoreTranscode'] = self.ignore_transcode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.part_duration is not None:
            result['PartDuration'] = self.part_duration
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.segment_num is not None:
            result['SegmentNum'] = self.segment_num
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IgnoreTranscode') is not None:
            self.ignore_transcode = m.get('IgnoreTranscode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PartDuration') is not None:
            self.part_duration = m.get('PartDuration')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('SegmentNum') is not None:
            self.segment_num = m.get('SegmentNum')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddLivePackageConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLivePackageConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLivePackageConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLivePackageConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLivePullStreamInfoConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        source_url: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. This parameter is determined by you.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The domain name used for stream pulling. It is the main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The time when stream pulling ends.
        # 
        # The time range specified by the StartTime and EndTime parameters cannot exceed seven days. The time specified by the EndTime parameter must be later than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The origin URL of the live stream. You can specify multiple URLs. Separate them with semicolons (;).
        # 
        # >  You can pull only live streams in the Real-Time Messaging Protocol (RTMP), Flash Video (FLV), HTTP Live Streaming (HLS), and Secure Reliable Transport (SRT) formats.
        # 
        # This parameter is required.
        self.source_url = source_url
        # The time when stream pulling starts.
        # 
        # The time range specified by the StartTime and EndTime parameters cannot exceed seven days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream. This parameter is determined by you.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddLivePullStreamInfoConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLivePullStreamInfoConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLivePullStreamInfoConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLivePullStreamInfoConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveRecordNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        need_status_notify: bool = None,
        notify_auth_key: str = None,
        notify_req_auth: bool = None,
        notify_url: str = None,
        on_demand_url: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to enable callbacks for recording status. Valid values:
        # 
        # *   true: enables callbacks for recording status. If you set this parameter to **true**, an example of recording status callback is returned.
        # *   false (default): disables callbacks for recording status.
        self.need_status_notify = need_status_notify
        self.notify_auth_key = notify_auth_key
        self.notify_req_auth = notify_req_auth
        # The callback URL that is used to receive notifications about recording events and status.
        # 
        # >  The URL must start with `http://` or `https://`. For more information, see [Callbacks for live stream recording](https://help.aliyun.com/document_detail/55016.html).
        # 
        # This parameter is required.
        self.notify_url = notify_url
        # The callback URL for on-demand recordings.
        # 
        # >  The URL must start with `http://` or `https://`. For more information, see [On-demand recording](https://help.aliyun.com/document_detail/85910.html).
        self.on_demand_url = on_demand_url
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.need_status_notify is not None:
            result['NeedStatusNotify'] = self.need_status_notify
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.on_demand_url is not None:
            result['OnDemandUrl'] = self.on_demand_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NeedStatusNotify') is not None:
            self.need_status_notify = m.get('NeedStatusNotify')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OnDemandUrl') is not None:
            self.on_demand_url = m.get('OnDemandUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class AddLiveRecordNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveRecordNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveRecordNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveRecordNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveRecordVodConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        auto_compose: str = None,
        compose_vod_transcode_group_id: str = None,
        cycle_duration: int = None,
        domain_name: str = None,
        on_demand: int = None,
        owner_id: int = None,
        region_id: str = None,
        storage_location: str = None,
        stream_name: str = None,
        vod_transcode_group_id: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Specifies whether to enable automatic merging. If you set the value to **ON**, automatic merging is enabled and the ComposeVodTranscodeGroupId parameter is required. If you do not specify this parameter, automatic merging is disabled.
        # 
        # >  If you enable automatic merging, the VOD files that are created from live streams are automatically merged by using the editing and production feature of ApsaraVideo VOD. For information about the billing of the feature, see [Billing of value-added services](https://help.aliyun.com/document_detail/188310.html).
        self.auto_compose = auto_compose
        # The ID of the transcoding template group in ApsaraVideo VOD that is used to transcode the video file. The video file is generated by merging the VOD files created from live streams.
        # 
        # > 
        # 
        # *   This parameter is required if you set the AutoCompose parameter to ON.
        # 
        # *   For more information about automatic merging and transcoding, see [FAQ about Live-to-VOD](https://help.aliyun.com/document_detail/99726.html).
        # 
        # *   For information about the billing of transcoding in ApsaraVideo VOD, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
        self.compose_vod_transcode_group_id = compose_vod_transcode_group_id
        # The recording cycle. Unit: seconds. Valid values: **300 to 21600**. Default value: **3600**.
        self.cycle_duration = cycle_duration
        # The main streaming domain.
        # 
        # >  Make sure that ApsaraVideo VOD is activated in the same region as the live center of the streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to enable on-demand recording. Valid values:
        # 
        # *   **0** (default): disables on-demand recording.
        # *   **1**: enables on-demand recording.
        self.on_demand = on_demand
        self.owner_id = owner_id
        self.region_id = region_id
        # The storage location.
        self.storage_location = storage_location
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name
        # The ID of the transcoding template group in ApsaraVideo VOD.
        # 
        # This parameter is required.
        self.vod_transcode_group_id = vod_transcode_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_compose is not None:
            result['AutoCompose'] = self.auto_compose
        if self.compose_vod_transcode_group_id is not None:
            result['ComposeVodTranscodeGroupId'] = self.compose_vod_transcode_group_id
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.vod_transcode_group_id is not None:
            result['VodTranscodeGroupId'] = self.vod_transcode_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoCompose') is not None:
            self.auto_compose = m.get('AutoCompose')
        if m.get('ComposeVodTranscodeGroupId') is not None:
            self.compose_vod_transcode_group_id = m.get('ComposeVodTranscodeGroupId')
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VodTranscodeGroupId') is not None:
            self.vod_transcode_group_id = m.get('VodTranscodeGroupId')
        return self


class AddLiveRecordVodConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveRecordVodConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveRecordVodConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveRecordVodConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveSnapshotDetectPornConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        interval: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        owner_id: int = None,
        scene: List[str] = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The interval at which snapshots are captured from the live stream. Valid values: **5 to 3600**. Unit: seconds.
        self.interval = interval
        # The name of the OSS bucket.
        # 
        # After the review is complete, you can search for specific violations in the OSS console based on the callback information. You must create the OSS bucket in advance. For more information, see [Configure content moderation](https://help.aliyun.com/document_detail/199449.html).
        # 
        # This parameter is required.
        self.oss_bucket = oss_bucket
        # The endpoint of the Object Storage Service (OSS) bucket.
        # 
        # After the review is complete, you can search for specific violations in the OSS console based on the callback information. You must configure the OSS endpoint in advance. For more information, see [Configure content moderation](https://help.aliyun.com/document_detail/199449.html).
        # 
        # This parameter is required.
        self.oss_endpoint = oss_endpoint
        # The name of the snapshot that stores violations such as pornographic content and politically sensitive content.
        self.oss_object = oss_object
        self.owner_id = owner_id
        # Scene list detection.
        self.scene = scene
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class AddLiveSnapshotDetectPornConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveSnapshotDetectPornConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveSnapshotDetectPornConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveSnapshotDetectPornConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveSnapshotNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_auth_key: str = None,
        notify_req_auth: str = None,
        notify_url: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The callback authentication key. The key must be 16 to 32 characters in length and can contain only letters and digits.
        # 
        # > This parameter is required if you set the NotifyReqAuth parameter to **yes**.
        self.notify_auth_key = notify_auth_key
        # Specifies whether to enable callback authentication. Valid values:
        # 
        # *   **yes**\
        # *   **no** (default)
        # 
        # > This parameter is required if you set the NotifyAuthKey parameter to yes.
        self.notify_req_auth = notify_req_auth
        # The callback URL. Specify a valid URL that is up to 500 characters in length.
        # 
        # This parameter is required.
        self.notify_url = notify_url
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddLiveSnapshotNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveSnapshotNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveSnapshotNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveSnapshotNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveStreamMergeRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        in_app_name_1: str = None,
        in_app_name_2: str = None,
        in_stream_name_1: str = None,
        in_stream_name_2: str = None,
        live_merger: str = None,
        merge_parameters: str = None,
        owner_id: int = None,
        protocol: str = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application that generates the output stream. The value must be the same as the application name in the ingest URL of the output stream. Otherwise, the configuration does not take effect. You cannot set the value to an asterisk (\\*).
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end time of the stream mixing.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The interval between the start time and the end time must be within 7 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The name of the application that generates the input primary stream. The value must be the same as the application name that is specified in the ingest URL of the primary stream. Otherwise, the configuration does not take effect.
        # 
        # This parameter is required.
        self.in_app_name_1 = in_app_name_1
        # The name of the application that generates the input secondary stream. The value must be the same as the application name that is specified in the ingest URL of the secondary stream. Otherwise, the configuration does not take effect.
        # 
        # This parameter is required.
        self.in_app_name_2 = in_app_name_2
        # The name of the input primary stream. The value must be the same as the stream name that is specified in the ingest URL of the primary stream. Otherwise, the configuration does not take effect.
        # 
        # This parameter is required.
        self.in_stream_name_1 = in_stream_name_1
        # The name of the input secondary stream. The value must be the same as the stream name that is specified in the ingest URL of the secondary stream. Otherwise, the configuration does not take effect.
        # 
        # This parameter is required.
        self.in_stream_name_2 = in_stream_name_2
        self.live_merger = live_merger
        self.merge_parameters = merge_parameters
        self.owner_id = owner_id
        # The streaming protocol. Valid values:
        # 
        # *   **rtmp**: This is the default value.
        # *   **rtc**\
        self.protocol = protocol
        self.region_id = region_id
        # The start time of the stream mixing.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the output stream. The value must be the same as the stream name in the ingest URL of the output stream. Otherwise, the configuration does not take effect. You cannot set the value to an asterisk (\\*).
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.in_app_name_1 is not None:
            result['InAppName1'] = self.in_app_name_1
        if self.in_app_name_2 is not None:
            result['InAppName2'] = self.in_app_name_2
        if self.in_stream_name_1 is not None:
            result['InStreamName1'] = self.in_stream_name_1
        if self.in_stream_name_2 is not None:
            result['InStreamName2'] = self.in_stream_name_2
        if self.live_merger is not None:
            result['LiveMerger'] = self.live_merger
        if self.merge_parameters is not None:
            result['MergeParameters'] = self.merge_parameters
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InAppName1') is not None:
            self.in_app_name_1 = m.get('InAppName1')
        if m.get('InAppName2') is not None:
            self.in_app_name_2 = m.get('InAppName2')
        if m.get('InStreamName1') is not None:
            self.in_stream_name_1 = m.get('InStreamName1')
        if m.get('InStreamName2') is not None:
            self.in_stream_name_2 = m.get('InStreamName2')
        if m.get('LiveMerger') is not None:
            self.live_merger = m.get('LiveMerger')
        if m.get('MergeParameters') is not None:
            self.merge_parameters = m.get('MergeParameters')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddLiveStreamMergeResponseBody(TeaModel):
    def __init__(
        self,
        message: str = None,
        request_id: str = None,
    ):
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveStreamMergeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveStreamMergeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveStreamMergeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        encrypt_parameters: str = None,
        lazy: str = None,
        owner_id: int = None,
        region_id: str = None,
        template: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # *   The transcoding template takes effect only if the value of this parameter is the same as the application name that is specified in the ingest URL. The name can be up to 256 characters in length and can contain digits, letters, hyphens (-), and underscores (_).
        # *   You can also set this parameter to an asterisk (\\*). Asterisks (\\*) can match any string, including an empty string.
        # 
        # >  If you configure a transcoding template for which App is set to an asterisk (\\*), the transcoding template is used only if no transcoding template for which App is set to the same value as AppName in the ingest URL exists.
        # 
        # This parameter is required.
        self.app = app
        # The name of the main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The encryption configuration. The value is a JSON string. The following fields are included in the syntax:
        # 
        # *   EncryptType: the type of the encryption. Set the value to **aliyun**.
        # *   KmsKeyID: the ID of the CMK in KMS.
        # *   KmsKeyExpireInterval: the validity period of the CMK. Valid values: **60 to 3600**. Unit: seconds.
        self.encrypt_parameters = encrypt_parameters
        # Specifies whether to use the load-on-demand mechanism for transcoding. Default value: **yes**.
        self.lazy = lazy
        self.owner_id = owner_id
        self.region_id = region_id
        # The transcoding template. Valid values:
        # 
        # *   Standard transcoding template:
        # 
        #     *   **lld**: low definition
        #     *   **lsd**: standard definition
        #     *   **lhd**: high definition
        #     *   **lud**: ultra-high definition
        # 
        # *   Narrowband HD transcoding template:
        # 
        #     *   **ld**: low definition
        #     *   **sd**: standard definition
        #     *   **hd**: high definition
        #     *   **ud**: ultra-high definition
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.encrypt_parameters is not None:
            result['EncryptParameters'] = self.encrypt_parameters
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EncryptParameters') is not None:
            self.encrypt_parameters = m.get('EncryptParameters')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class AddLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveStreamWatermarkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        domain: str = None,
        height: int = None,
        name: str = None,
        offset_corner: str = None,
        owner_id: int = None,
        picture_url: str = None,
        ref_height: int = None,
        ref_width: int = None,
        region_id: str = None,
        transparency: int = None,
        type: int = None,
        xoffset: float = None,
        yoffset: float = None,
    ):
        # The description of the watermark.
        self.description = description
        # The streaming domain.
        self.domain = domain
        # The height of the watermark. Unit: pixels. The height of the watermark is scaled in proportion to the height of the background video.
        # 
        # This parameter is required.
        self.height = height
        # The name of the watermark.
        # 
        # This parameter is required.
        self.name = name
        # The location of the watermark. Valid values:
        # 
        # *   TopLeft: the upper-left corner.
        # *   TopRight: the upper-right corner.
        # *   BottomLeft: the lower-left corner.
        # *   BottomRight: the lower-right corner.
        # 
        # This parameter is required.
        self.offset_corner = offset_corner
        self.owner_id = owner_id
        # The URL of the watermark image.
        # 
        # This parameter is required.
        self.picture_url = picture_url
        # The height of the background video. Unit: pixels.
        # 
        # This parameter is required.
        self.ref_height = ref_height
        # The width of the background video. Unit: pixels.
        # 
        # This parameter is required.
        self.ref_width = ref_width
        self.region_id = region_id
        # The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.
        # 
        # This parameter is required.
        self.transparency = transparency
        # The type of the watermark. Valid values:
        # 
        # *   **0**: image.
        # *   **1**: text. Only image watermarks are supported.
        # 
        # This parameter is required.
        self.type = type
        # The offset of the watermark along the x-axis. Unit: pixels.
        # 
        # >  In this case, the value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.
        # 
        # This parameter is required.
        self.xoffset = xoffset
        # The offset of the watermark along the y-axis. Unit: pixels.
        # 
        # >  In this case, the value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.
        # 
        # This parameter is required.
        self.yoffset = yoffset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.offset_corner is not None:
            result['OffsetCorner'] = self.offset_corner
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.picture_url is not None:
            result['PictureUrl'] = self.picture_url
        if self.ref_height is not None:
            result['RefHeight'] = self.ref_height
        if self.ref_width is not None:
            result['RefWidth'] = self.ref_width
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.transparency is not None:
            result['Transparency'] = self.transparency
        if self.type is not None:
            result['Type'] = self.type
        if self.xoffset is not None:
            result['XOffset'] = self.xoffset
        if self.yoffset is not None:
            result['YOffset'] = self.yoffset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OffsetCorner') is not None:
            self.offset_corner = m.get('OffsetCorner')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PictureUrl') is not None:
            self.picture_url = m.get('PictureUrl')
        if m.get('RefHeight') is not None:
            self.ref_height = m.get('RefHeight')
        if m.get('RefWidth') is not None:
            self.ref_width = m.get('RefWidth')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Transparency') is not None:
            self.transparency = m.get('Transparency')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('XOffset') is not None:
            self.xoffset = m.get('XOffset')
        if m.get('YOffset') is not None:
            self.yoffset = m.get('YOffset')
        return self


class AddLiveStreamWatermarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the watermark template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class AddLiveStreamWatermarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveStreamWatermarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveStreamWatermarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLiveStreamWatermarkRuleRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        description: str = None,
        domain: str = None,
        name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
        template_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The description of the custom rule.
        self.description = description
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The name of the custom rule.
        # 
        # This parameter is required.
        self.name = name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. The following rules apply:
        # 
        # *   A stream name can be exactly matched. Example: liveStreamA.
        # *   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
        # *   You can place the asterisk before or after an approximate string.
        # 
        # 
        # 
        # >*   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).
        # >*   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.
        # 
        # This parameter is required.
        self.stream = stream
        # The ID of the watermark template.
        # 
        # >  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class AddLiveStreamWatermarkRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the watermark rule.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class AddLiveStreamWatermarkRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLiveStreamWatermarkRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLiveStreamWatermarkRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPlaylistItemsRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        program_config: str = None,
        program_id: str = None,
        program_items: str = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # The production studio must use the following configurations:
        # 
        # *   **NormType**: 3****. You need to call the **CreateCaster** operation to create a production studio for lightweight carousel playback in advance.
        # *   **CasterTemplate**: lp_noTranscode.
        # *   **channelEnable**: 0.
        # *   **programEffect**: 1.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        # The configurations of the episode list. If the episode list is added to the production studio for the first time, specify this parameter to pass in the initial configurations. For more information, see the **ProgramConfig** section of this topic.
        self.program_config = program_config
        # The ID of the episode list. If you do not specify this parameter, an episode list is created by default.
        self.program_id = program_id
        # The episodes that you want to add to the production studio. The value is a JSON string. For more information, see the **InputProgramItem** section of this topic.
        # 
        # This parameter is required.
        self.program_items = program_items
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_config is not None:
            result['ProgramConfig'] = self.program_config
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_items is not None:
            result['ProgramItems'] = self.program_items
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramConfig') is not None:
            self.program_config = m.get('ProgramConfig')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramItems') is not None:
            self.program_items = m.get('ProgramItems')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddPlaylistItemsResponseBodyItemsFailedItems(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        item_name: str = None,
    ):
        # The ID of the episode.
        self.item_id = item_id
        # The name of the episode.
        self.item_name = item_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        return self


class AddPlaylistItemsResponseBodyItemsSuccessItems(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        item_name: str = None,
    ):
        # The ID of the episode.
        self.item_id = item_id
        # The name of the episode.
        self.item_name = item_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        return self


class AddPlaylistItemsResponseBodyItems(TeaModel):
    def __init__(
        self,
        failed_items: List[AddPlaylistItemsResponseBodyItemsFailedItems] = None,
        success_items: List[AddPlaylistItemsResponseBodyItemsSuccessItems] = None,
    ):
        # The episodes that failed to be added.
        self.failed_items = failed_items
        # The episodes that were added.
        self.success_items = success_items

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()
        if self.success_items:
            for k in self.success_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        result['SuccessItems'] = []
        if self.success_items is not None:
            for k in self.success_items:
                result['SuccessItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = AddPlaylistItemsResponseBodyItemsFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        self.success_items = []
        if m.get('SuccessItems') is not None:
            for k in m.get('SuccessItems'):
                temp_model = AddPlaylistItemsResponseBodyItemsSuccessItems()
                self.success_items.append(temp_model.from_map(k))
        return self


class AddPlaylistItemsResponseBody(TeaModel):
    def __init__(
        self,
        items: AddPlaylistItemsResponseBodyItems = None,
        program_id: str = None,
        request_id: str = None,
    ):
        # The information about the episodes.
        self.items = items
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to remove episodes, query episodes, edit an episode list, delete an episode list, query the information about an episode list, start playing an episode list, or stop playing an episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.items:
            self.items.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items.to_map()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            temp_model = AddPlaylistItemsResponseBodyItems()
            self.items = temp_model.from_map(m['Items'])
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPlaylistItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPlaylistItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPlaylistItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddRtsLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        audio_bitrate: int = None,
        audio_channel_num: int = None,
        audio_codec: str = None,
        audio_profile: str = None,
        audio_rate: int = None,
        delete_bframes: bool = None,
        domain: str = None,
        fps: int = None,
        gop: str = None,
        height: int = None,
        lazy: str = None,
        opus: bool = None,
        owner_id: int = None,
        profile: int = None,
        region_id: str = None,
        template: str = None,
        template_type: str = None,
        video_bitrate: int = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs. Value requirements:
        # 
        # *   The name can contain letters, digits, underscores (_), and hyphens (-).
        # *   We recommend that you specify a name that is more than three characters in length. The name must start with a letter or digit.
        # 
        # This parameter is required.
        self.app = app
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: **1** to **1000**.
        # 
        # >  This parameter is required if you set the TemplateType parameter to audio.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values:
        # 
        # *   **1**: mono
        # *   **2**: stereo
        self.audio_channel_num = audio_channel_num
        # The audio encoder. Valid values:
        # 
        # *   **aac**\
        # *   **mp3**\
        # 
        # > If you want to use the Opus encoding format, set the Opus parameter to true.
        self.audio_codec = audio_codec
        # The audio codec profile. Valid values:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        self.audio_profile = audio_profile
        # The audio sampling rate. Valid values: **22050 to 96000**. The value 44100 is commonly used. Unit: Hz.
        # 
        # > If you set the AudioProfile parameter to aac_ld, the audio sampling rate cannot exceed 44,100 Hz.
        self.audio_rate = audio_rate
        # Specifies whether to remove B-frames during transcoding. Valid values:
        # 
        # >  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.
        # 
        # *   **true**: removes B-frames.
        # *   **false**: retains B-frames. This is the default value.
        # 
        # > If you do not specify this parameter, the default value **false** is used.
        self.delete_bframes = delete_bframes
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The frame rate of the output video. Unit: FPS. Valid values: **1** to **60**.
        # 
        # >  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.
        self.fps = fps
        # The group of pictures (GOP) size of the output video. This parameter is used to specify the keyframe interval. Unit: seconds. Valid values: **1** to **3**.
        self.gop = gop
        # The height of the output video. Unit: pixels.
        # 
        # >  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.
        # 
        # The value must comply with the following rules:****\
        # 
        # *   **Height  100**: The height of the video is no less than 100 pixels.
        # *   **max(Height,Width)  2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
        # *   **min(Height,Width)  1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.
        # 
        # For example, a resolution of 1560  1560 pixels is invalid.
        # 
        # > An original quality template needs to retain the source information. Therefore, the video resolution cannot exceed 4K.
        self.height = height
        # Specifies whether to trigger transcoding only when a stream is pulled. Valid values:
        # 
        # *   **yes**: triggers transcoding only when a stream is pulled.
        # *   **no**: triggers transcoding whenever a stream is ingested, no matter whether the stream is pulled.
        self.lazy = lazy
        # Specifies whether to transcode audio to the Opus format to be compatible with native WebRTC. Valid values:
        # 
        # *   **true**: transcodes audio to the Opus format.
        # *   **false**: does not transcode audio to the Opus format.
        # 
        # > If you do not specify this parameter, the default value **false** is used.
        self.opus = opus
        self.owner_id = owner_id
        # The codec profile. The video codec profile determines how ApsaraVideo Live performs codec on the video. In normal cases, a greater value indicates a higher image quality and requires more codec resources. Valid values:
        # 
        # *   **1**: baseline, which is suitable for mobile devices.
        # *   **2**: main, which is suitable for standard-definition devices.
        # *   **3**: high, which is suitable for high-definition devices.
        self.profile = profile
        self.region_id = region_id
        # The name of the transcoding template. Value requirements:
        # 
        # *   The name can contain letters, digits, underscores (_), and hyphens (-).
        # *   We recommend that you specify a name that is more than three characters in length. The name must start with a letter or digit.
        # 
        # > The name cannot be the same as that of a default transcoding template.
        # 
        # This parameter is required.
        self.template = template
        # The type of the transcoding template.
        # 
        # If you set this parameter to h264, h264-nbhd, or h264-origin, you must also specify the Height, Width, FPS, VideoBitrate, and DeleteBframes parameters. Valid values:
        # 
        # *   **h264**: H.264 standard transcoding template.
        # *   **h264-nbhd**: H.264 Narrowband HD transcoding template.
        # *   **h264-origin**: H.264 original quality template. If you use this type of template, the same transcoding parameters of the video source are retained by default.
        # *   **audio**: audio-only transcoding template. If you use this type of template, images are removed from the video source and an audio-only stream is generated. In addition, you must also specify the AudioBitrate parameter.
        # 
        # This parameter is required.
        self.template_type = template_type
        # The bitrate of the output video. Unit: Kbit/s. Valid values: **1** to **6000**.
        # 
        # >  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.
        # 
        # > The bitrate of the output video is as close to the value that you specify as possible, but not exactly the same as the value, especially when the value is excessively large or small.
        self.video_bitrate = video_bitrate
        # The width of the output video. Unit: pixels.
        # 
        # >  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.
        # 
        # The value must comply with the following rules:
        # 
        # *   **Width  100**: The width of the video is no less than 100 pixels.
        # *   **max(Height,Width)  2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
        # *   **min(Height,Width)  1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.
        # 
        # For example, a resolution of 1560  1560 pixels is invalid.
        # 
        # > An original quality template needs to retain the source information. Therefore, the video resolution cannot exceed 4K.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channel_num is not None:
            result['AudioChannelNum'] = self.audio_channel_num
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_profile is not None:
            result['AudioProfile'] = self.audio_profile
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.delete_bframes is not None:
            result['DeleteBframes'] = self.delete_bframes
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.fps is not None:
            result['FPS'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.opus is not None:
            result['Opus'] = self.opus
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannelNum') is not None:
            self.audio_channel_num = m.get('AudioChannelNum')
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioProfile') is not None:
            self.audio_profile = m.get('AudioProfile')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('DeleteBframes') is not None:
            self.delete_bframes = m.get('DeleteBframes')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('FPS') is not None:
            self.fps = m.get('FPS')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('Opus') is not None:
            self.opus = m.get('Opus')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddRtsLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddRtsLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddRtsLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddRtsLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddShowIntoShowListRequestShowList(TeaModel):
    def __init__(
        self,
        duration: int = None,
        live_input_type: int = None,
        repeat_times: int = None,
        resource_id: str = None,
        resource_type: str = None,
        resource_url: str = None,
        show_name: str = None,
    ):
        # The duration of the episode. Unit: seconds.
        # 
        # >  You can specify only one of the **RepeatTimes** and **Duration** parameters.
        self.duration = duration
        # The custom type label.
        self.live_input_type = live_input_type
        # The number of times the episode repeats after the first playback is complete. Default value: 0.
        # 
        # > 
        # 
        # *   You can specify only one of the **RepeatTimes** and **Duration** parameters.
        # 
        # *   The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.
        self.repeat_times = repeat_times
        # The ID of the resource.
        self.resource_id = resource_id
        # The resource type. Valid values:
        # 
        # *   live: live stream
        # *   vod: on-demand video
        # *   pic: image
        # 
        # > 
        # 
        # *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        # 
        # *   You can add a live stream from ApsaraVideo Live or by using a third-party URL.
        # *   You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL, or add an on-demand image.
        self.resource_type = resource_type
        # The URL of the resource.
        self.resource_url = resource_url
        # The name of the episode.
        self.show_name = show_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.live_input_type is not None:
            result['liveInputType'] = self.live_input_type
        if self.repeat_times is not None:
            result['repeatTimes'] = self.repeat_times
        if self.resource_id is not None:
            result['resourceId'] = self.resource_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.resource_url is not None:
            result['resourceUrl'] = self.resource_url
        if self.show_name is not None:
            result['showName'] = self.show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('liveInputType') is not None:
            self.live_input_type = m.get('liveInputType')
        if m.get('repeatTimes') is not None:
            self.repeat_times = m.get('repeatTimes')
        if m.get('resourceId') is not None:
            self.resource_id = m.get('resourceId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('resourceUrl') is not None:
            self.resource_url = m.get('resourceUrl')
        if m.get('showName') is not None:
            self.show_name = m.get('showName')
        return self


class AddShowIntoShowListRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        duration: int = None,
        live_input_type: int = None,
        owner_id: int = None,
        region_id: str = None,
        repeat_times: int = None,
        resource_id: str = None,
        resource_type: str = None,
        resource_url: str = None,
        show_name: str = None,
        spot: int = None,
        is_batch_mode: bool = None,
        show_list: List[AddShowIntoShowListRequestShowList] = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The duration of the episode. Unit: seconds.
        # 
        # > You can specify only one of the **RepeatTimes** and **Duration** parameters.
        self.duration = duration
        # The custom type label.
        self.live_input_type = live_input_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The number of times the episode repeats after the first playback is complete. The default value is 0.
        # 
        # > 
        # 
        # *   You can specify only one of the **RepeatTimes** and **Duration** parameters. - The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to -1, the episode is to be played for infinite times. If you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.
        self.repeat_times = repeat_times
        # The ID of the resource.
        self.resource_id = resource_id
        # The resource type. Valid values:
        # 
        # *   live: live stream
        # *   vod: on-demand video
        # *   pic: image
        # 
        # > 
        # 
        # *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets. - You can add a live stream from ApsaraVideo Live or by using a third-party URL. - You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL, or add an on-demand image.
        self.resource_type = resource_type
        # The URL of the resource.
        self.resource_url = resource_url
        # The name of the episode.
        self.show_name = show_name
        # The position of the episode in the episode list. Position indexes start from 0. By default, the episode is added to the end of the episode list.
        self.spot = spot
        # Specifies whether to add multiple episodes to the episode list at a time. Valid values:
        # 
        # *   true: adds multiple episodes to the episode list at a time.
        # *   false: adds a single episode to the episode list.
        # 
        # > If you do not specify this parameter or this parameter is left empty, a single episode is to be added to the episode list.
        self.is_batch_mode = is_batch_mode
        # The episodes that you want to add to the episode list. Each episode has a unique name and resource URL.
        self.show_list = show_list

    def validate(self):
        if self.show_list:
            for k in self.show_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.live_input_type is not None:
            result['LiveInputType'] = self.live_input_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_times is not None:
            result['RepeatTimes'] = self.repeat_times
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.resource_url is not None:
            result['ResourceUrl'] = self.resource_url
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        if self.spot is not None:
            result['Spot'] = self.spot
        if self.is_batch_mode is not None:
            result['isBatchMode'] = self.is_batch_mode
        result['showList'] = []
        if self.show_list is not None:
            for k in self.show_list:
                result['showList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('LiveInputType') is not None:
            self.live_input_type = m.get('LiveInputType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatTimes') is not None:
            self.repeat_times = m.get('RepeatTimes')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('ResourceUrl') is not None:
            self.resource_url = m.get('ResourceUrl')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        if m.get('Spot') is not None:
            self.spot = m.get('Spot')
        if m.get('isBatchMode') is not None:
            self.is_batch_mode = m.get('isBatchMode')
        self.show_list = []
        if m.get('showList') is not None:
            for k in m.get('showList'):
                temp_model = AddShowIntoShowListRequestShowList()
                self.show_list.append(temp_model.from_map(k))
        return self


class AddShowIntoShowListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        show_id: str = None,
        failed_list: str = None,
        successful_show_ids: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the episode.
        self.show_id = show_id
        # The list of resources that failed to be added and the reason for failure.
        self.failed_list = failed_list
        # The IDs of the episodes that were added.
        self.successful_show_ids = successful_show_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.failed_list is not None:
            result['failedList'] = self.failed_list
        if self.successful_show_ids is not None:
            result['successfulShowIds'] = self.successful_show_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('failedList') is not None:
            self.failed_list = m.get('failedList')
        if m.get('successfulShowIds') is not None:
            self.successful_show_ids = m.get('successfulShowIds')
        return self


class AddShowIntoShowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddShowIntoShowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddShowIntoShowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddStudioLayoutRequest(TeaModel):
    def __init__(
        self,
        bg_image_config: str = None,
        caster_id: str = None,
        common_config: str = None,
        layer_order_config_list: str = None,
        layout_name: str = None,
        layout_type: str = None,
        media_input_config_list: str = None,
        owner_id: int = None,
        region_id: str = None,
        screen_input_config_list: str = None,
    ):
        # The background material configurations. The value is a JSON string. For more information, see **BgImageConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to studio.
        self.bg_image_config = bg_image_config
        # The ID of the production studio.
        # 
        # >  The production studio must be a virtual studio that you create in advance. You can use the ApsaraVideo Live console or call the CreateCaster operation to create a virtual studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The common layout configurations. The value is a JSON string. For more information, see **CommonConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to common.
        self.common_config = common_config
        # The layer sorting configurations. The value is a JSON string. For more information, see **layerOrderConfig**. You can sort layers of background and multimedia materials. The chroma key layer cannot be sorted. A layer that is in the front of the code is placed behind other layers in the layout.
        self.layer_order_config_list = layer_order_config_list
        # The name of the layout.
        # 
        # This parameter is required.
        self.layout_name = layout_name
        # The type of the layout. Valid values:
        # 
        # *   **common**: If you set this parameter to common, you must specify the CommonConfig parameter.
        # *   **studio**: If you set this parameter to studio, you must specify the BgImageConfig and ScreenInputConfigList parameters. The MediaInputConfigList parameter is optional.
        # 
        # This parameter is required.
        self.layout_type = layout_type
        # The multimedia input configurations. The value is a JSON string. For more information, see **MediaInputConfig**.
        # 
        # >  This parameter is optional and is valid only if you set LayoutType to studio.
        self.media_input_config_list = media_input_config_list
        self.owner_id = owner_id
        self.region_id = region_id
        # The input configurations for chroma key. The value is a JSON string. For more information, see **ScreenInputConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to studio.
        self.screen_input_config_list = screen_input_config_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_image_config is not None:
            result['BgImageConfig'] = self.bg_image_config
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.common_config is not None:
            result['CommonConfig'] = self.common_config
        if self.layer_order_config_list is not None:
            result['LayerOrderConfigList'] = self.layer_order_config_list
        if self.layout_name is not None:
            result['LayoutName'] = self.layout_name
        if self.layout_type is not None:
            result['LayoutType'] = self.layout_type
        if self.media_input_config_list is not None:
            result['MediaInputConfigList'] = self.media_input_config_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.screen_input_config_list is not None:
            result['ScreenInputConfigList'] = self.screen_input_config_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgImageConfig') is not None:
            self.bg_image_config = m.get('BgImageConfig')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CommonConfig') is not None:
            self.common_config = m.get('CommonConfig')
        if m.get('LayerOrderConfigList') is not None:
            self.layer_order_config_list = m.get('LayerOrderConfigList')
        if m.get('LayoutName') is not None:
            self.layout_name = m.get('LayoutName')
        if m.get('LayoutType') is not None:
            self.layout_type = m.get('LayoutType')
        if m.get('MediaInputConfigList') is not None:
            self.media_input_config_list = m.get('MediaInputConfigList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScreenInputConfigList') is not None:
            self.screen_input_config_list = m.get('ScreenInputConfigList')
        return self


class AddStudioLayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        request_id: str = None,
    ):
        # The ID of the layout. You can use the ID as a request parameter in the following operations: DeleteStudioLayout, ModifyStudioLayout, and DescribeStudioLayouts.
        self.layout_id = layout_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddStudioLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddStudioLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddStudioLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTrancodeSEIRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        delay: int = None,
        domain_name: str = None,
        owner_id: int = None,
        pattern: str = None,
        region_id: str = None,
        repeat: int = None,
        stream_name: str = None,
        text: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The time period after which the SEI is inserted after the request is received. Unit: milliseconds.
        # 
        # This parameter is required.
        self.delay = delay
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # Specifies whether to append the SEI to each keyframe or frame. Valid values:
        # 
        # *   **keyframe**\
        # *   **frame**\
        # 
        # This parameter is required.
        self.pattern = pattern
        self.region_id = region_id
        # The number of times that the SEI is repeatedly inserted. A value of -1 specifies infinite times.
        # 
        # This parameter is required.
        self.repeat = repeat
        # The name of the live stream.
        # 
        # >  The value of this parameter must be the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The SEI text. It can be up to 4,000 bytes in length.
        # 
        # This parameter is required.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat is not None:
            result['Repeat'] = self.repeat
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Repeat') is not None:
            self.repeat = m.get('Repeat')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class AddTrancodeSEIResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddTrancodeSEIResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTrancodeSEIResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTrancodeSEIResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BanLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        except_users: List[str] = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The users whom you do not want to mute when the group is muted.
        self.except_users = except_users
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.except_users is not None:
            result['ExceptUsers'] = self.except_users
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('ExceptUsers') is not None:
            self.except_users = m.get('ExceptUsers')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class BanLiveMessageGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        except_users_shrink: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The users whom you do not want to mute when the group is muted.
        self.except_users_shrink = except_users_shrink
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.except_users_shrink is not None:
            result['ExceptUsers'] = self.except_users_shrink
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('ExceptUsers') is not None:
            self.except_users_shrink = m.get('ExceptUsers')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class BanLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BanLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BanLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BanLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchDeleteLiveDomainConfigsRequest(TeaModel):
    def __init__(
        self,
        domain_names: str = None,
        function_names: str = None,
        owner_account: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ingest domain or streaming domain. Separate multiple domain names with commas (,).
        # 
        # This parameter is required.
        self.domain_names = domain_names
        # The names of the features. Separate multiple features with commas (,). For more information, see **Features specified by the Functions parameter**.
        # 
        # This parameter is required.
        self.function_names = function_names
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.function_names is not None:
            result['FunctionNames'] = self.function_names
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('FunctionNames') is not None:
            self.function_names = m.get('FunctionNames')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class BatchDeleteLiveDomainConfigsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchDeleteLiveDomainConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchDeleteLiveDomainConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchDeleteLiveDomainConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetOnlineUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        user_ids: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The list of user IDs. Separate multiple user IDs with commas (,). You can specify a maximum of 20 user IDs.
        # 
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class BatchGetOnlineUsersResponseBodyResultOnlineUsers(TeaModel):
    def __init__(
        self,
        join_time: int = None,
        online: bool = None,
        user_id: str = None,
    ):
        # The time when the user joined the group. The value is a UTC timestamp. Unit: milliseconds.
        self.join_time = join_time
        # Indicates whether the user is online. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.online = online
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_time is not None:
            result['JoinTime'] = self.join_time
        if self.online is not None:
            result['Online'] = self.online
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTime') is not None:
            self.join_time = m.get('JoinTime')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class BatchGetOnlineUsersResponseBodyResult(TeaModel):
    def __init__(
        self,
        online_users: List[BatchGetOnlineUsersResponseBodyResultOnlineUsers] = None,
    ):
        # The information about users.
        self.online_users = online_users

    def validate(self):
        if self.online_users:
            for k in self.online_users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OnlineUsers'] = []
        if self.online_users is not None:
            for k in self.online_users:
                result['OnlineUsers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.online_users = []
        if m.get('OnlineUsers') is not None:
            for k in m.get('OnlineUsers'):
                temp_model = BatchGetOnlineUsersResponseBodyResultOnlineUsers()
                self.online_users.append(temp_model.from_map(k))
        return self


class BatchGetOnlineUsersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: BatchGetOnlineUsersResponseBodyResult = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The returned results.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = BatchGetOnlineUsersResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class BatchGetOnlineUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetOnlineUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetOnlineUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchSetLiveDomainConfigsRequest(TeaModel):
    def __init__(
        self,
        domain_names: str = None,
        functions: str = None,
        owner_account: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The domain names that you want to batch configure. Supported domain names include ingest domains, main streaming domains, and sub-streaming domains. Separate multiple domain names with commas (,).
        # 
        # This parameter is required.
        self.domain_names = domain_names
        # The list of features.
        # 
        # Some features, such as `filetype_based_ttl_set`, support multiple configuration records. To update one of the configuration records, use `configId` to identify the record. For more information, see **Format of the Functions parameter** and **Features specified by the Functions parameter**.
        # 
        # This parameter is required.
        self.functions = functions
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.functions is not None:
            result['Functions'] = self.functions
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('Functions') is not None:
            self.functions = m.get('Functions')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class BatchSetLiveDomainConfigsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchSetLiveDomainConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchSetLiveDomainConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchSetLiveDomainConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelMuteAllGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        group_id: str = None,
        operator_user_id: str = None,
    ):
        # Interactive message application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # 
        # 
        # - 0
        # 
        # - 1
        # 
        # - 2
        self.broad_cast_type = broad_cast_type
        # Message group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # Operator\\"s UserId. > This parameter is required and the user must be the creator of the group.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class CancelMuteAllGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the cancellation was successful, with values:
        # - true: Success. 
        # - false: Not successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelMuteAllGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: CancelMuteAllGroupUserResponseBodyResult = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = CancelMuteAllGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class CancelMuteAllGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelMuteAllGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelMuteAllGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelMuteGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        cancel_mute_user_list: List[str] = None,
        group_id: str = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The IDs of the users.
        # 
        # This parameter is required.
        self.cancel_mute_user_list = cancel_mute_user_list
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.cancel_mute_user_list is not None:
            result['CancelMuteUserList'] = self.cancel_mute_user_list
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('CancelMuteUserList') is not None:
            self.cancel_mute_user_list = m.get('CancelMuteUserList')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class CancelMuteGroupUserShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        cancel_mute_user_list_shrink: str = None,
        group_id: str = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The IDs of the users.
        # 
        # This parameter is required.
        self.cancel_mute_user_list_shrink = cancel_mute_user_list_shrink
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.cancel_mute_user_list_shrink is not None:
            result['CancelMuteUserList'] = self.cancel_mute_user_list_shrink
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('CancelMuteUserList') is not None:
            self.cancel_mute_user_list_shrink = m.get('CancelMuteUserList')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class CancelMuteGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the members are unmuted. Valid values:
        # 
        # *   true: The members are unmuted.
        # *   false: The members failed to be unmuted.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelMuteGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: CancelMuteGroupUserResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = CancelMuteGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class CancelMuteGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelMuteGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelMuteGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeLiveDomainResourceGroupRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        new_resource_group_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ingest domain or streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The ID of the resource group to which the domain name is moved.
        # 
        # This parameter is required.
        self.new_resource_group_id = new_resource_group_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.new_resource_group_id is not None:
            result['NewResourceGroupId'] = self.new_resource_group_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NewResourceGroupId') is not None:
            self.new_resource_group_id = m.get('NewResourceGroupId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ChangeLiveDomainResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeLiveDomainResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeLiveDomainResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeLiveDomainResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckLiveMessageUsersInGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        user_ids: List[str] = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The list of users that you want to query.
        # 
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class CheckLiveMessageUsersInGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        user_ids_shrink: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The list of users that you want to query.
        # 
        # This parameter is required.
        self.user_ids_shrink = user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        return self


class CheckLiveMessageUsersInGroupResponseBodyUsers(TeaModel):
    def __init__(
        self,
        online: bool = None,
        user_id: str = None,
    ):
        # Indicates whether the user is in the group.
        self.online = online
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.online is not None:
            result['Online'] = self.online
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CheckLiveMessageUsersInGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        users: List[CheckLiveMessageUsersInGroupResponseBodyUsers] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The list of users queried.
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = CheckLiveMessageUsersInGroupResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class CheckLiveMessageUsersInGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckLiveMessageUsersInGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckLiveMessageUsersInGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckLiveMessageUsersOnlineRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        user_ids: List[str] = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The list of users that you want to query.
        # 
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class CheckLiveMessageUsersOnlineShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        user_ids_shrink: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The list of users that you want to query.
        # 
        # This parameter is required.
        self.user_ids_shrink = user_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.user_ids_shrink is not None:
            result['UserIds'] = self.user_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('UserIds') is not None:
            self.user_ids_shrink = m.get('UserIds')
        return self


class CheckLiveMessageUsersOnlineResponseBodyUserList(TeaModel):
    def __init__(
        self,
        online: bool = None,
        user_id: str = None,
    ):
        # Indicates whether the user is online.
        self.online = online
        # The user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.online is not None:
            result['Online'] = self.online
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CheckLiveMessageUsersOnlineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_list: List[CheckLiveMessageUsersOnlineResponseBodyUserList] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The list of users queried.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = CheckLiveMessageUsersOnlineResponseBodyUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class CheckLiveMessageUsersOnlineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckLiveMessageUsersOnlineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckLiveMessageUsersOnlineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseLiveShiftRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class CloseLiveShiftResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CloseLiveShiftResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseLiveShiftResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseLiveShiftResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyCasterRequest(TeaModel):
    def __init__(
        self,
        caster_name: str = None,
        client_token: str = None,
        owner_id: int = None,
        region_id: str = None,
        src_caster_id: str = None,
    ):
        # The name of the new production studio.
        # 
        # This parameter is required.
        self.caster_name = caster_name
        # The user-generated request token. This token is used to ensure the idempotence of the request.
        # 
        # You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        # 
        # This parameter is required.
        self.client_token = client_token
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the original production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.src_caster_id = src_caster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.src_caster_id is not None:
            result['SrcCasterId'] = self.src_caster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SrcCasterId') is not None:
            self.src_caster_id = m.get('SrcCasterId')
        return self


class CopyCasterResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the new production studio.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopyCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyCasterSceneConfigRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        from_scene_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        to_scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the source scene, which must be a PVW scene.
        # 
        # This parameter is required.
        self.from_scene_id = from_scene_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the destination scene, which must be a PGM scene.
        # 
        # This parameter is required.
        self.to_scene_id = to_scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.from_scene_id is not None:
            result['FromSceneId'] = self.from_scene_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.to_scene_id is not None:
            result['ToSceneId'] = self.to_scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('FromSceneId') is not None:
            self.from_scene_id = m.get('FromSceneId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ToSceneId') is not None:
            self.to_scene_id = m.get('ToSceneId')
        return self


class CopyCasterSceneConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopyCasterSceneConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyCasterSceneConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyCasterSceneConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCasterRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateCasterRequest(TeaModel):
    def __init__(
        self,
        caster_name: str = None,
        caster_template: str = None,
        charge_type: str = None,
        client_token: str = None,
        expire_time: str = None,
        norm_type: int = None,
        owner_id: int = None,
        purchase_time: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag: List[CreateCasterRequestTag] = None,
    ):
        # The name of the production studio.
        self.caster_name = caster_name
        # The preset resolution of the production studio. If the subscription billing method is used, this parameter supports the following valid values:
        # 
        # *   **lp_ld**: low definition
        # *   **lp_sd**: standard definition
        # *   **lp_hd**: high definition
        # *   **lp_ud**: ultra high definition
        # *   **lp_ld_v**: low definition (portrait mode)
        # *   **lp_sd_v**: standard definition (portrait mode)
        # *   **lp_hd_v**: high definition (portrait mode)
        # *   **lp_ud_v**: ultra high definition (portrait mode)
        # 
        # >  If the pay-as-you-go billing method is used, you must call the [SetCasterConfig](https://help.aliyun.com/document_detail/60271.html) operation to specify the resolution.
        self.caster_template = caster_template
        # The billing method. Only the pay-as-you-go billing method is supported.**** Valid values:
        # 
        # *   **PrePaid**: subscription. This billing method is not yet supported.
        # *   **PostPaid**: pay-as-you-go
        # 
        # This parameter is required.
        self.charge_type = charge_type
        # The client token that is used to ensure the idempotence of the request.
        # 
        # You can specify a custom value for this parameter, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
        # 
        # This parameter is required.
        self.client_token = client_token
        # The expiration time of the production studio. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  This parameter is valid only if you set the **ChargeType** parameter to **PrePaid**.
        self.expire_time = expire_time
        # The type of the production studio. Valid values:
        # 
        # *   **1**: general mode
        # *   **6**: playlist mode (for carousel playback)
        # 
        # This parameter is required.
        self.norm_type = norm_type
        self.owner_id = owner_id
        # The time when the production studio was purchased. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  This parameter is valid only if you set the **ChargeType** parameter to **PrePaid**.
        self.purchase_time = purchase_time
        self.region_id = region_id
        # The ID of the resource group. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).
        self.resource_group_id = resource_group_id
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.caster_template is not None:
            result['CasterTemplate'] = self.caster_template
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.norm_type is not None:
            result['NormType'] = self.norm_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.purchase_time is not None:
            result['PurchaseTime'] = self.purchase_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('CasterTemplate') is not None:
            self.caster_template = m.get('CasterTemplate')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('NormType') is not None:
            self.norm_type = m.get('NormType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PurchaseTime') is not None:
            self.purchase_time = m.get('PurchaseTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateCasterRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateCasterResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        custom_template: str = None,
        owner_id: int = None,
        region_id: str = None,
        template: str = None,
    ):
        # The configuration of the template. The value is in the following JSON format: {height:xxx,scale:xxx,gop:xxx,bframes:xxx,cdesc:xxx}. All fields are required. If any field is left empty, the call fails.
        # 
        # >  For more information, see **Fields of the CustomTemplate parameter**.
        # 
        # This parameter is required.
        self.custom_template = custom_template
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the template.
        # 
        # > Record the template name. The template name is required if you want to use, query, or delete the template.
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            self.custom_template = m.get('CustomTemplate')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class CreateCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_input: str = None,
        stream_output: str = None,
        template_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The task name. The name can contain letters, digits, hyphens (-), and underscores (_). The name must be 255 characters in length.
        # 
        # This parameter is required.
        self.name = name
        self.owner_id = owner_id
        self.region_id = region_id
        # The URL of the input stream.
        # 
        # This parameter is required.
        self.stream_input = stream_input
        # The URL of the output stream.
        # 
        # This parameter is required.
        self.stream_output = stream_output
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input
        if self.stream_output is not None:
            result['StreamOutput'] = self.stream_output
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamInput') is not None:
            self.stream_input = m.get('StreamInput')
        if m.get('StreamOutput') is not None:
            self.stream_output = m.get('StreamOutput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the edge transcoding task.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_id: str = None,
        events: List[str] = None,
        users: List[str] = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The callback URL. For more information about the content of the messages that are sent to the callback URL, see the Callback section in this topic.
        # 
        # This parameter is required.
        self.callback_url = callback_url
        # The channel ID. You can call the [ListEventSub](https://help.aliyun.com/document_detail/2628135.html) operation to query the channel ID.
        # 
        # > 
        # 
        # *   This parameter is required if you specify the Users.N parameter.
        # 
        # *   If you set this parameter to \\* or do not specify this parameter, all channels are subscribed to.
        # 
        # *   Each application ID allows only one all-channel subscription.
        self.channel_id = channel_id
        # Subscribe to events.
        # 
        # This parameter is required.
        self.events = events
        # The user whose events you want to subscribe to. If you leave this parameter empty, the events of all users in the channel are subscribed to, including the events of the streamer and viewers. Specify this parameter in the following format:
        # 
        #     Users.1=****\
        #     Users.2=****\
        #     ......
        self.users = users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.events is not None:
            result['Events'] = self.events
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Events') is not None:
            self.events = m.get('Events')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class CreateEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscribe_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The subscription ID.
        self.subscribe_id = subscribe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        return self


class CreateEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveAIStudioRequestMattingLayout(TeaModel):
    def __init__(
        self,
        height_normalized: float = None,
        position_x: float = None,
        position_y: float = None,
    ):
        # The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_x = position_x
        # The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_y = position_y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_x is not None:
            result['PositionX'] = self.position_x
        if self.position_y is not None:
            result['PositionY'] = self.position_y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionX') is not None:
            self.position_x = m.get('PositionX')
        if m.get('PositionY') is not None:
            self.position_y = m.get('PositionY')
        return self


class CreateLiveAIStudioRequestMediaLayout(TeaModel):
    def __init__(
        self,
        height_normalized: float = None,
        position_x: float = None,
        position_y: float = None,
    ):
        # The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_x = position_x
        # The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_y = position_y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_x is not None:
            result['PositionX'] = self.position_x
        if self.position_y is not None:
            result['PositionY'] = self.position_y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionX') is not None:
            self.position_x = m.get('PositionX')
        if m.get('PositionY') is not None:
            self.position_y = m.get('PositionY')
        return self


class CreateLiveAIStudioRequest(TeaModel):
    def __init__(
        self,
        background_resource_id: str = None,
        background_resource_url: str = None,
        background_type: str = None,
        description: str = None,
        height: int = None,
        matting_layout: CreateLiveAIStudioRequestMattingLayout = None,
        matting_type: str = None,
        media_layout: CreateLiveAIStudioRequestMediaLayout = None,
        media_resource_id: str = None,
        media_resource_url: str = None,
        media_type: str = None,
        owner_id: int = None,
        region_id: str = None,
        studio_name: str = None,
        width: int = None,
    ):
        # The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.background_resource_id = background_resource_id
        # The URL of the background material. Specify either this parameter or the BackgroundResourceId parameter.
        self.background_resource_url = background_resource_url
        # The type of the background material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.background_type = background_type
        # The custom description.
        self.description = description
        # The preview height. Unit: pixels.
        # 
        # The following preview specifications (width  height) are supported:
        # 
        # *   Landscape low definition 360p (640360)
        # *   Portrait low definition 360p (360640)
        # *   Landscape standard definition 480p (854480)
        # *   Portrait standard definition 480p (480854)
        # *   Landscape high definition 720p (1280720)
        # *   Portrait high definition 720p (7201280)
        # *   Landscape ultra-high definition 1080p (19201080)
        # *   Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The layout information of the chroma-keyed material.
        # 
        # This parameter is required.
        self.matting_layout = matting_layout
        # The type of chroma key. Valid values:
        # 
        # *   green: green-screen chroma key
        # *   blue: blue-screen chroma key
        # *   complex: background replacement
        # 
        # This parameter is required.
        self.matting_type = matting_type
        # The layout information of the multimedia material.
        self.media_layout = media_layout
        # The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.media_resource_id = media_resource_id
        # The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.
        self.media_resource_url = media_resource_url
        # The type of the multimedia material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.media_type = media_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the virtual studio template. The name must be unique.
        # 
        # This parameter is required.
        self.studio_name = studio_name
        # The preview width. Unit: pixels.
        self.width = width

    def validate(self):
        if self.matting_layout:
            self.matting_layout.validate()
        if self.media_layout:
            self.media_layout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_resource_id is not None:
            result['BackgroundResourceId'] = self.background_resource_id
        if self.background_resource_url is not None:
            result['BackgroundResourceUrl'] = self.background_resource_url
        if self.background_type is not None:
            result['BackgroundType'] = self.background_type
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.matting_layout is not None:
            result['MattingLayout'] = self.matting_layout.to_map()
        if self.matting_type is not None:
            result['MattingType'] = self.matting_type
        if self.media_layout is not None:
            result['MediaLayout'] = self.media_layout.to_map()
        if self.media_resource_id is not None:
            result['MediaResourceId'] = self.media_resource_id
        if self.media_resource_url is not None:
            result['MediaResourceUrl'] = self.media_resource_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundResourceId') is not None:
            self.background_resource_id = m.get('BackgroundResourceId')
        if m.get('BackgroundResourceUrl') is not None:
            self.background_resource_url = m.get('BackgroundResourceUrl')
        if m.get('BackgroundType') is not None:
            self.background_type = m.get('BackgroundType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MattingLayout') is not None:
            temp_model = CreateLiveAIStudioRequestMattingLayout()
            self.matting_layout = temp_model.from_map(m['MattingLayout'])
        if m.get('MattingType') is not None:
            self.matting_type = m.get('MattingType')
        if m.get('MediaLayout') is not None:
            temp_model = CreateLiveAIStudioRequestMediaLayout()
            self.media_layout = temp_model.from_map(m['MediaLayout'])
        if m.get('MediaResourceId') is not None:
            self.media_resource_id = m.get('MediaResourceId')
        if m.get('MediaResourceUrl') is not None:
            self.media_resource_url = m.get('MediaResourceUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CreateLiveAIStudioShrinkRequest(TeaModel):
    def __init__(
        self,
        background_resource_id: str = None,
        background_resource_url: str = None,
        background_type: str = None,
        description: str = None,
        height: int = None,
        matting_layout_shrink: str = None,
        matting_type: str = None,
        media_layout_shrink: str = None,
        media_resource_id: str = None,
        media_resource_url: str = None,
        media_type: str = None,
        owner_id: int = None,
        region_id: str = None,
        studio_name: str = None,
        width: int = None,
    ):
        # The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.background_resource_id = background_resource_id
        # The URL of the background material. Specify either this parameter or the BackgroundResourceId parameter.
        self.background_resource_url = background_resource_url
        # The type of the background material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.background_type = background_type
        # The custom description.
        self.description = description
        # The preview height. Unit: pixels.
        # 
        # The following preview specifications (width  height) are supported:
        # 
        # *   Landscape low definition 360p (640360)
        # *   Portrait low definition 360p (360640)
        # *   Landscape standard definition 480p (854480)
        # *   Portrait standard definition 480p (480854)
        # *   Landscape high definition 720p (1280720)
        # *   Portrait high definition 720p (7201280)
        # *   Landscape ultra-high definition 1080p (19201080)
        # *   Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The layout information of the chroma-keyed material.
        # 
        # This parameter is required.
        self.matting_layout_shrink = matting_layout_shrink
        # The type of chroma key. Valid values:
        # 
        # *   green: green-screen chroma key
        # *   blue: blue-screen chroma key
        # *   complex: background replacement
        # 
        # This parameter is required.
        self.matting_type = matting_type
        # The layout information of the multimedia material.
        self.media_layout_shrink = media_layout_shrink
        # The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.media_resource_id = media_resource_id
        # The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.
        self.media_resource_url = media_resource_url
        # The type of the multimedia material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.media_type = media_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the virtual studio template. The name must be unique.
        # 
        # This parameter is required.
        self.studio_name = studio_name
        # The preview width. Unit: pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_resource_id is not None:
            result['BackgroundResourceId'] = self.background_resource_id
        if self.background_resource_url is not None:
            result['BackgroundResourceUrl'] = self.background_resource_url
        if self.background_type is not None:
            result['BackgroundType'] = self.background_type
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.matting_layout_shrink is not None:
            result['MattingLayout'] = self.matting_layout_shrink
        if self.matting_type is not None:
            result['MattingType'] = self.matting_type
        if self.media_layout_shrink is not None:
            result['MediaLayout'] = self.media_layout_shrink
        if self.media_resource_id is not None:
            result['MediaResourceId'] = self.media_resource_id
        if self.media_resource_url is not None:
            result['MediaResourceUrl'] = self.media_resource_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundResourceId') is not None:
            self.background_resource_id = m.get('BackgroundResourceId')
        if m.get('BackgroundResourceUrl') is not None:
            self.background_resource_url = m.get('BackgroundResourceUrl')
        if m.get('BackgroundType') is not None:
            self.background_type = m.get('BackgroundType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MattingLayout') is not None:
            self.matting_layout_shrink = m.get('MattingLayout')
        if m.get('MattingType') is not None:
            self.matting_type = m.get('MattingType')
        if m.get('MediaLayout') is not None:
            self.media_layout_shrink = m.get('MediaLayout')
        if m.get('MediaResourceId') is not None:
            self.media_resource_id = m.get('MediaResourceId')
        if m.get('MediaResourceUrl') is not None:
            self.media_resource_url = m.get('MediaResourceUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CreateLiveAIStudioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        studio_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the virtual studio template.
        self.studio_id = studio_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.studio_id is not None:
            result['StudioId'] = self.studio_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StudioId') is not None:
            self.studio_id = m.get('StudioId')
        return self


class CreateLiveAIStudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveAIStudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveAIStudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveDelayConfigRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        delay_time: int = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
        task_trigger_mode: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.
        # 
        # This parameter is required.
        self.app = app
        # The duration for which the playback of the live stream is delayed. The value must be an integer. Valid values: 16 to 3600. Unit: seconds.
        # 
        # This parameter is required.
        self.delay_time = delay_time
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.
        # 
        # This parameter is required.
        self.stream = stream
        # The trigger mode. Valid values:
        # 
        # *   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
        # *   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
        # *   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.
        # 
        # This parameter is required.
        self.task_trigger_mode = task_trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.task_trigger_mode is not None:
            result['TaskTriggerMode'] = self.task_trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TaskTriggerMode') is not None:
            self.task_trigger_mode = m.get('TaskTriggerMode')
        return self


class CreateLiveDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        audit_type: int = None,
        audit_url: str = None,
        data_center: str = None,
        event_callback_url: str = None,
        msg_life_cycle: int = None,
    ):
        # The name of the application. The name must be 2 to 16 characters in length.
        self.app_name = app_name
        # The content moderation method. Valid values:
        # 
        # *   0 (default): disables content moderation.
        # *   1: uses built-in content moderation.
        # *   2: uses custom content moderation.
        self.audit_type = audit_type
        # The URL for content moderation. If you set AuditType to 2, you must specify this parameter. The URL must start with http:// or https:// and cannot contain a private IP address or a port number. For more information about custom content moderation, see the "Custom content moderation" section of this topic.
        self.audit_url = audit_url
        # The data center. Valid values:
        # 
        # *   cn-shanghai (default)
        # *   ap-southeast-1: Singapore
        # 
        # >  When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
        self.data_center = data_center
        # The callback URL for events, such as logon, logoff, and joining and leaving a group. If you leave this parameter empty, event callbacks are disabled. [](~~2672836~~)The callback URL must start with http:// or https:// and cannot contain a private IP address or a port number. For information about the callback message format and authentication logic, see the "Event callbacks" and "Callback authentication" sections of this topic.
        self.event_callback_url = event_callback_url
        # The retention period of group messages in the application. Valid values:
        # 
        # *   0 (default): 30 days.
        # *   1: 90 days.
        # *   2: 180 days.
        self.msg_life_cycle = msg_life_cycle

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.audit_type is not None:
            result['AuditType'] = self.audit_type
        if self.audit_url is not None:
            result['AuditUrl'] = self.audit_url
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.event_callback_url is not None:
            result['EventCallbackUrl'] = self.event_callback_url
        if self.msg_life_cycle is not None:
            result['MsgLifeCycle'] = self.msg_life_cycle
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AuditType') is not None:
            self.audit_type = m.get('AuditType')
        if m.get('AuditUrl') is not None:
            self.audit_url = m.get('AuditUrl')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('EventCallbackUrl') is not None:
            self.event_callback_url = m.get('EventCallbackUrl')
        if m.get('MsgLifeCycle') is not None:
            self.msg_life_cycle = m.get('MsgLifeCycle')
        return self


class CreateLiveMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_key: str = None,
        app_sign: str = None,
        data_center: str = None,
        request_id: str = None,
    ):
        # The application ID. The ID is used in subsequent operations, such as joining a group.
        self.app_id = app_id
        # The AppKey for authentication of this application.
        self.app_key = app_key
        # The application signature. The signature is required when you use the interactive messaging SDK.
        self.app_sign = app_sign
        # The data center in which the interactive messaging application was created.
        self.data_center = data_center
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        administrators: List[str] = None,
        app_id: str = None,
        creator_id: str = None,
        data_center: str = None,
        group_id: str = None,
        group_info: str = None,
        group_name: str = None,
    ):
        # The list of administrators.
        self.administrators = administrators
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the group creator. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.creator_id = creator_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group that you want to create. The group ID must be unique within your business. The ID can be up to 64 bytes in length and can contain letters and digits.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The additional information about the group. The value can be up to 32 KB in length.
        self.group_info = group_info
        # The name of the group. The name can be up to 128 bytes in length.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators is not None:
            result['Administrators'] = self.administrators
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators = m.get('Administrators')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class CreateLiveMessageGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        administrators_shrink: str = None,
        app_id: str = None,
        creator_id: str = None,
        data_center: str = None,
        group_id: str = None,
        group_info: str = None,
        group_name: str = None,
    ):
        # The list of administrators.
        self.administrators_shrink = administrators_shrink
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the group creator. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.creator_id = creator_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group that you want to create. The group ID must be unique within your business. The ID can be up to 64 bytes in length and can contain letters and digits.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The additional information about the group. The value can be up to 32 KB in length.
        self.group_info = group_info
        # The name of the group. The name can be up to 128 bytes in length.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.administrators_shrink is not None:
            result['Administrators'] = self.administrators_shrink
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Administrators') is not None:
            self.administrators_shrink = m.get('Administrators')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class CreateLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        already_delete: bool = None,
        already_exists: bool = None,
        group_id: str = None,
        request_id: str = None,
    ):
        # Indicates whether the group is deleted. If the group existed and is deleted, the group ID is unavailable. We recommend that you create a new group.
        self.already_delete = already_delete
        # Indicates whether the group already exists.
        self.already_exists = already_exists
        # The ID of the group created.
        self.group_id = group_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.already_delete is not None:
            result['AlreadyDelete'] = self.already_delete
        if self.already_exists is not None:
            result['AlreadyExists'] = self.already_exists
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlreadyDelete') is not None:
            self.already_delete = m.get('AlreadyDelete')
        if m.get('AlreadyExists') is not None:
            self.already_exists = m.get('AlreadyExists')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLivePrivateLineRequest(TeaModel):
    def __init__(
        self,
        acceleration_area: str = None,
        acceleration_type: str = None,
        app_name: str = None,
        domain_name: str = None,
        instance_id: str = None,
        max_bandwidth: str = None,
        owner_id: int = None,
        region_id: str = None,
        reuse: str = None,
        stream_name: str = None,
        video_center: str = None,
    ):
        # The acceleration channel.
        # 
        # This parameter is required.
        self.acceleration_area = acceleration_area
        # The acceleration type. Valid values:
        # 
        # *   play: streaming acceleration
        # *   publish: stream ingest acceleration
        # 
        # This parameter is required.
        self.acceleration_type = acceleration_type
        # The name of the application.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The acceleration channel that you want to reuse. This parameter is required if Reuse is set to yes.
        self.instance_id = instance_id
        # The accelerated bandwidth. Unit: Mbit/s. This parameter is required if Reuse is set to no.
        self.max_bandwidth = max_bandwidth
        self.owner_id = owner_id
        self.region_id = region_id
        # Specifies whether to reuse an existing acceleration channel. Valid values:
        # 
        # *   yes: reuses an existing acceleration channel.
        # *   no: creates a new acceleration channel.
        # 
        # This parameter is required.
        self.reuse = reuse
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The live center. Valid values: cn-beijing, cn-shanghai, cn-shenzhen, cn-qingdao, ap-northeast-1, ap-southeast-5, eu-central-1, and ap-southeast-1, which indicate China (Beijing), China (Shanghai), China (Shenzhen), China (Qingdao), Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), and Singapore, respectively.
        # 
        # This parameter is required.
        self.video_center = video_center

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceleration_area is not None:
            result['AccelerationArea'] = self.acceleration_area
        if self.acceleration_type is not None:
            result['AccelerationType'] = self.acceleration_type
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.max_bandwidth is not None:
            result['MaxBandwidth'] = self.max_bandwidth
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reuse is not None:
            result['Reuse'] = self.reuse
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.video_center is not None:
            result['VideoCenter'] = self.video_center
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccelerationArea') is not None:
            self.acceleration_area = m.get('AccelerationArea')
        if m.get('AccelerationType') is not None:
            self.acceleration_type = m.get('AccelerationType')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaxBandwidth') is not None:
            self.max_bandwidth = m.get('MaxBandwidth')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Reuse') is not None:
            self.reuse = m.get('Reuse')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VideoCenter') is not None:
            self.video_center = m.get('VideoCenter')
        return self


class CreateLivePrivateLineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLivePrivateLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLivePrivateLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLivePrivateLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        dst_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        repeat_number: int = None,
        retry_count: int = None,
        retry_interval: int = None,
        source_protocol: str = None,
        source_type: str = None,
        source_urls: List[str] = None,
        start_time: str = None,
        task_name: str = None,
    ):
        # The HTTP callback URL. By default, this parameter is left empty.
        # 
        # > 
        # 
        # *   The URL is used to receive callbacks related to the task.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # *   If you do not specify this parameter, no callbacks are returned for events related to the task.
        self.callback_url = callback_url
        # The destination URL to which the stream is relayed.
        # 
        # > 
        # 
        # *   The supported protocol for the URL is RTMP.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # This parameter is required.
        self.dst_url = dst_url
        # The end time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   The end time must be later than the start time.
        # 
        # *   The end time must be later than the current time.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The file index, which specifies the sequence of the file where the playback starts.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame of the first video resource in the list.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.offset = offset
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # >  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.repeat_number = repeat_number
        # The number of retries allowed. Default value: 3.
        self.retry_count = retry_count
        # The retry interval. Unit: seconds. Valid values: [60,300]. Default value: 60.
        self.retry_interval = retry_interval
        # The protocol of the source stream.
        # 
        # Valid values:
        # 
        # *   rtmp
        # *   rtsp
        # *   srt
        # *   http-flv
        # *   flv
        # 
        # >  This parameter is required if you set the **SourceType** parameter to live, but does not take effect if you set the SourceType parameter to vod or url.
        self.source_protocol = source_protocol
        # The type of the source stream. Valid values:
        # 
        # *   live: a live stream
        # *   vod: a list of ApsaraVideo VOD resources
        # *   url: a list of video resources from a third party
        # 
        # This parameter is required.
        self.source_type = source_type
        # The source URLs.
        # 
        # > 
        # 
        # *   If SourceType is set to live, you can specify only one streaming URL.
        # 
        # *   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.
        # 
        # *   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.
        # 
        # *   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.
        # 
        # *   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.
        # 
        # This parameter is required.
        self.source_urls = source_urls
        # The start time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the task. Default value: "". Fuzzy search for task names is supported.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_urls is not None:
            result['SourceUrls'] = self.source_urls
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceUrls') is not None:
            self.source_urls = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class CreateLivePullToPushShrinkRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        dst_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        repeat_number: int = None,
        retry_count: int = None,
        retry_interval: int = None,
        source_protocol: str = None,
        source_type: str = None,
        source_urls_shrink: str = None,
        start_time: str = None,
        task_name: str = None,
    ):
        # The HTTP callback URL. By default, this parameter is left empty.
        # 
        # > 
        # 
        # *   The URL is used to receive callbacks related to the task.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # *   If you do not specify this parameter, no callbacks are returned for events related to the task.
        self.callback_url = callback_url
        # The destination URL to which the stream is relayed.
        # 
        # > 
        # 
        # *   The supported protocol for the URL is RTMP.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # This parameter is required.
        self.dst_url = dst_url
        # The end time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   The end time must be later than the start time.
        # 
        # *   The end time must be later than the current time.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The file index, which specifies the sequence of the file where the playback starts.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame of the first video resource in the list.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.offset = offset
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # >  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.repeat_number = repeat_number
        # The number of retries allowed. Default value: 3.
        self.retry_count = retry_count
        # The retry interval. Unit: seconds. Valid values: [60,300]. Default value: 60.
        self.retry_interval = retry_interval
        # The protocol of the source stream.
        # 
        # Valid values:
        # 
        # *   rtmp
        # *   rtsp
        # *   srt
        # *   http-flv
        # *   flv
        # 
        # >  This parameter is required if you set the **SourceType** parameter to live, but does not take effect if you set the SourceType parameter to vod or url.
        self.source_protocol = source_protocol
        # The type of the source stream. Valid values:
        # 
        # *   live: a live stream
        # *   vod: a list of ApsaraVideo VOD resources
        # *   url: a list of video resources from a third party
        # 
        # This parameter is required.
        self.source_type = source_type
        # The source URLs.
        # 
        # > 
        # 
        # *   If SourceType is set to live, you can specify only one streaming URL.
        # 
        # *   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.
        # 
        # *   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.
        # 
        # *   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.
        # 
        # *   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.
        # 
        # This parameter is required.
        self.source_urls_shrink = source_urls_shrink
        # The start time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the task. Default value: "". Fuzzy search for task names is supported.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_urls_shrink is not None:
            result['SourceUrls'] = self.source_urls_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceUrls') is not None:
            self.source_urls_shrink = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class CreateLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
        task_id: str = None,
    ):
        # The description of the custom rule.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The code that is returned for the request.
        # 
        # > 
        # 
        # *   0 is returned if the request is normal.
        # 
        # *   For information about codes that are returned when exceptions occur, see the following Error codes table.
        self.ret_code = ret_code
        # The task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveRealTimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        logstore: str = None,
        owner_id: int = None,
        project: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the Logstore to which log entries are delivered.
        # 
        # This parameter is required.
        self.logstore = logstore
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery.
        # 
        # This parameter is required.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateLiveRealTimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveRealTimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveRealTimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveRealTimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveStreamMonitorRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        callback_url: str = None,
        ding_talk_web_hook_url: str = None,
        domain: str = None,
        input_list: str = None,
        monitor_config: str = None,
        monitor_name: str = None,
        output_template: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
    ):
        # The name of the application that plays the output streams of the monitoring session.
        # 
        # You can specify a name. If you do not specify a name, the system uses **monitor** as the name of the application.
        self.app = app
        # Supports input of callback addresses in HTTP(S) format.
        self.callback_url = callback_url
        # DingTalk alert monitoring sends alert notifications through a DingTalk group robot. Please set up the DingTalk group robot first and enter the HTTP(S) address of the robot here. For more details, see [Custom Robot Access](https://open.dingtalk.com/document/robots/custom-robot-access).
        # > Configure the custom keyword for the DingTalk group robot as \\"alert\\", otherwise, messages will not be received.
        self.ding_talk_web_hook_url = ding_talk_web_hook_url
        # The endpoint of the monitoring session.
        # 
        # This parameter is required.
        self.domain = domain
        # The list of input streams to monitor. For more information, see the following **InputConfig** table.
        # 
        # This parameter is required.
        self.input_list = input_list
        # Alarm threshold setting for monitoring, in JSON format. For more details, please refer to the table below for MonitorConfig.
        self.monitor_config = monitor_config
        # The name of the monitoring session.
        # 
        # This parameter is required.
        self.monitor_name = monitor_name
        # The output template of the monitoring session. Valid values:
        # 
        # *   **lp_ld**: low definition.
        # *   **lp_sd**: standard definition.
        # *   **lp_hd**: high definition.
        # *   **lp_ud**: ultra high definition.
        # 
        # This parameter is required.
        self.output_template = output_template
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the output stream of the monitoring session. If you do not specify a name, the system generates a name at random.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.ding_talk_web_hook_url is not None:
            result['DingTalkWebHookUrl'] = self.ding_talk_web_hook_url
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.input_list is not None:
            result['InputList'] = self.input_list
        if self.monitor_config is not None:
            result['MonitorConfig'] = self.monitor_config
        if self.monitor_name is not None:
            result['MonitorName'] = self.monitor_name
        if self.output_template is not None:
            result['OutputTemplate'] = self.output_template
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('DingTalkWebHookUrl') is not None:
            self.ding_talk_web_hook_url = m.get('DingTalkWebHookUrl')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('InputList') is not None:
            self.input_list = m.get('InputList')
        if m.get('MonitorConfig') is not None:
            self.monitor_config = m.get('MonitorConfig')
        if m.get('MonitorName') is not None:
            self.monitor_name = m.get('MonitorName')
        if m.get('OutputTemplate') is not None:
            self.output_template = m.get('OutputTemplate')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class CreateLiveStreamMonitorResponseBody(TeaModel):
    def __init__(
        self,
        monitor_id: str = None,
        request_id: str = None,
    ):
        # The ID of the monitoring session.
        self.monitor_id = monitor_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveStreamMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveStreamMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveStreamMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveStreamRecordIndexFilesRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        end_time_included: bool = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        owner_id: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all applications, specify an asterisk (\\*) as the value.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end time of the index file. TS segments that are uploaded before the end time are included in the index file. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # Specifies whether to include the end time. If you set this parameter to true, the system attempts to include one more TS segment. The created index file covers the entire time range that is specified by the StartTime and EndTime parameters.
        self.end_time_included = end_time_included
        # The name of the OSS bucket.
        # 
        # This parameter is required.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        # 
        # This parameter is required.
        self.oss_endpoint = oss_endpoint
        # The name of the recording that is stored in OSS.
        # 
        # This parameter is required.
        self.oss_object = oss_object
        self.owner_id = owner_id
        self.security_token = security_token
        # The start time of the index file. TS segments that are uploaded after the start time are included in the index file. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all streams, specify an asterisk (\\*) as the value.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_time_included is not None:
            result['EndTimeIncluded'] = self.end_time_included
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimeIncluded') is not None:
            self.end_time_included = m.get('EndTimeIncluded')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        create_time: str = None,
        domain_name: str = None,
        duration: float = None,
        end_time: str = None,
        height: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        record_id: str = None,
        record_url: str = None,
        start_time: str = None,
        stream_name: str = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The time when the index file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The main streaming domain.
        self.domain_name = domain_name
        # The recording length. Unit: seconds.
        self.duration = duration
        # The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The height of the video.
        self.height = height
        # The name of the OSS bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the recording that is stored in OSS.
        self.oss_object = oss_object
        # The ID of the index file.
        self.record_id = record_id
        # The URL of the M3U8 index file.
        self.record_url = record_url
        # The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The width of the video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.height is not None:
            result['Height'] = self.height
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.record_url is not None:
            result['RecordUrl'] = self.record_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RecordUrl') is not None:
            self.record_url = m.get('RecordUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class CreateLiveStreamRecordIndexFilesResponseBody(TeaModel):
    def __init__(
        self,
        record_info: CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo = None,
        request_id: str = None,
    ):
        # The recording configuration.
        self.record_info = record_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.record_info:
            self.record_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_info is not None:
            result['RecordInfo'] = self.record_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordInfo') is not None:
            temp_model = CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo()
            self.record_info = temp_model.from_map(m['RecordInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLiveStreamRecordIndexFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLiveStreamRecordIndexFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveStreamRecordIndexFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_config: Dict[str, str] = None,
        app_name: str = None,
        extension: Dict[str, str] = None,
    ):
        # The configurations of the application.
        self.app_config = app_config
        # The name of the interactive message application. The name must be 2 to 16 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The extended fields.
        self.extension = extension

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.extension is not None:
            result['Extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        return self


class CreateMessageAppShrinkRequest(TeaModel):
    def __init__(
        self,
        app_config_shrink: str = None,
        app_name: str = None,
        extension_shrink: str = None,
    ):
        # The configurations of the application.
        self.app_config_shrink = app_config_shrink
        # The name of the interactive message application. The name must be 2 to 16 characters in length.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The extended fields.
        self.extension_shrink = extension_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config_shrink is not None:
            result['AppConfig'] = self.app_config_shrink
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.extension_shrink is not None:
            result['Extension'] = self.extension_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config_shrink = m.get('AppConfig')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Extension') is not None:
            self.extension_shrink = m.get('Extension')
        return self


class CreateMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class CreateMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: CreateMessageAppResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = CreateMessageAppResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class CreateMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        creator_id: str = None,
        extension: Dict[str, str] = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the creator. The ID can be up to 36 characters in length and can contain only letters and digits.
        # 
        # This parameter is required.
        self.creator_id = creator_id
        # The extended field.
        self.extension = extension

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        return self


class CreateMessageGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        creator_id: str = None,
        extension_shrink: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the creator. The ID can be up to 36 characters in length and can contain only letters and digits.
        # 
        # This parameter is required.
        self.creator_id = creator_id
        # The extended field.
        self.extension_shrink = extension_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension_shrink is not None:
            result['Extension'] = self.extension_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension_shrink = m.get('Extension')
        return self


class CreateMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        extension: Dict[str, Any] = None,
        group_id: str = None,
    ):
        # The extended field.
        self.extension = extension
        # The ID of the message group.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class CreateMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: CreateMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = CreateMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class CreateMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMixStreamRequest(TeaModel):
    def __init__(
        self,
        callback_config: str = None,
        domain_name: str = None,
        input_stream_list: str = None,
        layout_id: str = None,
        output_config: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The callback URL. The value is a JSON array. If a callback event is triggered, ApsaraVideo Live sends an HTTP POST request to the URL. The content is included in the HTTP request body.
        self.callback_config = callback_config
        # The main streaming domain.
        # 
        # >  Only domain names that reside in the China (Shanghai) and China (Beijing) regions are supported.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The input streams. The value is a JSON array.
        # 
        # For more information, see **InputStreamConfig**.
        # 
        # This parameter is required.
        self.input_stream_list = input_stream_list
        # The ID of the layout. Valid values:
        # 
        # *   **MixStreamLayout-1-1**\
        # *   **MixStreamLayout-2-1**\
        # *   **MixStreamLayout-2-2**\
        # *   **MixStreamLayout-2-3**\
        # *   **MixStreamLayout-3-1**\
        # *   **MixStreamLayout-3-2**\
        # *   **MixStreamLayout-4-1**\
        # *   **USERDEFINED**: If you do not use a preset layout, set this parameter to **USERDEFINED**.
        # 
        # >  For more information, see [Preset layouts for stream mixing](https://help.aliyun.com/document_detail/199361.html).
        # 
        # This parameter is required.
        self.layout_id = layout_id
        # The configuration of the output stream. The value is a JSON string.
        # 
        # For more information, see **OutputConfig**.
        # 
        # This parameter is required.
        self.output_config = output_config
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_config is not None:
            result['CallbackConfig'] = self.callback_config
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.input_stream_list is not None:
            result['InputStreamList'] = self.input_stream_list
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackConfig') is not None:
            self.callback_config = m.get('CallbackConfig')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InputStreamList') is not None:
            self.input_stream_list = m.get('InputStreamList')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMixStreamResponseBody(TeaModel):
    def __init__(
        self,
        mix_stream_id: str = None,
        request_id: str = None,
    ):
        # The ID of the stream mixing task. You can specify this parameter in a request to delete the stream mixing task or query stream mixing tasks.
        self.mix_stream_id = mix_stream_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateMixStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMixStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMixStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRTCWhipStreamAddressRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        client_token: str = None,
        display_name: str = None,
        expire_time: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.client_token = client_token
        # This parameter is required.
        self.display_name = display_name
        self.expire_time = expire_time
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateRTCWhipStreamAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        whip_address: str = None,
    ):
        self.request_id = request_id
        self.whip_address = whip_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.whip_address is not None:
            result['WhipAddress'] = self.whip_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WhipAddress') is not None:
            self.whip_address = m.get('WhipAddress')
        return self


class CreateRTCWhipStreamAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRTCWhipStreamAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRTCWhipStreamAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRoomRealTimeStreamAddressRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        display_name: str = None,
        expire_time: int = None,
        user_id: str = None,
    ):
        # The ID of the ARTC application. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the channel. You can specify only one ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The name of the RTMP stream. The name can be up to 40 characters in length.
        # 
        # This parameter is required.
        self.display_name = display_name
        # The validity period of the RTMP URL. Unit: seconds. The default value is 36,000 seconds, which is 10 hours.
        self.expire_time = expire_time
        # The ID of the user who ingests the stream over RTMP. The user ID must be different from IDs of other users in the channel. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateRoomRealTimeStreamAddressResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rtmp_address: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The RTMP ingest URL.
        self.rtmp_address = rtmp_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rtmp_address is not None:
            result['RtmpAddress'] = self.rtmp_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RtmpAddress') is not None:
            self.rtmp_address = m.get('RtmpAddress')
        return self


class CreateRoomRealTimeStreamAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRoomRealTimeStreamAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRoomRealTimeStreamAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRtcAsrTaskRequest(TeaModel):
    def __init__(
        self,
        auth_key: str = None,
        auto_terminate_delay: int = None,
        auto_terminate_enabled: bool = None,
        callback_url: str = None,
        channel_id: str = None,
        language: str = None,
        mode: str = None,
        owner_id: int = None,
        region_id: str = None,
        report_interval: int = None,
        rtc_user_id: str = None,
        sdkapp_id: str = None,
        stream_url: str = None,
        target_languages: str = None,
        translate_enabled: bool = None,
    ):
        # The AuthKey that is used to generate the MD5 signature in callbacks.
        self.auth_key = auth_key
        # The maximum latency at which the task is automatically stopped. Unit: seconds. Valid values: 1 to 10.
        self.auto_terminate_delay = auto_terminate_delay
        # Specifies whether to automatically stop the task when the latency exceeds the specified limit. Default value: false.
        self.auto_terminate_enabled = auto_terminate_enabled
        # The callback URL.
        # 
        # This parameter is required.
        self.callback_url = callback_url
        # The ID of the channel.
        # 
        # >  This parameter is required and takes effect only if you set the Mode parameter to rtc.
        self.channel_id = channel_id
        # The source language of the audio. Valid values:
        # 
        # *   ja: Japanese
        # *   yue: Cantonese
        # *   fspk: mixed Mandarin and English
        # *   en: English
        # *   cn: Mandarin
        # 
        # This parameter is required.
        self.language = language
        # The type of the stream. Valid values: live and rtc. The value live specifies a regular live stream, such as a Real-Time Messaging Protocol (RTMP) stream.
        # 
        # This parameter is required.
        self.mode = mode
        self.owner_id = owner_id
        self.region_id = region_id
        # The interval at which callbacks are returned. Unit: milliseconds. Valid values: -1 and 0 to 500.
        # 
        # *   \\-1: accepts callbacks only for whole sentences, but not for incomplete sentences.
        # *   0 or an empty value: returns callbacks in real time.
        # *   A value that is greater than 0 and less than or equal to 500: returns callbacks at the specified interval.
        self.report_interval = report_interval
        # The ID of the user who ingests the stream.
        # 
        # >  This parameter is required and takes effect only if you set the Mode parameter to rtc. You can specify only one user ID.
        self.rtc_user_id = rtc_user_id
        # The ID of the ApsaraVideo Real-time Communication (ARTC) application.
        # 
        # >  This parameter is required and takes effect only if you set the Mode parameter to rtc.
        self.sdkapp_id = sdkapp_id
        # The URL of the live stream.
        # 
        # >  This parameter is required and takes effect only if you set the Mode parameter to live.
        self.stream_url = stream_url
        # The language into which the subtitles are translated. Valid values:
        # 
        # *   cn: Chinese
        # *   en: English
        # *   ja: Japanese
        self.target_languages = target_languages
        # Specifies whether to enable the translation feature.
        self.translate_enabled = translate_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.auto_terminate_delay is not None:
            result['AutoTerminateDelay'] = self.auto_terminate_delay
        if self.auto_terminate_enabled is not None:
            result['AutoTerminateEnabled'] = self.auto_terminate_enabled
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.channel_id is not None:
            result['ChannelID'] = self.channel_id
        if self.language is not None:
            result['Language'] = self.language
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.report_interval is not None:
            result['ReportInterval'] = self.report_interval
        if self.rtc_user_id is not None:
            result['RtcUserId'] = self.rtc_user_id
        if self.sdkapp_id is not None:
            result['SDKAppID'] = self.sdkapp_id
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.target_languages is not None:
            result['TargetLanguages'] = self.target_languages
        if self.translate_enabled is not None:
            result['TranslateEnabled'] = self.translate_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('AutoTerminateDelay') is not None:
            self.auto_terminate_delay = m.get('AutoTerminateDelay')
        if m.get('AutoTerminateEnabled') is not None:
            self.auto_terminate_enabled = m.get('AutoTerminateEnabled')
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('ChannelID') is not None:
            self.channel_id = m.get('ChannelID')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReportInterval') is not None:
            self.report_interval = m.get('ReportInterval')
        if m.get('RtcUserId') is not None:
            self.rtc_user_id = m.get('RtcUserId')
        if m.get('SDKAppID') is not None:
            self.sdkapp_id = m.get('SDKAppID')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TargetLanguages') is not None:
            self.target_languages = m.get('TargetLanguages')
        if m.get('TranslateEnabled') is not None:
            self.translate_enabled = m.get('TranslateEnabled')
        return self


class CreateRtcAsrTaskResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
        task_id: str = None,
    ):
        # The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.
        self.ret_code = ret_code
        # The ID of the task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateRtcAsrTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRtcAsrTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRtcAsrTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRtcMPUEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_ids: str = None,
    ):
        # The ID of the application.
        # 
        # > The ID can be up to 64 characters in length and can contain letters, digits, underscores, and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The callback URL.
        # 
        # > The callback URL can be up to 2,083 characters in length. You can use headers such as HTTP and HTTPS in callback URLs. The URL can contain letters, digits, and the following special characters: - _ ? % = # . / +\
        # 
        # This parameter is required.
        self.callback_url = callback_url
        # The ID of the channel to which you want to send mixed-stream relay event callbacks. Separate multiple channel IDs with commas (,).
        # 
        # > 
        # 
        # *   If you leave this parameter empty, you are subscribed to mixed-stream relay events of all channels in the application.
        # 
        # *   You cannot specify duplicate channel IDs. You can specify up to 20 channel IDs in each call.
        # 
        # *   The ID can be up to 64 characters in length and contain letters, digits, underscores (_), and hyphens (-).
        self.channel_ids = channel_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        return self


class CreateRtcMPUEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sub_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the subscription.
        self.sub_id = sub_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        return self


class CreateRtcMPUEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRtcMPUEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRtcMPUEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to add input sources, layouts, components, or an episode list to the production studio or query the layouts of the production studio.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterComponentRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The component ID. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.
        # 
        # This parameter is required.
        self.component_id = component_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterComponentResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can use the ID as a request parameter in the API operation that is called to query the components in the production studio, add an episode list to the production studio, or modify a component in the production studio.
        self.caster_id = caster_id
        # The component ID. You can use the ID as a request parameter in the API operation that is called to query the component in the production studio or modify the component in the production studio.
        self.component_id = component_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterComponentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterComponentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterComponentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterEpisodeRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episode_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the episode. If the episode was added by calling the [AddCasterEpisode](https://help.aliyun.com/document_detail/2848068.html) operation, check the value of the response parameter EpisodeId to obtain the ID.
        # 
        # This parameter is required.
        self.episode_id = episode_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterEpisodeResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episode_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can specify the ID as a parameter in the request to modify the episode in the production studio.
        self.caster_id = caster_id
        # The ID of the episode. You can specify the ID as a parameter in the request to modify the episode in the production studio.
        self.episode_id = episode_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterEpisodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterEpisodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterEpisodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterEpisodeGroupRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_id: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was added by calling the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterEpisodeGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterEpisodeGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterEpisodeGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterEpisodeGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterLayoutRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the layout. If the layout was added by calling the [AddCasterLayout](https://help.aliyun.com/document_detail/60249.html) operation, check the value of the response parameter LayoutId to obtain the ID.
        # 
        # This parameter is required.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterLayoutResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        layout_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to modify a layout in the production studio, query layouts in the production studio, add a component in the production studio, or query components in the production studio.
        self.caster_id = caster_id
        # The ID of the layout. You can use the ID as a request parameter in the API operation that is used to query layouts in the production studio.
        self.layout_id = layout_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterProgramRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCasterProgramResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can specify the ID as a request parameter in the API operation that is used to add, delete, or modify episodes in the production studio.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterSceneConfigRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
        type: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This parameter is required.
        self.scene_id = scene_id
        # The type of the setting that you want to delete. Valid values:
        # 
        # *   **Component**: component setting
        # *   **Layout**: layout setting
        # *   **All**: component and layout settings
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteCasterSceneConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterSceneConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterSceneConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterSceneConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCasterVideoResourceRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        resource_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The resource ID. If the input source was added by calling the AddCasterVideoResource operation, check the value of the response parameter ResourceId to obtain the ID.
        # 
        # This parameter is required.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class DeleteCasterVideoResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCasterVideoResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCasterVideoResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCasterVideoResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteChannelRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
    ):
        # The application ID. You can specify only one application ID.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class DeleteChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        template: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the template that you want to delete. The value is a string.
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class DeleteCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        job_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the edge transcoding task.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        subscribe_id: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.
        # 
        # This parameter is required.
        self.subscribe_id = subscribe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        return self


class DeleteEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAIProduceRulesRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        rules_id: str = None,
        suffix_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the subtitle rule.
        self.rules_id = rules_id
        # The suffix of the subtitle rule.
        # 
        # >  Set the value to the name of the subtitle template.
        self.suffix_name = suffix_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        if self.suffix_name is not None:
            result['SuffixName'] = self.suffix_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        if m.get('SuffixName') is not None:
            self.suffix_name = m.get('SuffixName')
        return self


class DeleteLiveAIProduceRulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAIProduceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAIProduceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAIProduceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAIStudioRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        studio_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the template. You can obtain the ID from the response to the CreateLiveAIStudio operation.
        # 
        # This parameter is required.
        self.studio_id = studio_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_id is not None:
            result['StudioId'] = self.studio_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioId') is not None:
            self.studio_id = m.get('StudioId')
        return self


class DeleteLiveAIStudioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAIStudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAIStudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAIStudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAISubtitleRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the subtitle template.
        # 
        # This parameter is required.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.
        self.subtitle_name = subtitle_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        return self


class DeleteLiveAISubtitleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAISubtitleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAISubtitleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAISubtitleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAppRecordConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveAppRecordConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAppRecordConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAppRecordConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAppRecordConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAppSnapshotConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveAppSnapshotConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAppSnapshotConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAppSnapshotConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAppSnapshotConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAudioAuditConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # >  A value of asterisk (\\*) specifies all applications under the domain name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream.
        # 
        # >  A value of asterisk (\\*) specifies all live streams in the application.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveAudioAuditConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAudioAuditConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAudioAuditConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAudioAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveAudioAuditNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveAudioAuditNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveAudioAuditNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveAudioAuditNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveAudioAuditNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveCenterTransferRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        dst_url: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The third-party URL to which the live stream is relayed.
        self.dst_url = dst_url
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveCenterTransferResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveCenterTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveCenterTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveCenterTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveDelayConfigRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.
        # 
        # This parameter is required.
        self.app = app
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.
        # 
        # This parameter is required.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DeleteLiveDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveDetectNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveDetectNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveDetectNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveDetectNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveDetectNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_account: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ingest domain or streaming domain that you want to delete.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_account = owner_account
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveDomainMappingRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        pull_domain: str = None,
        push_domain: str = None,
        security_token: str = None,
    ):
        self.owner_id = owner_id
        # The streaming domain. The type of the domain name is **liveVideo**.
        # 
        # This parameter is required.
        self.pull_domain = pull_domain
        # The ingest domain. The type of the domain name is **liveEdge**.
        # 
        # This parameter is required.
        self.push_domain = push_domain
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pull_domain is not None:
            result['PullDomain'] = self.pull_domain
        if self.push_domain is not None:
            result['PushDomain'] = self.push_domain
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PullDomain') is not None:
            self.pull_domain = m.get('PullDomain')
        if m.get('PushDomain') is not None:
            self.push_domain = m.get('PushDomain')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveDomainMappingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveDomainMappingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveDomainMappingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveDomainMappingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveDomainPlayMappingRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        play_domain: str = None,
        pull_domain: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The sub-streaming domain.
        # 
        # This parameter is required.
        self.play_domain = play_domain
        # The main streaming domain.
        # 
        # This parameter is required.
        self.pull_domain = pull_domain
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_domain is not None:
            result['PlayDomain'] = self.play_domain
        if self.pull_domain is not None:
            result['PullDomain'] = self.pull_domain
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayDomain') is not None:
            self.play_domain = m.get('PlayDomain')
        if m.get('PullDomain') is not None:
            self.pull_domain = m.get('PullDomain')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveDomainPlayMappingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveDomainPlayMappingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveDomainPlayMappingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveDomainPlayMappingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveEdgeTransferRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ingest domain. You can set only one stream relay configuration for an ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveEdgeTransferResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveEdgeTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveEdgeTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveEdgeTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveLazyPullStreamInfoConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # >  If you want to delete configurations of triggered stream pulling for all applications, set the value to **ali_all_app**.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveLazyPullStreamInfoConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveLazyPullStreamInfoConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveLazyPullStreamInfoConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveLazyPullStreamInfoConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        operator_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group that you want to delete.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the deletion operation. The ID can be up to 64 bytes in length and can contain only letters and digits.
        self.operator_id = operator_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        return self


class DeleteLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        request_id: str = None,
    ):
        # The ID of the deleted or non-existent group.
        self.group_id = group_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveMessageGroupMessageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        deleter_id: str = None,
        deleter_info: str = None,
        group_id: str = None,
        message_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the user who deletes the message. The ID must be up to 64 bytes in length and can contain letters and digits.
        self.deleter_id = deleter_id
        # The additional information about the user who performs the deletion operation. The value can be up to 512 bytes in length.
        self.deleter_info = deleter_info
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the message that you want to delete. Set this parameter to the value of MsgTid that you specified when you called the SendLiveMessageGroup operation. The ID must be up to 64 bytes in length and can contain letters and digits.
        # 
        # This parameter is required.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.deleter_id is not None:
            result['DeleterId'] = self.deleter_id
        if self.deleter_info is not None:
            result['DeleterInfo'] = self.deleter_info
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('DeleterId') is not None:
            self.deleter_id = m.get('DeleterId')
        if m.get('DeleterInfo') is not None:
            self.deleter_info = m.get('DeleterInfo')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class DeleteLiveMessageGroupMessageResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        message_id: str = None,
        request_id: str = None,
    ):
        # The group ID.
        self.group_id = group_id
        # The ID of the deleted or non-existent message.
        self.message_id = message_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveMessageGroupMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveMessageGroupMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveMessageGroupMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveMessageUserMessageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        deleter_id: str = None,
        deleter_info: str = None,
        message_id: str = None,
        receiver_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center where the interactive messaging application is deployed. Set this parameter to the value of DataCenter that you specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation. Valid values: cn-shanghai (Shanghai) and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the user who performs the deletion operation. The ID can contain only letters and digits and can be up to 64 bytes in length.
        self.deleter_id = deleter_id
        # The additional information about the user who performs the deletion operation. The value can be up to 512 bytes in length.
        self.deleter_info = deleter_info
        # The ID of the message that you want to delete. Set this parameter to the value of MsgTid that you specified when you called the SendLiveMessageUser operation. The ID can contain only letters and digits and can be up to 64 bytes in length.
        # 
        # This parameter is required.
        self.message_id = message_id
        # The ID of the user who received the message to delete. The ID can contain only letters and digits and can be up to 64 bytes in length.
        # 
        # This parameter is required.
        self.receiver_id = receiver_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.deleter_id is not None:
            result['DeleterId'] = self.deleter_id
        if self.deleter_info is not None:
            result['DeleterInfo'] = self.deleter_info
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.receiver_id is not None:
            result['ReceiverId'] = self.receiver_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('DeleterId') is not None:
            self.deleter_id = m.get('DeleterId')
        if m.get('DeleterInfo') is not None:
            self.deleter_info = m.get('DeleterInfo')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('ReceiverId') is not None:
            self.receiver_id = m.get('ReceiverId')
        return self


class DeleteLiveMessageUserMessageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveMessageUserMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveMessageUserMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveMessageUserMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePackageConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # App name, `*` matches all names.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Live streaming domain (primary playback domain).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # Live stream name, `*` matches all streams under AppName.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLivePackageConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePackageConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePackageConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePackageConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePrivateLineRequest(TeaModel):
    def __init__(
        self,
        acceleration_type: str = None,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The acceleration type. Valid values:
        # 
        # *   play: streaming acceleration
        # *   publish: stream ingest acceleration
        # 
        # This parameter is required.
        self.acceleration_type = acceleration_type
        # The name of the application.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceleration_type is not None:
            result['AccelerationType'] = self.acceleration_type
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccelerationType') is not None:
            self.acceleration_type = m.get('AccelerationType')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLivePrivateLineResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePrivateLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePrivateLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePrivateLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePullStreamInfoConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can call [DescribeLivePullStreamConfig](https://help.aliyun.com/document_detail/2847818.htmll) operation to query the application name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can call [DescribeLivePullStreamConfig](https://help.aliyun.com/document_detail/2847818.htmll) operation to query the stream name.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLivePullStreamInfoConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLivePullStreamInfoConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePullStreamInfoConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePullStreamInfoConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DeleteLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The error description.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The code that is returned for the request.
        # 
        # > 
        # 
        # *   0 is returned if the request is normal.
        # 
        # *   For information about codes that are returned when exceptions occur, see the following Error codes table.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class DeleteLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRealTimeLogLogstoreRequest(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        owner_id: int = None,
        project: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The name of the Logstore to which log entries are delivered.
        # 
        # This parameter is required.
        self.logstore = logstore
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery.
        # 
        # This parameter is required.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveRealTimeLogLogstoreResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRealTimeLogLogstoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRealTimeLogLogstoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRealTimeLogLogstoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        logstore: str = None,
        owner_id: int = None,
        project: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The streaming domain.
        # 
        # Separate multiple streaming domains with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the Logstore to which log entries are delivered.
        # 
        # This parameter is required.
        self.logstore = logstore
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery.
        # 
        # This parameter is required.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRecordNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveRecordNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRecordNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRecordNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRecordNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveRecordVodConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveRecordVodConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveRecordVodConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveRecordVodConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveRecordVodConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveSnapshotDetectPornConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs. You can call the [DescribeLiveSnapshotDetectPornConfig](https://help.aliyun.com/document_detail/2847918.html) operation to query the application name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveSnapshotDetectPornConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveSnapshotDetectPornConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveSnapshotDetectPornConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveSnapshotDetectPornConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveSnapshotNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveSnapshotNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveSnapshotNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveSnapshotNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveSnapshotNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveSpecificStagingConfigRequest(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ID of the configuration that you want to delete. If you want to specify multiple IDs, separate them with commas (,). You can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
        # 
        # This parameter is required.
        self.config_id = config_id
        # The accelerated domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DeleteLiveSpecificStagingConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveSpecificStagingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveSpecificStagingConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveSpecificStagingConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamBlockRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveStreamBlockResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The result description. If the request was successful, ok is returned. If the request failed, the failure detail is returned.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The status. Valid values:
        # 
        # *   ok: The request was successful.
        # *   fail: The request failed.
        # 
        # >  If any parameter failed to be configured, the request failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DeleteLiveStreamBlockResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamBlockResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamBlockResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamMergeRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application that generates the output stream. You can view the application name on the [Primary/Secondary Stream Mixing](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the output stream. You can view the stream name on the [Primary/Secondary Stream Mixing](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveStreamMergeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamMergeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamMergeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamMergeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamMonitorRequest(TeaModel):
    def __init__(
        self,
        monitor_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the monitoring session.
        # 
        # >  You can obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        # 
        # This parameter is required.
        self.monitor_id = monitor_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveStreamMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamRecordIndexFilesRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        record_id: List[str] = None,
        region_id: str = None,
        remove_file: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The name of the main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The index file IDs.
        # 
        # This parameter is required.
        self.record_id = record_id
        self.region_id = region_id
        # Specifies whether to delete the corresponding file in Object Storage Service (OSS) synchronously. Valid values:
        # 
        # *   **true**: The corresponding file in OSS is deleted.
        # *   **false**: The corresponding file in OSS is not deleted.
        # 
        # This parameter is required.
        self.remove_file = remove_file
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_file is not None:
            result['RemoveFile'] = self.remove_file
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveFile') is not None:
            self.remove_file = m.get('RemoveFile')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo(TeaModel):
    def __init__(
        self,
        message: str = None,
        record_id: str = None,
    ):
        # The processing result of each file indicated by the file ID. Valid values:
        # 
        # *   **OK**: The file has been deleted.
        # *   **AccessDenied**: Access to the file has been denied.
        # *   **FileNotFound**: The file fails to be found.
        self.message = message
        # The ID of the index file that is used to locate the live stream recording files to be deleted.
        self.record_id = record_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        return self


class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList(TeaModel):
    def __init__(
        self,
        record_delete_info: List[DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo] = None,
    ):
        self.record_delete_info = record_delete_info

    def validate(self):
        if self.record_delete_info:
            for k in self.record_delete_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordDeleteInfo'] = []
        if self.record_delete_info is not None:
            for k in self.record_delete_info:
                result['RecordDeleteInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_delete_info = []
        if m.get('RecordDeleteInfo') is not None:
            for k in m.get('RecordDeleteInfo'):
                temp_model = DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo()
                self.record_delete_info.append(temp_model.from_map(k))
        return self


class DeleteLiveStreamRecordIndexFilesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        record_delete_info_list: DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList = None,
        request_id: str = None,
    ):
        # The status code. A return value of 500 indicates an error. For details, see the Error codes section of this topic.
        self.code = code
        # The status description. A return value of 500 indicates an error. For details, see the Error codes section of this topic.
        self.message = message
        # The deletion information.
        self.record_delete_info_list = record_delete_info_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.record_delete_info_list:
            self.record_delete_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.record_delete_info_list is not None:
            result['RecordDeleteInfoList'] = self.record_delete_info_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RecordDeleteInfoList') is not None:
            temp_model = DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList()
            self.record_delete_info_list = temp_model.from_map(m['RecordDeleteInfoList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamRecordIndexFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamRecordIndexFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamRecordIndexFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        security_token: str = None,
        template: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.security_token = security_token
        # The transcoding template ID. Valid values:
        # 
        # *   Standard transcoding:
        # 
        #     *   lld: low definition
        #     *   lsd: standard definition
        #     *   lhd: high definition
        #     *   lud : ultra-high definition
        # 
        # *   Narrowband HD transcoding:
        # 
        #     *   ld: low definition
        #     *   sd: standard definition
        #     *   hd: high definition
        #     *   ud: ultra-high definition
        # 
        # *   Custom transcoding: a custom ID
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class DeleteLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamWatermarkRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        template_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the watermark template.
        # 
        # >  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteLiveStreamWatermarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamWatermarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamWatermarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamWatermarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamWatermarkRuleRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        rule_id: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the watermark rule.
        # 
        # >  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.
        self.rule_id = rule_id
        # The name of the stream. The following matching rules apply:
        # 
        # *   A stream name can be exactly matched, Example: liveStreamA.
        # *   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
        # *   You can place the asterisk before or after an approximate string.
        # 
        # > 
        # 
        # *   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).
        # 
        # *   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DeleteLiveStreamWatermarkRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamWatermarkRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamWatermarkRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamWatermarkRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveStreamsNotifyUrlConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLiveStreamsNotifyUrlConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveStreamsNotifyUrlConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLiveStreamsNotifyUrlConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveStreamsNotifyUrlConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the interactive messaging application that you want to delete. You can specify only one ID.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the application was deleted. Valid values:
        # 
        # *   true: The application was deleted.
        # *   false: The application failed to be deleted.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: DeleteMessageAppResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = DeleteMessageAppResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class DeleteMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMixStreamRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        mix_stream_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.
        # 
        # This parameter is required.
        self.mix_stream_id = mix_stream_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the output stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteMixStreamResponseBody(TeaModel):
    def __init__(
        self,
        mix_stream_id: str = None,
        request_id: str = None,
    ):
        # The ID of the stream mixing task.
        self.mix_stream_id = mix_stream_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMixStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMixStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMixStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePlaylistRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_id: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeletePlaylistResponseBody(TeaModel):
    def __init__(
        self,
        program_id: str = None,
        request_id: str = None,
    ):
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to query the information about the episode list, start the episode list, or stop the episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePlaylistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePlaylistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePlaylistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePlaylistItemsRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_id: str = None,
        program_item_ids: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        # The IDs of the episodes that you want to remove.
        # 
        # This parameter is required.
        self.program_item_ids = program_item_ids
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_item_ids is not None:
            result['ProgramItemIds'] = self.program_item_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramItemIds') is not None:
            self.program_item_ids = m.get('ProgramItemIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeletePlaylistItemsResponseBody(TeaModel):
    def __init__(
        self,
        program_id: str = None,
        request_id: str = None,
    ):
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to query the episodes in the episode list, edit the episode list, delete the episode list, query the information about the episode list, or stop the episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePlaylistItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePlaylistItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePlaylistItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRtcAsrTaskRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The task ID. You can obtain the ID from the response to the [CreateRtcAsrTask](https://help.aliyun.com/document_detail/2848217.html) operation.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DeleteRtcAsrTaskResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class DeleteRtcAsrTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRtcAsrTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRtcAsrTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRtcMPUEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the application.
        # 
        # >  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DeleteRtcMPUEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRtcMPUEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRtcMPUEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRtcMPUEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotCallbackAuthRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteSnapshotCallbackAuthResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnapshotCallbackAuthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSnapshotCallbackAuthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotCallbackAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotFilesRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        create_timestamp_list: List[int] = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        remove_file: bool = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The timestamps when the snapshots that you want to delete were captured.
        # 
        # This parameter is required.
        self.create_timestamp_list = create_timestamp_list
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # Specifies whether to also delete the corresponding file in Object Storage Service (OSS) at the same time. Value values:
        # 
        # *   **true**: deletes the corresponding file in OSS.
        # *   **false**: does not delete the corresponding file in OSS.
        # 
        # >  To delete the corresponding file in OSS, you must have the permissions on the OSS bucket.
        # 
        # This parameter is required.
        self.remove_file = remove_file
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_timestamp_list is not None:
            result['CreateTimestampList'] = self.create_timestamp_list
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_file is not None:
            result['RemoveFile'] = self.remove_file
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTimestampList') is not None:
            self.create_timestamp_list = m.get('CreateTimestampList')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveFile') is not None:
            self.remove_file = m.get('RemoveFile')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo(TeaModel):
    def __init__(
        self,
        create_timestamp: int = None,
        message: str = None,
    ):
        # The timestamp when the snapshot was captured. Unit: milliseconds.
        self.create_timestamp = create_timestamp
        # The processing result of the snapshot. Valid values:
        # 
        # *   **OK**: The snapshot was deleted.
        # *   **FileNotFound**: The snapshot was not found.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList(TeaModel):
    def __init__(
        self,
        snapshot_delete_info: List[DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo] = None,
    ):
        self.snapshot_delete_info = snapshot_delete_info

    def validate(self):
        if self.snapshot_delete_info:
            for k in self.snapshot_delete_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotDeleteInfo'] = []
        if self.snapshot_delete_info is not None:
            for k in self.snapshot_delete_info:
                result['SnapshotDeleteInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot_delete_info = []
        if m.get('SnapshotDeleteInfo') is not None:
            for k in m.get('SnapshotDeleteInfo'):
                temp_model = DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo()
                self.snapshot_delete_info.append(temp_model.from_map(k))
        return self


class DeleteSnapshotFilesResponseBody(TeaModel):
    def __init__(
        self,
        failure_count: int = None,
        request_id: str = None,
        snapshot_delete_info_list: DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList = None,
        success_count: int = None,
    ):
        # The number of snapshots that failed to be deleted.
        self.failure_count = failure_count
        # The request ID.
        self.request_id = request_id
        # The information about the snapshots.
        self.snapshot_delete_info_list = snapshot_delete_info_list
        # The number of successful screenshot deletions.
        self.success_count = success_count

    def validate(self):
        if self.snapshot_delete_info_list:
            self.snapshot_delete_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failure_count is not None:
            result['FailureCount'] = self.failure_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_delete_info_list is not None:
            result['SnapshotDeleteInfoList'] = self.snapshot_delete_info_list.to_map()
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailureCount') is not None:
            self.failure_count = m.get('FailureCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotDeleteInfoList') is not None:
            temp_model = DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList()
            self.snapshot_delete_info_list = temp_model.from_map(m['SnapshotDeleteInfoList'])
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        return self


class DeleteSnapshotFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSnapshotFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStudioLayoutRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the layout. If the layout was added by calling the [AddStudioLayout](https://help.aliyun.com/document_detail/2848062.html) operation, check the value of the response parameter LayoutId to obtain the ID.
        # 
        # This parameter is required.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteStudioLayoutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStudioLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStudioLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStudioLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoShowListTasksRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio for which you want to query scheduled tasks.
        # 
        # >  If the scheduled tasks were created by calling the [InitializeAutoShowListTask](https://help.aliyun.com/document_detail/2848056.html) operation, check the value of the response parameter CasterId to obtain the ID. If you do not specify this parameter, the system queries all the scheduled tasks that belong to the user specified by the OwnerId parameter.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeAutoShowListTasksResponseBody(TeaModel):
    def __init__(
        self,
        auto_show_list_tasks: str = None,
        request_id: str = None,
    ):
        # The information about the scheduled tasks. The following fields are included:
        # 
        # *   Status: the status of the scheduled task. Valid values: 0 and 1. A value of 0 indicates that the scheduled task is paused. A value of 1 indicates that the scheduled task is started.
        # *   LiveTemplate: the transcoding templates.
        # *   TranscodeConfig: the transcoding configuration for the source URL.
        # *   CasterId: the ID of the production studio.
        self.auto_show_list_tasks = auto_show_list_tasks
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_show_list_tasks is not None:
            result['AutoShowListTasks'] = self.auto_show_list_tasks
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoShowListTasks') is not None:
            self.auto_show_list_tasks = m.get('AutoShowListTasks')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAutoShowListTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAutoShowListTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoShowListTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterChannelsRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterChannelsResponseBodyChannelsChannel(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        face_beauty: str = None,
        resource_id: str = None,
        rtmp_url: str = None,
        stream_url: str = None,
    ):
        # The ID of the channel.
        # 
        # The layout references the channel ID when the channel is enabled. You can specify up to one video resource for the channel. The value of this parameter must be in the RV[Number] format, such as RV01 and RV12.
        self.channel_id = channel_id
        # The face retouching effect. Valid values: 0 (all effects), 1 (skin smoothing), 2 (skin whitening), 3 (dark circles removal), and 4 (nasolabial folds removal).
        self.face_beauty = face_beauty
        # The ID of the video resource.
        self.resource_id = resource_id
        # The URL in the Real-Time Messaging Protocol (RTMP) format.
        self.rtmp_url = rtmp_url
        # The URL of the output content in the channel.
        self.stream_url = stream_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.face_beauty is not None:
            result['FaceBeauty'] = self.face_beauty
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.rtmp_url is not None:
            result['RtmpUrl'] = self.rtmp_url
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('FaceBeauty') is not None:
            self.face_beauty = m.get('FaceBeauty')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('RtmpUrl') is not None:
            self.rtmp_url = m.get('RtmpUrl')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class DescribeCasterChannelsResponseBodyChannels(TeaModel):
    def __init__(
        self,
        channel: List[DescribeCasterChannelsResponseBodyChannelsChannel] = None,
    ):
        self.channel = channel

    def validate(self):
        if self.channel:
            for k in self.channel:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Channel'] = []
        if self.channel is not None:
            for k in self.channel:
                result['Channel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel = []
        if m.get('Channel') is not None:
            for k in m.get('Channel'):
                temp_model = DescribeCasterChannelsResponseBodyChannelsChannel()
                self.channel.append(temp_model.from_map(k))
        return self


class DescribeCasterChannelsResponseBody(TeaModel):
    def __init__(
        self,
        channels: DescribeCasterChannelsResponseBodyChannels = None,
        request_id: str = None,
        total: int = None,
    ):
        # The channels.
        self.channels = channels
        # The request ID.
        self.request_id = request_id
        # The total number of channels.
        self.total = total

    def validate(self):
        if self.channels:
            self.channels.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channels') is not None:
            temp_model = DescribeCasterChannelsResponseBodyChannels()
            self.channels = temp_model.from_map(m['Channels'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterChannelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterChannelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterChannelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterComponentsRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The component ID. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.
        self.component_id = component_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent(TeaModel):
    def __init__(
        self,
        border_color: str = None,
        border_width_normalized: float = None,
        color: str = None,
        font_name: str = None,
        line_space_normalized: float = None,
        location_id: str = None,
        pts_offset: int = None,
        show_source_lan: bool = None,
        size_normalized: float = None,
        source_lan: str = None,
        target_lan: str = None,
        word_count_per_line: int = None,
        word_space_normalized: float = None,
        words_count: int = None,
    ):
        # The color of the text border.
        # 
        # Valid values: **0x000000 to 0xffffff**. If the value of this parameter is "", this parameter does not take effect.
        self.border_color = border_color
        # The normalized value of the width of the text border. The value of this parameter equals the border width divided by the font size.
        # 
        # The maximum width of the text border is **16**, even if the border width calculated based on this parameter is greater than **16**.
        self.border_width_normalized = border_width_normalized
        # The color of the text. Valid values: **0x000000 to 0xffffff**.
        self.color = color
        # The font of the text, which is specified by the system. Valid values:
        # 
        # *   **KaiTi**\
        # *   **AlibabaPuHuiTi-Regular**\
        # *   **AlibabaPuHuiTi-Bold**\
        # *   **NAlibabaPuHuiTi-Light**\
        # *   **NotoSansHans-Regular**\
        # *   **NotoSansHans-Bold**\
        # *   **NotoSansHans-Light**\
        # 
        # ****\
        self.font_name = font_name
        # The line spacing, which indicates the interval between every two lines.
        self.line_space_normalized = line_space_normalized
        # The location ID of the component. If the value of the ComponentType parameter is caption, the LocationId parameter indicates the channel ID of the video source that is referenced by the component.
        self.location_id = location_id
        # The offset between the presentation timestamps (PTS) of the subtitles and the audio.
        # 
        # Valid values: **-10000 to 10000**. Default value: **0**.
        self.pts_offset = pts_offset
        # Indicates whether the source language of the subtitles is displayed. Valid values:
        # 
        # *   **true**: The source language is displayed.
        # *   **false**: The source language is not displayed.
        self.show_source_lan = show_source_lan
        # The normalized value of the font size of the subtitles. The value of this parameter equals the font size divided by the output height.``
        # 
        # The maximum font size of the subtitles is **1,024**, even if the font size calculated based on this parameter is greater than **1,024**. If the value of this parameter is **-1**, this parameter does not take effect.
        self.size_normalized = size_normalized
        # The source language of the audio in the video source. Valid values:
        # 
        # *   **en**: English
        # *   **cn**: Chinese
        # *   **es**: Spanish
        # *   **ru**: Russian
        self.source_lan = source_lan
        # The target language of the audio in the video source. Valid values:
        # 
        # *   **en**: English
        # *   **cn**: Chinese
        # *   **es**: Spanish
        # *   **ru**: Russian
        self.target_lan = target_lan
        # The maximum number of words displayed in each line.
        self.word_count_per_line = word_count_per_line
        # The word spacing, which indicates the interval between every two words.
        self.word_space_normalized = word_space_normalized
        # The number of words displayed on the component. The value of this parameter can be specified based on the font size.
        # 
        # Valid values: **10 to 50**.
        self.words_count = words_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.color is not None:
            result['Color'] = self.color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.line_space_normalized is not None:
            result['LineSpaceNormalized'] = self.line_space_normalized
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.pts_offset is not None:
            result['PtsOffset'] = self.pts_offset
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.size_normalized is not None:
            result['SizeNormalized'] = self.size_normalized
        if self.source_lan is not None:
            result['SourceLan'] = self.source_lan
        if self.target_lan is not None:
            result['TargetLan'] = self.target_lan
        if self.word_count_per_line is not None:
            result['WordCountPerLine'] = self.word_count_per_line
        if self.word_space_normalized is not None:
            result['WordSpaceNormalized'] = self.word_space_normalized
        if self.words_count is not None:
            result['WordsCount'] = self.words_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('LineSpaceNormalized') is not None:
            self.line_space_normalized = m.get('LineSpaceNormalized')
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('PtsOffset') is not None:
            self.pts_offset = m.get('PtsOffset')
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SizeNormalized') is not None:
            self.size_normalized = m.get('SizeNormalized')
        if m.get('SourceLan') is not None:
            self.source_lan = m.get('SourceLan')
        if m.get('TargetLan') is not None:
            self.target_lan = m.get('TargetLan')
        if m.get('WordCountPerLine') is not None:
            self.word_count_per_line = m.get('WordCountPerLine')
        if m.get('WordSpaceNormalized') is not None:
            self.word_space_normalized = m.get('WordSpaceNormalized')
        if m.get('WordsCount') is not None:
            self.words_count = m.get('WordsCount')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds(TeaModel):
    def __init__(
        self,
        position: List[float] = None,
    ):
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer(TeaModel):
    def __init__(
        self,
        height_normalized: float = None,
        position_normalizeds: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds = None,
        position_refer: str = None,
        transparency: int = None,
        width_normalized: float = None,
    ):
        # The normalized value for heights of the elements in the layer. The widths of the elements are proportionally scaled based on this parameter.
        # 
        # If the value of this parameter is **0**, the elements in the layer are not scaled.
        self.height_normalized = height_normalized
        # The normalized value of the position of the layer, in the format of `[x,y]`. Example: `[0,0]`.
        # 
        # >  The values of x and y need to be normalized.
        self.position_normalizeds = position_normalizeds
        # The reference coordinates of the layer. Valid values:
        # 
        # *   **topLeft**: the upper-left corner
        # *   **topRight**: the upper-right corner
        # *   **bottomLeft**: the lower-left corner
        # *   **bottomRight**: the lower-right corner
        self.position_refer = position_refer
        # The transparency of the layer. Valid values: 0 to 255.
        # 
        # A value of **0** indicates that the layer is completely transparent. A value of **255** indicates that the layer is completely opaque.
        self.transparency = transparency
        # The normalized value for widths of the elements in the layer. The heights of the elements are proportionally scaled based on this parameter. If the value of this parameter is **0**, the elements in the layer are not scaled.
        # 
        # >  This parameter conflicts with the HeightNormalized parameter. If both of them are specified, only the HeightNormalized parameter takes effect. If only one of them is specified, the latest specified value is used.
        self.width_normalized = width_normalized

    def validate(self):
        if self.position_normalizeds:
            self.position_normalizeds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_normalizeds is not None:
            result['PositionNormalizeds'] = self.position_normalizeds.to_map()
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.transparency is not None:
            result['Transparency'] = self.transparency
        if self.width_normalized is not None:
            result['WidthNormalized'] = self.width_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionNormalizeds') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds()
            self.position_normalizeds = temp_model.from_map(m['PositionNormalizeds'])
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('Transparency') is not None:
            self.transparency = m.get('Transparency')
        if m.get('WidthNormalized') is not None:
            self.width_normalized = m.get('WidthNormalized')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent(TeaModel):
    def __init__(
        self,
        material_id: str = None,
    ):
        # The ID of the material from the media library.
        self.material_id = material_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent(TeaModel):
    def __init__(
        self,
        border_color: str = None,
        border_width_normalized: float = None,
        color: str = None,
        font_name: str = None,
        size_normalized: float = None,
        text: str = None,
    ):
        # The color of the text border. Valid values: **0x000000 to 0xffffff**. If the value of this parameter is **""**, this parameter does not take effect.
        self.border_color = border_color
        # The normalized value of the width of the text border. The value of this parameter equals the border width divided by the font size.****\
        # 
        # The maximum width of the text border is **16**, even if the border width calculated based on this parameter is greater than **16**.
        self.border_width_normalized = border_width_normalized
        # The color of the text. Valid values: **0x000000 to 0xffffff**.
        self.color = color
        # The font of the text, which is specified by the system. Valid values:
        # 
        # *   **KaiTi**\
        # *   **AlibabaPuHuiTi-Regular**\
        # *   **AlibabaPuHuiTi-Bold**\
        # *   **NAlibabaPuHuiTi-Light**\
        # *   **NotoSansHans-Regular**\
        # *   **NotoSansHans-Bold**\
        # *   **NotoSansHans-Light**\
        # 
        # ****\
        self.font_name = font_name
        # The normalized value of the font size of the text.
        # 
        # The value of this parameter equals the font size divided by the output height.**** The maximum font size of the text is **1,024**, even if the font size calculated based on this parameter is greater than **1,024**. If the value of this parameter is **-1**, this parameter does not take effect.
        self.size_normalized = size_normalized
        # The content of the text.
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.color is not None:
            result['Color'] = self.color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.size_normalized is not None:
            result['SizeNormalized'] = self.size_normalized
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('SizeNormalized') is not None:
            self.size_normalized = m.get('SizeNormalized')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class DescribeCasterComponentsResponseBodyComponentsComponent(TeaModel):
    def __init__(
        self,
        caption_layer_content: DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent = None,
        component_id: str = None,
        component_layer: DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer = None,
        component_name: str = None,
        component_type: str = None,
        effect: str = None,
        image_layer_content: DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent = None,
        location_id: str = None,
        text_layer_content: DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent = None,
    ):
        # The information about the subtitle component.
        self.caption_layer_content = caption_layer_content
        # The component ID.
        self.component_id = component_id
        # The information about the component layer, such as the size and layout.
        self.component_layer = component_layer
        # The name of the component. By default, the name is the ID of the component.
        self.component_name = component_name
        # The type of the component. Valid values:
        # 
        # *   **text**: a text component
        # *   **image**: an image component
        # *   **caption**: a caption component
        self.component_type = component_type
        # The display effect for the component. Valid values:
        # 
        # *   **none**\
        # *   **animateH**: horizontal scrolling
        # *   **animateV**: vertical scrolling
        self.effect = effect
        # The information about the image component. This parameter is returned only for image components.
        self.image_layer_content = image_layer_content
        # The location ID of the component.
        # 
        # Each location ID can be assigned to only one component and must be in the RC[Number] format. The values of this parameter are in ascending order, for example, from RC01 to RC12.
        self.location_id = location_id
        # The information about the text component. This parameter is returned only for text components.
        self.text_layer_content = text_layer_content

    def validate(self):
        if self.caption_layer_content:
            self.caption_layer_content.validate()
        if self.component_layer:
            self.component_layer.validate()
        if self.image_layer_content:
            self.image_layer_content.validate()
        if self.text_layer_content:
            self.text_layer_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caption_layer_content is not None:
            result['CaptionLayerContent'] = self.caption_layer_content.to_map()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.component_layer is not None:
            result['ComponentLayer'] = self.component_layer.to_map()
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.image_layer_content is not None:
            result['ImageLayerContent'] = self.image_layer_content.to_map()
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.text_layer_content is not None:
            result['TextLayerContent'] = self.text_layer_content.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptionLayerContent') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent()
            self.caption_layer_content = temp_model.from_map(m['CaptionLayerContent'])
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('ComponentLayer') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer()
            self.component_layer = temp_model.from_map(m['ComponentLayer'])
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('ImageLayerContent') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent()
            self.image_layer_content = temp_model.from_map(m['ImageLayerContent'])
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('TextLayerContent') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent()
            self.text_layer_content = temp_model.from_map(m['TextLayerContent'])
        return self


class DescribeCasterComponentsResponseBodyComponents(TeaModel):
    def __init__(
        self,
        component: List[DescribeCasterComponentsResponseBodyComponentsComponent] = None,
    ):
        self.component = component

    def validate(self):
        if self.component:
            for k in self.component:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Component'] = []
        if self.component is not None:
            for k in self.component:
                result['Component'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.component = []
        if m.get('Component') is not None:
            for k in m.get('Component'):
                temp_model = DescribeCasterComponentsResponseBodyComponentsComponent()
                self.component.append(temp_model.from_map(k))
        return self


class DescribeCasterComponentsResponseBody(TeaModel):
    def __init__(
        self,
        components: DescribeCasterComponentsResponseBodyComponents = None,
        request_id: str = None,
        total: int = None,
    ):
        # The components.
        self.components = components
        # The request ID.
        self.request_id = request_id
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.components:
            self.components.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.components is not None:
            result['Components'] = self.components.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Components') is not None:
            temp_model = DescribeCasterComponentsResponseBodyComponents()
            self.components = temp_model.from_map(m['Components'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterComponentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterComponentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterConfigRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_oss_object_prefix: str = None,
    ):
        # The length of the recording.
        self.cycle_duration = cycle_duration
        # The format of the recording.
        self.format = format
        # The name of the recording.
        self.oss_object_prefix = oss_object_prefix
        # The name of the segment.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class DescribeCasterConfigResponseBodyRecordConfigRecordFormat(TeaModel):
    def __init__(
        self,
        record_format: List[DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat] = None,
    ):
        self.record_format = record_format

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        return self


class DescribeCasterConfigResponseBodyRecordConfig(TeaModel):
    def __init__(
        self,
        on_demand: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        record_format: DescribeCasterConfigResponseBodyRecordConfigRecordFormat = None,
    ):
        # On-demand recording. Values:
        # - 0: Off. 
        # - 1: Via HTTP callback. 
        # - 2: Parse streaming parameters for on-demand recording. 
        # - 7: Default to not record.
        self.on_demand = on_demand
        # The OSS bucket for storage.
        self.oss_bucket = oss_bucket
        # The Object Storage Service (OSS) endpoint.
        self.oss_endpoint = oss_endpoint
        # The recording configuration.
        self.record_format = record_format

    def validate(self):
        if self.record_format:
            self.record_format.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.record_format is not None:
            result['RecordFormat'] = self.record_format.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('RecordFormat') is not None:
            temp_model = DescribeCasterConfigResponseBodyRecordConfigRecordFormat()
            self.record_format = temp_model.from_map(m['RecordFormat'])
        return self


class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds(TeaModel):
    def __init__(
        self,
        resource_id: List[str] = None,
    ):
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup(TeaModel):
    def __init__(
        self,
        host_resource_id: str = None,
        mode: int = None,
        resource_ids: DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds = None,
    ):
        # The ID of the resource in the production studio.
        self.host_resource_id = host_resource_id
        # The cache mode of the Static Page Caching policy. Valid values:
        # 
        # *   0: standard mode
        # *   1: force mode
        # *   2: no cache
        self.mode = mode
        # The IDs of the resources for which you want to modify the resource group. The number of resource IDs is 1 to 50.
        self.resource_ids = resource_ids

    def validate(self):
        if self.resource_ids:
            self.resource_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_resource_id is not None:
            result['HostResourceId'] = self.host_resource_id
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HostResourceId') is not None:
            self.host_resource_id = m.get('HostResourceId')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ResourceIds') is not None:
            temp_model = DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds()
            self.resource_ids = temp_model.from_map(m['ResourceIds'])
        return self


class DescribeCasterConfigResponseBodySyncGroupsConfig(TeaModel):
    def __init__(
        self,
        sync_group: List[DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup] = None,
    ):
        self.sync_group = sync_group

    def validate(self):
        if self.sync_group:
            for k in self.sync_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SyncGroup'] = []
        if self.sync_group is not None:
            for k in self.sync_group:
                result['SyncGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sync_group = []
        if m.get('SyncGroup') is not None:
            for k in m.get('SyncGroup'):
                temp_model = DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup()
                self.sync_group.append(temp_model.from_map(k))
        return self


class DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        fps: int = None,
        height: int = None,
        width: int = None,
    ):
        # The video bitrate.
        self.bitrate = bitrate
        # The video frame rate.
        self.fps = fps
        # The video height. Unit: pixels.
        self.height = height
        # The video width. Unit: pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.fps is not None:
            result['fps'] = self.fps
        if self.height is not None:
            result['height'] = self.height
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('fps') is not None:
            self.fps = m.get('fps')
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class DescribeCasterConfigResponseBodyTranscodeConfigCustomParams(TeaModel):
    def __init__(
        self,
        video: DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo = None,
    ):
        # The video parameters.
        self.video = video

    def validate(self):
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.video is not None:
            result['video'] = self.video.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('video') is not None:
            temp_model = DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo()
            self.video = temp_model.from_map(m['video'])
        return self


class DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds(TeaModel):
    def __init__(
        self,
        location_id: List[str] = None,
    ):
        self.location_id = location_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        return self


class DescribeCasterConfigResponseBodyTranscodeConfig(TeaModel):
    def __init__(
        self,
        caster_template: str = None,
        custom_params: DescribeCasterConfigResponseBodyTranscodeConfigCustomParams = None,
        live_template_ids: DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds = None,
    ):
        # The transcoding template of the production studio. Valid values:
        # 
        # *   **lp_ld**: low definition
        # *   **lp_sd**: standard definition
        # *   **lp_hd**: high definition
        # *   **lp_ud**: ultra high definition
        # *   **lp_ld_v**: low definition (portrait mode)
        # *   **lp_sd_v**: standard definition (portrait mode)
        # *   **lp_hd_v**: high definition (portrait mode)
        # *   **lp_ud_v**: ultra high definition (portrait mode)
        self.caster_template = caster_template
        # The custom settings.
        self.custom_params = custom_params
        # The transcoding setting for live streams.
        self.live_template_ids = live_template_ids

    def validate(self):
        if self.custom_params:
            self.custom_params.validate()
        if self.live_template_ids:
            self.live_template_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_template is not None:
            result['CasterTemplate'] = self.caster_template
        if self.custom_params is not None:
            result['CustomParams'] = self.custom_params.to_map()
        if self.live_template_ids is not None:
            result['LiveTemplateIds'] = self.live_template_ids.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterTemplate') is not None:
            self.caster_template = m.get('CasterTemplate')
        if m.get('CustomParams') is not None:
            temp_model = DescribeCasterConfigResponseBodyTranscodeConfigCustomParams()
            self.custom_params = temp_model.from_map(m['CustomParams'])
        if m.get('LiveTemplateIds') is not None:
            temp_model = DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds()
            self.live_template_ids = temp_model.from_map(m['LiveTemplateIds'])
        return self


class DescribeCasterConfigResponseBody(TeaModel):
    def __init__(
        self,
        auto_switch_urgent_config: str = None,
        auto_switch_urgent_on: str = None,
        callback_url: str = None,
        caster_id: str = None,
        caster_name: str = None,
        channel_enable: int = None,
        delay: float = None,
        domain_name: str = None,
        program_effect: int = None,
        program_name: str = None,
        record_config: DescribeCasterConfigResponseBodyRecordConfig = None,
        request_id: str = None,
        side_output_url: str = None,
        side_output_url_list: str = None,
        sync_groups_config: DescribeCasterConfigResponseBodySyncGroupsConfig = None,
        transcode_config: DescribeCasterConfigResponseBodyTranscodeConfig = None,
        urgent_image_id: str = None,
        urgent_image_url: str = None,
        urgent_live_stream_url: str = None,
        urgent_material_id: str = None,
    ):
        # The configuration for automatic switchover to the standby resource. The `eofThres` field specifies the duration after which the production studio automatically switches to the standby resource if a stream interruption occurs. Unit: seconds.
        self.auto_switch_urgent_config = auto_switch_urgent_config
        # Indicates whether the production studio automatically switches to the standby resource in case of a stream interruption.
        # 
        # *   **true**\
        # *   **false**\
        self.auto_switch_urgent_on = auto_switch_urgent_on
        # The callback URL.
        self.callback_url = callback_url
        # The ID of the production studio.
        self.caster_id = caster_id
        # The name of the production studio.
        self.caster_name = caster_name
        # Indicates whether channels are enabled for the production studio. Valid values:
        # 
        # *   **0**: Channels are disabled.
        # *   **1**: Channels are enabled.
        self.channel_enable = channel_enable
        # Indicates whether stream delay is enabled. Unit: seconds.
        # 
        # *   **0**: Stream delay is disabled.
        # *   **A value greater than 0**: Stream delay is enabled.
        self.delay = delay
        # The main streaming domain.
        self.domain_name = domain_name
        # Indicates whether the carousel playback feature is enabled. Valid values:
        # 
        # *   **0**: The carousel playback feature is disabled.
        # *   **1**: The carousel playback feature is enabled.
        self.program_effect = program_effect
        # The name of the playlist for carousel playback.
        self.program_name = program_name
        # The recording configuration. If this parameter is empty, the recording feature is disabled.
        self.record_config = record_config
        # The ID of the request.
        self.request_id = request_id
        # The custom stream redirect URL.
        self.side_output_url = side_output_url
        # The list of custom stream redirect URLs.
        self.side_output_url_list = side_output_url_list
        # The storage configuration.
        self.sync_groups_config = sync_groups_config
        # The transcoding configuration.
        self.transcode_config = transcode_config
        # Prepared broadcast image media asset ID.
        self.urgent_image_id = urgent_image_id
        # URL of the standby image material.
        self.urgent_image_url = urgent_image_url
        # The URL of the standby live stream.
        self.urgent_live_stream_url = urgent_live_stream_url
        # The ID of the material that is used as the standby video from the media library.
        self.urgent_material_id = urgent_material_id

    def validate(self):
        if self.record_config:
            self.record_config.validate()
        if self.sync_groups_config:
            self.sync_groups_config.validate()
        if self.transcode_config:
            self.transcode_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_switch_urgent_config is not None:
            result['AutoSwitchUrgentConfig'] = self.auto_switch_urgent_config
        if self.auto_switch_urgent_on is not None:
            result['AutoSwitchUrgentOn'] = self.auto_switch_urgent_on
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.channel_enable is not None:
            result['ChannelEnable'] = self.channel_enable
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.program_effect is not None:
            result['ProgramEffect'] = self.program_effect
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.record_config is not None:
            result['RecordConfig'] = self.record_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.side_output_url is not None:
            result['SideOutputUrl'] = self.side_output_url
        if self.side_output_url_list is not None:
            result['SideOutputUrlList'] = self.side_output_url_list
        if self.sync_groups_config is not None:
            result['SyncGroupsConfig'] = self.sync_groups_config.to_map()
        if self.transcode_config is not None:
            result['TranscodeConfig'] = self.transcode_config.to_map()
        if self.urgent_image_id is not None:
            result['UrgentImageId'] = self.urgent_image_id
        if self.urgent_image_url is not None:
            result['UrgentImageUrl'] = self.urgent_image_url
        if self.urgent_live_stream_url is not None:
            result['UrgentLiveStreamUrl'] = self.urgent_live_stream_url
        if self.urgent_material_id is not None:
            result['UrgentMaterialId'] = self.urgent_material_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoSwitchUrgentConfig') is not None:
            self.auto_switch_urgent_config = m.get('AutoSwitchUrgentConfig')
        if m.get('AutoSwitchUrgentOn') is not None:
            self.auto_switch_urgent_on = m.get('AutoSwitchUrgentOn')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('ChannelEnable') is not None:
            self.channel_enable = m.get('ChannelEnable')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ProgramEffect') is not None:
            self.program_effect = m.get('ProgramEffect')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('RecordConfig') is not None:
            temp_model = DescribeCasterConfigResponseBodyRecordConfig()
            self.record_config = temp_model.from_map(m['RecordConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SideOutputUrl') is not None:
            self.side_output_url = m.get('SideOutputUrl')
        if m.get('SideOutputUrlList') is not None:
            self.side_output_url_list = m.get('SideOutputUrlList')
        if m.get('SyncGroupsConfig') is not None:
            temp_model = DescribeCasterConfigResponseBodySyncGroupsConfig()
            self.sync_groups_config = temp_model.from_map(m['SyncGroupsConfig'])
        if m.get('TranscodeConfig') is not None:
            temp_model = DescribeCasterConfigResponseBodyTranscodeConfig()
            self.transcode_config = temp_model.from_map(m['TranscodeConfig'])
        if m.get('UrgentImageId') is not None:
            self.urgent_image_id = m.get('UrgentImageId')
        if m.get('UrgentImageUrl') is not None:
            self.urgent_image_url = m.get('UrgentImageUrl')
        if m.get('UrgentLiveStreamUrl') is not None:
            self.urgent_live_stream_url = m.get('UrgentLiveStreamUrl')
        if m.get('UrgentMaterialId') is not None:
            self.urgent_material_id = m.get('UrgentMaterialId')
        return self


class DescribeCasterConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterLayoutsRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the layout.
        # 
        # If you do not specify a layout ID, all layouts of the production studio are queried.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer(TeaModel):
    def __init__(
        self,
        fixed_delay_duration: int = None,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles.
        # 
        # Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.
        self.fixed_delay_duration = fixed_delay_duration
        # The sound channels that are used for volume input in the audio layer. Valid values:
        # 
        # *   **leftChannel**: the left channel
        # *   **rightChannel**: the right channel
        # *   **all** (default): both the left and right channels
        self.valid_channel = valid_channel
        # The normalized value of the height of the audio layer. The width of the audio layer is proportionally scaled based on this parameter.
        # 
        # >  The default value is **0**, which indicates that the audio layer is not scaled.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers(TeaModel):
    def __init__(
        self,
        audio_layer: List[DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer] = None,
    ):
        self.audio_layer = audio_layer

    def validate(self):
        if self.audio_layer:
            for k in self.audio_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioLayer'] = []
        if self.audio_layer is not None:
            for k in self.audio_layer:
                result['AudioLayer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_layer = []
        if m.get('AudioLayer') is not None:
            for k in m.get('AudioLayer'):
                temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer()
                self.audio_layer.append(temp_model.from_map(k))
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList(TeaModel):
    def __init__(
        self,
        location_id: List[str] = None,
    ):
        self.location_id = location_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList(TeaModel):
    def __init__(
        self,
        location_id: List[str] = None,
    ):
        self.location_id = location_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds(TeaModel):
    def __init__(
        self,
        position: List[float] = None,
    ):
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer(TeaModel):
    def __init__(
        self,
        fill_mode: str = None,
        fixed_delay_duration: int = None,
        height_normalized: float = None,
        position_normalizeds: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds = None,
        position_refer: str = None,
        width_normalized: float = None,
    ):
        # The scaling mode of the video layer. Valid values:
        # 
        # *   **none** (default): specifies that the video layer is not scaled. The video layer is displayed based on its original size.
        # *   **fit**: specifies that the video layer is adapted to the fill area. The video layer is displayed based on the fill area. In this case, the video layer is scaled proportionally, with its original aspect ratio retained. The video layer is placed in the center, with its longer sides aligned with the fill area. If the aspect ratio of the video layer is different from that of the fill area, the content of the lower layer is displayed alongside the shorter sides. If there is no lower layer, black bars are displayed instead.
        self.fill_mode = fill_mode
        # The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles.
        # 
        # Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.
        self.fixed_delay_duration = fixed_delay_duration
        # The normalized value of the height of the video layer.
        # 
        # *   If the FillMode parameter of the video layer is set to none, the width of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
        # *   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.
        self.height_normalized = height_normalized
        # The normalized value of the position of the video layer, in the format of `[x,y]`. Default value: `[0,0]`.
        # 
        # >  The values of x and y are normalized.
        self.position_normalizeds = position_normalizeds
        # The reference coordinates of the video layer. Valid values:
        # 
        # *   **topLeft** (default): the upper-left corner
        # *   **topRight**: the upper-right corner
        # *   **bottomLeft**: the lower-left corner
        # *   **bottomRight**: the lower-right corner
        # *   **center**: the center
        # *   **topCenter**: the upper center
        # *   **bottomCenter**: the lower center
        # *   **leftCenter**: the left center
        # *   **rightCenter**: the right center
        self.position_refer = position_refer
        # The normalized value of the width of the video layer.
        # 
        # *   If the FillMode parameter of the video layer is set to none, the height of the video layer is scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
        # *   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.
        self.width_normalized = width_normalized

    def validate(self):
        if self.position_normalizeds:
            self.position_normalizeds.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fill_mode is not None:
            result['FillMode'] = self.fill_mode
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_normalizeds is not None:
            result['PositionNormalizeds'] = self.position_normalizeds.to_map()
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.width_normalized is not None:
            result['WidthNormalized'] = self.width_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FillMode') is not None:
            self.fill_mode = m.get('FillMode')
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionNormalizeds') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds()
            self.position_normalizeds = temp_model.from_map(m['PositionNormalizeds'])
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('WidthNormalized') is not None:
            self.width_normalized = m.get('WidthNormalized')
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers(TeaModel):
    def __init__(
        self,
        video_layer: List[DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer] = None,
    ):
        self.video_layer = video_layer

    def validate(self):
        if self.video_layer:
            for k in self.video_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoLayer'] = []
        if self.video_layer is not None:
            for k in self.video_layer:
                result['VideoLayer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_layer = []
        if m.get('VideoLayer') is not None:
            for k in m.get('VideoLayer'):
                temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer()
                self.video_layer.append(temp_model.from_map(k))
        return self


class DescribeCasterLayoutsResponseBodyLayoutsLayout(TeaModel):
    def __init__(
        self,
        audio_layers: DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers = None,
        blend_list: DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList = None,
        layout_id: str = None,
        mix_list: DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList = None,
        video_layers: DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers = None,
    ):
        # The configurations of the audio layers.
        self.audio_layers = audio_layers
        # The location IDs of the video layers, which are in the same order as the video layers.
        self.blend_list = blend_list
        # The ID of the layout.
        self.layout_id = layout_id
        # The location IDs of the audio layers, which are in the same order as the audio layers.
        self.mix_list = mix_list
        # The configurations of the video layers, which are in the default array sequence.
        self.video_layers = video_layers

    def validate(self):
        if self.audio_layers:
            self.audio_layers.validate()
        if self.blend_list:
            self.blend_list.validate()
        if self.mix_list:
            self.mix_list.validate()
        if self.video_layers:
            self.video_layers.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_layers is not None:
            result['AudioLayers'] = self.audio_layers.to_map()
        if self.blend_list is not None:
            result['BlendList'] = self.blend_list.to_map()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.mix_list is not None:
            result['MixList'] = self.mix_list.to_map()
        if self.video_layers is not None:
            result['VideoLayers'] = self.video_layers.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLayers') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers()
            self.audio_layers = temp_model.from_map(m['AudioLayers'])
        if m.get('BlendList') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList()
            self.blend_list = temp_model.from_map(m['BlendList'])
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('MixList') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList()
            self.mix_list = temp_model.from_map(m['MixList'])
        if m.get('VideoLayers') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers()
            self.video_layers = temp_model.from_map(m['VideoLayers'])
        return self


class DescribeCasterLayoutsResponseBodyLayouts(TeaModel):
    def __init__(
        self,
        layout: List[DescribeCasterLayoutsResponseBodyLayoutsLayout] = None,
    ):
        self.layout = layout

    def validate(self):
        if self.layout:
            for k in self.layout:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Layout'] = []
        if self.layout is not None:
            for k in self.layout:
                result['Layout'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.layout = []
        if m.get('Layout') is not None:
            for k in m.get('Layout'):
                temp_model = DescribeCasterLayoutsResponseBodyLayoutsLayout()
                self.layout.append(temp_model.from_map(k))
        return self


class DescribeCasterLayoutsResponseBody(TeaModel):
    def __init__(
        self,
        layouts: DescribeCasterLayoutsResponseBodyLayouts = None,
        request_id: str = None,
        total: int = None,
    ):
        # The layouts.
        self.layouts = layouts
        # The request ID.
        self.request_id = request_id
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.layouts:
            self.layouts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layouts is not None:
            result['Layouts'] = self.layouts.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Layouts') is not None:
            temp_model = DescribeCasterLayoutsResponseBodyLayouts()
            self.layouts = temp_model.from_map(m['Layouts'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterLayoutsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterLayoutsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterLayoutsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterProgramRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        end_time: str = None,
        episode_id: str = None,
        episode_type: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
        status: int = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the episode.
        self.episode_id = episode_id
        # The type of the episode. Valid values:
        # 
        # *   **Resource**: a video resource
        # *   **Component**: a component
        self.episode_type = episode_type
        self.owner_id = owner_id
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The status of the episode. Valid values:
        # 
        # *   **0**: The episode is not played.
        # *   **1**: The episode is being played.
        # *   **2**: The playback of the episode is complete.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.episode_type is not None:
            result['EpisodeType'] = self.episode_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('EpisodeType') is not None:
            self.episode_type = m.get('EpisodeType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds(TeaModel):
    def __init__(
        self,
        component_id: List[str] = None,
    ):
        self.component_id = component_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        return self


class DescribeCasterProgramResponseBodyEpisodesEpisode(TeaModel):
    def __init__(
        self,
        component_ids: DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds = None,
        end_time: str = None,
        episode_id: str = None,
        episode_name: str = None,
        episode_type: str = None,
        resource_id: str = None,
        start_time: str = None,
        status: int = None,
        switch_type: str = None,
    ):
        # The components.
        self.component_ids = component_ids
        # The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The ID of the episode.
        self.episode_id = episode_id
        # The name of the episode.
        self.episode_name = episode_name
        # The type of the episode. Valid values:
        # 
        # *   **Resource**: a video resource
        # *   **Component**: a component
        self.episode_type = episode_type
        # The ID of the video resource.
        self.resource_id = resource_id
        # The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The status of the episode.
        self.status = status
        # The policy for switching episodes. Valid values:
        # 
        # *   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
        # *   **ContentFirst**: The episode starts and ends as scheduled.
        self.switch_type = switch_type

    def validate(self):
        if self.component_ids:
            self.component_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_ids is not None:
            result['ComponentIds'] = self.component_ids.to_map()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.episode_name is not None:
            result['EpisodeName'] = self.episode_name
        if self.episode_type is not None:
            result['EpisodeType'] = self.episode_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentIds') is not None:
            temp_model = DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds()
            self.component_ids = temp_model.from_map(m['ComponentIds'])
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('EpisodeName') is not None:
            self.episode_name = m.get('EpisodeName')
        if m.get('EpisodeType') is not None:
            self.episode_type = m.get('EpisodeType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class DescribeCasterProgramResponseBodyEpisodes(TeaModel):
    def __init__(
        self,
        episode: List[DescribeCasterProgramResponseBodyEpisodesEpisode] = None,
    ):
        self.episode = episode

    def validate(self):
        if self.episode:
            for k in self.episode:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Episode'] = []
        if self.episode is not None:
            for k in self.episode:
                result['Episode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.episode = []
        if m.get('Episode') is not None:
            for k in m.get('Episode'):
                temp_model = DescribeCasterProgramResponseBodyEpisodesEpisode()
                self.episode.append(temp_model.from_map(k))
        return self


class DescribeCasterProgramResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episodes: DescribeCasterProgramResponseBodyEpisodes = None,
        program_effect: int = None,
        program_name: str = None,
        request_id: str = None,
        total: int = None,
    ):
        # The ID of the production studio.
        self.caster_id = caster_id
        # The list of the episodes.
        self.episodes = episodes
        # Indicates whether carousel playback is enabled.
        # 
        # *   **0**: Carousel playback is disabled.
        # *   **1**: Carousel playback is enabled.
        self.program_effect = program_effect
        # The name of the episode list.
        self.program_name = program_name
        # The request ID.
        self.request_id = request_id
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.episodes:
            self.episodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.episodes is not None:
            result['Episodes'] = self.episodes.to_map()
        if self.program_effect is not None:
            result['ProgramEffect'] = self.program_effect
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('Episodes') is not None:
            temp_model = DescribeCasterProgramResponseBodyEpisodes()
            self.episodes = temp_model.from_map(m['Episodes'])
        if m.get('ProgramEffect') is not None:
            self.program_effect = m.get('ProgramEffect')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterSceneAudioRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer(TeaModel):
    def __init__(
        self,
        fixed_delay_duration: int = None,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # The fixed delay of the audio layer. Unit: milliseconds.
        self.fixed_delay_duration = fixed_delay_duration
        # The sound channel type of the audio layer. Valid values:
        # 
        # *   **left**: the left channel
        # *   **right**: the right channel
        # *   **all** (default): both the left and right channels
        self.valid_channel = valid_channel
        # The volume of the audio layer.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class DescribeCasterSceneAudioResponseBodyAudioLayers(TeaModel):
    def __init__(
        self,
        audio_layer: List[DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer] = None,
    ):
        self.audio_layer = audio_layer

    def validate(self):
        if self.audio_layer:
            for k in self.audio_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioLayer'] = []
        if self.audio_layer is not None:
            for k in self.audio_layer:
                result['AudioLayer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_layer = []
        if m.get('AudioLayer') is not None:
            for k in m.get('AudioLayer'):
                temp_model = DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer()
                self.audio_layer.append(temp_model.from_map(k))
        return self


class DescribeCasterSceneAudioResponseBodyMixList(TeaModel):
    def __init__(
        self,
        location_id: List[str] = None,
    ):
        self.location_id = location_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        return self


class DescribeCasterSceneAudioResponseBody(TeaModel):
    def __init__(
        self,
        audio_layers: DescribeCasterSceneAudioResponseBodyAudioLayers = None,
        caster_id: str = None,
        follow_enable: int = None,
        mix_list: DescribeCasterSceneAudioResponseBodyMixList = None,
        request_id: str = None,
    ):
        # The configurations of the audio layers.
        self.audio_layers = audio_layers
        # The ID of the production studio. You can specify the ID in a request to start a scene in the production studio.
        self.caster_id = caster_id
        # The audio mode. By default, the audio follows video (AFV) mode is used. Valid values:
        # 
        # *   **0**: the audio mixing mode
        # *   **1**: the AFV mode
        self.follow_enable = follow_enable
        self.mix_list = mix_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.audio_layers:
            self.audio_layers.validate()
        if self.mix_list:
            self.mix_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_layers is not None:
            result['AudioLayers'] = self.audio_layers.to_map()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.follow_enable is not None:
            result['FollowEnable'] = self.follow_enable
        if self.mix_list is not None:
            result['MixList'] = self.mix_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioLayers') is not None:
            temp_model = DescribeCasterSceneAudioResponseBodyAudioLayers()
            self.audio_layers = temp_model.from_map(m['AudioLayers'])
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('FollowEnable') is not None:
            self.follow_enable = m.get('FollowEnable')
        if m.get('MixList') is not None:
            temp_model = DescribeCasterSceneAudioResponseBodyMixList()
            self.mix_list = temp_model.from_map(m['MixList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCasterSceneAudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterSceneAudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterSceneAudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterScenesRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class DescribeCasterScenesResponseBodySceneListSceneComponentIds(TeaModel):
    def __init__(
        self,
        component_id: List[str] = None,
    ):
        self.component_id = component_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['componentId'] = self.component_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('componentId') is not None:
            self.component_id = m.get('componentId')
        return self


class DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo(TeaModel):
    def __init__(
        self,
        output_stream_url: str = None,
        transcode_config: str = None,
        video_format: str = None,
    ):
        # The streaming URL.
        self.output_stream_url = output_stream_url
        # The transcoding configuration. Valid values:
        # 
        # *   **sd**: standard definition
        # *   **lld**: low definition
        # *   **lud**: ultra-high definition
        # *   **lhd**: high definition
        self.transcode_config = transcode_config
        # The format. Valid values:
        # 
        # *   **flv**\
        # *   **mp4**\
        # *   **m3u8**\
        self.video_format = video_format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_stream_url is not None:
            result['OutputStreamUrl'] = self.output_stream_url
        if self.transcode_config is not None:
            result['TranscodeConfig'] = self.transcode_config
        if self.video_format is not None:
            result['VideoFormat'] = self.video_format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputStreamUrl') is not None:
            self.output_stream_url = m.get('OutputStreamUrl')
        if m.get('TranscodeConfig') is not None:
            self.transcode_config = m.get('TranscodeConfig')
        if m.get('VideoFormat') is not None:
            self.video_format = m.get('VideoFormat')
        return self


class DescribeCasterScenesResponseBodySceneListSceneStreamInfos(TeaModel):
    def __init__(
        self,
        stream_info: List[DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo] = None,
    ):
        self.stream_info = stream_info

    def validate(self):
        if self.stream_info:
            for k in self.stream_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfo'] = []
        if self.stream_info is not None:
            for k in self.stream_info:
                result['StreamInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_info = []
        if m.get('StreamInfo') is not None:
            for k in m.get('StreamInfo'):
                temp_model = DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo()
                self.stream_info.append(temp_model.from_map(k))
        return self


class DescribeCasterScenesResponseBodySceneListScene(TeaModel):
    def __init__(
        self,
        component_ids: DescribeCasterScenesResponseBodySceneListSceneComponentIds = None,
        layout_id: str = None,
        output_type: str = None,
        scene_id: str = None,
        scene_name: str = None,
        status: int = None,
        stream_infos: DescribeCasterScenesResponseBodySceneListSceneStreamInfos = None,
        stream_url: str = None,
    ):
        # The components.
        self.component_ids = component_ids
        # The ID of the layout.
        self.layout_id = layout_id
        # Indicates whether the output video is in PVW mode or PGM mode. Valid values:
        # 
        # *   **0**: in PVW mode.
        # *   **1**: in PGM mode.
        self.output_type = output_type
        # The ID of the scene. You can use the ID as a request parameter in the API operation that is used to modify the audio configurations of the scene, query the audio configurations of the scene, start the scene, or stop the scene.
        self.scene_id = scene_id
        # The name of the scene.
        self.scene_name = scene_name
        # The status of the scene. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.status = status
        # The information about the stream.
        self.stream_infos = stream_infos
        # The URL of the output stream.
        self.stream_url = stream_url

    def validate(self):
        if self.component_ids:
            self.component_ids.validate()
        if self.stream_infos:
            self.stream_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_ids is not None:
            result['ComponentIds'] = self.component_ids.to_map()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.output_type is not None:
            result['OutputType'] = self.output_type
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        if self.scene_name is not None:
            result['SceneName'] = self.scene_name
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_infos is not None:
            result['StreamInfos'] = self.stream_infos.to_map()
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentIds') is not None:
            temp_model = DescribeCasterScenesResponseBodySceneListSceneComponentIds()
            self.component_ids = temp_model.from_map(m['ComponentIds'])
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OutputType') is not None:
            self.output_type = m.get('OutputType')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        if m.get('SceneName') is not None:
            self.scene_name = m.get('SceneName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInfos') is not None:
            temp_model = DescribeCasterScenesResponseBodySceneListSceneStreamInfos()
            self.stream_infos = temp_model.from_map(m['StreamInfos'])
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class DescribeCasterScenesResponseBodySceneList(TeaModel):
    def __init__(
        self,
        scene: List[DescribeCasterScenesResponseBodySceneListScene] = None,
    ):
        self.scene = scene

    def validate(self):
        if self.scene:
            for k in self.scene:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Scene'] = []
        if self.scene is not None:
            for k in self.scene:
                result['Scene'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.scene = []
        if m.get('Scene') is not None:
            for k in m.get('Scene'):
                temp_model = DescribeCasterScenesResponseBodySceneListScene()
                self.scene.append(temp_model.from_map(k))
        return self


class DescribeCasterScenesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        scene_list: DescribeCasterScenesResponseBodySceneList = None,
        total: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The scenes.
        self.scene_list = scene_list
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.scene_list:
            self.scene_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scene_list is not None:
            result['SceneList'] = self.scene_list.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SceneList') is not None:
            temp_model = DescribeCasterScenesResponseBodySceneList()
            self.scene_list = temp_model.from_map(m['SceneList'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterScenesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterScenesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterScenesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterStreamUrlRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~) interface, check the value of the CasterId parameter in the response.
        # 
        # If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:
        # 
        # Production Studios > Production Studio Management
        # 
        # >  The CasterId is reflected in the Name column on the Production Studio Management page.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo(TeaModel):
    def __init__(
        self,
        output_stream_url: str = None,
        transcode_config: str = None,
        video_format: str = None,
    ):
        # The streaming URL.
        self.output_stream_url = output_stream_url
        # The resolution to which the scene transcodes the stream for playback. Valid values:
        # 
        # *   **lsd**: standard definition.
        # *   **lld**: low definition.
        # *   **lud**: ultra high definition.
        # *   **lhd**: high definition.
        self.transcode_config = transcode_config
        # The format to which the scene transcodes the stream for playback. Valid values:
        # 
        # *   **flv**.
        # *   **rtmp**.
        # *   **m3u8**.
        self.video_format = video_format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_stream_url is not None:
            result['OutputStreamUrl'] = self.output_stream_url
        if self.transcode_config is not None:
            result['TranscodeConfig'] = self.transcode_config
        if self.video_format is not None:
            result['VideoFormat'] = self.video_format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputStreamUrl') is not None:
            self.output_stream_url = m.get('OutputStreamUrl')
        if m.get('TranscodeConfig') is not None:
            self.transcode_config = m.get('TranscodeConfig')
        if m.get('VideoFormat') is not None:
            self.video_format = m.get('VideoFormat')
        return self


class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos(TeaModel):
    def __init__(
        self,
        stream_info: List[DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo] = None,
    ):
        self.stream_info = stream_info

    def validate(self):
        if self.stream_info:
            for k in self.stream_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfo'] = []
        if self.stream_info is not None:
            for k in self.stream_info:
                result['StreamInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_info = []
        if m.get('StreamInfo') is not None:
            for k in m.get('StreamInfo'):
                temp_model = DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo()
                self.stream_info.append(temp_model.from_map(k))
        return self


class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream(TeaModel):
    def __init__(
        self,
        output_type: int = None,
        rtmp_url: str = None,
        scene_id: str = None,
        stream_infos: DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos = None,
        stream_url: str = None,
    ):
        # Indicates whether the output stream is in preview mode or program mode.
        # 
        # *   **0**: indicates that the output videos of the scene are in preview mode.
        # *   **1**: indicates that the output videos of the scene are in program mode.
        self.output_type = output_type
        # The Real Time Messaging Protocol (RTMP) URL.
        self.rtmp_url = rtmp_url
        # The ID of the scene.
        self.scene_id = scene_id
        # The information about the stream.
        self.stream_infos = stream_infos
        # The streaming URL.
        self.stream_url = stream_url

    def validate(self):
        if self.stream_infos:
            self.stream_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_type is not None:
            result['OutputType'] = self.output_type
        if self.rtmp_url is not None:
            result['RtmpUrl'] = self.rtmp_url
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        if self.stream_infos is not None:
            result['StreamInfos'] = self.stream_infos.to_map()
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputType') is not None:
            self.output_type = m.get('OutputType')
        if m.get('RtmpUrl') is not None:
            self.rtmp_url = m.get('RtmpUrl')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        if m.get('StreamInfos') is not None:
            temp_model = DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos()
            self.stream_infos = temp_model.from_map(m['StreamInfos'])
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class DescribeCasterStreamUrlResponseBodyCasterStreams(TeaModel):
    def __init__(
        self,
        caster_stream: List[DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream] = None,
    ):
        self.caster_stream = caster_stream

    def validate(self):
        if self.caster_stream:
            for k in self.caster_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CasterStream'] = []
        if self.caster_stream is not None:
            for k in self.caster_stream:
                result['CasterStream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.caster_stream = []
        if m.get('CasterStream') is not None:
            for k in m.get('CasterStream'):
                temp_model = DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream()
                self.caster_stream.append(temp_model.from_map(k))
        return self


class DescribeCasterStreamUrlResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        caster_streams: DescribeCasterStreamUrlResponseBodyCasterStreams = None,
        request_id: str = None,
        total: int = None,
    ):
        # The ID of the production studio.
        self.caster_id = caster_id
        # The information about the streams of the production studio.
        self.caster_streams = caster_streams
        # The ID of the request.
        self.request_id = request_id
        # The number of streams that were returned.
        self.total = total

    def validate(self):
        if self.caster_streams:
            self.caster_streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.caster_streams is not None:
            result['CasterStreams'] = self.caster_streams.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CasterStreams') is not None:
            temp_model = DescribeCasterStreamUrlResponseBodyCasterStreams()
            self.caster_streams = temp_model.from_map(m['CasterStreams'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCasterStreamUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterStreamUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterStreamUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCasterVideoResourcesRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource(TeaModel):
    def __init__(
        self,
        begin_offset: int = None,
        end_offset: int = None,
        flv_url: str = None,
        image_id: str = None,
        image_url: str = None,
        live_stream_url: str = None,
        location_id: str = None,
        material_id: str = None,
        pts_callback_interval: int = None,
        repeat_num: int = None,
        resource_id: str = None,
        resource_name: str = None,
        vod_url: str = None,
    ):
        # The offset of the position where the system starts to read the video resource. This parameter takes effect only if the input source is a video file. Unit: milliseconds.
        # 
        # A value **greater than 0** indicates an offset from the first frame.
        self.begin_offset = begin_offset
        # The offset of the position where the system stops reading the video file. This parameter takes effect only if the input source is a video file. Unit: milliseconds.
        # 
        # *   A value greater than **0** indicates an offset from the first frame.
        # *   A value smaller than **0** indicates an offset from the last frame.
        self.end_offset = end_offset
        # The source URL.
        self.flv_url = flv_url
        # The image ID.
        self.image_id = image_id
        # The image URL.
        self.image_url = image_url
        # The URL of the live stream.
        self.live_stream_url = live_stream_url
        # The position of the video resource.
        self.location_id = location_id
        # The material ID.
        self.material_id = material_id
        # The interval between presentation timestamp (PTS) callbacks. If you set the value to 0, the PTS callback is disabled. This parameter is returned only when the video resource is a video-on-demand (VOD) file.
        self.pts_callback_interval = pts_callback_interval
        # The number of playback times after the first playback is complete. This parameter takes effect only when the input source is a video file. Valid values:
        # 
        # *   **0** (default): The video file is played only once.
        # *   **-1**: The video file is played in loop mode.
        self.repeat_num = repeat_num
        # The resource ID.
        self.resource_id = resource_id
        # The resource name.
        self.resource_name = resource_name
        # The URL of the VOD file.
        # 
        # This parameter is returned only when the video resource is an MP4, FLV, or TS file that is not from the media library.
        self.vod_url = vod_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_offset is not None:
            result['BeginOffset'] = self.begin_offset
        if self.end_offset is not None:
            result['EndOffset'] = self.end_offset
        if self.flv_url is not None:
            result['FlvUrl'] = self.flv_url
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.live_stream_url is not None:
            result['LiveStreamUrl'] = self.live_stream_url
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        if self.pts_callback_interval is not None:
            result['PtsCallbackInterval'] = self.pts_callback_interval
        if self.repeat_num is not None:
            result['RepeatNum'] = self.repeat_num
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.vod_url is not None:
            result['VodUrl'] = self.vod_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginOffset') is not None:
            self.begin_offset = m.get('BeginOffset')
        if m.get('EndOffset') is not None:
            self.end_offset = m.get('EndOffset')
        if m.get('FlvUrl') is not None:
            self.flv_url = m.get('FlvUrl')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LiveStreamUrl') is not None:
            self.live_stream_url = m.get('LiveStreamUrl')
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        if m.get('PtsCallbackInterval') is not None:
            self.pts_callback_interval = m.get('PtsCallbackInterval')
        if m.get('RepeatNum') is not None:
            self.repeat_num = m.get('RepeatNum')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('VodUrl') is not None:
            self.vod_url = m.get('VodUrl')
        return self


class DescribeCasterVideoResourcesResponseBodyVideoResources(TeaModel):
    def __init__(
        self,
        video_resource: List[DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource] = None,
    ):
        self.video_resource = video_resource

    def validate(self):
        if self.video_resource:
            for k in self.video_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoResource'] = []
        if self.video_resource is not None:
            for k in self.video_resource:
                result['VideoResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_resource = []
        if m.get('VideoResource') is not None:
            for k in m.get('VideoResource'):
                temp_model = DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource()
                self.video_resource.append(temp_model.from_map(k))
        return self


class DescribeCasterVideoResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        total: int = None,
        video_resources: DescribeCasterVideoResourcesResponseBodyVideoResources = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The total number of returned entries.
        self.total = total
        # The input sources.
        self.video_resources = video_resources

    def validate(self):
        if self.video_resources:
            self.video_resources.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        if self.video_resources is not None:
            result['VideoResources'] = self.video_resources.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('VideoResources') is not None:
            temp_model = DescribeCasterVideoResourcesResponseBodyVideoResources()
            self.video_resources = temp_model.from_map(m['VideoResources'])
        return self


class DescribeCasterVideoResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCasterVideoResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCasterVideoResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCastersRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCastersRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        caster_name: str = None,
        charge_type: int = None,
        end_time: str = None,
        norm_type: str = None,
        order_by_modify_asc: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        start_time: str = None,
        status: int = None,
        tag: List[DescribeCastersRequestTag] = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the ApsaraVideo Live console and click Production Studios in the left-side navigation pane.
        # 
        # > 
        # 
        # *   You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # *   If you leave this parameter empty, the data of all production studios is returned.
        self.caster_id = caster_id
        # The name of the production studio.
        self.caster_name = caster_name
        # The billing method. Valid values:
        # 
        # *   0: the subscription billing method
        # *   1: the pay-as-you-go billing method
        self.charge_type = charge_type
        # The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The type of the production studio. Valid values:
        # 
        # *   1: general mode
        # *   3: lightweight carousel playback mode
        # *   4: virtual studio
        # *   6: playlist mode
        self.norm_type = norm_type
        # Specifies whether to sort the production studios in ascending order based on the modification time.
        # 
        # >  If you leave this parameter empty, the default value is used. Default value: false.
        self.order_by_modify_asc = order_by_modify_asc
        self.owner_id = owner_id
        # The number of the page to return.
        self.page_num = page_num
        # The number of templates to return on each page. If you leave this parameter empty, the default value is used. Default value: 100.
        self.page_size = page_size
        self.region_id = region_id
        # The resource group ID. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).
        self.resource_group_id = resource_group_id
        # The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The status of the production studio. Valid values:
        # 
        # *   0: idle
        # *   1: streaming
        self.status = status
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.norm_type is not None:
            result['NormType'] = self.norm_type
        if self.order_by_modify_asc is not None:
            result['OrderByModifyAsc'] = self.order_by_modify_asc
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NormType') is not None:
            self.norm_type = m.get('NormType')
        if m.get('OrderByModifyAsc') is not None:
            self.order_by_modify_asc = m.get('OrderByModifyAsc')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeCastersRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeCastersResponseBodyCasterListCasterTagsTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of the tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeCastersResponseBodyCasterListCasterTags(TeaModel):
    def __init__(
        self,
        tag: List[DescribeCastersResponseBodyCasterListCasterTagsTag] = None,
    ):
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag = []
        if m.get('tag') is not None:
            for k in m.get('tag'):
                temp_model = DescribeCastersResponseBodyCasterListCasterTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeCastersResponseBodyCasterListCaster(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        caster_name: str = None,
        caster_template: str = None,
        channel_enable: int = None,
        charge_type: str = None,
        client_token_id: str = None,
        create_time: str = None,
        duration: str = None,
        expire_time: str = None,
        last_modified: str = None,
        norm_type: int = None,
        purchase_time: str = None,
        resource_group_id: str = None,
        start_time: str = None,
        status: int = None,
        tags: DescribeCastersResponseBodyCasterListCasterTags = None,
    ):
        # The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.
        self.caster_id = caster_id
        # The name of the production studio.
        self.caster_name = caster_name
        # The resolution in which the production studio plays videos. This parameter is returned if the subscription billing method is used. Valid values:
        # 
        # *   lp_ld: low definition
        # *   lp_sd: standard definition
        # *   lp_hd: high definition
        # *   lp_ud: ultra high definition.
        # *   lp_ld_v: low definition (portrait mode)
        # *   lp_sd_v: standard definition (portrait mode)
        # *   lp_hd_v: high definition (portrait mode)
        # *   lp_ud_v: ultra high definition (portrait mode)
        self.caster_template = caster_template
        # Indicates whether the channel is enabled for the production studio.
        # 
        # *   0: The channel is disabled.
        # *   1: The channel is enabled.
        self.channel_enable = channel_enable
        # The billing method. Valid values:
        # 
        # *   PrePaid: the subscription billing method
        # *   PostPaid: the pay-as-you-go billing method
        self.charge_type = charge_type
        # The client token that is used to ensure the idempotence of the request.
        self.client_token_id = client_token_id
        # The time when the production studio was created.
        self.create_time = create_time
        # The streaming duration. Format: hh:mm:ss.
        self.duration = duration
        # The time when the production studio expires.
        self.expire_time = expire_time
        # The time when the production studio was last modified. For example, the time when the production studio was last started, stopped, or modified is returned.
        self.last_modified = last_modified
        # The type of the production studio. Valid values:
        # 
        # *   0: playlist mode
        # *   1: general mode
        self.norm_type = norm_type
        # The time when the production studio was purchased.
        self.purchase_time = purchase_time
        # The resource group ID. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).
        self.resource_group_id = resource_group_id
        # The time when the production studio was started. This parameter is returned if the production studio is in the streaming status.
        self.start_time = start_time
        # The status of the production studio. Valid values:
        # 
        # *   0: idle
        # *   1: streaming
        self.status = status
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.caster_template is not None:
            result['CasterTemplate'] = self.caster_template
        if self.channel_enable is not None:
            result['ChannelEnable'] = self.channel_enable
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.client_token_id is not None:
            result['ClientTokenId'] = self.client_token_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.norm_type is not None:
            result['NormType'] = self.norm_type
        if self.purchase_time is not None:
            result['PurchaseTime'] = self.purchase_time
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('CasterTemplate') is not None:
            self.caster_template = m.get('CasterTemplate')
        if m.get('ChannelEnable') is not None:
            self.channel_enable = m.get('ChannelEnable')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('ClientTokenId') is not None:
            self.client_token_id = m.get('ClientTokenId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('NormType') is not None:
            self.norm_type = m.get('NormType')
        if m.get('PurchaseTime') is not None:
            self.purchase_time = m.get('PurchaseTime')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeCastersResponseBodyCasterListCasterTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeCastersResponseBodyCasterList(TeaModel):
    def __init__(
        self,
        caster: List[DescribeCastersResponseBodyCasterListCaster] = None,
    ):
        self.caster = caster

    def validate(self):
        if self.caster:
            for k in self.caster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Caster'] = []
        if self.caster is not None:
            for k in self.caster:
                result['Caster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.caster = []
        if m.get('Caster') is not None:
            for k in m.get('Caster'):
                temp_model = DescribeCastersResponseBodyCasterListCaster()
                self.caster.append(temp_model.from_map(k))
        return self


class DescribeCastersResponseBody(TeaModel):
    def __init__(
        self,
        caster_list: DescribeCastersResponseBodyCasterList = None,
        request_id: str = None,
        total: int = None,
    ):
        # The production studios.
        self.caster_list = caster_list
        # The request ID.
        self.request_id = request_id
        # The number of production studios.
        self.total = total

    def validate(self):
        if self.caster_list:
            self.caster_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_list is not None:
            result['CasterList'] = self.caster_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterList') is not None:
            temp_model = DescribeCastersResponseBodyCasterList()
            self.caster_list = temp_model.from_map(m['CasterList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeCastersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCastersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCastersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelParticipantsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # The ID of the application. You can specify only one application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the channel. You can specify only one channel ID.
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The sort order. Valid values:
        # 
        # *   **asc**: ascending order.
        # *   **desc**: descending order. This is the default value.
        self.order = order
        # The number of the page to return. Default value: 1.
        self.page_num = page_num
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeChannelParticipantsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        times: int = None,
        total_num: int = None,
        total_page: int = None,
        user_list: List[str] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The time elapsed until the result was returned. Unit: seconds. The value is a UNIX timestamp.
        self.times = times
        # The number of entries returned.
        self.total_num = total_num
        # The page number of the returned page.
        self.total_page = total_page
        # The list of user IDs.
        self.user_list = user_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.times is not None:
            result['Times'] = self.times
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        if self.user_list is not None:
            result['UserList'] = self.user_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        if m.get('UserList') is not None:
            self.user_list = m.get('UserList')
        return self


class DescribeChannelParticipantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelParticipantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelParticipantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
    ):
        # The application ID. You can specify only one application ID in a request.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID in a request.
        # 
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class DescribeChannelUsersResponseBody(TeaModel):
    def __init__(
        self,
        interactive_user_list: List[str] = None,
        interactive_user_number: int = None,
        is_channel_exists: bool = None,
        live_user_list: List[str] = None,
        live_user_number: int = None,
        request_id: str = None,
        timestamp: int = None,
    ):
        # The list of streamers/co-streamers.
        self.interactive_user_list = interactive_user_list
        # The number of co-streamers.
        self.interactive_user_number = interactive_user_number
        # Indicates whether the channel exists. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # > After all users leave the channel, the system requires a few seconds to clear the cache. If you call the operation during this period, the value of this parameter is true, and the value of InteractiveUserNumber and LiveUserNumber is 0.
        self.is_channel_exists = is_channel_exists
        # The list of viewers.
        self.live_user_list = live_user_list
        # The number of viewers.
        self.live_user_number = live_user_number
        # The ID of the request.
        self.request_id = request_id
        # The UTC timestamp when the response is returned.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interactive_user_list is not None:
            result['InteractiveUserList'] = self.interactive_user_list
        if self.interactive_user_number is not None:
            result['InteractiveUserNumber'] = self.interactive_user_number
        if self.is_channel_exists is not None:
            result['IsChannelExists'] = self.is_channel_exists
        if self.live_user_list is not None:
            result['LiveUserList'] = self.live_user_list
        if self.live_user_number is not None:
            result['LiveUserNumber'] = self.live_user_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InteractiveUserList') is not None:
            self.interactive_user_list = m.get('InteractiveUserList')
        if m.get('InteractiveUserNumber') is not None:
            self.interactive_user_number = m.get('InteractiveUserNumber')
        if m.get('IsChannelExists') is not None:
            self.is_channel_exists = m.get('IsChannelExists')
        if m.get('LiveUserList') is not None:
            self.live_user_list = m.get('LiveUserList')
        if m.get('LiveUserNumber') is not None:
            self.live_user_number = m.get('LiveUserNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeChannelUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainUsageDataRequest(TeaModel):
    def __init__(
        self,
        area: str = None,
        data_protocol: str = None,
        domain_name: str = None,
        end_time: str = None,
        field: str = None,
        interval: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        type: str = None,
    ):
        # The billable region. Valid values:
        # 
        # *   **CN**: Chinese mainland
        # *   **OverSeas**: outside the Chinese mainland
        # *   **AP1**: Asia Pacific 1
        # *   **AP2**: Asia Pacific 2
        # *   **AP3**: Asia Pacific 3
        # *   **NA**: North America
        # *   **SA**: South America
        # *   **EU**: Europe
        # *   **MEAA**: Middle East and Africa
        # *   **all**: all regions
        # 
        # >  If you do not specify this parameter, the default value CN is used. Alibaba Cloud supports the following countries and regions outside the Chinese mainland: - Asia Pacific 1: Hong Kong (China), Macao (China), Taiwan (China), Japan, and Southeast Asia excluding Vietnam and Indonesia. - Asia Pacific 2: Indonesia, South Korea, and Vietnam. - Asia Pacific 3: Australia and New Zealand. - North America: US and Canada. - South America: Brazil. Europe: Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany. - Middle East and Africa: South Africa, Oman, UAE, and Kuwait.
        self.area = area
        # The protocol of the data to query. Valid values:
        # 
        # *   **http**: HTTP
        # *   **https**: HTTPS
        # *   **quic**: QUIC
        # *   **all** (default): HTTP, HTTPS, and QUIC
        self.data_protocol = data_protocol
        # The domain name.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # The end time must be later than the start time. The maximum time range that you can specify is **31** days.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The category of the resource usage data to query. Valid values:
        # 
        # *   **bps**: streaming bandwidth
        # *   **traf**: streaming traffic
        # *   **req_traf**: stream ingest traffic if you set Type to push, or stream relay traffic if you set Type to push_proxy
        # *   **req_bps**: stream ingest bandwidth if you set Type to push, or stream relay bandwidth if you set Type to push_proxy
        # 
        # This parameter is required.
        self.field = field
        # The time interval between the data entries to return. Unit: seconds. Valid values: **300** (5 minutes), **3600** (1 hour), and **86400** (1 day).
        self.interval = interval
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The type of the resource usage data to query.
        # 
        # Valid values if you set **Field** to **bps** or **traf**:
        # 
        # *   **rts**: bandwidth or traffic for Real-Time Streaming (RTS)
        # *   **quic**: bandwidth or traffic for QUIC
        # *   **all**: all bandwidth or traffic
        # 
        # Valid values if you set **Field** to **req_traf** or **req_bps**:
        # 
        # *   **push**: stream ingest bandwidth or traffic
        # *   **push_proxy**: stream relay bandwidth or traffic
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.data_protocol is not None:
            result['DataProtocol'] = self.data_protocol
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.field is not None:
            result['Field'] = self.field
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('DataProtocol') is not None:
            self.data_protocol = m.get('DataProtocol')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        value: str = None,
    ):
        # The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time_stamp = time_stamp
        # The amount of resource usage.
        # 
        # *   If the value of the Field parameter is traf or req_traf, the returned data is measured in bytes.
        # *   If the value of the Field parameter is bps or req_bps, the returned data is measured in bit/s.
        # *   If the value of the Field parameter is acc, the returned data is measured by count.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDomainUsageDataResponseBodyUsageDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeDomainUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        area: str = None,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
        type: str = None,
        usage_data_per_interval: DescribeDomainUsageDataResponseBodyUsageDataPerInterval = None,
    ):
        # The billable region where the resource usage data was generated.
        self.area = area
        # The time interval between the returned entries. Unit: seconds.
        self.data_interval = data_interval
        # The domain name.
        self.domain_name = domain_name
        # The end of the time range for which the resource usage data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the resource usage data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The type of the resource usage data.
        self.type = type
        # The resource usage data that was collected for each time interval.
        self.usage_data_per_interval = usage_data_per_interval

    def validate(self):
        if self.usage_data_per_interval:
            self.usage_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.usage_data_per_interval is not None:
            result['UsageDataPerInterval'] = self.usage_data_per_interval.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UsageDataPerInterval') is not None:
            temp_model = DescribeDomainUsageDataResponseBodyUsageDataPerInterval()
            self.usage_data_per_interval = temp_model.from_map(m['UsageDataPerInterval'])
        return self


class DescribeDomainUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDomainWithIntegrityRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        integrity: float = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The integrity.
        # 
        # This parameter is required.
        self.integrity = integrity
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.integrity is not None:
            result['Integrity'] = self.integrity
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Integrity') is not None:
            self.integrity = m.get('Integrity')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeDomainWithIntegrityResponseBodyContent(TeaModel):
    def __init__(
        self,
        columns: List[str] = None,
        name: str = None,
        points: List[str] = None,
    ):
        # The column names.
        self.columns = columns
        # The table name.
        self.name = name
        # The subpoints.
        self.points = points

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.name is not None:
            result['Name'] = self.name
        if self.points is not None:
            result['Points'] = self.points
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Points') is not None:
            self.points = m.get('Points')
        return self


class DescribeDomainWithIntegrityResponseBody(TeaModel):
    def __init__(
        self,
        content: List[DescribeDomainWithIntegrityResponseBodyContent] = None,
        request_id: str = None,
    ):
        # The verification information.
        self.content = content
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = DescribeDomainWithIntegrityResponseBodyContent()
                self.content.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDomainWithIntegrityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDomainWithIntegrityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDomainWithIntegrityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHlsLiveStreamRealTimeBpsDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        time: str = None,
    ):
        # The domain names to query. Separate them with commas (,). A domain name cannot contain double-byte characters.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The timestamp.
        # 
        # This parameter is required.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos(TeaModel):
    def __init__(
        self,
        down_flow: float = None,
        online: float = None,
        rate: str = None,
    ):
        # The bandwidth. Unit: bit/s.
        self.down_flow = down_flow
        # The number of online users.
        self.online = online
        # The bitrate.
        self.rate = rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.down_flow is not None:
            result['DownFlow'] = self.down_flow
        if self.online is not None:
            result['Online'] = self.online
        if self.rate is not None:
            result['Rate'] = self.rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownFlow') is not None:
            self.down_flow = m.get('DownFlow')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        return self


class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos(TeaModel):
    def __init__(
        self,
        infos: List[DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos] = None,
        stream_name: str = None,
    ):
        # The statistics on the HLS stream.
        self.infos = infos
        # The name of the stream.
        self.stream_name = stream_name

    def validate(self):
        if self.infos:
            for k in self.infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Infos'] = []
        if self.infos is not None:
            for k in self.infos:
                result['Infos'].append(k.to_map() if k else None)
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.infos = []
        if m.get('Infos') is not None:
            for k in m.get('Infos'):
                temp_model = DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos()
                self.infos.append(temp_model.from_map(k))
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        stream_infos: List[DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos] = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # Details about the statistics on each HLS stream under the domain name.
        self.stream_infos = stream_infos

    def validate(self):
        if self.stream_infos:
            for k in self.stream_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        result['StreamInfos'] = []
        if self.stream_infos is not None:
            for k in self.stream_infos:
                result['StreamInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        self.stream_infos = []
        if m.get('StreamInfos') is not None:
            for k in m.get('StreamInfos'):
                temp_model = DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos()
                self.stream_infos.append(temp_model.from_map(k))
        return self


class DescribeHlsLiveStreamRealTimeBpsDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        time: str = None,
        usage_data: List[DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The timestamp for which the data was queried.
        self.time = time
        # The usage data.
        self.usage_data = usage_data

    def validate(self):
        if self.usage_data:
            for k in self.usage_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time is not None:
            result['Time'] = self.time
        result['UsageData'] = []
        if self.usage_data is not None:
            for k in self.usage_data:
                result['UsageData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        self.usage_data = []
        if m.get('UsageData') is not None:
            for k in m.get('UsageData'):
                temp_model = DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData()
                self.usage_data.append(temp_model.from_map(k))
        return self


class DescribeHlsLiveStreamRealTimeBpsDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeHlsLiveStreamRealTimeBpsDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveAIProduceRulesRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        page_number: str = None,
        page_size: str = None,
        region_id: str = None,
        rules_id: str = None,
        suffix_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The main streaming domain.
        self.domain = domain
        self.owner_id = owner_id
        # The page number. Valid values: [1,100].
        self.page_number = page_number
        # The number of entries per page. Valid values: [1,100].
        self.page_size = page_size
        self.region_id = region_id
        # The ID of the subtitle rule.
        self.rules_id = rules_id
        # The suffix of the subtitle rule.
        # 
        # > Set the value to the name of the subtitle template.
        self.suffix_name = suffix_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        if self.suffix_name is not None:
            result['SuffixName'] = self.suffix_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        if m.get('SuffixName') is not None:
            self.suffix_name = m.get('SuffixName')
        return self


class DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo(TeaModel):
    def __init__(
        self,
        app: str = None,
        description: str = None,
        domain: str = None,
        gmt_modify_time: str = None,
        is_lazy: bool = None,
        live_template: str = None,
        rules_id: str = None,
        studio_name: str = None,
        subtitle_name: str = None,
        suffix_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The description of the rule.
        self.description = description
        # The streaming domain.
        self.domain = domain
        # The last time when the rule was modified. The value is a timestamp.
        self.gmt_modify_time = gmt_modify_time
        # Indicates whether the rule takes effect when stream pulling starts.
        self.is_lazy = is_lazy
        # The specification of the exported subtitles.
        self.live_template = live_template
        # The ID of the subtitle rule.
        self.rules_id = rules_id
        # The name of the virtual background template.
        self.studio_name = studio_name
        # The name of the subtitle template.
        self.subtitle_name = subtitle_name
        # The suffix of the subtitle rule.
        self.suffix_name = suffix_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.gmt_modify_time is not None:
            result['GmtModifyTime'] = self.gmt_modify_time
        if self.is_lazy is not None:
            result['IsLazy'] = self.is_lazy
        if self.live_template is not None:
            result['LiveTemplate'] = self.live_template
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.suffix_name is not None:
            result['SuffixName'] = self.suffix_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('GmtModifyTime') is not None:
            self.gmt_modify_time = m.get('GmtModifyTime')
        if m.get('IsLazy') is not None:
            self.is_lazy = m.get('IsLazy')
        if m.get('LiveTemplate') is not None:
            self.live_template = m.get('LiveTemplate')
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('SuffixName') is not None:
            self.suffix_name = m.get('SuffixName')
        return self


class DescribeLiveAIProduceRulesResponseBodyRuleInfoList(TeaModel):
    def __init__(
        self,
        rule_info: List[DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo] = None,
    ):
        self.rule_info = rule_info

    def validate(self):
        if self.rule_info:
            for k in self.rule_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RuleInfo'] = []
        if self.rule_info is not None:
            for k in self.rule_info:
                result['RuleInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rule_info = []
        if m.get('RuleInfo') is not None:
            for k in m.get('RuleInfo'):
                temp_model = DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo()
                self.rule_info.append(temp_model.from_map(k))
        return self


class DescribeLiveAIProduceRulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_info_list: DescribeLiveAIProduceRulesResponseBodyRuleInfoList = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The subtitle rules.
        self.rule_info_list = rule_info_list

    def validate(self):
        if self.rule_info_list:
            self.rule_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_info_list is not None:
            result['RuleInfoList'] = self.rule_info_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleInfoList') is not None:
            temp_model = DescribeLiveAIProduceRulesResponseBodyRuleInfoList()
            self.rule_info_list = temp_model.from_map(m['RuleInfoList'])
        return self


class DescribeLiveAIProduceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveAIProduceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveAIProduceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveAIStudioRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        studio_id: str = None,
        studio_name: str = None,
    ):
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: 1 to 50.
        self.page_size = page_size
        self.region_id = region_id
        # The ID of the virtual studio template that you want to query. This parameter is optional.
        self.studio_id = studio_id
        # The name of the virtual studio template.
        self.studio_name = studio_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_id is not None:
            result['StudioId'] = self.studio_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioId') is not None:
            self.studio_id = m.get('StudioId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        return self


class DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds(TeaModel):
    def __init__(
        self,
        rule_id: List[str] = None,
    ):
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['ruleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ruleId') is not None:
            self.rule_id = m.get('ruleId')
        return self


class DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig(TeaModel):
    def __init__(
        self,
        background_resource_id: str = None,
        background_resource_url: str = None,
        background_type: str = None,
        description: str = None,
        height: str = None,
        matting_layout: str = None,
        matting_type: str = None,
        media_layout: str = None,
        media_resource_id: str = None,
        media_resource_url: str = None,
        media_type: str = None,
        rule_ids: DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds = None,
        template_id: str = None,
        template_name: str = None,
        width: str = None,
    ):
        # The ID of the background material.
        self.background_resource_id = background_resource_id
        # The URL of the background material. Make sure that the URL is accessible over the Internet. Either this parameter or the BackgroundResourceId parameter is returned.
        self.background_resource_url = background_resource_url
        # The type of the background material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.background_type = background_type
        # The custom description.
        self.description = description
        # The preview height. Unit: pixels.
        # 
        # The following preview specifications (width  height) are supported:
        # 
        # *   Landscape low definition 360p (640360)
        # *   Portrait low definition 360p (360640)
        # *   Landscape standard definition 480p (854480)
        # *   Portrait standard definition 480p (480854)
        # *   Landscape high definition 720p (1280720)
        # *   Portrait high definition 720p (7201280)
        # *   Landscape ultra-high definition 1080p (19201080)
        # *   Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The layout information of the multimedia material.
        self.matting_layout = matting_layout
        # The type of chroma key that is performed on ingested streams. Valid values:
        # 
        # *   green: green-key chroma key
        # *   blue: blue-screen chroma key
        # *   complex: background replacement
        self.matting_type = matting_type
        # LIVE, live streaming
        self.media_layout = media_layout
        # The ID of the multimedia material in ApsaraVideo VOD.
        self.media_resource_id = media_resource_id
        # The URL of the multimedia material.
        self.media_resource_url = media_resource_url
        # The type of the multimedia material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.media_type = media_type
        # The IDs of the bound rules.
        self.rule_ids = rule_ids
        # The ID of the virtual studio template.
        self.template_id = template_id
        # The name of the virtual studio template. The name is the same as the value of the StudioName parameter that was specified when you called the CreateLiveAiStudio operation to create the virtual studio template.
        self.template_name = template_name
        # The preview width.
        self.width = width

    def validate(self):
        if self.rule_ids:
            self.rule_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_resource_id is not None:
            result['BackgroundResourceId'] = self.background_resource_id
        if self.background_resource_url is not None:
            result['BackgroundResourceUrl'] = self.background_resource_url
        if self.background_type is not None:
            result['BackgroundType'] = self.background_type
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.matting_layout is not None:
            result['MattingLayout'] = self.matting_layout
        if self.matting_type is not None:
            result['MattingType'] = self.matting_type
        if self.media_layout is not None:
            result['MediaLayout'] = self.media_layout
        if self.media_resource_id is not None:
            result['MediaResourceId'] = self.media_resource_id
        if self.media_resource_url is not None:
            result['MediaResourceUrl'] = self.media_resource_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundResourceId') is not None:
            self.background_resource_id = m.get('BackgroundResourceId')
        if m.get('BackgroundResourceUrl') is not None:
            self.background_resource_url = m.get('BackgroundResourceUrl')
        if m.get('BackgroundType') is not None:
            self.background_type = m.get('BackgroundType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MattingLayout') is not None:
            self.matting_layout = m.get('MattingLayout')
        if m.get('MattingType') is not None:
            self.matting_type = m.get('MattingType')
        if m.get('MediaLayout') is not None:
            self.media_layout = m.get('MediaLayout')
        if m.get('MediaResourceId') is not None:
            self.media_resource_id = m.get('MediaResourceId')
        if m.get('MediaResourceUrl') is not None:
            self.media_resource_url = m.get('MediaResourceUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('RuleIds') is not None:
            temp_model = DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds()
            self.rule_ids = temp_model.from_map(m['RuleIds'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class DescribeLiveAIStudioResponseBodyStudioConfigs(TeaModel):
    def __init__(
        self,
        subtitle_config: List[DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig] = None,
    ):
        self.subtitle_config = subtitle_config

    def validate(self):
        if self.subtitle_config:
            for k in self.subtitle_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleConfig'] = []
        if self.subtitle_config is not None:
            for k in self.subtitle_config:
                result['SubtitleConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_config = []
        if m.get('SubtitleConfig') is not None:
            for k in m.get('SubtitleConfig'):
                temp_model = DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig()
                self.subtitle_config.append(temp_model.from_map(k))
        return self


class DescribeLiveAIStudioResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        studio_configs: DescribeLiveAIStudioResponseBodyStudioConfigs = None,
        total: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page. Default value: 10. Valid values: 1 to 50.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The virtual studio templates.
        self.studio_configs = studio_configs
        # The total number of templates.
        self.total = total

    def validate(self):
        if self.studio_configs:
            self.studio_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.studio_configs is not None:
            result['StudioConfigs'] = self.studio_configs.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StudioConfigs') is not None:
            temp_model = DescribeLiveAIStudioResponseBodyStudioConfigs()
            self.studio_configs = temp_model.from_map(m['StudioConfigs'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveAIStudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveAIStudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveAIStudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveAISubtitleRequest(TeaModel):
    def __init__(
        self,
        is_default: bool = None,
        owner_id: int = None,
        page_number: str = None,
        page_size: str = None,
        region_id: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
    ):
        # Specifies whether to query the default subtitle template. Valid values:
        # 
        # *   true
        # 
        # *   false
        # 
        #     **\
        # 
        #     **Note **The default template includes the built-in parameter configurations. You can specify the copyFrom parameter when you call the AddLiveAISubtitle operation to use the default template.
        self.is_default = is_default
        self.owner_id = owner_id
        # The page number. Valid values: [1,100].
        self.page_number = page_number
        # The number of entries per page. Valid values: [1,100].
        self.page_size = page_size
        self.region_id = region_id
        # The ID of the subtitle template.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.
        self.subtitle_name = subtitle_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        return self


class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized(TeaModel):
    def __init__(
        self,
        position: List[float] = None,
    ):
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer(TeaModel):
    def __init__(
        self,
        rules_id: List[str] = None,
    ):
        self.rules_id = rules_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        return self


class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        bg_width_normalized: float = None,
        border_width_normalized: float = None,
        description: str = None,
        dst_language: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size_normalized: str = None,
        height: str = None,
        max_lines: int = None,
        position_normalized: DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized = None,
        rules_refer: DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer = None,
        show_source_lan: int = None,
        src_language: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
        width: str = None,
        word_perline: int = None,
    ):
        # The background color of the subtitles.
        self.bg_color = bg_color
        # The size of the background image.
        self.bg_width_normalized = bg_width_normalized
        # The font weight.
        self.border_width_normalized = border_width_normalized
        # The description of the template.
        self.description = description
        # The language to which the subtitles are translated.
        self.dst_language = dst_language
        # The font color.
        self.font_color = font_color
        # The font.
        self.font_name = font_name
        # The font size.
        self.font_size_normalized = font_size_normalized
        # The height of the preview image.
        self.height = height
        # The number of displayed lines.
        self.max_lines = max_lines
        # The position of the subtitles.
        self.position_normalized = position_normalized
        # The ID of the subtitle rule.
        self.rules_refer = rules_refer
        # Indicates whether the source language of the subtitle is displayed.
        self.show_source_lan = show_source_lan
        # The source language of the subtitles.
        self.src_language = src_language
        # The ID of the subtitle template.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template.
        self.subtitle_name = subtitle_name
        # The width of the preview image.
        self.width = width
        # The number of words per line.
        self.word_perline = word_perline

    def validate(self):
        if self.position_normalized:
            self.position_normalized.validate()
        if self.rules_refer:
            self.rules_refer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.bg_width_normalized is not None:
            result['BgWidthNormalized'] = self.bg_width_normalized
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.description is not None:
            result['Description'] = self.description
        if self.dst_language is not None:
            result['DstLanguage'] = self.dst_language
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size_normalized is not None:
            result['FontSizeNormalized'] = self.font_size_normalized
        if self.height is not None:
            result['Height'] = self.height
        if self.max_lines is not None:
            result['MaxLines'] = self.max_lines
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized.to_map()
        if self.rules_refer is not None:
            result['RulesRefer'] = self.rules_refer.to_map()
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.src_language is not None:
            result['SrcLanguage'] = self.src_language
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.width is not None:
            result['Width'] = self.width
        if self.word_perline is not None:
            result['WordPerline'] = self.word_perline
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BgWidthNormalized') is not None:
            self.bg_width_normalized = m.get('BgWidthNormalized')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DstLanguage') is not None:
            self.dst_language = m.get('DstLanguage')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSizeNormalized') is not None:
            self.font_size_normalized = m.get('FontSizeNormalized')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxLines') is not None:
            self.max_lines = m.get('MaxLines')
        if m.get('PositionNormalized') is not None:
            temp_model = DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized()
            self.position_normalized = temp_model.from_map(m['PositionNormalized'])
        if m.get('RulesRefer') is not None:
            temp_model = DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer()
            self.rules_refer = temp_model.from_map(m['RulesRefer'])
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SrcLanguage') is not None:
            self.src_language = m.get('SrcLanguage')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WordPerline') is not None:
            self.word_perline = m.get('WordPerline')
        return self


class DescribeLiveAISubtitleResponseBodySubtitleConfigs(TeaModel):
    def __init__(
        self,
        subtitle_config: List[DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig] = None,
    ):
        self.subtitle_config = subtitle_config

    def validate(self):
        if self.subtitle_config:
            for k in self.subtitle_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubtitleConfig'] = []
        if self.subtitle_config is not None:
            for k in self.subtitle_config:
                result['SubtitleConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subtitle_config = []
        if m.get('SubtitleConfig') is not None:
            for k in m.get('SubtitleConfig'):
                temp_model = DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig()
                self.subtitle_config.append(temp_model.from_map(k))
        return self


class DescribeLiveAISubtitleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subtitle_configs: DescribeLiveAISubtitleResponseBodySubtitleConfigs = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The information about the subtitle templates.
        self.subtitle_configs = subtitle_configs

    def validate(self):
        if self.subtitle_configs:
            self.subtitle_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.subtitle_configs is not None:
            result['SubtitleConfigs'] = self.subtitle_configs.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubtitleConfigs') is not None:
            temp_model = DescribeLiveAISubtitleResponseBodySubtitleConfigs()
            self.subtitle_configs = temp_model.from_map(m['SubtitleConfigs'])
        return self


class DescribeLiveAISubtitleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveAISubtitleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveAISubtitleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveAudioAuditConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes(TeaModel):
    def __init__(
        self,
        scene: List[str] = None,
    ):
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        biz_type: str = None,
        domain_name: str = None,
        scenes: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The business type. You can specify a model. The default value is the domain name.
        self.biz_type = biz_type
        # The main streaming domain.
        self.domain_name = domain_name
        # The moderation scenarios.
        self.scenes = scenes
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        if self.scenes:
            self.scenes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.scenes is not None:
            result['Scenes'] = self.scenes.to_map()
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Scenes') is not None:
            temp_model = DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes()
            self.scenes = temp_model.from_map(m['Scenes'])
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList(TeaModel):
    def __init__(
        self,
        live_audio_audit_config: List[DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig] = None,
    ):
        self.live_audio_audit_config = live_audio_audit_config

    def validate(self):
        if self.live_audio_audit_config:
            for k in self.live_audio_audit_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveAudioAuditConfig'] = []
        if self.live_audio_audit_config is not None:
            for k in self.live_audio_audit_config:
                result['LiveAudioAuditConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_audio_audit_config = []
        if m.get('LiveAudioAuditConfig') is not None:
            for k in m.get('LiveAudioAuditConfig'):
                temp_model = DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig()
                self.live_audio_audit_config.append(temp_model.from_map(k))
        return self


class DescribeLiveAudioAuditConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_audio_audit_config_list: DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList = None,
        request_id: str = None,
    ):
        # The list of audio moderation configurations.
        self.live_audio_audit_config_list = live_audio_audit_config_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_audio_audit_config_list:
            self.live_audio_audit_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_audio_audit_config_list is not None:
            result['LiveAudioAuditConfigList'] = self.live_audio_audit_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveAudioAuditConfigList') is not None:
            temp_model = DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList()
            self.live_audio_audit_config_list = temp_model.from_map(m['LiveAudioAuditConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveAudioAuditConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveAudioAuditConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveAudioAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveAudioAuditNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig(TeaModel):
    def __init__(
        self,
        callback: str = None,
        callback_template: str = None,
        domain_name: str = None,
    ):
        # The callback URL.
        self.callback = callback
        # The callback template. The following fields are configured:
        # 
        # *   **{DomainName}**: the streaming domain.
        # *   **{AppName}**: the name of the application to which the live stream belongs.
        # *   **{StreamName}**: the name of the live stream.
        # *   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
        # *   **{Result}**: the moderation results.
        self.callback_template = callback_template
        # The main streaming domain.
        self.domain_name = domain_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.callback_template is not None:
            result['CallbackTemplate'] = self.callback_template
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('CallbackTemplate') is not None:
            self.callback_template = m.get('CallbackTemplate')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        return self


class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList(TeaModel):
    def __init__(
        self,
        live_audio_audit_notify_config: List[DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig] = None,
    ):
        self.live_audio_audit_notify_config = live_audio_audit_notify_config

    def validate(self):
        if self.live_audio_audit_notify_config:
            for k in self.live_audio_audit_notify_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveAudioAuditNotifyConfig'] = []
        if self.live_audio_audit_notify_config is not None:
            for k in self.live_audio_audit_notify_config:
                result['LiveAudioAuditNotifyConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_audio_audit_notify_config = []
        if m.get('LiveAudioAuditNotifyConfig') is not None:
            for k in m.get('LiveAudioAuditNotifyConfig'):
                temp_model = DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig()
                self.live_audio_audit_notify_config.append(temp_model.from_map(k))
        return self


class DescribeLiveAudioAuditNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_audio_audit_notify_config_list: DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList = None,
        request_id: str = None,
    ):
        # The configuration of callbacks for audio moderation results.
        self.live_audio_audit_notify_config_list = live_audio_audit_notify_config_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_audio_audit_notify_config_list:
            self.live_audio_audit_notify_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_audio_audit_notify_config_list is not None:
            result['LiveAudioAuditNotifyConfigList'] = self.live_audio_audit_notify_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveAudioAuditNotifyConfigList') is not None:
            temp_model = DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList()
            self.live_audio_audit_notify_config_list = temp_model.from_map(m['LiveAudioAuditNotifyConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveAudioAuditNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveAudioAuditNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveAudioAuditNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveCdnDiagnoseInfoRequest(TeaModel):
    def __init__(
        self,
        security_token: str = None,
        app: str = None,
        domain: str = None,
        end_time: int = None,
        interval_type: str = None,
        phase: int = None,
        request_type: str = None,
        start_time: int = None,
        stream_name: str = None,
        stream_suffix: str = None,
    ):
        self.security_token = security_token
        # This parameter is required.
        self.app = app
        # This parameter is required.
        self.domain = domain
        # This parameter is required.
        self.end_time = end_time
        self.interval_type = interval_type
        # This parameter is required.
        self.phase = phase
        self.request_type = request_type
        # This parameter is required.
        self.start_time = start_time
        # This parameter is required.
        self.stream_name = stream_name
        # This parameter is required.
        self.stream_suffix = stream_suffix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.app is not None:
            result['app'] = self.app
        if self.domain is not None:
            result['domain'] = self.domain
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.interval_type is not None:
            result['intervalType'] = self.interval_type
        if self.phase is not None:
            result['phase'] = self.phase
        if self.request_type is not None:
            result['requestType'] = self.request_type
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.stream_name is not None:
            result['streamName'] = self.stream_name
        if self.stream_suffix is not None:
            result['streamSuffix'] = self.stream_suffix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('intervalType') is not None:
            self.interval_type = m.get('intervalType')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('requestType') is not None:
            self.request_type = m.get('requestType')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('streamName') is not None:
            self.stream_name = m.get('streamName')
        if m.get('streamSuffix') is not None:
            self.stream_suffix = m.get('streamSuffix')
        return self


class DescribeLiveCdnDiagnoseInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveCdnDiagnoseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveCdnDiagnoseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveCdnDiagnoseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveCenterStreamRateDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveCenterStreamRateDataResponseBodyRateDatas(TeaModel):
    def __init__(
        self,
        audio_fps: str = None,
        audio_rate: str = None,
        time: str = None,
        video_fps: str = None,
        video_rate: str = None,
    ):
        # The audio frame rate.
        self.audio_fps = audio_fps
        # The audio bitrate.
        self.audio_rate = audio_rate
        # The time when the data was collected. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time = time
        # The video frame rate.
        self.video_fps = video_fps
        # The video bitrate.
        self.video_rate = video_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_fps is not None:
            result['AudioFps'] = self.audio_fps
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.time is not None:
            result['Time'] = self.time
        if self.video_fps is not None:
            result['VideoFps'] = self.video_fps
        if self.video_rate is not None:
            result['VideoRate'] = self.video_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFps') is not None:
            self.audio_fps = m.get('AudioFps')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('VideoFps') is not None:
            self.video_fps = m.get('VideoFps')
        if m.get('VideoRate') is not None:
            self.video_rate = m.get('VideoRate')
        return self


class DescribeLiveCenterStreamRateDataResponseBody(TeaModel):
    def __init__(
        self,
        rate_datas: List[DescribeLiveCenterStreamRateDataResponseBodyRateDatas] = None,
        request_id: str = None,
    ):
        # The list of frame rates and bitrates.
        self.rate_datas = rate_datas
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.rate_datas:
            for k in self.rate_datas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RateDatas'] = []
        if self.rate_datas is not None:
            for k in self.rate_datas:
                result['RateDatas'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rate_datas = []
        if m.get('RateDatas') is not None:
            for k in m.get('RateDatas'):
                temp_model = DescribeLiveCenterStreamRateDataResponseBodyRateDatas()
                self.rate_datas.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveCenterStreamRateDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveCenterStreamRateDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveCenterStreamRateDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveCenterTransferRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        dst_url: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The third-party URL to which the live stream is relayed.
        self.dst_url = dst_url
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        dst_url: str = None,
        end_time: str = None,
        start_time: str = None,
        stream_name: str = None,
        transfer_args: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The streaming domain.
        self.domain_name = domain_name
        # The third-party URL to which the live stream is relayed.
        self.dst_url = dst_url
        # The end time of stream relay.
        self.end_time = end_time
        # The start time of stream relay.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The validity period of stream relay. Valid values:
        # 
        # *   **always**: The stream can always be relayed.
        # *   **time**: The stream can be relayed in a specified time period.
        self.transfer_args = transfer_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transfer_args is not None:
            result['TransferArgs'] = self.transfer_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TransferArgs') is not None:
            self.transfer_args = m.get('TransferArgs')
        return self


class DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList(TeaModel):
    def __init__(
        self,
        live_center_transfer_info: List[DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo] = None,
    ):
        self.live_center_transfer_info = live_center_transfer_info

    def validate(self):
        if self.live_center_transfer_info:
            for k in self.live_center_transfer_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveCenterTransferInfo'] = []
        if self.live_center_transfer_info is not None:
            for k in self.live_center_transfer_info:
                result['LiveCenterTransferInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_center_transfer_info = []
        if m.get('LiveCenterTransferInfo') is not None:
            for k in m.get('LiveCenterTransferInfo'):
                temp_model = DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo()
                self.live_center_transfer_info.append(temp_model.from_map(k))
        return self


class DescribeLiveCenterTransferResponseBody(TeaModel):
    def __init__(
        self,
        live_center_transfer_info_list: DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList = None,
        request_id: str = None,
    ):
        # The stream relay information.
        self.live_center_transfer_info_list = live_center_transfer_info_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_center_transfer_info_list:
            self.live_center_transfer_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_center_transfer_info_list is not None:
            result['LiveCenterTransferInfoList'] = self.live_center_transfer_info_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveCenterTransferInfoList') is not None:
            temp_model = DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList()
            self.live_center_transfer_info_list = temp_model.from_map(m['LiveCenterTransferInfoList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveCenterTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveCenterTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveCenterTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveCertificateDetailRequest(TeaModel):
    def __init__(
        self,
        cert_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The name of the certificate.
        # 
        # This parameter is required.
        self.cert_name = cert_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveCertificateDetailResponseBody(TeaModel):
    def __init__(
        self,
        cert: str = None,
        cert_id: int = None,
        cert_name: str = None,
        request_id: str = None,
    ):
        # The content of the certificate.
        self.cert = cert
        # The ID of the certificate.
        self.cert_id = cert_id
        # The name of the certificate.
        self.cert_name = cert_name
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert is not None:
            result['Cert'] = self.cert
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cert') is not None:
            self.cert = m.get('Cert')
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveCertificateDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveCertificateDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveCertificateDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveCertificateListRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ingest domain or streaming domain. Separate multiple domain names with commas (,).
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert(TeaModel):
    def __init__(
        self,
        cert_id: int = None,
        cert_name: str = None,
        common: str = None,
        fingerprint: str = None,
        issuer: str = None,
        last_time: int = None,
    ):
        # The ID of the certificate.
        self.cert_id = cert_id
        # The name of the certificate.
        self.cert_name = cert_name
        # The Common Name (CN) attribute of the certificate.
        self.common = common
        # The fingerprint of the certificate.
        self.fingerprint = fingerprint
        # The certificate authority (CA) that issued the certificate.
        self.issuer = issuer
        # The time when the certificate was issued. Unit: seconds.
        self.last_time = last_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertId'] = self.cert_id
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.common is not None:
            result['Common'] = self.common
        if self.fingerprint is not None:
            result['Fingerprint'] = self.fingerprint
        if self.issuer is not None:
            result['Issuer'] = self.issuer
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertId') is not None:
            self.cert_id = m.get('CertId')
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('Common') is not None:
            self.common = m.get('Common')
        if m.get('Fingerprint') is not None:
            self.fingerprint = m.get('Fingerprint')
        if m.get('Issuer') is not None:
            self.issuer = m.get('Issuer')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        return self


class DescribeLiveCertificateListResponseBodyCertificateListModelCertList(TeaModel):
    def __init__(
        self,
        cert: List[DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert] = None,
    ):
        self.cert = cert

    def validate(self):
        if self.cert:
            for k in self.cert:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cert'] = []
        if self.cert is not None:
            for k in self.cert:
                result['Cert'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cert = []
        if m.get('Cert') is not None:
            for k in m.get('Cert'):
                temp_model = DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert()
                self.cert.append(temp_model.from_map(k))
        return self


class DescribeLiveCertificateListResponseBodyCertificateListModel(TeaModel):
    def __init__(
        self,
        cert_list: DescribeLiveCertificateListResponseBodyCertificateListModelCertList = None,
        count: int = None,
    ):
        # The certificates.
        self.cert_list = cert_list
        # The number of certificates.
        self.count = count

    def validate(self):
        if self.cert_list:
            self.cert_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_list is not None:
            result['CertList'] = self.cert_list.to_map()
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertList') is not None:
            temp_model = DescribeLiveCertificateListResponseBodyCertificateListModelCertList()
            self.cert_list = temp_model.from_map(m['CertList'])
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class DescribeLiveCertificateListResponseBody(TeaModel):
    def __init__(
        self,
        certificate_list_model: DescribeLiveCertificateListResponseBodyCertificateListModel = None,
        request_id: str = None,
    ):
        # The details.
        self.certificate_list_model = certificate_list_model
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.certificate_list_model:
            self.certificate_list_model.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.certificate_list_model is not None:
            result['CertificateListModel'] = self.certificate_list_model.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertificateListModel') is not None:
            temp_model = DescribeLiveCertificateListResponseBodyCertificateListModel()
            self.certificate_list_model = temp_model.from_map(m['CertificateListModel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveCertificateListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveCertificateListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveCertificateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDelayConfigRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name.
        # 
        # This parameter is required.
        self.app = app
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application.
        # 
        # This parameter is required.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeLiveDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        app: str = None,
        delay_time: str = None,
        domain: str = None,
        request_id: str = None,
        stream: str = None,
        task_trigger_mode: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The duration for which the playback of the live stream is delayed.
        self.delay_time = delay_time
        # The main streaming domain.
        self.domain = domain
        # The request ID.
        self.request_id = request_id
        # The name of the live stream.
        self.stream = stream
        # The trigger mode. Valid values:
        # 
        # *   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
        # *   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
        # *   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.
        self.task_trigger_mode = task_trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.task_trigger_mode is not None:
            result['TaskTriggerMode'] = self.task_trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TaskTriggerMode') is not None:
            self.task_trigger_mode = m.get('TaskTriggerMode')
        return self


class DescribeLiveDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDelayedStreamingUsageRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. We recommend that you specify a time range that is less than or equal to 10 hours.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   300
        # *   3600
        # *   86400
        # 
        # If you specify an invalid value or do not specify this parameter, the default value 3600 is used.
        self.interval = interval
        self.owner_id = owner_id
        # The ID of the region. Separate multiple region IDs with commas (,). Valid values:
        # 
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # *   cn-shenzhen: China (Shenzhen)
        # *   cn-qingdao: China (Qingdao)
        # *   ap-southeast-1: Singapore
        # *   eu-central-1: Germany (Frankfurt)
        # *   ap-northeast-1: Japan (Tokyo)
        # *   ap-southeast-5: Indonesia (Jakarta)
        # 
        # If you leave this parameter empty, data of all regions is aggregated and returned by default.
        self.region = region
        self.region_id = region_id
        # The key that is used to group data. If you leave this parameter empty, data is aggregated and returned. Valid values:
        # 
        # *   domain: The DomainName parameter in the response takes effect only if SplitBy is set to domain.
        # *   region: The Region parameter in the response takes effect only if SplitBy is set to region.
        # *   stream: The StreamName parameter in the response takes effect only if SplitBy is set to stream.
        # 
        # >  This parameter takes effect only if the parameter corresponding to the value of this parameter is not left empty. Otherwise, an error is returned. For example, you cannot set this parameter to domain if the DomainName parameter is left empty.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. By default, data in the last seven days is returned.
        self.start_time = start_time
        # The name of the stream. Separate multiple stream names with commas (,). By default, data of all streams is aggregated and returned.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        duration: int = None,
        region: str = None,
        stream_name: str = None,
        time_stamp: str = None,
    ):
        # The domain name. If SplitBy is set to domain, the data returned is grouped by domain name.
        self.domain_name = domain_name
        # The duration of stream delay.
        self.duration = duration
        # The ID of the region. If SplitBy is set to region, the data returned is grouped by region.
        self.region = region
        # The name of the stream. If SplitBy is set to stream, the data returned is grouped by stream.
        self.stream_name = stream_name
        # The timestamp of the data returned.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.region is not None:
            result['Region'] = self.region
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDelayedStreamingUsageResponseBodyDelayData(TeaModel):
    def __init__(
        self,
        delay_data_item: List[DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem] = None,
    ):
        self.delay_data_item = delay_data_item

    def validate(self):
        if self.delay_data_item:
            for k in self.delay_data_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DelayDataItem'] = []
        if self.delay_data_item is not None:
            for k in self.delay_data_item:
                result['DelayDataItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.delay_data_item = []
        if m.get('DelayDataItem') is not None:
            for k in m.get('DelayDataItem'):
                temp_model = DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem()
                self.delay_data_item.append(temp_model.from_map(k))
        return self


class DescribeLiveDelayedStreamingUsageResponseBody(TeaModel):
    def __init__(
        self,
        delay_data: DescribeLiveDelayedStreamingUsageResponseBodyDelayData = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The details about the stream delay usage data.
        self.delay_data = delay_data
        # The end of the time range during which the data was queried.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.delay_data:
            self.delay_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay_data is not None:
            result['DelayData'] = self.delay_data.to_map()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DelayData') is not None:
            temp_model = DescribeLiveDelayedStreamingUsageResponseBodyDelayData()
            self.delay_data = temp_model.from_map(m['DelayData'])
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDelayedStreamingUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDelayedStreamingUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDelayedStreamingUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDetectNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_url: str = None,
    ):
        # The main streaming domain.
        self.domain_name = domain_name
        # The callback URL.
        self.notify_url = notify_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        return self


class DescribeLiveDetectNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_detect_notify_config: DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig = None,
        request_id: str = None,
    ):
        # The callback configuration.
        self.live_detect_notify_config = live_detect_notify_config
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.live_detect_notify_config:
            self.live_detect_notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_detect_notify_config is not None:
            result['LiveDetectNotifyConfig'] = self.live_detect_notify_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveDetectNotifyConfig') is not None:
            temp_model = DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig()
            self.live_detect_notify_config = temp_model.from_map(m['LiveDetectNotifyConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDetectNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDetectNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDetectNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDetectPornDataRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain_name: str = None,
        end_time: str = None,
        fee: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        scene: str = None,
        split_by: str = None,
        start_time: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you do not specify this parameter, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # Specifies whether a quota of free image scanning is available. Valid values:
        # 
        # *   **free**: specifies that a quota of free image scanning is available.
        # *   **charge**: specifies that a quota of free image scanning is not available and fees are charged.
        self.fee = fee
        self.owner_id = owner_id
        # The ID of the region where the domain name resides.
        self.region = region
        self.region_id = region_id
        # The moderation scenario. Valid values:
        # 
        # *   **porn**: pornography detection. This is the default value.
        # *   **terrorism**: terrorism detection
        # *   **ad**: ad violation detection
        # *   **live**: undesirable scene detection
        # *   **logo**: logo detection
        self.scene = scene
        # The fields based on which data is grouped. Separate multiple fields with commas (,).
        # 
        # > If you leave the **SplitBy** parameter empty, only the **TimeStamp** and **Count** parameters are returned.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # > 
        # 
        # *   You can query data in the last 90 days.
        # 
        # *   The minimum data granularity is 5 minutes. If you do not specify this parameter, data in the last 24 hours is queried.
        self.start_time = start_time
        # The name of the live stream.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.fee is not None:
            result['Fee'] = self.fee
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Fee') is not None:
            self.fee = m.get('Fee')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule(TeaModel):
    def __init__(
        self,
        app: str = None,
        count: int = None,
        domain: str = None,
        fee: str = None,
        region: str = None,
        scene: str = None,
        stream: str = None,
        time_stamp: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The number of reviewed images.
        self.count = count
        # The main streaming domain.
        self.domain = domain
        # Indicates whether a quota of free image scanning is available. Valid values:
        # 
        # *   **free**\
        # *   **charge**\
        self.fee = fee
        # The region in which the domain name resides.
        self.region = region
        # The moderation scenario. Valid values:
        # 
        # *   **porn** (default): pornography
        # *   **terrorism**: terrorism or politically sensitive content
        # *   **ad**: ad violation
        # *   **live**: undesirable scene
        # *   **logo**\
        self.scene = scene
        # The name of the live stream.
        self.stream = stream
        # The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.count is not None:
            result['Count'] = self.count
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.fee is not None:
            result['Fee'] = self.fee
        if self.region is not None:
            result['Region'] = self.region
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Fee') is not None:
            self.fee = m.get('Fee')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDetectPornDataResponseBodyDetectPornData(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDetectPornDataResponseBody(TeaModel):
    def __init__(
        self,
        detect_porn_data: DescribeLiveDetectPornDataResponseBodyDetectPornData = None,
        request_id: str = None,
    ):
        # The bandwidth data returned at each interval.
        self.detect_porn_data = detect_porn_data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.detect_porn_data:
            self.detect_porn_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detect_porn_data is not None:
            result['DetectPornData'] = self.detect_porn_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DetectPornData') is not None:
            temp_model = DescribeLiveDetectPornDataResponseBodyDetectPornData()
            self.detect_porn_data = temp_model.from_map(m['DetectPornData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDetectPornDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDetectPornDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDetectPornDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainBpsDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain. You can query one or more domain names. If you specify multiple domain names, separate them with commas (,). If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300** (default)
        # *   **3600**\
        # *   **86400**\
        # 
        # > 
        # 
        # *   If you specify an invalid value or do not specify this parameter, the default value **300** is used.
        # 
        # *   When the time granularity is **300** seconds, the returned bandwidth is the average bandwidth within the 300 seconds.
        # *   When the time granularity is **3600** or **86400** seconds, the returned bandwidth is the peak value of all average bandwidths within each 300-second period.
        self.interval = interval
        # The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs.
        self.isp_name_en = isp_name_en
        # The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        bps_value: str = None,
        http_bps_value: str = None,
        https_bps_value: str = None,
        time_stamp: str = None,
    ):
        # The bandwidth. Unit: bit/s.
        self.bps_value = bps_value
        # The bandwidth over HTTP. Unit: bit/s.
        self.http_bps_value = http_bps_value
        # The bandwidth over HTTPS. Unit: bit/s.
        self.https_bps_value = https_bps_value
        # The timestamp of the data returned.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bps_value is not None:
            result['BpsValue'] = self.bps_value
        if self.http_bps_value is not None:
            result['HttpBpsValue'] = self.http_bps_value
        if self.https_bps_value is not None:
            result['HttpsBpsValue'] = self.https_bps_value
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BpsValue') is not None:
            self.bps_value = m.get('BpsValue')
        if m.get('HttpBpsValue') is not None:
            self.http_bps_value = m.get('HttpBpsValue')
        if m.get('HttpsBpsValue') is not None:
            self.https_bps_value = m.get('HttpsBpsValue')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainBpsDataResponseBody(TeaModel):
    def __init__(
        self,
        bps_data_per_interval: DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval = None,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The bandwidth data returned at each interval.
        self.bps_data_per_interval = bps_data_per_interval
        # The time granularity of the query. Unit: seconds.
        self.data_interval = data_interval
        # The streaming domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.bps_data_per_interval:
            self.bps_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bps_data_per_interval is not None:
            result['BpsDataPerInterval'] = self.bps_data_per_interval.to_map()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BpsDataPerInterval') is not None:
            temp_model = DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval()
            self.bps_data_per_interval = temp_model.from_map(m['BpsDataPerInterval'])
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainBpsDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainBpsDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainBpsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainBpsDataByLayerRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        isp_name_en: str = None,
        layer: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain. You can specify multiple domain names by separating them with commas (,). If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-ddTHH:mm:ssZ* format. The time must be displayed in UTC.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300**\
        # *   **3600**\
        # *   **86400**\
        # 
        # > 
        # 
        # *   If the time range specified by the StartTime and EndTime parameters is smaller than or equal to 3 days, the supported time granularities include 300, 3,600, and 86,400 seconds.
        # 
        # *   If the time range is larger than 3 days but smaller than or equal to 31 days, the supported time granularities include 3,600 and 86,400 seconds.
        # 
        # *   If the time range is larger than 31 days, the supported time granularity is 86,400 seconds.
        # 
        # *   If you specify an invalid value or do not specify this parameter, the default time granularity of 300 seconds is used.
        self.interval = interval
        # The name of the Internet service provider (ISP). If you do not specify this parameter, the data of all ISPs is returned.
        # 
        # >  You can call the [DescribeLiveRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query available regions and ISPs.
        self.isp_name_en = isp_name_en
        # The layer at which you want to query the data. Valid values:
        # 
        # *   IPv4 and IPv6 (network layer)
        # *   http, https, and quic (application layer)
        # *   all (default)
        self.layer = layer
        # The name of the region. If you do not specify this parameter, the data of all regions is returned.
        # 
        # >  You can call the [DescribeLiveRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query available regions and ISPs.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-ddTHH:mm:ssZ* format. The time must be displayed in UTC.
        # 
        # >  If you do not specify this parameter, the data of the last 24 hours is returned by default. The minimum time granularity is 5 minutes.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        traffic_value: str = None,
        value: str = None,
    ):
        # The timestamp of the data returned.
        self.time_stamp = time_stamp
        # The total traffic. Unit: bytes.
        self.traffic_value = traffic_value
        # The peak bandwidth. Unit: bit/s.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.traffic_value is not None:
            result['TrafficValue'] = self.traffic_value
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TrafficValue') is not None:
            self.traffic_value = m.get('TrafficValue')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainBpsDataByLayerResponseBody(TeaModel):
    def __init__(
        self,
        bps_data_interval: DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval = None,
        data_interval: str = None,
        request_id: str = None,
    ):
        # The data returned at each time interval.
        self.bps_data_interval = bps_data_interval
        # The time interval between the data entries returned. Unit: seconds.
        self.data_interval = data_interval
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.bps_data_interval:
            self.bps_data_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bps_data_interval is not None:
            result['BpsDataInterval'] = self.bps_data_interval.to_map()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BpsDataInterval') is not None:
            temp_model = DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval()
            self.bps_data_interval = temp_model.from_map(m['BpsDataInterval'])
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainBpsDataByLayerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainBpsDataByLayerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainBpsDataByLayerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainByCertificateRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        sslpub: str = None,
        sslstatus: bool = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The public key of the SSL certificate. You must Base64-encode the public key before you invoke the encodeURIComponent function to encode a URI component. The public key must be in the PEM format.
        # 
        # This parameter is required.
        self.sslpub = sslpub
        # Specifies whether to return only domain names with HTTPS enabled or disabled.
        # 
        # *   **true**: returns only domain names with HTTPS enabled.
        # *   **false**: The rule is disabled.
        self.sslstatus = sslstatus

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sslpub is not None:
            result['SSLPub'] = self.sslpub
        if self.sslstatus is not None:
            result['SSLStatus'] = self.sslstatus
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SSLPub') is not None:
            self.sslpub = m.get('SSLPub')
        if m.get('SSLStatus') is not None:
            self.sslstatus = m.get('SSLStatus')
        return self


class DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo(TeaModel):
    def __init__(
        self,
        cert_ca_is_legacy: str = None,
        cert_expire_time: str = None,
        cert_expired: str = None,
        cert_start_time: str = None,
        cert_subject_common_name: str = None,
        cert_type: str = None,
        domain_list: str = None,
        domain_names: str = None,
        issuer: str = None,
    ):
        # Indicates whether the SSL certificate is obsolete. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.cert_ca_is_legacy = cert_ca_is_legacy
        # The time at which the certificate expires.
        self.cert_expire_time = cert_expire_time
        # Indicates whether the SSL certificate is expired. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.cert_expired = cert_expired
        # The effective time of the certificate.
        self.cert_start_time = cert_start_time
        # The name of the SSL certificate owner.
        self.cert_subject_common_name = cert_subject_common_name
        # The type of the certificate. Valid values: **RSA**, **DSA**, and **ECDSA**.
        self.cert_type = cert_type
        # The list of domain names. If a value is returned, the value matches the SSL certificate. Multiple domain names are separated by commas (,).
        self.domain_list = domain_list
        # The domain names (DNS fields) that match the SSL certificate. Multiple domain names are separated by commas (,).
        self.domain_names = domain_names
        # The certificate authority (CA) that issued the SSL certificate.
        self.issuer = issuer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_ca_is_legacy is not None:
            result['CertCaIsLegacy'] = self.cert_ca_is_legacy
        if self.cert_expire_time is not None:
            result['CertExpireTime'] = self.cert_expire_time
        if self.cert_expired is not None:
            result['CertExpired'] = self.cert_expired
        if self.cert_start_time is not None:
            result['CertStartTime'] = self.cert_start_time
        if self.cert_subject_common_name is not None:
            result['CertSubjectCommonName'] = self.cert_subject_common_name
        if self.cert_type is not None:
            result['CertType'] = self.cert_type
        if self.domain_list is not None:
            result['DomainList'] = self.domain_list
        if self.domain_names is not None:
            result['DomainNames'] = self.domain_names
        if self.issuer is not None:
            result['Issuer'] = self.issuer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertCaIsLegacy') is not None:
            self.cert_ca_is_legacy = m.get('CertCaIsLegacy')
        if m.get('CertExpireTime') is not None:
            self.cert_expire_time = m.get('CertExpireTime')
        if m.get('CertExpired') is not None:
            self.cert_expired = m.get('CertExpired')
        if m.get('CertStartTime') is not None:
            self.cert_start_time = m.get('CertStartTime')
        if m.get('CertSubjectCommonName') is not None:
            self.cert_subject_common_name = m.get('CertSubjectCommonName')
        if m.get('CertType') is not None:
            self.cert_type = m.get('CertType')
        if m.get('DomainList') is not None:
            self.domain_list = m.get('DomainList')
        if m.get('DomainNames') is not None:
            self.domain_names = m.get('DomainNames')
        if m.get('Issuer') is not None:
            self.issuer = m.get('Issuer')
        return self


class DescribeLiveDomainByCertificateResponseBodyCertInfos(TeaModel):
    def __init__(
        self,
        cert_info: List[DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo] = None,
    ):
        self.cert_info = cert_info

    def validate(self):
        if self.cert_info:
            for k in self.cert_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CertInfo'] = []
        if self.cert_info is not None:
            for k in self.cert_info:
                result['CertInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cert_info = []
        if m.get('CertInfo') is not None:
            for k in m.get('CertInfo'):
                temp_model = DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo()
                self.cert_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainByCertificateResponseBody(TeaModel):
    def __init__(
        self,
        cert_infos: DescribeLiveDomainByCertificateResponseBodyCertInfos = None,
        request_id: str = None,
    ):
        # The information about the certificate.
        self.cert_infos = cert_infos
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.cert_infos:
            self.cert_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_infos is not None:
            result['CertInfos'] = self.cert_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertInfos') is not None:
            temp_model = DescribeLiveDomainByCertificateResponseBodyCertInfos()
            self.cert_infos = temp_model.from_map(m['CertInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainByCertificateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainByCertificateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainByCertificateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainCertificateInfoRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain or ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo(TeaModel):
    def __init__(
        self,
        cert_domain_name: str = None,
        cert_expire_time: str = None,
        cert_life: str = None,
        cert_name: str = None,
        cert_org: str = None,
        cert_type: str = None,
        domain_name: str = None,
        sslprotocol: str = None,
        sslpub: str = None,
        status: str = None,
    ):
        # The streaming domain or ingest domain that matches the certificate.
        self.cert_domain_name = cert_domain_name
        # The expiration time of the certificate. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.cert_expire_time = cert_expire_time
        # The validity period of the certificate.
        # 
        # *   If the validity period is greater than 12 months, XX years XX months is displayed. For example, 2 years 3 months indicates that the validity period is 2 years and 3 months.
        # *   If the validity period is less than 12 months, XX months is displayed. For example, 3 months indicates that the validity period is 3 months.
        self.cert_life = cert_life
        # The name of the certificate.
        self.cert_name = cert_name
        # The certificate authority (CA) that issued the certificate.
        self.cert_org = cert_org
        # The type of the certificate. Valid values:
        # 
        # *   **free**: a free certificate (for testing)
        # *   **cas**: a certificate that is purchased from Certificate Management Service
        # *   **upload**: a custom certificate that you uploaded
        self.cert_type = cert_type
        # The streaming domain or ingest domain.
        self.domain_name = domain_name
        # The status of HTTPS. Valid values:
        # 
        # *   **on**: HTTPS is enabled.
        # *   **off**: HTTPS is disabled.
        self.sslprotocol = sslprotocol
        # The public key of the certificate.
        self.sslpub = sslpub
        # The status of the free certificate that is used for testing. Valid values:
        # 
        # *   **success**: The certificate is effective.
        # *   **checking**: The system is checking whether the domain name is mapped to the CNAME that is assigned by ApsaraVideo Live.
        # *   **cname_error**: The domain name is not mapped to the CNAME that is assigned by ApsaraVideo Live.
        # *   **domain_invalid**: The domain name contains invalid characters.
        # *   **unsupport_wildcard**: The domain name is a wildcard domain name, which is not supported.
        # *   **applying**: The certificate is in the application progress.
        # *   **failed**: The application for the certificate failed.
        # 
        # >  The **Status** parameter is valid only if the certificate is a free certificate for testing. If the certificate is not a free certificate for testing, an empty value is returned.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_domain_name is not None:
            result['CertDomainName'] = self.cert_domain_name
        if self.cert_expire_time is not None:
            result['CertExpireTime'] = self.cert_expire_time
        if self.cert_life is not None:
            result['CertLife'] = self.cert_life
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.cert_org is not None:
            result['CertOrg'] = self.cert_org
        if self.cert_type is not None:
            result['CertType'] = self.cert_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.sslprotocol is not None:
            result['SSLProtocol'] = self.sslprotocol
        if self.sslpub is not None:
            result['SSLPub'] = self.sslpub
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertDomainName') is not None:
            self.cert_domain_name = m.get('CertDomainName')
        if m.get('CertExpireTime') is not None:
            self.cert_expire_time = m.get('CertExpireTime')
        if m.get('CertLife') is not None:
            self.cert_life = m.get('CertLife')
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('CertOrg') is not None:
            self.cert_org = m.get('CertOrg')
        if m.get('CertType') is not None:
            self.cert_type = m.get('CertType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('SSLProtocol') is not None:
            self.sslprotocol = m.get('SSLProtocol')
        if m.get('SSLPub') is not None:
            self.sslpub = m.get('SSLPub')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveDomainCertificateInfoResponseBodyCertInfos(TeaModel):
    def __init__(
        self,
        cert_info: List[DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo] = None,
    ):
        self.cert_info = cert_info

    def validate(self):
        if self.cert_info:
            for k in self.cert_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CertInfo'] = []
        if self.cert_info is not None:
            for k in self.cert_info:
                result['CertInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cert_info = []
        if m.get('CertInfo') is not None:
            for k in m.get('CertInfo'):
                temp_model = DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo()
                self.cert_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainCertificateInfoResponseBody(TeaModel):
    def __init__(
        self,
        cert_infos: DescribeLiveDomainCertificateInfoResponseBodyCertInfos = None,
        request_id: str = None,
    ):
        # The certificate information.
        self.cert_infos = cert_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.cert_infos:
            self.cert_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_infos is not None:
            result['CertInfos'] = self.cert_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertInfos') is not None:
            temp_model = DescribeLiveDomainCertificateInfoResponseBodyCertInfos()
            self.cert_infos = temp_model.from_map(m['CertInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainCertificateInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainCertificateInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainCertificateInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainConfigsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        function_names: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ingest domain or streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The names of the features. Separate multiple features with commas (,). For more information, see the **Features specified by the Functions parameter** section in this topic.
        # 
        # This parameter is required.
        self.function_names = function_names
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.function_names is not None:
            result['FunctionNames'] = self.function_names
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FunctionNames') is not None:
            self.function_names = m.get('FunctionNames')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(TeaModel):
    def __init__(
        self,
        arg_name: str = None,
        arg_value: str = None,
    ):
        # The name of the attribute.
        self.arg_name = arg_name
        # The attribute value.
        self.arg_value = arg_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arg_name is not None:
            result['ArgName'] = self.arg_name
        if self.arg_value is not None:
            result['ArgValue'] = self.arg_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArgName') is not None:
            self.arg_name = m.get('ArgName')
        if m.get('ArgValue') is not None:
            self.arg_value = m.get('ArgValue')
        return self


class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(TeaModel):
    def __init__(
        self,
        function_arg: List[DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg] = None,
    ):
        self.function_arg = function_arg

    def validate(self):
        if self.function_arg:
            for k in self.function_arg:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FunctionArg'] = []
        if self.function_arg is not None:
            for k in self.function_arg:
                result['FunctionArg'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.function_arg = []
        if m.get('FunctionArg') is not None:
            for k in m.get('FunctionArg'):
                temp_model = DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg()
                self.function_arg.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        function_args: DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs = None,
        function_name: str = None,
        status: str = None,
    ):
        # The configuration ID.
        self.config_id = config_id
        # The attributes of the feature.
        self.function_args = function_args
        # The name of the feature.
        self.function_name = function_name
        # The configuration status. Valid values:
        # 
        # *   **success**\
        # *   **testing**\
        # *   **failed**\
        # *   **configuring**\
        self.status = status

    def validate(self):
        if self.function_args:
            self.function_args.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.function_args is not None:
            result['FunctionArgs'] = self.function_args.to_map()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('FunctionArgs') is not None:
            temp_model = DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs()
            self.function_args = temp_model.from_map(m['FunctionArgs'])
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveDomainConfigsResponseBodyDomainConfigs(TeaModel):
    def __init__(
        self,
        domain_config: List[DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig] = None,
    ):
        self.domain_config = domain_config

    def validate(self):
        if self.domain_config:
            for k in self.domain_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainConfig'] = []
        if self.domain_config is not None:
            for k in self.domain_config:
                result['DomainConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_config = []
        if m.get('DomainConfig') is not None:
            for k in m.get('DomainConfig'):
                temp_model = DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig()
                self.domain_config.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainConfigsResponseBody(TeaModel):
    def __init__(
        self,
        domain_configs: DescribeLiveDomainConfigsResponseBodyDomainConfigs = None,
        request_id: str = None,
    ):
        # The configurations of the domain name.
        self.domain_configs = domain_configs
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.domain_configs:
            self.domain_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_configs is not None:
            result['DomainConfigs'] = self.domain_configs.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainConfigs') is not None:
            temp_model = DescribeLiveDomainConfigsResponseBodyDomainConfigs()
            self.domain_configs = temp_model.from_map(m['DomainConfigs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainDetailRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The streaming domain or ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveDomainDetailResponseBodyDomainDetail(TeaModel):
    def __init__(
        self,
        cert_name: str = None,
        cname: str = None,
        description: str = None,
        domain_name: str = None,
        domain_status: str = None,
        gmt_created: str = None,
        gmt_modified: str = None,
        live_domain_type: str = None,
        region: str = None,
        resource_group_id: str = None,
        sslprotocol: str = None,
        sslpub: str = None,
        scope: str = None,
    ):
        # The name of the certificate.
        self.cert_name = cert_name
        # The CNAME that is assigned to the domain name. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name to the CNAME.
        # 
        # >  A time-to-live (TTL) value is specified in the CNAME record of a domain name to indicate how long the CNAME record can be cached on the DNS resolver. If you modify the CNAME record of the domain name, the new settings take effect after the cache expires, which takes about 10 minutes. For more information, see [CNAME resolution](https://help.aliyun.com/document_detail/362010.html).
        self.cname = cname
        # The description of the domain name.
        self.description = description
        # The streaming domain or ingest domain.
        self.domain_name = domain_name
        # The status of the domain name. Valid values:
        # 
        # *   **online**: The domain name is enabled.
        # *   **offline**: The domain name is disabled.
        # *   **configuring**: The domain is being configured.
        self.domain_status = domain_status
        # The time when the domain name was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_created = gmt_created
        # The time when the domain name was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_modified = gmt_modified
        # The type of the domain name. Valid values:
        # 
        # *   **liveVideo**: streaming domain
        # *   **liveEdge**: ingest domain
        self.live_domain_type = live_domain_type
        # The ID of the region where the domain name resides.
        self.region = region
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether the SSL certificate is enabled. Valid values:
        # 
        # *   **on**\
        # *   **off**\
        self.sslprotocol = sslprotocol
        # The public key of the certificate.
        self.sslpub = sslpub
        # The acceleration region. Valid values:
        # 
        # *   **domestic**: regions in the Chinese mainland.
        # *   **overseas**: regions outside the Chinese mainland.
        # *   **global**: regions in and outside the Chinese mainland.
        self.scope = scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.cname is not None:
            result['Cname'] = self.cname
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_status is not None:
            result['DomainStatus'] = self.domain_status
        if self.gmt_created is not None:
            result['GmtCreated'] = self.gmt_created
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.live_domain_type is not None:
            result['LiveDomainType'] = self.live_domain_type
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sslprotocol is not None:
            result['SSLProtocol'] = self.sslprotocol
        if self.sslpub is not None:
            result['SSLPub'] = self.sslpub
        if self.scope is not None:
            result['Scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('Cname') is not None:
            self.cname = m.get('Cname')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainStatus') is not None:
            self.domain_status = m.get('DomainStatus')
        if m.get('GmtCreated') is not None:
            self.gmt_created = m.get('GmtCreated')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('LiveDomainType') is not None:
            self.live_domain_type = m.get('LiveDomainType')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SSLProtocol') is not None:
            self.sslprotocol = m.get('SSLProtocol')
        if m.get('SSLPub') is not None:
            self.sslpub = m.get('SSLPub')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        return self


class DescribeLiveDomainDetailResponseBody(TeaModel):
    def __init__(
        self,
        domain_detail: DescribeLiveDomainDetailResponseBodyDomainDetail = None,
        request_id: str = None,
    ):
        # The configuration details of the domain name.
        self.domain_detail = domain_detail
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.domain_detail:
            self.domain_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_detail is not None:
            result['DomainDetail'] = self.domain_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainDetail') is not None:
            temp_model = DescribeLiveDomainDetailResponseBodyDomainDetail()
            self.domain_detail = temp_model.from_map(m['DomainDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainEdgeLogRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        self.end_time = end_time
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        self.end_time = end_time
        self.log_name = log_name
        self.log_path = log_path
        self.log_size = log_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.page_index = page_index
        self.page_size = page_size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        self.log_count = log_count
        self.log_infos = log_infos
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainEdgeLogResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        self.domain_log_details = domain_log_details
        self.domain_name = domain_name
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainEdgeLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainEdgeLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainEdgeLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainFrameRateAndBitRateDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        query_time: str = None,
        region_id: str = None,
    ):
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The point of time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.query_time = query_time
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.query_time is not None:
            result['QueryTime'] = self.query_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('QueryTime') is not None:
            self.query_time = m.get('QueryTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(TeaModel):
    def __init__(
        self,
        audio_frame_rate: float = None,
        bit_rate: float = None,
        stream_url: str = None,
        video_frame_rate: float = None,
    ):
        # The audio frame rate of the live stream. Unit: FPS.
        self.audio_frame_rate = audio_frame_rate
        # The bitrate of the live stream. Unit: bit/s.
        self.bit_rate = bit_rate
        # The URL of the live stream.
        self.stream_url = stream_url
        # The video frame rate of the live stream. Unit: frames per second (FPS).
        self.video_frame_rate = video_frame_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_frame_rate is not None:
            result['AudioFrameRate'] = self.audio_frame_rate
        if self.bit_rate is not None:
            result['BitRate'] = self.bit_rate
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        if self.video_frame_rate is not None:
            result['VideoFrameRate'] = self.video_frame_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFrameRate') is not None:
            self.audio_frame_rate = m.get('AudioFrameRate')
        if m.get('BitRate') is not None:
            self.bit_rate = m.get('BitRate')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        if m.get('VideoFrameRate') is not None:
            self.video_frame_rate = m.get('VideoFrameRate')
        return self


class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos(TeaModel):
    def __init__(
        self,
        frame_rate_and_bit_rate_info: List[DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo] = None,
    ):
        self.frame_rate_and_bit_rate_info = frame_rate_and_bit_rate_info

    def validate(self):
        if self.frame_rate_and_bit_rate_info:
            for k in self.frame_rate_and_bit_rate_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrameRateAndBitRateInfo'] = []
        if self.frame_rate_and_bit_rate_info is not None:
            for k in self.frame_rate_and_bit_rate_info:
                result['FrameRateAndBitRateInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.frame_rate_and_bit_rate_info = []
        if m.get('FrameRateAndBitRateInfo') is not None:
            for k in m.get('FrameRateAndBitRateInfo'):
                temp_model = DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo()
                self.frame_rate_and_bit_rate_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainFrameRateAndBitRateDataResponseBody(TeaModel):
    def __init__(
        self,
        frame_rate_and_bit_rate_infos: DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos = None,
        request_id: str = None,
    ):
        # The frame rates and bitrates of the live streams that were queried.
        self.frame_rate_and_bit_rate_infos = frame_rate_and_bit_rate_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.frame_rate_and_bit_rate_infos:
            self.frame_rate_and_bit_rate_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_rate_and_bit_rate_infos is not None:
            result['FrameRateAndBitRateInfos'] = self.frame_rate_and_bit_rate_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameRateAndBitRateInfos') is not None:
            temp_model = DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos()
            self.frame_rate_and_bit_rate_infos = temp_model.from_map(m['FrameRateAndBitRateInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainFrameRateAndBitRateDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainFrameRateAndBitRateDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainLimitRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The name of the main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit(TeaModel):
    def __init__(
        self,
        current_num: int = None,
        current_transcode_num: int = None,
        current_transfer_num: int = None,
        domain_name: str = None,
        limit_num: int = None,
        limit_transcode_num: int = None,
        limit_transfer_num: int = None,
    ):
        # The current number of ingested streams.
        self.current_num = current_num
        # The current number of transcoded streams.
        self.current_transcode_num = current_transcode_num
        # The current number of streams relayed from the live center.
        self.current_transfer_num = current_transfer_num
        # The name of the queried main streaming domain.
        self.domain_name = domain_name
        # The maximum number of ingested streams.
        self.limit_num = limit_num
        # The maximum number of transcoded streams.
        self.limit_transcode_num = limit_transcode_num
        # The maximum allowed number of streams relayed from the live center.
        self.limit_transfer_num = limit_transfer_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_num is not None:
            result['CurrentNum'] = self.current_num
        if self.current_transcode_num is not None:
            result['CurrentTranscodeNum'] = self.current_transcode_num
        if self.current_transfer_num is not None:
            result['CurrentTransferNum'] = self.current_transfer_num
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.limit_num is not None:
            result['LimitNum'] = self.limit_num
        if self.limit_transcode_num is not None:
            result['LimitTranscodeNum'] = self.limit_transcode_num
        if self.limit_transfer_num is not None:
            result['LimitTransferNum'] = self.limit_transfer_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentNum') is not None:
            self.current_num = m.get('CurrentNum')
        if m.get('CurrentTranscodeNum') is not None:
            self.current_transcode_num = m.get('CurrentTranscodeNum')
        if m.get('CurrentTransferNum') is not None:
            self.current_transfer_num = m.get('CurrentTransferNum')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LimitNum') is not None:
            self.limit_num = m.get('LimitNum')
        if m.get('LimitTranscodeNum') is not None:
            self.limit_transcode_num = m.get('LimitTranscodeNum')
        if m.get('LimitTransferNum') is not None:
            self.limit_transfer_num = m.get('LimitTransferNum')
        return self


class DescribeLiveDomainLimitResponseBodyLiveDomainLimitList(TeaModel):
    def __init__(
        self,
        live_domain_limit: List[DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit] = None,
    ):
        self.live_domain_limit = live_domain_limit

    def validate(self):
        if self.live_domain_limit:
            for k in self.live_domain_limit:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveDomainLimit'] = []
        if self.live_domain_limit is not None:
            for k in self.live_domain_limit:
                result['LiveDomainLimit'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_domain_limit = []
        if m.get('LiveDomainLimit') is not None:
            for k in m.get('LiveDomainLimit'):
                temp_model = DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit()
                self.live_domain_limit.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainLimitResponseBody(TeaModel):
    def __init__(
        self,
        live_domain_limit_list: DescribeLiveDomainLimitResponseBodyLiveDomainLimitList = None,
        request_id: str = None,
    ):
        # The limits.
        self.live_domain_limit_list = live_domain_limit_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_domain_limit_list:
            self.live_domain_limit_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_domain_limit_list is not None:
            result['LiveDomainLimitList'] = self.live_domain_limit_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveDomainLimitList') is not None:
            temp_model = DescribeLiveDomainLimitResponseBodyLiveDomainLimitList()
            self.live_domain_limit_list = temp_model.from_map(m['LiveDomainLimitList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainLimitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainLimitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainLimitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainLogRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain or ingest domain.
        # 
        # You can specify only one domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query data. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # The end time must be later than the start time. The maximum time range that can be specified is 31 days.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number.
        # 
        # >  If you do not specify the PageNumber parameter, the data on the first page is returned.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # *   Valid values: integers from **1 to 1000**.
        # *   Default value: **300**.
        # *   Maximum value: **1000**.
        self.page_size = page_size
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        # The end of the time range for which the logs were queried.
        self.end_time = end_time
        # The name of the log file.
        self.log_name = log_name
        # The path of the log file.
        self.log_path = log_path
        # The size of the log file.
        self.log_size = log_size
        # The beginning of the time range for which the logs were queried.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.page_index = page_index
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        # The total number of entries returned on the current page.
        self.log_count = log_count
        # Details about the logs.
        self.log_infos = log_infos
        # The page information.
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLiveDomainLogResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainLogResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLiveDomainLogResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        # The log information.
        self.domain_log_details = domain_log_details
        # The streaming domain or ingest domain.
        self.domain_name = domain_name
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLiveDomainLogResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainLogExTtlRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        self.end_time = end_time
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        self.end_time = end_time
        self.log_name = log_name
        self.log_path = log_path
        self.log_size = log_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.page_index = page_index
        self.page_size = page_size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        self.log_count = log_count
        self.log_infos = log_infos
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainLogExTtlResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        self.domain_log_details = domain_log_details
        self.domain_name = domain_name
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainLogExTtlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainLogExTtlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainLogExTtlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainMappingRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The domain name for which you want to query the mappings. The following types of domain names are supported:
        # 
        # *   Ingest domain
        # *   Main streaming domain
        # *   Sub-streaming domain
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        type: str = None,
    ):
        # The domain name to which the queried domain name is mapped.
        self.domain_name = domain_name
        # The type of the queried domain name. Valid values:
        # 
        # *   **vhost**: main streaming domain
        # *   **publish**: ingest domain
        # *   **play**: sub-streaming domain
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveDomainMappingResponseBodyLiveDomainModels(TeaModel):
    def __init__(
        self,
        live_domain_model: List[DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel] = None,
    ):
        self.live_domain_model = live_domain_model

    def validate(self):
        if self.live_domain_model:
            for k in self.live_domain_model:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveDomainModel'] = []
        if self.live_domain_model is not None:
            for k in self.live_domain_model:
                result['LiveDomainModel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_domain_model = []
        if m.get('LiveDomainModel') is not None:
            for k in m.get('LiveDomainModel'):
                temp_model = DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel()
                self.live_domain_model.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainMappingResponseBody(TeaModel):
    def __init__(
        self,
        live_domain_models: DescribeLiveDomainMappingResponseBodyLiveDomainModels = None,
        request_id: str = None,
    ):
        # The mappings of the queried domain name.
        self.live_domain_models = live_domain_models
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_domain_models:
            self.live_domain_models.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_domain_models is not None:
            result['LiveDomainModels'] = self.live_domain_models.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveDomainModels') is not None:
            temp_model = DescribeLiveDomainMappingResponseBodyLiveDomainModels()
            self.live_domain_models = temp_model.from_map(m['LiveDomainModels'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainMappingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainMappingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainMappingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainMonitoringUsageDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        instance_id: str = None,
        interval: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the monitoring session. If you leave this parameter empty, data of all monitoring sessions is queried by default. Separate multiple session IDs with commas (,).
        self.instance_id = instance_id
        # The time granularity. Valid values: **3600** and **86400**. 3600 specifies that data is queried by hour and 86400 specifies that data is queried by day.
        self.interval = interval
        self.owner_id = owner_id
        # The region of the live center. If you leave this parameter empty, data of all regions is queried by default. Separate multiple regions with commas (,).
        self.region = region
        self.region_id = region_id
        # The key that is used to group data. Valid values: **domain**, **region**, **instance**, and **resolution**. Default value: **resolution**. resolution specifies that data is grouped by resolution. Separate multiple values with commas (,).
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format.
        # 
        # *   The time must be in UTC.
        # *   The minimum data granularity is 1 hour.
        # *   If you leave this parameter empty, data in the previous 24 hours is queried.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        duration: int = None,
        instance_id: str = None,
        region: str = None,
        resolution: str = None,
        time_stamp: str = None,
    ):
        # The domain name. This field is valid only when you specify domain for the **SplitBy** parameter.
        self.domain_name = domain_name
        # The duration. Unit: minutes.
        self.duration = duration
        # The ID of the monitoring session. This field is valid only when you specify instance for the **SplitBy** parameter.
        self.instance_id = instance_id
        # The region of the live center. This field is valid only when you specify Region for the **SplitBy** parameter.
        self.region = region
        # The resolution. This field is valid only when you specify resolution for the **SplitBy** parameter.
        self.resolution = resolution
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region is not None:
            result['Region'] = self.region
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData(TeaModel):
    def __init__(
        self,
        monitoring_data_item: List[DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem] = None,
    ):
        self.monitoring_data_item = monitoring_data_item

    def validate(self):
        if self.monitoring_data_item:
            for k in self.monitoring_data_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MonitoringDataItem'] = []
        if self.monitoring_data_item is not None:
            for k in self.monitoring_data_item:
                result['MonitoringDataItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.monitoring_data_item = []
        if m.get('MonitoringDataItem') is not None:
            for k in m.get('MonitoringDataItem'):
                temp_model = DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem()
                self.monitoring_data_item.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainMonitoringUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        instance_id: str = None,
        monitoring_data: DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData = None,
        region: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The end of the time range.
        self.end_time = end_time
        # The ID of the monitoring session.
        self.instance_id = instance_id
        # The live monitoring data.
        self.monitoring_data = monitoring_data
        # The region of the live center.
        self.region = region
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range.
        self.start_time = start_time

    def validate(self):
        if self.monitoring_data:
            self.monitoring_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.monitoring_data is not None:
            result['MonitoringData'] = self.monitoring_data.to_map()
        if self.region is not None:
            result['Region'] = self.region
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MonitoringData') is not None:
            temp_model = DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData()
            self.monitoring_data = temp_model.from_map(m['MonitoringData'])
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainMonitoringUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainMonitoringUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainMonitoringUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainMultiStreamConfigRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        owner_id: int = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DescribeLiveDomainMultiStreamConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        switch: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the dual-stream disaster recovery feature is enabled. Valid values:
        # 
        # *   **on**: enabled
        # *   **off**: disabled
        self.switch = switch

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.switch is not None:
            result['Switch'] = self.switch
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Switch') is not None:
            self.switch = m.get('Switch')
        return self


class DescribeLiveDomainMultiStreamConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainMultiStreamConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainMultiStreamConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainOnlineUserNumRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        query_time: str = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The point of time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.query_time = query_time
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.query_time is not None:
            result['QueryTime'] = self.query_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('QueryTime') is not None:
            self.query_time = m.get('QueryTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo(TeaModel):
    def __init__(
        self,
        transcode_template: str = None,
        user_number: int = None,
    ):
        # The transcoding template. A value of origin indicates that the stream is a source stream.
        self.transcode_template = transcode_template
        # The number of online users for the stream, which can be a source stream or transcoded stream.
        self.user_number = user_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.transcode_template is not None:
            result['TranscodeTemplate'] = self.transcode_template
        if self.user_number is not None:
            result['UserNumber'] = self.user_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TranscodeTemplate') is not None:
            self.transcode_template = m.get('TranscodeTemplate')
        if m.get('UserNumber') is not None:
            self.user_number = m.get('UserNumber')
        return self


class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos(TeaModel):
    def __init__(
        self,
        info: List[DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo] = None,
    ):
        self.info = info

    def validate(self):
        if self.info:
            for k in self.info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Info'] = []
        if self.info is not None:
            for k in self.info:
                result['Info'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.info = []
        if m.get('Info') is not None:
            for k in m.get('Info'):
                temp_model = DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo()
                self.info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo(TeaModel):
    def __init__(
        self,
        infos: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos = None,
        stream_name: str = None,
    ):
        # The statistics on the stream.
        self.infos = infos
        # The name of the stream.
        self.stream_name = stream_name

    def validate(self):
        if self.infos:
            self.infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.infos is not None:
            result['Infos'] = self.infos.to_map()
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Infos') is not None:
            temp_model = DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos()
            self.infos = temp_model.from_map(m['Infos'])
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo(TeaModel):
    def __init__(
        self,
        live_stream_online_user_num_info: List[DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo] = None,
    ):
        self.live_stream_online_user_num_info = live_stream_online_user_num_info

    def validate(self):
        if self.live_stream_online_user_num_info:
            for k in self.live_stream_online_user_num_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamOnlineUserNumInfo'] = []
        if self.live_stream_online_user_num_info is not None:
            for k in self.live_stream_online_user_num_info:
                result['LiveStreamOnlineUserNumInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_online_user_num_info = []
        if m.get('LiveStreamOnlineUserNumInfo') is not None:
            for k in m.get('LiveStreamOnlineUserNumInfo'):
                temp_model = DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo()
                self.live_stream_online_user_num_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainOnlineUserNumResponseBody(TeaModel):
    def __init__(
        self,
        online_user_info: DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo = None,
        request_id: str = None,
        stream_count: int = None,
        user_count: int = None,
    ):
        # The information about the streams.
        self.online_user_info = online_user_info
        # The request ID.
        self.request_id = request_id
        # The number of streams.
        self.stream_count = stream_count
        # The total number of online users at the specified point in time for all the live streams under the main streaming domain.
        self.user_count = user_count

    def validate(self):
        if self.online_user_info:
            self.online_user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.online_user_info is not None:
            result['OnlineUserInfo'] = self.online_user_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_count is not None:
            result['StreamCount'] = self.stream_count
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OnlineUserInfo') is not None:
            temp_model = DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo()
            self.online_user_info = temp_model.from_map(m['OnlineUserInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamCount') is not None:
            self.stream_count = m.get('StreamCount')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class DescribeLiveDomainOnlineUserNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainOnlineUserNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainOnlineUserNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainPublishErrorCodeRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The application name. The data is aggregated based on the application. If you specify this parameter, the DomainName parameter is required.
        self.app_name = app_name
        # The ingest domain. If you want to specify multiple ingest domains, separate them with commas (,).
        # 
        # >  This parameter is required.
        self.domain_name = domain_name
        # The end time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you do not configure StartTime, the data within the previous hour is queried.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you do not configure StartTime, the data within the previous hour is queried.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        proportion: str = None,
    ):
        # The response code. Valid values:
        # 
        # *   3: The data read timed out.
        # *   4: A data write error occurred.
        # *   6: The data write timed out.
        # *   200: The request is successful.
        # *   500: An unknown internal error occurred.
        # *   501: The stream ingest failed.
        # *   502: The signaling operation timed out.
        # *   401: A stream ingest parameter is invalid.
        # *   403: The stream ingest authentication failed.
        self.code = code
        # The number of times the HTTP status code was returned.
        self.count = count
        # The proportion of the HTTP status code.
        self.proportion = proportion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.proportion is not None:
            result['Proportion'] = self.proportion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Proportion') is not None:
            self.proportion = m.get('Proportion')
        return self


class DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData(TeaModel):
    def __init__(
        self,
        code_data: List[DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData] = None,
        time_stamp: str = None,
    ):
        # The proportions of error codes.
        self.code_data = code_data
        # The timestamp of the data returned.
        self.time_stamp = time_stamp

    def validate(self):
        if self.code_data:
            for k in self.code_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CodeData'] = []
        if self.code_data is not None:
            for k in self.code_data:
                result['CodeData'].append(k.to_map() if k else None)
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.code_data = []
        if m.get('CodeData') is not None:
            for k in m.get('CodeData'):
                temp_model = DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData()
                self.code_data.append(temp_model.from_map(k))
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDomainPublishErrorCodeResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        real_time_code_data: List[DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData] = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time granularity of the query. Unit: seconds. Default value: 60.
        self.data_interval = data_interval
        # The ingest domain.
        self.domain_name = domain_name
        # The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The proportions of error codes at each time interval.
        self.real_time_code_data = real_time_code_data
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.real_time_code_data:
            for k in self.real_time_code_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['RealTimeCodeData'] = []
        if self.real_time_code_data is not None:
            for k in self.real_time_code_data:
                result['RealTimeCodeData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.real_time_code_data = []
        if m.get('RealTimeCodeData') is not None:
            for k in m.get('RealTimeCodeData'):
                temp_model = DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData()
                self.real_time_code_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPublishErrorCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainPublishErrorCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainPublishErrorCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainPushBpsDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The ingest domain. You can specify multiple ingest domains and separate them with commas (,). If you do not specify this parameter, the merged data of all your ingest domains is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. The end time must be later than the start time.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300**\
        # *   **3600**\
        # *   **86400**\
        # 
        # The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.interval = interval
        # The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.
        self.isp_name_en = isp_name_en
        # The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. If you do not specify this parameter, the data of the last 24 hours is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        bps_value: str = None,
        time_stamp: str = None,
    ):
        # The bandwidth. Unit: bit/s.
        self.bps_value = bps_value
        # The timestamp of the data returned.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bps_value is not None:
            result['BpsValue'] = self.bps_value
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BpsValue') is not None:
            self.bps_value = m.get('BpsValue')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainPushBpsDataResponseBody(TeaModel):
    def __init__(
        self,
        bps_data_per_interval: DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval = None,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The bandwidth data that was collected at each interval.
        self.bps_data_per_interval = bps_data_per_interval
        # The time granularity of the query.
        self.data_interval = data_interval
        # The ingest domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.bps_data_per_interval:
            self.bps_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bps_data_per_interval is not None:
            result['BpsDataPerInterval'] = self.bps_data_per_interval.to_map()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BpsDataPerInterval') is not None:
            temp_model = DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval()
            self.bps_data_per_interval = temp_model.from_map(m['BpsDataPerInterval'])
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPushBpsDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainPushBpsDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainPushBpsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainPushTrafficDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The ingest domain. You can specify multiple ingest domains and separate them with commas (,). If you do not specify this parameter, the merged data of all your ingest domains is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300**\
        # *   **3600**\
        # *   **86400**\
        # 
        # The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.interval = interval
        # The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.
        self.isp_name_en = isp_name_en
        # The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. If you do not specify this parameter, the data of the last 24 hours is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        traffic_value: str = None,
    ):
        # The timestamp of the data returned.
        self.time_stamp = time_stamp
        # The traffic. Unit: bytes.
        self.traffic_value = traffic_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.traffic_value is not None:
            result['TrafficValue'] = self.traffic_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TrafficValue') is not None:
            self.traffic_value = m.get('TrafficValue')
        return self


class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainPushTrafficDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
        traffic_data_per_interval: DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The ingest domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried.
        self.start_time = start_time
        # The traffic data that was collected at each interval.
        self.traffic_data_per_interval = traffic_data_per_interval

    def validate(self):
        if self.traffic_data_per_interval:
            self.traffic_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.traffic_data_per_interval is not None:
            result['TrafficDataPerInterval'] = self.traffic_data_per_interval.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TrafficDataPerInterval') is not None:
            temp_model = DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval()
            self.traffic_data_per_interval = temp_model.from_map(m['TrafficDataPerInterval'])
        return self


class DescribeLiveDomainPushTrafficDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainPushTrafficDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainPushTrafficDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainPvUvDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time must be in UTC.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo(TeaModel):
    def __init__(
        self,
        pv: str = None,
        time_stamp: str = None,
        uv: str = None,
    ):
        # The number of PVs.
        self.pv = pv
        # The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.
        self.time_stamp = time_stamp
        # The number of UVs.
        self.uv = uv

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pv is not None:
            result['PV'] = self.pv
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.uv is not None:
            result['UV'] = self.uv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PV') is not None:
            self.pv = m.get('PV')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('UV') is not None:
            self.uv = m.get('UV')
        return self


class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos(TeaModel):
    def __init__(
        self,
        pv_uv_data_info: List[DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo] = None,
    ):
        self.pv_uv_data_info = pv_uv_data_info

    def validate(self):
        if self.pv_uv_data_info:
            for k in self.pv_uv_data_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PvUvDataInfo'] = []
        if self.pv_uv_data_info is not None:
            for k in self.pv_uv_data_info:
                result['PvUvDataInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pv_uv_data_info = []
        if m.get('PvUvDataInfo') is not None:
            for k in m.get('PvUvDataInfo'):
                temp_model = DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo()
                self.pv_uv_data_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainPvUvDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        pv_uv_data_infos: DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time interval between the entries returned. Unit: seconds. Default value: 3600.
        self.data_interval = data_interval
        # The streaming domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.
        self.end_time = end_time
        # The data of PVs and UVs.
        self.pv_uv_data_infos = pv_uv_data_infos
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.pv_uv_data_infos:
            self.pv_uv_data_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.pv_uv_data_infos is not None:
            result['PvUvDataInfos'] = self.pv_uv_data_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PvUvDataInfos') is not None:
            temp_model = DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos()
            self.pv_uv_data_infos = temp_model.from_map(m['PvUvDataInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainPvUvDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainPvUvDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainPvUvDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainRealTimeBpsDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain name or names.
        # 
        # Separate multiple domain names with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you do not set this parameter, the data of the hour following the specified start time is returned.
        self.end_time = end_time
        # The name of the Internet service provider (ISP).
        # 
        # To query ISPs, call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation.
        self.isp_name_en = isp_name_en
        # The name of the region in which you want to query data.
        # 
        # To query regions, call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        value: str = None,
    ):
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The bandwidth. Unit: bit/s.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainRealTimeBpsDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        real_time_bps_data_per_interval: DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The interval at which data was queried.
        self.data_interval = data_interval
        # The streaming domain name or names that was queried.
        self.domain_name = domain_name
        # The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The bandwidth data that was collected every minute.
        self.real_time_bps_data_per_interval = real_time_bps_data_per_interval
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.real_time_bps_data_per_interval:
            self.real_time_bps_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.real_time_bps_data_per_interval is not None:
            result['RealTimeBpsDataPerInterval'] = self.real_time_bps_data_per_interval.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RealTimeBpsDataPerInterval') is not None:
            temp_model = DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval()
            self.real_time_bps_data_per_interval = temp_model.from_map(m['RealTimeBpsDataPerInterval'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeBpsDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainRealTimeBpsDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainRealTimeBpsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainRealTimeHttpCodeDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain.
        # 
        # Separate multiple domain names with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last **1** hour is returned.
        self.end_time = end_time
        # The name of the Internet service provider (ISP).
        # 
        # You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/448109.html) operation to query a list of available ISPs.
        self.isp_name_en = isp_name_en
        # The name of the region.
        # 
        # You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/448109.html) operation to query a list of available regions.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last **1** hour is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(TeaModel):
    def __init__(
        self,
        code: str = None,
        count: str = None,
        proportion: str = None,
    ):
        # The HTTP status code.
        self.code = code
        # The number of times the HTTP status code was returned.
        self.count = count
        # The proportion of the HTTP status code.
        self.proportion = proportion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.proportion is not None:
            result['Proportion'] = self.proportion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Proportion') is not None:
            self.proportion = m.get('Proportion')
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(TeaModel):
    def __init__(
        self,
        real_time_code_proportion_data: List[DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData] = None,
    ):
        self.real_time_code_proportion_data = real_time_code_proportion_data

    def validate(self):
        if self.real_time_code_proportion_data:
            for k in self.real_time_code_proportion_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RealTimeCodeProportionData'] = []
        if self.real_time_code_proportion_data is not None:
            for k in self.real_time_code_proportion_data:
                result['RealTimeCodeProportionData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.real_time_code_proportion_data = []
        if m.get('RealTimeCodeProportionData') is not None:
            for k in m.get('RealTimeCodeProportionData'):
                temp_model = DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData()
                self.real_time_code_proportion_data.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        value: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue = None,
    ):
        # The timestamp of the data returned.
        self.time_stamp = time_stamp
        # The proportions of HTTP status codes.
        self.value = value

    def validate(self):
        if self.value:
            self.value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.value is not None:
            result['Value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Value') is not None:
            temp_model = DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue()
            self.value = temp_model.from_map(m['Value'])
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(TeaModel):
    def __init__(
        self,
        usage_data: List[DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData] = None,
    ):
        self.usage_data = usage_data

    def validate(self):
        if self.usage_data:
            for k in self.usage_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UsageData'] = []
        if self.usage_data is not None:
            for k in self.usage_data:
                result['UsageData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.usage_data = []
        if m.get('UsageData') is not None:
            for k in m.get('UsageData'):
                temp_model = DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData()
                self.usage_data.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        real_time_http_code_data: DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time interval between the entries returned. Unit: seconds Default value: 60.
        self.data_interval = data_interval
        # The streaming domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The proportions of HTTP status codes at each time interval.
        self.real_time_http_code_data = real_time_http_code_data
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.real_time_http_code_data:
            self.real_time_http_code_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.real_time_http_code_data is not None:
            result['RealTimeHttpCodeData'] = self.real_time_http_code_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RealTimeHttpCodeData') is not None:
            temp_model = DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData()
            self.real_time_http_code_data = temp_model.from_map(m['RealTimeHttpCodeData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeHttpCodeDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainRealTimeHttpCodeDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainRealTimeTrafficDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain.
        # 
        # Separate multiple streaming domains with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The name of the ISP.
        # 
        # You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs.
        self.isp_name_en = isp_name_en
        # The name of the region.
        # 
        # You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If you do not specify this parameter, the data of the last hour is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        value: str = None,
    ):
        # The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time_stamp = time_stamp
        # The traffic. Unit: bytes.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainRealTimeTrafficDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        real_time_traffic_data_per_interval: DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time interval between the entries returned. Unit: seconds
        self.data_interval = data_interval
        # The streaming domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The traffic that was collected at each interval.
        self.real_time_traffic_data_per_interval = real_time_traffic_data_per_interval
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.real_time_traffic_data_per_interval:
            self.real_time_traffic_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.real_time_traffic_data_per_interval is not None:
            result['RealTimeTrafficDataPerInterval'] = self.real_time_traffic_data_per_interval.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RealTimeTrafficDataPerInterval') is not None:
            temp_model = DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval()
            self.real_time_traffic_data_per_interval = temp_model.from_map(m['RealTimeTrafficDataPerInterval'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRealTimeTrafficDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainRealTimeTrafficDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainRealTimeTrafficDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The name of the Logstore to which log entries are delivered.
        self.logstore = logstore
        # The name of the Log Service project that is used for real-time log delivery.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        self.region = region
        # The request ID.
        self.request_id = request_id
        # The status of real-time log delivery. Valid values:
        # 
        # *   online: Real-time log delivery is enabled.
        # *   offline: Real-time log delivery is disabled.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveDomainRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainRecordUsageDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. Value requirements:
        # 
        # *   The end time is later than the start time.
        # *   The time range between the start time and end time is up to 31 days. If the time range is more than 31 days, the request fails and an error is reported.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   60
        # *   300
        # *   3600
        # *   86400
        # 
        # > If you do not specify this parameter or specify an invalid value: The time granularity of the query for a time range that is less than or equal to 31 days is 300 seconds by default. The time granularity of the query for a time range that is more than 31 days is 86400 seconds by default.
        self.interval = interval
        self.owner_id = owner_id
        # The ID of the region. Valid values:
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **cn-qingdao**: China (Qingdao)
        # *   **ap-southeast-1**: Singapore
        # *   **eu-central-1**: Germany (Frankfurt)
        # *   **ap-northeast-1**: Japan (Tokyo)
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        self.region = region
        self.region_id = region_id
        # The key that is used to group data. Valid values:
        # 
        # *   **domain**: groups results by domain name.
        # *   **record_fmt**: groups results by recording type.
        # 
        # >  You can select one option or both. If you want to select both options, separate them with a comma (,). The default value is `domain,record_fmt`. If you leave this parameter empty or set the value to `null`, this parameter is ignored.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The minimum data granularity is 5 minutes.
        # *   If you do not specify this parameter, the data in the last 24 hours is returned.
        # 
        # > The earliest start time that you can specify is 90 days back from the current time, accurate to seconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule(TeaModel):
    def __init__(
        self,
        count: int = None,
        domain: str = None,
        duration: int = None,
        region: str = None,
        time_stamp: str = None,
        type: str = None,
    ):
        # The number of peak channels.
        self.count = count
        # The main streaming domain. This parameter is returned if the value of the request parameter SplitBy contains `domain`.
        self.domain = domain
        # The recording length. Unit: seconds.
        self.duration = duration
        # The region ID.
        self.region = region
        # The time when recording started.
        self.time_stamp = time_stamp
        # The recording file type. This parameter is returned if the value of the request parameter SplitBy contains `record_fmt`.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.region is not None:
            result['Region'] = self.region
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainRecordUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        record_usage_data: DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The end of the time range during which data was queried.
        self.end_time = end_time
        # The recording data that was collected for each interval.
        self.record_usage_data = record_usage_data
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which data was queried.
        self.start_time = start_time

    def validate(self):
        if self.record_usage_data:
            self.record_usage_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.record_usage_data is not None:
            result['RecordUsageData'] = self.record_usage_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RecordUsageData') is not None:
            temp_model = DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData()
            self.record_usage_data = temp_model.from_map(m['RecordUsageData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainRecordUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainRecordUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainRecordUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainSnapshotDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  You can query data in the last **90** days.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo(TeaModel):
    def __init__(
        self,
        date: str = None,
        total: int = None,
    ):
        # The date.
        self.date = date
        # The total number of snapshots that were captured on the day.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos(TeaModel):
    def __init__(
        self,
        snapshot_data_info: List[DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo] = None,
    ):
        self.snapshot_data_info = snapshot_data_info

    def validate(self):
        if self.snapshot_data_info:
            for k in self.snapshot_data_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotDataInfo'] = []
        if self.snapshot_data_info is not None:
            for k in self.snapshot_data_info:
                result['SnapshotDataInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.snapshot_data_info = []
        if m.get('SnapshotDataInfo') is not None:
            for k in m.get('SnapshotDataInfo'):
                temp_model = DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo()
                self.snapshot_data_info.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainSnapshotDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        snapshot_data_infos: DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The daily statistics on the number of snapshots.
        self.snapshot_data_infos = snapshot_data_infos

    def validate(self):
        if self.snapshot_data_infos:
            self.snapshot_data_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_data_infos is not None:
            result['SnapshotDataInfos'] = self.snapshot_data_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotDataInfos') is not None:
            temp_model = DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos()
            self.snapshot_data_infos = temp_model.from_map(m['SnapshotDataInfos'])
        return self


class DescribeLiveDomainSnapshotDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainSnapshotDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainSnapshotDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainStagingConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        function_names: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The accelerated domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The feature that you want to query. Separate multiple features with commas (,).
        # 
        # This parameter is required.
        self.function_names = function_names
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.function_names is not None:
            result['FunctionNames'] = self.function_names
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FunctionNames') is not None:
            self.function_names = m.get('FunctionNames')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(TeaModel):
    def __init__(
        self,
        arg_name: str = None,
        arg_value: str = None,
    ):
        # The name of the parameter.
        self.arg_name = arg_name
        # The configured value.
        self.arg_value = arg_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arg_name is not None:
            result['ArgName'] = self.arg_name
        if self.arg_value is not None:
            result['ArgValue'] = self.arg_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArgName') is not None:
            self.arg_name = m.get('ArgName')
        if m.get('ArgValue') is not None:
            self.arg_value = m.get('ArgValue')
        return self


class DescribeLiveDomainStagingConfigResponseBodyDomainConfigs(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        function_args: List[DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs] = None,
        function_name: str = None,
        status: str = None,
    ):
        # The configuration ID.
        self.config_id = config_id
        # The configurations of the feature.
        self.function_args = function_args
        # The name of the feature.
        self.function_name = function_name
        # The configuration status. Valid values:
        # 
        # *   **success**\
        # *   **testing**\
        # *   **failed**\
        # *   **configuring**\
        self.status = status

    def validate(self):
        if self.function_args:
            for k in self.function_args:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        result['FunctionArgs'] = []
        if self.function_args is not None:
            for k in self.function_args:
                result['FunctionArgs'].append(k.to_map() if k else None)
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        self.function_args = []
        if m.get('FunctionArgs') is not None:
            for k in m.get('FunctionArgs'):
                temp_model = DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs()
                self.function_args.append(temp_model.from_map(k))
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveDomainStagingConfigResponseBody(TeaModel):
    def __init__(
        self,
        domain_configs: List[DescribeLiveDomainStagingConfigResponseBodyDomainConfigs] = None,
        request_id: str = None,
    ):
        # The feature configurations of the accelerated domain name.
        self.domain_configs = domain_configs
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.domain_configs:
            for k in self.domain_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainConfigs'] = []
        if self.domain_configs is not None:
            for k in self.domain_configs:
                result['DomainConfigs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_configs = []
        if m.get('DomainConfigs') is not None:
            for k in m.get('DomainConfigs'):
                temp_model = DescribeLiveDomainStagingConfigResponseBodyDomainConfigs()
                self.domain_configs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainStagingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainStagingConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainStagingConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainStreamTranscodeDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        precision: str = None,
        region_id: str = None,
        split: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **3600**: 1 hour
        # *   **86400**: 1 day
        # 
        # >  If you do not specify this parameter, the time granularity of 1 hour is used by default.
        self.interval = interval
        self.owner_id = owner_id
        # The time precision of the query. Valid values:
        # 
        # *   **min** (default): in minutes.
        # *   **sec**: in seconds.
        self.precision = precision
        self.region_id = region_id
        # The key that is used to group data. Valid values:
        # 
        # *   **domain**: The DomainName parameter is available in the response only if Split is set to domain.
        # *   **region**: The Region parameter is available in the response only if Split is set to region.
        # *   **transcode_type**: The TanscodeType parameter is available in the response only if Split is set to transcode_type.
        # *   **resolution**: The Resolution parameter is available in the response only if Split is set to resolution.
        # *   **fps**: The Fps parameter is available in the response only if Split is set to fps.
        # 
        # You can specify one or more keys. If you specify multiple keys, separate them with commas (,).
        # 
        # Default value: `domain,region,transcode_type,resolution,fps`.
        self.split = split
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The minimum query interval is 1 hour.
        # *   If you do not set this parameter, the transcoding length for the last 24 hours is returned.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.precision is not None:
            result['Precision'] = self.precision
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split is not None:
            result['Split'] = self.split
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Precision') is not None:
            self.precision = m.get('Precision')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Split') is not None:
            self.split = m.get('Split')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData(TeaModel):
    def __init__(
        self,
        domain: str = None,
        duration: int = None,
        fps: str = None,
        region: str = None,
        resolution: str = None,
        tanscode_type: str = None,
        time_stamp: str = None,
    ):
        # The main streaming domain. This parameter is returned only when you add the domain key to the value of the Split parameter.
        self.domain = domain
        # The transcoding length. Unit: minutes.
        self.duration = duration
        # The frame rate of the transcoded stream. This parameter is returned only when you add the fps key to the value of the Split parameter.
        self.fps = fps
        # The region in which the domain name resides. Valid values:
        # 
        # >  This parameter takes effect only when you set Split to region.
        # 
        # *   **cn-beijing**: China (Beijing)
        # *   **cn-shanghai**: China (Shanghai)
        # *   **cn-qingdao**: China (Qingdao)
        # *   **cn-shenzhen**: China (Shenzhen)
        # *   **ap-northeast-1**: Japan (Tokyo)
        # *   **ap-southeast-1**: Singapore
        # *   **ap-southeast-5**: Indonesia (Jakarta)
        # *   **eu-central-1**: Germany (Frankfurt)
        self.region = region
        # The resolution of the transcoded stream. This parameter is returned only when you add the resolution key to the value of the Split parameter. Valid values:
        # 
        # *   **2K**\
        # *   **4K**\
        # *   **LD**: low definition
        # *   **SD**: standard definition
        # *   **HD**: high definition
        # *   **def**: audio
        self.resolution = resolution
        # The transcoding type. Valid values:
        # 
        # >  This parameter takes effect only if the request parameter Split is set to transcode_type.
        # 
        # *   **H264NBHD**: Narrowband HD transcoding based on H.264
        # *   **H265NBHD**: Narrowband HD transcoding based on H.265
        # *   **AUDIO**: audio transcoding
        self.tanscode_type = tanscode_type
        # The timestamp of the data entry.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.region is not None:
            result['Region'] = self.region
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.tanscode_type is not None:
            result['TanscodeType'] = self.tanscode_type
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('TanscodeType') is not None:
            self.tanscode_type = m.get('TanscodeType')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList(TeaModel):
    def __init__(
        self,
        transcode_data: List[DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData] = None,
    ):
        self.transcode_data = transcode_data

    def validate(self):
        if self.transcode_data:
            for k in self.transcode_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TranscodeData'] = []
        if self.transcode_data is not None:
            for k in self.transcode_data:
                result['TranscodeData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.transcode_data = []
        if m.get('TranscodeData') is not None:
            for k in m.get('TranscodeData'):
                temp_model = DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData()
                self.transcode_data.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainStreamTranscodeDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transcode_data_list: DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The transcoding usage data returned at each interval.
        self.transcode_data_list = transcode_data_list

    def validate(self):
        if self.transcode_data_list:
            self.transcode_data_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.transcode_data_list is not None:
            result['TranscodeDataList'] = self.transcode_data_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TranscodeDataList') is not None:
            temp_model = DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList()
            self.transcode_data_list = temp_model.from_map(m['TranscodeDataList'])
        return self


class DescribeLiveDomainStreamTranscodeDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainStreamTranscodeDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainStreamTranscodeDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainTimeShiftDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   300
        # *   3600
        # *   86400
        # 
        # If you do not specify this parameter or specify an invalid value, the default value 300 is used.
        self.interval = interval
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # > 
        # 
        # *   The minimum data granularity is 5 minutes.
        # 
        # *   If you leave this parameter empty, data in the last 24 hours is queried.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule(TeaModel):
    def __init__(
        self,
        size: str = None,
        time_stamp: str = None,
        type: str = None,
    ):
        # The storage used for time shifting. Unit: bytes.
        self.size = size
        # The timestamp of the data returned.
        self.time_stamp = time_stamp
        # The type of time shifting. Examples: HLS_D1 and HLS_D7.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainTimeShiftDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        time_shift_data: DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The time shifting usage data that was collected for each time interval.
        self.time_shift_data = time_shift_data

    def validate(self):
        if self.time_shift_data:
            self.time_shift_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.time_shift_data is not None:
            result['TimeShiftData'] = self.time_shift_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TimeShiftData') is not None:
            temp_model = DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData()
            self.time_shift_data = temp_model.from_map(m['TimeShiftData'])
        return self


class DescribeLiveDomainTimeShiftDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainTimeShiftDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainTimeShiftDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainTrafficDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        isp_name_en: str = None,
        location_name_en: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain. You can query one or more domain names. If you specify multiple domain names, separate them with commas (,). If you do not specify this parameter, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300** (default)
        # *   **3600**\
        # *   **86400**\
        # 
        # >  If you specify an invalid value or do not specify this parameter, the default value **300** is used.
        self.interval = interval
        # The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.
        self.isp_name_en = isp_name_en
        # The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.
        self.location_name_en = location_name_en
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  You can query data in the last **90** days.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_name_en is not None:
            result['IspNameEn'] = self.isp_name_en
        if self.location_name_en is not None:
            result['LocationNameEn'] = self.location_name_en
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspNameEn') is not None:
            self.isp_name_en = m.get('IspNameEn')
        if m.get('LocationNameEn') is not None:
            self.location_name_en = m.get('LocationNameEn')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(TeaModel):
    def __init__(
        self,
        http_traffic_value: str = None,
        https_traffic_value: str = None,
        time_stamp: str = None,
        traffic_value: str = None,
    ):
        # The traffic over HTTP. Unit: bytes.
        self.http_traffic_value = http_traffic_value
        # The traffic over HTTPS. Unit: bytes.
        self.https_traffic_value = https_traffic_value
        # The timestamp of the data returned.
        self.time_stamp = time_stamp
        # The total traffic. Unit: bytes.
        self.traffic_value = traffic_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_traffic_value is not None:
            result['HttpTrafficValue'] = self.http_traffic_value
        if self.https_traffic_value is not None:
            result['HttpsTrafficValue'] = self.https_traffic_value
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.traffic_value is not None:
            result['TrafficValue'] = self.traffic_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HttpTrafficValue') is not None:
            self.http_traffic_value = m.get('HttpTrafficValue')
        if m.get('HttpsTrafficValue') is not None:
            self.https_traffic_value = m.get('HttpsTrafficValue')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TrafficValue') is not None:
            self.traffic_value = m.get('TrafficValue')
        return self


class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDomainTrafficDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
        traffic_data_per_interval: DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval = None,
    ):
        # The time granularity of the query.
        self.data_interval = data_interval
        # The streaming domain.
        self.domain_name = domain_name
        # The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The network traffic data that was collected at each interval.
        self.traffic_data_per_interval = traffic_data_per_interval

    def validate(self):
        if self.traffic_data_per_interval:
            self.traffic_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.traffic_data_per_interval is not None:
            result['TrafficDataPerInterval'] = self.traffic_data_per_interval.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TrafficDataPerInterval') is not None:
            temp_model = DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval()
            self.traffic_data_per_interval = temp_model.from_map(m['TrafficDataPerInterval'])
        return self


class DescribeLiveDomainTrafficDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainTrafficDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainTrafficDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDomainTranscodeParamsRequest(TeaModel):
    def __init__(
        self,
        security_token: str = None,
        app: str = None,
        pushdomain: str = None,
        template_name: str = None,
    ):
        self.security_token = security_token
        # This parameter is required.
        self.app = app
        # This parameter is required.
        self.pushdomain = pushdomain
        self.template_name = template_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.app is not None:
            result['app'] = self.app
        if self.pushdomain is not None:
            result['pushdomain'] = self.pushdomain
        if self.template_name is not None:
            result['template_name'] = self.template_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('pushdomain') is not None:
            self.pushdomain = m.get('pushdomain')
        if m.get('template_name') is not None:
            self.template_name = m.get('template_name')
        return self


class DescribeLiveDomainTranscodeParamsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDomainTranscodeParamsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDomainTranscodeParamsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDomainTranscodeParamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveDrmUsageDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
    ):
        # The domain name.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   300
        # *   3600
        # *   86400
        # 
        # Default value: 3600.
        self.interval = interval
        self.owner_id = owner_id
        self.region_id = region_id
        # The key that is used to group data. The following keys are supported: domain, region, and drm_type. If you want to specify multiple keys, separate them with commas (,). Default value: domain,region,drm_type. If you leave this parameter empty or set it to null, the returned data is not grouped.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum time granularity is 5 minutes.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule(TeaModel):
    def __init__(
        self,
        count: int = None,
        domain: str = None,
        drm_type: str = None,
        region: str = None,
        time_stamp: str = None,
    ):
        # The number of times DRM-encrypted live streams are requested.
        self.count = count
        # The domain name. If the value of SplitBy includes domain, the returned data is grouped by domain name.
        self.domain = domain
        # The DRM type. If the value of SplitBy includes drm_type, the returned data is grouped by DRM type.
        self.drm_type = drm_type
        # The ID of the region. If the value of SplitBy includes region, the returned data is grouped by region.
        self.region = region
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.drm_type is not None:
            result['DrmType'] = self.drm_type
        if self.region is not None:
            result['Region'] = self.region
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('DrmType') is not None:
            self.drm_type = m.get('DrmType')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveDrmUsageDataResponseBodyDrmUsageData(TeaModel):
    def __init__(
        self,
        data_module: List[DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule] = None,
    ):
        self.data_module = data_module

    def validate(self):
        if self.data_module:
            for k in self.data_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataModule'] = []
        if self.data_module is not None:
            for k in self.data_module:
                result['DataModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_module = []
        if m.get('DataModule') is not None:
            for k in m.get('DataModule'):
                temp_model = DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule()
                self.data_module.append(temp_model.from_map(k))
        return self


class DescribeLiveDrmUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        drm_usage_data: DescribeLiveDrmUsageDataResponseBodyDrmUsageData = None,
        request_id: str = None,
    ):
        # The usage of the DRM encryption service at each time interval.
        self.drm_usage_data = drm_usage_data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.drm_usage_data:
            self.drm_usage_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drm_usage_data is not None:
            result['DrmUsageData'] = self.drm_usage_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DrmUsageData') is not None:
            temp_model = DescribeLiveDrmUsageDataResponseBodyDrmUsageData()
            self.drm_usage_data = temp_model.from_map(m['DrmUsageData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveDrmUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveDrmUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveDrmUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveEdgeTransferRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveEdgeTransferResponseBody(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        http_dns: str = None,
        request_id: str = None,
        stream_name: str = None,
        target_domain_list: str = None,
        transfer_args: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The ingest domain.
        self.domain_name = domain_name
        # The HTTPDNS API that is used to obtain the destination URLs.
        self.http_dns = http_dns
        # The request ID.
        self.request_id = request_id
        # The name of the ingested stream.
        self.stream_name = stream_name
        # The destination domain names to which the ingested stream is relayed. Multiple domain names are separated by commas (,).
        self.target_domain_list = target_domain_list
        # Indicates whether stream ingest parameters are passed through. Valid values:
        # 
        # *   **yes**: Stream ingest parameters are passed through.
        # *   **no**: Stream ingest parameters are not passed through.
        self.transfer_args = transfer_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.http_dns is not None:
            result['HttpDns'] = self.http_dns
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.target_domain_list is not None:
            result['TargetDomainList'] = self.target_domain_list
        if self.transfer_args is not None:
            result['TransferArgs'] = self.transfer_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('HttpDns') is not None:
            self.http_dns = m.get('HttpDns')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TargetDomainList') is not None:
            self.target_domain_list = m.get('TargetDomainList')
        if m.get('TransferArgs') is not None:
            self.transfer_args = m.get('TransferArgs')
        return self


class DescribeLiveEdgeTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveEdgeTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveEdgeTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveGrtnDurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        area: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The ID of the application. Separate multiple application IDs with commas (,). You can specify up to 30 application IDs. By default, the aggregated data of all applications is returned.
        self.app_id = app_id
        # The ID of the billable region. Valid values:
        # 
        # *   CN: Chinese mainland
        # *   OverSeas: countries and regions outside the Chinese mainland
        # *   AP1: Asia Pacific 1, including Hong Kong (China), Macao (China), Taiwan (China), Japan, and other Southeast Asia countries and regions except Vietnam and Indonesia
        # *   AP2: Asia Pacific 2, including Indonesia, South Korea, and Vietnam
        # *   AP3: Asia Pacific 3, including Australia and New Zealand
        # *   NA: North America, including US and Canada
        # *   SA: South America, specifically meaning Brazil
        # *   EU: Europe, including Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany
        # *   MEAA: Middle East and Africa, including South Africa, Oman, UAE, and Kuwait
        # 
        # If you do not specify this parameter, data of all regions is aggregated and returned by default.
        self.area = area
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The time range that can be specified is greater than or equal to 5 minutes and less than or equal to 31 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   300
        # *   3600
        # *   86400
        # 
        # If you specify an invalid value or do not specify this parameter, the default value 3600 is used.
        self.interval = interval
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.area is not None:
            result['Area'] = self.area
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        duration: int = None,
        media_profile: str = None,
        media_type: str = None,
        time_stamp: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The co-streaming duration. Unit: minutes.
        self.duration = duration
        # The media specification. Valid values:
        # 
        # *   0: audio-only. This is a basic specification.
        # *   480P: standard definition (SD). The video resolution is 640  480 or lower.
        # *   720P: high definition (HD). The video resolution is 1280  720 or lower.
        # *   1080P: full HD. The video resolution is 1920  1080 or lower.
        self.media_profile = media_profile
        # The media type. Valid values:
        # 
        # *   audio
        # *   video
        self.media_type = media_type
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.media_profile is not None:
            result['MediaProfile'] = self.media_profile
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('MediaProfile') is not None:
            self.media_profile = m.get('MediaProfile')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveGrtnDurationResponseBodyStreamDetailData(TeaModel):
    def __init__(
        self,
        stream_data: List[DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData] = None,
    ):
        self.stream_data = stream_data

    def validate(self):
        if self.stream_data:
            for k in self.stream_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamData'] = []
        if self.stream_data is not None:
            for k in self.stream_data:
                result['StreamData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_data = []
        if m.get('StreamData') is not None:
            for k in m.get('StreamData'):
                temp_model = DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData()
                self.stream_data.append(temp_model.from_map(k))
        return self


class DescribeLiveGrtnDurationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stream_detail_data: DescribeLiveGrtnDurationResponseBodyStreamDetailData = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the co-streaming usage data.
        self.stream_detail_data = stream_detail_data

    def validate(self):
        if self.stream_detail_data:
            self.stream_detail_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_detail_data is not None:
            result['StreamDetailData'] = self.stream_detail_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamDetailData') is not None:
            temp_model = DescribeLiveGrtnDurationResponseBodyStreamDetailData()
            self.stream_detail_data = temp_model.from_map(m['StreamDetailData'])
        return self


class DescribeLiveGrtnDurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveGrtnDurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveGrtnDurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveHttpsDomainListRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The accelerated domain name.
        self.keyword = keyword
        self.owner_id = owner_id
        # The page number. Valid values: **1 to 10000**.
        self.page_number = page_number
        # The number of entries per page. Default value: **20**.
        self.page_size = page_size
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo(TeaModel):
    def __init__(
        self,
        cert_common_name: str = None,
        cert_expire_time: str = None,
        cert_name: str = None,
        cert_start_time: str = None,
        cert_status: str = None,
        cert_type: str = None,
        cert_update_time: str = None,
        domain_name: str = None,
    ):
        # The primary domain name of the certificate.
        self.cert_common_name = cert_common_name
        # The time when the certificate expires.
        self.cert_expire_time = cert_expire_time
        # The name of the certificate.
        self.cert_name = cert_name
        # The time when the certificate became effective.
        self.cert_start_time = cert_start_time
        # The status of the certificate. Valid values:
        # 
        # *   **ok**: The certificate is working as expected.
        # *   **mismatch**: The certificate does not match the specified domain name.
        # *   **expired**: The certificate has expired.
        # *   **expire_soon**: The certificate will expire soon.
        self.cert_status = cert_status
        # The type of the certificate. Valid values:
        # 
        # *   **cas**: a certificate that you purchased from Certificate Management Service
        # *   **upload**: a custom certificate that you uploaded
        self.cert_type = cert_type
        # The time when the certificate was updated.
        self.cert_update_time = cert_update_time
        # The accelerated domain name.
        self.domain_name = domain_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_common_name is not None:
            result['CertCommonName'] = self.cert_common_name
        if self.cert_expire_time is not None:
            result['CertExpireTime'] = self.cert_expire_time
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.cert_start_time is not None:
            result['CertStartTime'] = self.cert_start_time
        if self.cert_status is not None:
            result['CertStatus'] = self.cert_status
        if self.cert_type is not None:
            result['CertType'] = self.cert_type
        if self.cert_update_time is not None:
            result['CertUpdateTime'] = self.cert_update_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertCommonName') is not None:
            self.cert_common_name = m.get('CertCommonName')
        if m.get('CertExpireTime') is not None:
            self.cert_expire_time = m.get('CertExpireTime')
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('CertStartTime') is not None:
            self.cert_start_time = m.get('CertStartTime')
        if m.get('CertStatus') is not None:
            self.cert_status = m.get('CertStatus')
        if m.get('CertType') is not None:
            self.cert_type = m.get('CertType')
        if m.get('CertUpdateTime') is not None:
            self.cert_update_time = m.get('CertUpdateTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        return self


class DescribeLiveHttpsDomainListResponseBodyCertInfos(TeaModel):
    def __init__(
        self,
        cert_info: List[DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo] = None,
    ):
        self.cert_info = cert_info

    def validate(self):
        if self.cert_info:
            for k in self.cert_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CertInfo'] = []
        if self.cert_info is not None:
            for k in self.cert_info:
                result['CertInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cert_info = []
        if m.get('CertInfo') is not None:
            for k in m.get('CertInfo'):
                temp_model = DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo()
                self.cert_info.append(temp_model.from_map(k))
        return self


class DescribeLiveHttpsDomainListResponseBody(TeaModel):
    def __init__(
        self,
        cert_infos: DescribeLiveHttpsDomainListResponseBodyCertInfos = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The information about the certificates.
        self.cert_infos = cert_infos
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.cert_infos:
            self.cert_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_infos is not None:
            result['CertInfos'] = self.cert_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertInfos') is not None:
            temp_model = DescribeLiveHttpsDomainListResponseBodyCertInfos()
            self.cert_infos = temp_model.from_map(m['CertInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLiveHttpsDomainListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveHttpsDomainListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveHttpsDomainListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveInteractionMetricDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        begin_ts: int = None,
        end_ts: int = None,
        metric_type: str = None,
        os: str = None,
        terminal_type: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.begin_ts = begin_ts
        # The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_ts = end_ts
        # The metric. Valid values:
        # 
        # *   JoinChannelSucRate: the success rate of joining a channel within 5 seconds.
        # *   VideoStuckRate: the video stuttering rate.
        # *   AudioStuckRate: the audio stuttering rate.
        # *   FirstFrameCost: the time to first frame.
        # 
        # This parameter is required.
        self.metric_type = metric_type
        # The operating system. Valid values: iOS and Android.
        self.os = os
        # The terminal type. Valid values: web and mobile.
        self.terminal_type = terminal_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.os is not None:
            result['Os'] = self.os
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLiveInteractionMetricDataResponseBodyNodes(TeaModel):
    def __init__(
        self,
        timestamp: str = None,
        value: str = None,
    ):
        # The time when the metric was queried. The value is a UNIX timestamp. Unit: milliseconds.
        self.timestamp = timestamp
        # The value of the metric.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveInteractionMetricDataResponseBody(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeLiveInteractionMetricDataResponseBodyNodes] = None,
        request_id: str = None,
        summary_data: str = None,
    ):
        # The node data.
        self.nodes = nodes
        # The ID of the request.
        self.request_id = request_id
        # The summary data.
        self.summary_data = summary_data

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.summary_data is not None:
            result['SummaryData'] = self.summary_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeLiveInteractionMetricDataResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SummaryData') is not None:
            self.summary_data = m.get('SummaryData')
        return self


class DescribeLiveInteractionMetricDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveInteractionMetricDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveInteractionMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveIpInfoRequest(TeaModel):
    def __init__(
        self,
        ip: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The IP address that you want to check. You can specify only one IP address in each call.
        # 
        # This parameter is required.
        self.ip = ip
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip is not None:
            result['IP'] = self.ip
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveIpInfoResponseBody(TeaModel):
    def __init__(
        self,
        isp: str = None,
        isp_ename: str = None,
        region: str = None,
        region_ename: str = None,
        request_id: str = None,
    ):
        # The Chinese name of the ISP.
        self.isp = isp
        # The English name of the Internet service provider (ISP).
        self.isp_ename = isp_ename
        # The Chinese name of the region.
        self.region = region
        # The English name of the region.
        self.region_ename = region_ename
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.isp_ename is not None:
            result['IspEname'] = self.isp_ename
        if self.region is not None:
            result['Region'] = self.region
        if self.region_ename is not None:
            result['RegionEname'] = self.region_ename
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('IspEname') is not None:
            self.isp_ename = m.get('IspEname')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionEname') is not None:
            self.region_ename = m.get('RegionEname')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveIpInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveIpInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveIpInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveLazyPullStreamConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        pull_app_name: str = None,
        pull_args: str = None,
        pull_domain_name: str = None,
        pull_protocol: str = None,
        transcode_lazy: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The name of the application for back-to-origin stream pulling. If the application specified in the streaming URL is used, this parameter is left empty.
        self.pull_app_name = pull_app_name
        # The parameters of back-to-origin stream pulling.
        self.pull_args = pull_args
        # The domain name for back-to-origin stream pulling.
        self.pull_domain_name = pull_domain_name
        # The protocol for back-to-origin stream pulling. Valid values:
        # 
        # *   **rtmp**\
        # *   **httpflv**\
        # *   **hls**\
        self.pull_protocol = pull_protocol
        # Indicates whether stream pulling is triggered when the transcoded stream is played. Default value: **no**. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.transcode_lazy = transcode_lazy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.pull_app_name is not None:
            result['PullAppName'] = self.pull_app_name
        if self.pull_args is not None:
            result['PullArgs'] = self.pull_args
        if self.pull_domain_name is not None:
            result['PullDomainName'] = self.pull_domain_name
        if self.pull_protocol is not None:
            result['PullProtocol'] = self.pull_protocol
        if self.transcode_lazy is not None:
            result['TranscodeLazy'] = self.transcode_lazy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('PullAppName') is not None:
            self.pull_app_name = m.get('PullAppName')
        if m.get('PullArgs') is not None:
            self.pull_args = m.get('PullArgs')
        if m.get('PullDomainName') is not None:
            self.pull_domain_name = m.get('PullDomainName')
        if m.get('PullProtocol') is not None:
            self.pull_protocol = m.get('PullProtocol')
        if m.get('TranscodeLazy') is not None:
            self.transcode_lazy = m.get('TranscodeLazy')
        return self


class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList(TeaModel):
    def __init__(
        self,
        live_lazy_pull_config: List[DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig] = None,
    ):
        self.live_lazy_pull_config = live_lazy_pull_config

    def validate(self):
        if self.live_lazy_pull_config:
            for k in self.live_lazy_pull_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveLazyPullConfig'] = []
        if self.live_lazy_pull_config is not None:
            for k in self.live_lazy_pull_config:
                result['LiveLazyPullConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_lazy_pull_config = []
        if m.get('LiveLazyPullConfig') is not None:
            for k in m.get('LiveLazyPullConfig'):
                temp_model = DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig()
                self.live_lazy_pull_config.append(temp_model.from_map(k))
        return self


class DescribeLiveLazyPullStreamConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_lazy_pull_config_list: DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList = None,
        request_id: str = None,
    ):
        # The configurations of triggered stream pulling.
        self.live_lazy_pull_config_list = live_lazy_pull_config_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.live_lazy_pull_config_list:
            self.live_lazy_pull_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_lazy_pull_config_list is not None:
            result['LiveLazyPullConfigList'] = self.live_lazy_pull_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveLazyPullConfigList') is not None:
            temp_model = DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList()
            self.live_lazy_pull_config_list = temp_model.from_map(m['LiveLazyPullConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveLazyPullStreamConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveLazyPullStreamConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveLazyPullStreamConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
    ):
        # The ID of the interactive messaging application to query.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        return self


class DescribeLiveMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_key: str = None,
        app_name: str = None,
        app_sign: str = None,
        audit_type: int = None,
        audit_url: str = None,
        create_time: int = None,
        data_center: str = None,
        disable: bool = None,
        event_callback_url: str = None,
        modify_time: int = None,
        msg_life_cycle: int = None,
        request_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The AppKey of the interactive messaging application. It is used to authorize operations related to the application ID.
        self.app_key = app_key
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The signature of the interactive messaging application. It is required by the interactive messaging SDK.
        self.app_sign = app_sign
        # The content moderation method. Valid values:
        # 
        # *   0: Content moderation is disabled.
        # *   1: Built-in content moderation is used.
        # *   2: Custom content moderation is used.
        self.audit_type = audit_type
        # The URL for content moderation. This parameter is returned when the value of AuditType is 2.
        self.audit_url = audit_url
        # The time when the interactive messaging application was created. The value is a UNIX timestamp. Unit: seconds.
        self.create_time = create_time
        # The data center.
        self.data_center = data_center
        # Indicates whether the interactive messaging application is disabled.
        self.disable = disable
        # The callback URL for events such as user logon, logoff, joining a group, and leaving a group. An empty value indicates that callbacks are disabled.
        self.event_callback_url = event_callback_url
        # The time when the interactive messaging application was modified. The value is a UNIX timestamp. Unit: seconds.
        self.modify_time = modify_time
        # The retention period of group messages in the application. Valid values:
        # 
        # *   0 (default): 30 days
        # *   1: 90 days
        # *   2: 180 days
        self.msg_life_cycle = msg_life_cycle
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.audit_type is not None:
            result['AuditType'] = self.audit_type
        if self.audit_url is not None:
            result['AuditUrl'] = self.audit_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.disable is not None:
            result['Disable'] = self.disable
        if self.event_callback_url is not None:
            result['EventCallbackUrl'] = self.event_callback_url
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.msg_life_cycle is not None:
            result['MsgLifeCycle'] = self.msg_life_cycle
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('AuditType') is not None:
            self.audit_type = m.get('AuditType')
        if m.get('AuditUrl') is not None:
            self.audit_url = m.get('AuditUrl')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('Disable') is not None:
            self.disable = m.get('Disable')
        if m.get('EventCallbackUrl') is not None:
            self.event_callback_url = m.get('EventCallbackUrl')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('MsgLifeCycle') is not None:
            self.msg_life_cycle = m.get('MsgLifeCycle')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the interactive messaging group whose information you want to query.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class DescribeLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        admin_list: List[str] = None,
        createtime: int = None,
        creator_id: str = None,
        deletatime: int = None,
        delete: bool = None,
        deletor: str = None,
        group_id: str = None,
        group_info: str = None,
        group_name: str = None,
        msg_amount: Dict[str, int] = None,
        online_user_counts: int = None,
        request_id: str = None,
        super_large_group: bool = None,
        total_times: int = None,
    ):
        # The list of the group administrators.
        self.admin_list = admin_list
        # The time when the group was created. The value is a UNIX timestamp. Unit: seconds.
        self.createtime = createtime
        # The ID of the group creator.
        self.creator_id = creator_id
        # The time when the group was deleted. This parameter is returned only if the group was deleted.
        self.deletatime = deletatime
        # Indicates whether the group was deleted.
        self.delete = delete
        # The ID of the user who deleted the group. This parameter is returned only if the group was deleted.
        self.deletor = deletor
        # The group ID.
        self.group_id = group_id
        # Additional information about the group.
        self.group_info = group_info
        # The name of the group.
        self.group_name = group_name
        # The categorized message statistics. This parameter is returned only if the group exists.
        self.msg_amount = msg_amount
        # The number of online users in the group. This parameter is returned only if the group exists.
        self.online_user_counts = online_user_counts
        # The request ID.
        self.request_id = request_id
        # Indicates whether the group is a super group. Valid values:
        # 
        # *   True
        # *   False
        self.super_large_group = super_large_group
        # The total number of sessions. This parameter is returned only if the group exists.
        self.total_times = total_times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_list is not None:
            result['AdminList'] = self.admin_list
        if self.createtime is not None:
            result['Createtime'] = self.createtime
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.deletatime is not None:
            result['Deletatime'] = self.deletatime
        if self.delete is not None:
            result['Delete'] = self.delete
        if self.deletor is not None:
            result['Deletor'] = self.deletor
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.msg_amount is not None:
            result['MsgAmount'] = self.msg_amount
        if self.online_user_counts is not None:
            result['OnlineUserCounts'] = self.online_user_counts
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.super_large_group is not None:
            result['SuperLargeGroup'] = self.super_large_group
        if self.total_times is not None:
            result['TotalTimes'] = self.total_times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminList') is not None:
            self.admin_list = m.get('AdminList')
        if m.get('Createtime') is not None:
            self.createtime = m.get('Createtime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Deletatime') is not None:
            self.deletatime = m.get('Deletatime')
        if m.get('Delete') is not None:
            self.delete = m.get('Delete')
        if m.get('Deletor') is not None:
            self.deletor = m.get('Deletor')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('MsgAmount') is not None:
            self.msg_amount = m.get('MsgAmount')
        if m.get('OnlineUserCounts') is not None:
            self.online_user_counts = m.get('OnlineUserCounts')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuperLargeGroup') is not None:
            self.super_large_group = m.get('SuperLargeGroup')
        if m.get('TotalTimes') is not None:
            self.total_times = m.get('TotalTimes')
        return self


class DescribeLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveMessageGroupBandRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the interactive messaging group.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class DescribeLiveMessageGroupBandResponseBody(TeaModel):
    def __init__(
        self,
        banned_user_list: List[str] = None,
        group_id: str = None,
        isbanned_all: bool = None,
        request_id: str = None,
        unbanned_user_list: List[str] = None,
    ):
        # The list of users that were muted separately, but not by muting the entire group.
        self.banned_user_list = banned_user_list
        # The group ID.
        self.group_id = group_id
        # Indicates whether all users in the interactive messaging group are muted.
        self.isbanned_all = isbanned_all
        # The request ID.
        self.request_id = request_id
        # The list of users who were not muted when the entire group was muted.
        self.unbanned_user_list = unbanned_user_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.banned_user_list is not None:
            result['BannedUserList'] = self.banned_user_list
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.isbanned_all is not None:
            result['IsbannedAll'] = self.isbanned_all
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.unbanned_user_list is not None:
            result['UnbannedUserList'] = self.unbanned_user_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BannedUserList') is not None:
            self.banned_user_list = m.get('BannedUserList')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsbannedAll') is not None:
            self.isbanned_all = m.get('IsbannedAll')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UnbannedUserList') is not None:
            self.unbanned_user_list = m.get('UnbannedUserList')
        return self


class DescribeLiveMessageGroupBandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveMessageGroupBandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveMessageGroupBandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePackageConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The application name. If you leave this parameter empty, all applications are matched.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The sorting order. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_num = page_num
        # The number of entries per page. Valid values: 5 to 30. Default value: 10.
        self.page_size = page_size
        self.region_id = region_id
        # The stream name. If you leave this parameter empty, all streams are matched.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        ignore_transcode: bool = None,
        part_duration: int = None,
        protocol: str = None,
        segment_duration: int = None,
        segment_num: int = None,
        stream_name: str = None,
    ):
        # The application name.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # Indicates whether the transcoded stream is ignored. Valid values:
        # 
        # *   **true** (default)
        # *   **false**\
        self.ignore_transcode = ignore_transcode
        # The part length. Unit: milliseconds.
        self.part_duration = part_duration
        # The streaming protocol and encapsulation format.
        self.protocol = protocol
        # The segment length. Unit: seconds.
        self.segment_duration = segment_duration
        # The number of segments.
        self.segment_num = segment_num
        # The stream name.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ignore_transcode is not None:
            result['IgnoreTranscode'] = self.ignore_transcode
        if self.part_duration is not None:
            result['PartDuration'] = self.part_duration
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.segment_num is not None:
            result['SegmentNum'] = self.segment_num
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IgnoreTranscode') is not None:
            self.ignore_transcode = m.get('IgnoreTranscode')
        if m.get('PartDuration') is not None:
            self.part_duration = m.get('PartDuration')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('SegmentNum') is not None:
            self.segment_num = m.get('SegmentNum')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLivePackageConfigResponseBodyLivePackageConfigList(TeaModel):
    def __init__(
        self,
        live_package_config: List[DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig] = None,
    ):
        self.live_package_config = live_package_config

    def validate(self):
        if self.live_package_config:
            for k in self.live_package_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LivePackageConfig'] = []
        if self.live_package_config is not None:
            for k in self.live_package_config:
                result['LivePackageConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_package_config = []
        if m.get('LivePackageConfig') is not None:
            for k in m.get('LivePackageConfig'):
                temp_model = DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig()
                self.live_package_config.append(temp_model.from_map(k))
        return self


class DescribeLivePackageConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_package_config_list: DescribeLivePackageConfigResponseBodyLivePackageConfigList = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The live stream encapsulation configurations.
        self.live_package_config_list = live_package_config_list
        # The sorting order. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of live stream encapsulation configurations.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.live_package_config_list:
            self.live_package_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_package_config_list is not None:
            result['LivePackageConfigList'] = self.live_package_config_list.to_map()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePackageConfigList') is not None:
            temp_model = DescribeLivePackageConfigResponseBodyLivePackageConfigList()
            self.live_package_config_list = temp_model.from_map(m['LivePackageConfigList'])
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLivePackageConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePackageConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePackageConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePrivateLineAreasRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion(TeaModel):
    def __init__(
        self,
        local_name: str = None,
        region_id: str = None,
    ):
        # The region name.
        self.local_name = local_name
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions(TeaModel):
    def __init__(
        self,
        region: List[DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion] = None,
    ):
        self.region = region

    def validate(self):
        if self.region:
            for k in self.region:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Region'] = []
        if self.region is not None:
            for k in self.region:
                result['Region'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.region = []
        if m.get('Region') is not None:
            for k in m.get('Region'):
                temp_model = DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion()
                self.region.append(temp_model.from_map(k))
        return self


class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea(TeaModel):
    def __init__(
        self,
        region_type: str = None,
        regions: DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions = None,
    ):
        # The region type. Valid values:
        # 
        # *   domestic: in the Chinese mainland
        # *   overseas: outside the Chinese mainland
        self.region_type = region_type
        # The regions.
        self.regions = regions

    def validate(self):
        if self.regions:
            self.regions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_type is not None:
            result['RegionType'] = self.region_type
        if self.regions is not None:
            result['Regions'] = self.regions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionType') is not None:
            self.region_type = m.get('RegionType')
        if m.get('Regions') is not None:
            temp_model = DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions()
            self.regions = temp_model.from_map(m['Regions'])
        return self


class DescribeLivePrivateLineAreasResponseBodyLiveAreasList(TeaModel):
    def __init__(
        self,
        live_area: List[DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea] = None,
    ):
        self.live_area = live_area

    def validate(self):
        if self.live_area:
            for k in self.live_area:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveArea'] = []
        if self.live_area is not None:
            for k in self.live_area:
                result['LiveArea'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_area = []
        if m.get('LiveArea') is not None:
            for k in m.get('LiveArea'):
                temp_model = DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea()
                self.live_area.append(temp_model.from_map(k))
        return self


class DescribeLivePrivateLineAreasResponseBody(TeaModel):
    def __init__(
        self,
        live_areas_list: DescribeLivePrivateLineAreasResponseBodyLiveAreasList = None,
        request_id: str = None,
    ):
        # Details about the regions.
        self.live_areas_list = live_areas_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_areas_list:
            self.live_areas_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_areas_list is not None:
            result['LiveAreasList'] = self.live_areas_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveAreasList') is not None:
            temp_model = DescribeLivePrivateLineAreasResponseBodyLiveAreasList()
            self.live_areas_list = temp_model.from_map(m['LiveAreasList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePrivateLineAreasResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePrivateLineAreasResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePrivateLineAreasResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePrivateLineAvailGARequest(TeaModel):
    def __init__(
        self,
        acceleration_area: str = None,
        app_name: str = None,
        domain_name: str = None,
        is_ga_instance: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
        video_center: str = None,
    ):
        # The acceleration channel.
        self.acceleration_area = acceleration_area
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to query Global Accelerator (GA) instances. Valid values:
        # 
        # *   yes: queries the status of GA instances.
        # *   no: queries the binding information between GA instances and acceleration circuits.
        # 
        # This parameter is required.
        self.is_ga_instance = is_ga_instance
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream.
        self.stream_name = stream_name
        # The live center. Valid values: cn-beijing, cn-shanghai, cn-shenzhen, cn-qingdao, ap-northeast-1, ap-southeast-5, eu-central-1, ap-southeast-1, and ap-south-1. cn-beijing indicates China (Beijing). cn-shanghai indicates China (Shanghai). cn-shenzhen indicates China (Shenzhen). cn-qingdao indicates China (Qingdao). ap-northeast-1 indicates Japan (Tokyo). ap-southeast-5 indicates Indonesia (Jakarta). eu-central-1 indicates Germany (Frankfurt). ap-southeast-1 indicates Singapore.
        self.video_center = video_center

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceleration_area is not None:
            result['AccelerationArea'] = self.acceleration_area
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.is_ga_instance is not None:
            result['IsGaInstance'] = self.is_ga_instance
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.video_center is not None:
            result['VideoCenter'] = self.video_center
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccelerationArea') is not None:
            self.acceleration_area = m.get('AccelerationArea')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IsGaInstance') is not None:
            self.is_ga_instance = m.get('IsGaInstance')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VideoCenter') is not None:
            self.video_center = m.get('VideoCenter')
        return self


class DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA(TeaModel):
    def __init__(
        self,
        acceleration_area: str = None,
        acceleration_type: str = None,
        app_name: str = None,
        binding_status: str = None,
        domain_name: str = None,
        ip: str = None,
        instance_id: str = None,
        status: str = None,
        stream_name: str = None,
        uid: str = None,
        video_center: str = None,
    ):
        # The acceleration channel.
        self.acceleration_area = acceleration_area
        # The acceleration type. Valid values:
        # 
        # *   play: streaming acceleration
        # *   publish: stream ingest acceleration
        self.acceleration_type = acceleration_type
        # The name of the application.
        self.app_name = app_name
        # Indicates whether the GA instance is bound to an acceleration circuit. Valid values:
        # 
        # *   yes
        # *   no
        self.binding_status = binding_status
        # The main streaming domain.
        self.domain_name = domain_name
        # The accelerated IP address.
        self.ip = ip
        # The ID of the GA instance.
        self.instance_id = instance_id
        # The status of the GA instance. Valid values:
        # 
        # *   active: The GA instance is available.
        # *   inactive: The GA instance is unavailable.
        self.status = status
        # The name of the live stream.
        self.stream_name = stream_name
        # The user ID (UID).
        self.uid = uid
        # The live center.
        self.video_center = video_center

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceleration_area is not None:
            result['AccelerationArea'] = self.acceleration_area
        if self.acceleration_type is not None:
            result['AccelerationType'] = self.acceleration_type
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.binding_status is not None:
            result['BindingStatus'] = self.binding_status
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ip is not None:
            result['IP'] = self.ip
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.video_center is not None:
            result['VideoCenter'] = self.video_center
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccelerationArea') is not None:
            self.acceleration_area = m.get('AccelerationArea')
        if m.get('AccelerationType') is not None:
            self.acceleration_type = m.get('AccelerationType')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BindingStatus') is not None:
            self.binding_status = m.get('BindingStatus')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IP') is not None:
            self.ip = m.get('IP')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('VideoCenter') is not None:
            self.video_center = m.get('VideoCenter')
        return self


class DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs(TeaModel):
    def __init__(
        self,
        live_private_line_avail_ga: List[DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA] = None,
    ):
        self.live_private_line_avail_ga = live_private_line_avail_ga

    def validate(self):
        if self.live_private_line_avail_ga:
            for k in self.live_private_line_avail_ga:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LivePrivateLineAvailGA'] = []
        if self.live_private_line_avail_ga is not None:
            for k in self.live_private_line_avail_ga:
                result['LivePrivateLineAvailGA'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_private_line_avail_ga = []
        if m.get('LivePrivateLineAvailGA') is not None:
            for k in m.get('LivePrivateLineAvailGA'):
                temp_model = DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA()
                self.live_private_line_avail_ga.append(temp_model.from_map(k))
        return self


class DescribeLivePrivateLineAvailGAResponseBody(TeaModel):
    def __init__(
        self,
        live_private_line_avail_gas: DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs = None,
        request_id: str = None,
    ):
        # The GA instance configuration details.
        self.live_private_line_avail_gas = live_private_line_avail_gas
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_private_line_avail_gas:
            self.live_private_line_avail_gas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_private_line_avail_gas is not None:
            result['LivePrivateLineAvailGAs'] = self.live_private_line_avail_gas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LivePrivateLineAvailGAs') is not None:
            temp_model = DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs()
            self.live_private_line_avail_gas = temp_model.from_map(m['LivePrivateLineAvailGAs'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePrivateLineAvailGAResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePrivateLineAvailGAResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePrivateLineAvailGAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveProducerUsageDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        instance: str = None,
        interval: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
        type: str = None,
        app: str = None,
    ):
        # The streaming domain of the production studio.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The end time must be later than the start time.
        self.end_time = end_time
        # The production studio instance that you want to query. You can specify one or more production studio instances. Separate multiple instances with commas (,).
        # 
        # >  If you do not set this parameter, the usage data of all production studio instances is returned.
        self.instance = instance
        # The time granularity for a query. Valid values: 3600 and 86400. Unit: seconds.
        self.interval = interval
        self.owner_id = owner_id
        # The region in which the domain name resides. If you leave this parameter empty, the data of all regions is returned. You can specify multiple regions by separating them with commas (,).
        self.region = region
        self.region_id = region_id
        # The key that is used to group data. You can specify one or more keys. Separate multiple keys with commas (,). Valid values: domain, region, instance, and type. The data for a key that you specify by using the SplitBy parameter is returned by group.
        # 
        # >  If you do not set this parameter, the aggregated data is returned.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The type of the production studio. You can specify one or more production studio types. Separate multiple types with commas (,). Valid values:
        # 
        # *   **slidelive**: playlist-mode studio.
        # *   **universal**: general studio.
        # 
        # >  If you do not set this parameter, the usage data of all types of production studios is returned.
        self.type = type
        # The name of the application to which the live stream belongs.
        self.app = app

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance is not None:
            result['Instance'] = self.instance
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        if self.app is not None:
            result['app'] = self.app
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('app') is not None:
            self.app = m.get('app')
        return self


class DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        instance: str = None,
        output_hd_duration: int = None,
        output_ld_duration: int = None,
        output_sd_duration: int = None,
        region: str = None,
        time_stamp: str = None,
        tran_hd_duration: int = None,
        tran_ld_duration: int = None,
        tran_sd_duration: int = None,
        type: str = None,
    ):
        # The domain name. If domain is specified by the SplitBy parameter, the usage data is returned based on different domain names.
        self.domain_name = domain_name
        # The production studio instance. If instance is specified by the SplitBy parameter, the usage data is returned based on different production studio instances.
        self.instance = instance
        # The duration of high definition streaming. Unit: minutes.
        self.output_hd_duration = output_hd_duration
        # The duration of low definition streaming. Unit: minutes.
        self.output_ld_duration = output_ld_duration
        # The duration of standard definition streaming. Unit: minutes.
        self.output_sd_duration = output_sd_duration
        # The region. If region is specified by the SplitBy parameter, the usage data is returned based on different regions.
        self.region = region
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The duration of high definition transcoding. Unit: minutes.
        self.tran_hd_duration = tran_hd_duration
        # The duration of low definition transcoding. Unit: minutes.
        self.tran_ld_duration = tran_ld_duration
        # The duration of standard definition transcoding. Unit: minutes.
        self.tran_sd_duration = tran_sd_duration
        # The type of the production studio. If type is specified by the SplitBy parameter, the usage data is returned based on different types of production studios.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.instance is not None:
            result['Instance'] = self.instance
        if self.output_hd_duration is not None:
            result['OutputHdDuration'] = self.output_hd_duration
        if self.output_ld_duration is not None:
            result['OutputLdDuration'] = self.output_ld_duration
        if self.output_sd_duration is not None:
            result['OutputSdDuration'] = self.output_sd_duration
        if self.region is not None:
            result['Region'] = self.region
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.tran_hd_duration is not None:
            result['TranHdDuration'] = self.tran_hd_duration
        if self.tran_ld_duration is not None:
            result['TranLdDuration'] = self.tran_ld_duration
        if self.tran_sd_duration is not None:
            result['TranSdDuration'] = self.tran_sd_duration
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        if m.get('OutputHdDuration') is not None:
            self.output_hd_duration = m.get('OutputHdDuration')
        if m.get('OutputLdDuration') is not None:
            self.output_ld_duration = m.get('OutputLdDuration')
        if m.get('OutputSdDuration') is not None:
            self.output_sd_duration = m.get('OutputSdDuration')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TranHdDuration') is not None:
            self.tran_hd_duration = m.get('TranHdDuration')
        if m.get('TranLdDuration') is not None:
            self.tran_ld_duration = m.get('TranLdDuration')
        if m.get('TranSdDuration') is not None:
            self.tran_sd_duration = m.get('TranSdDuration')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveProducerUsageDataResponseBodyBillProducerData(TeaModel):
    def __init__(
        self,
        bill_producer_data_item: List[DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem] = None,
    ):
        self.bill_producer_data_item = bill_producer_data_item

    def validate(self):
        if self.bill_producer_data_item:
            for k in self.bill_producer_data_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BillProducerDataItem'] = []
        if self.bill_producer_data_item is not None:
            for k in self.bill_producer_data_item:
                result['BillProducerDataItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bill_producer_data_item = []
        if m.get('BillProducerDataItem') is not None:
            for k in m.get('BillProducerDataItem'):
                temp_model = DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem()
                self.bill_producer_data_item.append(temp_model.from_map(k))
        return self


class DescribeLiveProducerUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        bill_producer_data: DescribeLiveProducerUsageDataResponseBodyBillProducerData = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The production studio usage data.
        self.bill_producer_data = bill_producer_data
        # The end of the time range during which data was queried.
        self.end_time = end_time
        # The ID of the request.
        self.request_id = request_id
        # The start of the time range for which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.bill_producer_data:
            self.bill_producer_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bill_producer_data is not None:
            result['BillProducerData'] = self.bill_producer_data.to_map()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BillProducerData') is not None:
            temp_model = DescribeLiveProducerUsageDataResponseBodyBillProducerData()
            self.bill_producer_data = temp_model.from_map(m['BillProducerData'])
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveProducerUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveProducerUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveProducerUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePullStreamConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        source_url: str = None,
        source_using: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The end of the time range for which the configurations were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The origin server of the live stream.
        self.source_url = source_url
        # The live stream origin server that you are using.
        self.source_using = source_using
        # The beginning of the time range for which the configurations were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.source_using is not None:
            result['SourceUsing'] = self.source_using
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('SourceUsing') is not None:
            self.source_using = m.get('SourceUsing')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLivePullStreamConfigResponseBodyLiveAppRecordList(TeaModel):
    def __init__(
        self,
        live_app_record: List[DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord] = None,
    ):
        self.live_app_record = live_app_record

    def validate(self):
        if self.live_app_record:
            for k in self.live_app_record:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveAppRecord'] = []
        if self.live_app_record is not None:
            for k in self.live_app_record:
                result['LiveAppRecord'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_app_record = []
        if m.get('LiveAppRecord') is not None:
            for k in m.get('LiveAppRecord'):
                temp_model = DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord()
                self.live_app_record.append(temp_model.from_map(k))
        return self


class DescribeLivePullStreamConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_app_record_list: DescribeLivePullStreamConfigResponseBodyLiveAppRecordList = None,
        request_id: str = None,
    ):
        # Details about the stream pulling configurations.
        self.live_app_record_list = live_app_record_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.live_app_record_list:
            self.live_app_record_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_app_record_list is not None:
            result['LiveAppRecordList'] = self.live_app_record_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveAppRecordList') is not None:
            temp_model = DescribeLivePullStreamConfigResponseBodyLiveAppRecordList()
            self.live_app_record_list = temp_model.from_map(m['LiveAppRecordList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePullStreamConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePullStreamConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePullStreamConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeLivePullToPushResponseBodyTaskInfo(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        dst_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        repeat_number: int = None,
        retry_count: int = None,
        retry_interval: int = None,
        source_protocol: str = None,
        source_type: str = None,
        source_urls: List[str] = None,
        start_time: str = None,
        task_id: str = None,
        task_name: str = None,
    ):
        # The HTTP callback URL.
        self.callback_url = callback_url
        # The destination URL to which the stream is relayed.
        self.dst_url = dst_url
        # The end time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The file index, which indicates the sequence of the file where the playback starts.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.offset = offset
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # >  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.repeat_number = repeat_number
        # The number of retries allowed.
        self.retry_count = retry_count
        # The retry interval. Unit: seconds.
        self.retry_interval = retry_interval
        # The protocol of the source stream.
        self.source_protocol = source_protocol
        # The type of the source stream. Valid values:
        # 
        # *   live: a live stream
        # *   vod: a list of ApsaraVideo VOD resources
        # *   url: a list of video resources from a third party
        self.source_type = source_type
        # The source URLs.
        self.source_urls = source_urls
        # The start time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The task ID.
        self.task_id = task_id
        # The task name.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_urls is not None:
            result['SourceUrls'] = self.source_urls
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceUrls') is not None:
            self.source_urls = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribeLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        current_file_index: int = None,
        current_offset: int = None,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
        task_exit_reason: str = None,
        task_exit_time: int = None,
        task_id: str = None,
        task_info: DescribeLivePullToPushResponseBodyTaskInfo = None,
        task_invalid_reason: str = None,
        task_status: int = None,
    ):
        # The current file index.
        self.current_file_index = current_file_index
        # The current offset for video playback.
        self.current_offset = current_offset
        # The error description.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The code that is returned for the request.
        # 
        # > 
        # 
        # *   0 is returned if the request is normal.
        # 
        # *   For information about codes that are returned when exceptions occur, see the following Error codes table.
        self.ret_code = ret_code
        # The reason why the task is stopped.
        # 
        # *   TriggerByUser: You proactively stopped the task.
        # *   OverEndTime: The specified end time was exceeded.
        # 
        # >  This parameter is returned only if the task is stopped.
        self.task_exit_reason = task_exit_reason
        # The time when the task was exited. The value is a Unix timestamp in seconds.
        # 
        # >  This parameter is returned only if the task status is exited.
        self.task_exit_time = task_exit_time
        # The task ID.
        self.task_id = task_id
        # The information about the task.
        self.task_info = task_info
        # The reason why the task was stopped.
        # 
        # *   PullStreamFailed: An exception occurred while pulling the source stream. A retry is in progress.
        # *   PushStreamFailed: An exception occurred while ingesting the stream. A retry is in progress.
        # *   UnknownError: An unknown exception occurred.
        # 
        # >  This parameter is returned only if the task status is stopped.
        self.task_invalid_reason = task_invalid_reason
        # The current status of the task.
        # 
        # *   0: not started.
        # *   1: running. Stream pulling and stream relay are normal.
        # *   2: abnormal.
        # *   3: stopped. It may be because exceptions occur during stream pulling or stream relay or you proactively call the StopLivePullToPush operation.
        # *   \\-1: exited.
        self.task_status = task_status

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_file_index is not None:
            result['CurrentFileIndex'] = self.current_file_index
        if self.current_offset is not None:
            result['CurrentOffset'] = self.current_offset
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        if self.task_exit_reason is not None:
            result['TaskExitReason'] = self.task_exit_reason
        if self.task_exit_time is not None:
            result['TaskExitTime'] = self.task_exit_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.task_invalid_reason is not None:
            result['TaskInvalidReason'] = self.task_invalid_reason
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentFileIndex') is not None:
            self.current_file_index = m.get('CurrentFileIndex')
        if m.get('CurrentOffset') is not None:
            self.current_offset = m.get('CurrentOffset')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        if m.get('TaskExitReason') is not None:
            self.task_exit_reason = m.get('TaskExitReason')
        if m.get('TaskExitTime') is not None:
            self.task_exit_time = m.get('TaskExitTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = DescribeLivePullToPushResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TaskInvalidReason') is not None:
            self.task_invalid_reason = m.get('TaskInvalidReason')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePullToPushListRequest(TeaModel):
    def __init__(
        self,
        dst_url: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region: str = None,
        region_id: str = None,
        task_id: str = None,
        task_name: str = None,
    ):
        # The destination URL. Fuzzy search is performed based on the destination URL.
        self.dst_url = dst_url
        self.owner_id = owner_id
        # The page number.
        # 
        # >  The value must be greater than 0 and not greater than the maximum value of the Integer data type. Default value: 1.
        self.page_number = page_number
        # The number of entries per page.
        # 
        # >  Valid values: [1,100]. Default value: 10.
        self.page_size = page_size
        # The region of the live center. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The task ID. Fuzzy search is performed based on the task ID.
        # 
        # >  The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        self.task_id = task_id
        # The task name. Fuzzy search is performed based on the task name.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribeLivePullToPushListResponseBodyTaskListTaskInfo(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        dst_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        repeat_number: int = None,
        retry_count: int = None,
        retry_interval: int = None,
        source_protocol: str = None,
        source_type: str = None,
        source_urls: List[str] = None,
        start_time: str = None,
        task_id: str = None,
        task_name: str = None,
    ):
        # The HTTP callback URL.
        self.callback_url = callback_url
        # The destination URL to which the stream is relayed.
        self.dst_url = dst_url
        # The end time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The file index, which indicates the sequence of the file where the playback starts.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.offset = offset
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # >  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        self.repeat_number = repeat_number
        # The number of retries allowed.
        self.retry_count = retry_count
        # The retry interval. Unit: seconds.
        self.retry_interval = retry_interval
        # The protocol of the source stream.
        self.source_protocol = source_protocol
        # The type of the source stream. Valid values:
        # 
        # *   live: a live stream
        # *   vod: a list of ApsaraVideo VOD resources
        # *   url: a list of video resources from a third party
        self.source_type = source_type
        # The source URLs.
        self.source_urls = source_urls
        # The start time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The task ID.
        self.task_id = task_id
        # The task name.
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.source_protocol is not None:
            result['SourceProtocol'] = self.source_protocol
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_urls is not None:
            result['SourceUrls'] = self.source_urls
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SourceProtocol') is not None:
            self.source_protocol = m.get('SourceProtocol')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceUrls') is not None:
            self.source_urls = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribeLivePullToPushListResponseBodyTaskList(TeaModel):
    def __init__(
        self,
        current_file_index: int = None,
        current_offset: int = None,
        task_exit_reason: str = None,
        task_exit_time: int = None,
        task_id: str = None,
        task_info: DescribeLivePullToPushListResponseBodyTaskListTaskInfo = None,
        task_invalid_reason: str = None,
        task_status: int = None,
    ):
        # The current file index.
        self.current_file_index = current_file_index
        # The current offset for video playback.
        self.current_offset = current_offset
        # The reason why the task was exited. Valid values:
        # 
        # *   TriggerByUser: You proactively ended the task.
        # *   OverEndTime: The specified end time was exceeded.
        # 
        # >  This parameter is returned only if the task status is exited.
        self.task_exit_reason = task_exit_reason
        # The time when the task was exited. The value is a Unix timestamp in seconds.
        # 
        # >  This parameter is returned only if the task status is exited.
        self.task_exit_time = task_exit_time
        # The task ID.
        self.task_id = task_id
        # The information about the task.
        self.task_info = task_info
        # The reason why the task was stopped.
        # 
        # *   PullStreamFailed: An exception occurred while pulling the source stream. A retry is in progress.
        # *   PushStreamFailed: An exception occurred while ingesting the stream. A retry is in progress.
        # *   UnknownError: An unknown exception occurred.
        # 
        # >  This parameter is returned only if the task status is stopped.
        self.task_invalid_reason = task_invalid_reason
        # The task status. Valid values:
        # 
        # *   0: not started.
        # *   1: running. Stream pulling and stream relay are normal.
        # *   2: abnormal.
        # *   3: stopped. It may be because exceptions occur during stream pulling or stream relay or you proactively call the StopLivePullToPush operation.
        # *   \\-1: exited.
        self.task_status = task_status

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_file_index is not None:
            result['CurrentFileIndex'] = self.current_file_index
        if self.current_offset is not None:
            result['CurrentOffset'] = self.current_offset
        if self.task_exit_reason is not None:
            result['TaskExitReason'] = self.task_exit_reason
        if self.task_exit_time is not None:
            result['TaskExitTime'] = self.task_exit_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        if self.task_invalid_reason is not None:
            result['TaskInvalidReason'] = self.task_invalid_reason
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentFileIndex') is not None:
            self.current_file_index = m.get('CurrentFileIndex')
        if m.get('CurrentOffset') is not None:
            self.current_offset = m.get('CurrentOffset')
        if m.get('TaskExitReason') is not None:
            self.task_exit_reason = m.get('TaskExitReason')
        if m.get('TaskExitTime') is not None:
            self.task_exit_time = m.get('TaskExitTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInfo') is not None:
            temp_model = DescribeLivePullToPushListResponseBodyTaskListTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        if m.get('TaskInvalidReason') is not None:
            self.task_invalid_reason = m.get('TaskInvalidReason')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeLivePullToPushListResponseBody(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        task_list: List[DescribeLivePullToPushListResponseBodyTaskList] = None,
        total: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The tasks.
        self.task_list = task_list
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = DescribeLivePullToPushListResponseBodyTaskList()
                self.task_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLivePullToPushListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePullToPushListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePullToPushListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePushProxyLogRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The ingest domain. You can specify only one domain in each request.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Get the log end time.
        # Date format follows the ISO8601 representation and uses UTC+0 time, formatted as yyyy-MM-ddTHH:mm:ssZ.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values: [1,1000]. Default value: 300.
        self.page_size = page_size
        self.region_id = region_id
        # Get the log start time in ISO8601 format with UTC+0 timezone, formatted as yyyy-MM-ddTHH:mm:ssZ.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        # The end of the time range during which data was queried.
        # 
        # The value is a UNIX timestamp.
        self.end_time = end_time
        # The name of the log file.
        self.log_name = log_name
        # The path of the log file.
        self.log_path = log_path
        # The size of the log file.
        self.log_size = log_size
        # The beginning of the time range during which data was queried.
        # 
        # The value is a UNIX timestamp.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number.
        self.page_index = page_index
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        # The total number of entries returned on the current page.
        self.log_count = log_count
        # Details about the logs.
        self.log_infos = log_infos
        # The page information.
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLivePushProxyLogResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLivePushProxyLogResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLivePushProxyLogResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        # The log information.
        self.domain_log_details = domain_log_details
        # Push domain.
        self.domain_name = domain_name
        # Request ID.
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLivePushProxyLogResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePushProxyLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePushProxyLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePushProxyLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePushProxyUsageDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        split_by: str = None,
        start_time: str = None,
    ):
        # The main streaming domain to query.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time.
        self.end_time = end_time
        self.owner_id = owner_id
        # The ID of the region. Separate multiple region IDs with commas (,). Valid values:
        # 
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # *   cn-shenzhen: China (Shenzhen)
        # *   cn-qingdao: China (Qingdao)
        # *   ap-southeast-1: Singapore
        # *   eu-central-1: Germany (Frankfurt)
        # *   ap-northeast-1: Japan (Tokyo)
        # *   ap-southeast-5: Indonesia (Jakarta)
        # 
        # If you do not specify this parameter, data of all regions is aggregated and returned by default.
        self.region = region
        self.region_id = region_id
        # The key that is used to group data. If you do not specify this parameter, the default value region is used. Data is aggregated and returned. Separate multiple keys with commas (,). Valid values:
        # 
        # *   domain: The value of DomainName in the response takes effect only if SplitBy is set to domain.
        # *   region: This is the default value. The value of Region in the response takes effect only if SplitBy is set to region.
        self.split_by = split_by
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. By default, data in the last seven days is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_by is not None:
            result['SplitBy'] = self.split_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitBy') is not None:
            self.split_by = m.get('SplitBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        region: str = None,
        stream_count: int = None,
        time_stamp: str = None,
    ):
        # The domain name. If the value of SplitBy includes domain, the returned data is grouped by domain name.
        self.domain_name = domain_name
        # The ID of the region. If the value of SplitBy includes region, the returned data is grouped by region.
        self.region = region
        # The peak number of live center stream relay channels.
        self.stream_count = stream_count
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.region is not None:
            result['Region'] = self.region
        if self.stream_count is not None:
            result['StreamCount'] = self.stream_count
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StreamCount') is not None:
            self.stream_count = m.get('StreamCount')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLivePushProxyUsageDataResponseBodyPushProxyData(TeaModel):
    def __init__(
        self,
        push_proxy_data_item: List[DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem] = None,
    ):
        self.push_proxy_data_item = push_proxy_data_item

    def validate(self):
        if self.push_proxy_data_item:
            for k in self.push_proxy_data_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PushProxyDataItem'] = []
        if self.push_proxy_data_item is not None:
            for k in self.push_proxy_data_item:
                result['PushProxyDataItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.push_proxy_data_item = []
        if m.get('PushProxyDataItem') is not None:
            for k in m.get('PushProxyDataItem'):
                temp_model = DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem()
                self.push_proxy_data_item.append(temp_model.from_map(k))
        return self


class DescribeLivePushProxyUsageDataResponseBody(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        push_proxy_data: DescribeLivePushProxyUsageDataResponseBodyPushProxyData = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The end time.
        self.end_time = end_time
        # The usage data of live center stream relay.
        self.push_proxy_data = push_proxy_data
        # The request ID.
        self.request_id = request_id
        # The start time.
        self.start_time = start_time

    def validate(self):
        if self.push_proxy_data:
            self.push_proxy_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.push_proxy_data is not None:
            result['PushProxyData'] = self.push_proxy_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PushProxyData') is not None:
            temp_model = DescribeLivePushProxyUsageDataResponseBodyPushProxyData()
            self.push_proxy_data = temp_model.from_map(m['PushProxyData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLivePushProxyUsageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLivePushProxyUsageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePushProxyUsageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRealtimeDeliveryAccRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        interval: str = None,
        log_store: str = None,
        owner_id: int = None,
        project: str = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The streaming domain.
        # 
        # *   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
        # *   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # The end time must be later than the start time. The maximum time range that can be specified is one year.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   **300**\
        # *   **3600**\
        # *   **86400**\
        # 
        # If you specify an invalid value or do not specify this parameter, the default value is used. If the specified time range is no more than three days, the default value is 300. If the specified time range is more than three days and no more than 30 days, the default value is 3600. If the specified time range is more than 30 days, the default value is 86400.
        self.interval = interval
        # The name of the Logstore to which log entries are delivered. If you leave this parameter empty, the data of all Logstores is returned.
        self.log_store = log_store
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery. If you leave this parameter empty, the data of all Log Service projects is returned.
        self.project = project
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData(TeaModel):
    def __init__(
        self,
        failed_num: int = None,
        success_num: int = None,
        time_stamp: str = None,
    ):
        # The number of failed real-time log deliveries.
        self.failed_num = failed_num
        # The number of successful real-time log deliveries.
        self.success_num = success_num
        # The timestamp of the data returned.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_num is not None:
            result['FailedNum'] = self.failed_num
        if self.success_num is not None:
            result['SuccessNum'] = self.success_num
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedNum') is not None:
            self.failed_num = m.get('FailedNum')
        if m.get('SuccessNum') is not None:
            self.success_num = m.get('SuccessNum')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData(TeaModel):
    def __init__(
        self,
        acc_data: List[DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData] = None,
    ):
        self.acc_data = acc_data

    def validate(self):
        if self.acc_data:
            for k in self.acc_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccData'] = []
        if self.acc_data is not None:
            for k in self.acc_data:
                result['AccData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.acc_data = []
        if m.get('AccData') is not None:
            for k in m.get('AccData'):
                temp_model = DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData()
                self.acc_data.append(temp_model.from_map(k))
        return self


class DescribeLiveRealtimeDeliveryAccResponseBody(TeaModel):
    def __init__(
        self,
        real_time_delivery_acc_data: DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData = None,
        request_id: str = None,
    ):
        # The information about real-time log deliveries.
        self.real_time_delivery_acc_data = real_time_delivery_acc_data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.real_time_delivery_acc_data:
            self.real_time_delivery_acc_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.real_time_delivery_acc_data is not None:
            result['RealTimeDeliveryAccData'] = self.real_time_delivery_acc_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RealTimeDeliveryAccData') is not None:
            temp_model = DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData()
            self.real_time_delivery_acc_data = temp_model.from_map(m['RealTimeDeliveryAccData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveRealtimeDeliveryAccResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRealtimeDeliveryAccResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRealtimeDeliveryAccResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRealtimeLogAuthorizedRequest(TeaModel):
    def __init__(
        self,
        live_openapi_reserve: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # This parameter has no practical significance.
        self.live_openapi_reserve = live_openapi_reserve
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_openapi_reserve is not None:
            result['LiveOpenapiReserve'] = self.live_openapi_reserve
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveOpenapiReserve') is not None:
            self.live_openapi_reserve = m.get('LiveOpenapiReserve')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveRealtimeLogAuthorizedResponseBody(TeaModel):
    def __init__(
        self,
        authorized_status: str = None,
        request_id: str = None,
    ):
        # The authorization status. **true**: authorized **false**: not authorized
        self.authorized_status = authorized_status
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized_status is not None:
            result['AuthorizedStatus'] = self.authorized_status
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizedStatus') is not None:
            self.authorized_status = m.get('AuthorizedStatus')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveRealtimeLogAuthorizedResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRealtimeLogAuthorizedResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRealtimeLogAuthorizedResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRecordConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        security_token: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The name of the main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The order in which the entries are sorted based on creation time. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_num = page_num
        # The number of entries per page. Valid values: **5 to 30**. Default value: **10**.
        self.page_size = page_size
        self.security_token = security_token
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of a recording file. Unit: seconds.
        self.cycle_duration = cycle_duration
        # The format of recording files.
        self.format = format
        # The naming format of a recording file.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a segment file. Unit: seconds.
        self.slice_duration = slice_duration
        # The naming format of a segment file.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList(TeaModel):
    def __init__(
        self,
        record_format: List[DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat] = None,
    ):
        self.record_format = record_format

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        oss_object_prefix: str = None,
        slice_duration: int = None,
        slice_oss_object_prefix: str = None,
    ):
        # The duration of a recording file. Unit: seconds.
        self.cycle_duration = cycle_duration
        # The format of recording files.
        self.format = format
        # The naming format of a recording file.
        self.oss_object_prefix = oss_object_prefix
        # The duration of a segment file. Unit: seconds.
        self.slice_duration = slice_duration
        # The naming format of a segment file.
        self.slice_oss_object_prefix = slice_oss_object_prefix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList(TeaModel):
    def __init__(
        self,
        record_format: List[DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat] = None,
    ):
        self.record_format = record_format

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates(TeaModel):
    def __init__(
        self,
        templates: List[str] = None,
    ):
        self.templates = templates

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.templates is not None:
            result['Templates'] = self.templates
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Templates') is not None:
            self.templates = m.get('Templates')
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        create_time: str = None,
        delay_time: int = None,
        domain_name: str = None,
        end_time: str = None,
        on_demond: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        record_format_list: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList = None,
        start_time: str = None,
        stream_name: str = None,
        transcode_record_format_list: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList = None,
        transcode_templates: DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The time when the recording configuration was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The maximum interruption duration of the live stream. If the actual interruption duration exceeds the threshold, a new recording is generated. Valid values: 15 to 21600. Unit: seconds.
        self.delay_time = delay_time
        # The name of the main streaming domain.
        self.domain_name = domain_name
        # The end time of the recording. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The configuration of on-demand recording. Valid values:
        # 
        # *   **0**: disables on-demand recording.
        # *   **1**: enables on-demand recording that is triggered by HTTP callbacks.
        # *   **2**: enables on-demand recording that is triggered by stream ingest parameters.
        # *   **7**: enables on-demand recording by calling the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/85907.html) operation to manually start or stop recording.
        # 
        # >  If you set OnDemand to **1**, you must call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/51831.html) operation to configure OnDemandUrl. Otherwise, the configuration of on-demand recording is invalid.
        self.on_demond = on_demond
        # The name of the Object Storage Service (OSS) bucket in which the recordings are stored.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The recording formats of original streams.
        self.record_format_list = record_format_list
        # The start time of the recording. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The recording formats of transcoded streams.
        self.transcode_record_format_list = transcode_record_format_list
        # The transcoding templates.
        self.transcode_templates = transcode_templates

    def validate(self):
        if self.record_format_list:
            self.record_format_list.validate()
        if self.transcode_record_format_list:
            self.transcode_record_format_list.validate()
        if self.transcode_templates:
            self.transcode_templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.on_demond is not None:
            result['OnDemond'] = self.on_demond
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.record_format_list is not None:
            result['RecordFormatList'] = self.record_format_list.to_map()
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transcode_record_format_list is not None:
            result['TranscodeRecordFormatList'] = self.transcode_record_format_list.to_map()
        if self.transcode_templates is not None:
            result['TranscodeTemplates'] = self.transcode_templates.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OnDemond') is not None:
            self.on_demond = m.get('OnDemond')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('RecordFormatList') is not None:
            temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList()
            self.record_format_list = temp_model.from_map(m['RecordFormatList'])
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TranscodeRecordFormatList') is not None:
            temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList()
            self.transcode_record_format_list = temp_model.from_map(m['TranscodeRecordFormatList'])
        if m.get('TranscodeTemplates') is not None:
            temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates()
            self.transcode_templates = temp_model.from_map(m['TranscodeTemplates'])
        return self


class DescribeLiveRecordConfigResponseBodyLiveAppRecordList(TeaModel):
    def __init__(
        self,
        live_app_record: List[DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord] = None,
    ):
        self.live_app_record = live_app_record

    def validate(self):
        if self.live_app_record:
            for k in self.live_app_record:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveAppRecord'] = []
        if self.live_app_record is not None:
            for k in self.live_app_record:
                result['LiveAppRecord'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_app_record = []
        if m.get('LiveAppRecord') is not None:
            for k in m.get('LiveAppRecord'):
                temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord()
                self.live_app_record.append(temp_model.from_map(k))
        return self


class DescribeLiveRecordConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_app_record_list: DescribeLiveRecordConfigResponseBodyLiveAppRecordList = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The list of recording configurations.
        self.live_app_record_list = live_app_record_list
        # The sorting order of recording configurations by creation time.
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of recording configurations that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.live_app_record_list:
            self.live_app_record_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_app_record_list is not None:
            result['LiveAppRecordList'] = self.live_app_record_list.to_map()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveAppRecordList') is not None:
            temp_model = DescribeLiveRecordConfigResponseBodyLiveAppRecordList()
            self.live_app_record_list = temp_model.from_map(m['LiveAppRecordList'])
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveRecordConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRecordConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRecordConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRecordNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        need_status_notify: bool = None,
        notify_auth_key: str = None,
        notify_req_auth: bool = None,
        notify_url: str = None,
        on_demand_url: str = None,
    ):
        # The main streaming domain.
        self.domain_name = domain_name
        # Indicates whether recording status callbacks are enabled. Valid values:
        # 
        # *   **true**\
        # *   **false** (default)
        self.need_status_notify = need_status_notify
        self.notify_auth_key = notify_auth_key
        self.notify_req_auth = notify_req_auth
        # The recording callback URL.
        self.notify_url = notify_url
        # The callback URL for on-demand recording.
        self.on_demand_url = on_demand_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.need_status_notify is not None:
            result['NeedStatusNotify'] = self.need_status_notify
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.on_demand_url is not None:
            result['OnDemandUrl'] = self.on_demand_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NeedStatusNotify') is not None:
            self.need_status_notify = m.get('NeedStatusNotify')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OnDemandUrl') is not None:
            self.on_demand_url = m.get('OnDemandUrl')
        return self


class DescribeLiveRecordNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_record_notify_config: DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig = None,
        request_id: str = None,
    ):
        # The configuration of callbacks for live stream recording.
        self.live_record_notify_config = live_record_notify_config
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_record_notify_config:
            self.live_record_notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_record_notify_config is not None:
            result['LiveRecordNotifyConfig'] = self.live_record_notify_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveRecordNotifyConfig') is not None:
            temp_model = DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig()
            self.live_record_notify_config = temp_model.from_map(m['LiveRecordNotifyConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveRecordNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRecordNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRecordNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRecordNotifyRecordsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
        status: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number. Default value: 1. Valid values: 1 to 100000.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of entries per page. Valid values: 1 to 500. Default value: 20.
        # 
        # This parameter is required.
        self.page_size = page_size
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  You can query data within the last seven days.
        # 
        # This parameter is required.
        self.start_time = start_time
        # Specifies whether the callback is successful. Valid values:
        # 
        # *   success
        # *   failed
        self.status = status
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveRecordNotifyRecordsResponseBodyCallbackList(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        description: str = None,
        domain_name: str = None,
        notify_content: str = None,
        notify_header: str = None,
        notify_response: str = None,
        notify_result: str = None,
        notify_time: str = None,
        notify_type: str = None,
        notify_url: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The description of the result. A value of success indicates that the request is successful. If the request fails, an error message is returned.
        self.description = description
        # The main streaming domain.
        self.domain_name = domain_name
        # The callback content.
        self.notify_content = notify_content
        self.notify_header = notify_header
        self.notify_response = notify_response
        # The callback result. Valid values:
        # 
        # *   success
        # *   failed
        self.notify_result = notify_result
        # The time when the callback was returned. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.notify_time = notify_time
        # The callback type. Valid values:
        # 
        # *   file_created: The recording file is created.
        # *   record_error: A recording error occurs.
        # *   record_started: Recording is started.
        # *   record_paused: Recording is paused.
        # *   record_resumed: Recording is resumed.
        # *   record_force_transcode_fail: The recording task fails to trigger transcoding.
        # *   transformat_error: An error occurs when the live stream is parsed.
        self.notify_type = notify_type
        # The recording callback URL.
        self.notify_url = notify_url
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_content is not None:
            result['NotifyContent'] = self.notify_content
        if self.notify_header is not None:
            result['NotifyHeader'] = self.notify_header
        if self.notify_response is not None:
            result['NotifyResponse'] = self.notify_response
        if self.notify_result is not None:
            result['NotifyResult'] = self.notify_result
        if self.notify_time is not None:
            result['NotifyTime'] = self.notify_time
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyContent') is not None:
            self.notify_content = m.get('NotifyContent')
        if m.get('NotifyHeader') is not None:
            self.notify_header = m.get('NotifyHeader')
        if m.get('NotifyResponse') is not None:
            self.notify_response = m.get('NotifyResponse')
        if m.get('NotifyResult') is not None:
            self.notify_result = m.get('NotifyResult')
        if m.get('NotifyTime') is not None:
            self.notify_time = m.get('NotifyTime')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveRecordNotifyRecordsResponseBody(TeaModel):
    def __init__(
        self,
        callback_list: List[DescribeLiveRecordNotifyRecordsResponseBodyCallbackList] = None,
        code: int = None,
        msg: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The callback records.
        self.callback_list = callback_list
        # The error code.
        self.code = code
        # The returned message.
        self.msg = msg
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.callback_list:
            for k in self.callback_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CallbackList'] = []
        if self.callback_list is not None:
            for k in self.callback_list:
                result['CallbackList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.callback_list = []
        if m.get('CallbackList') is not None:
            for k in m.get('CallbackList'):
                temp_model = DescribeLiveRecordNotifyRecordsResponseBodyCallbackList()
                self.callback_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveRecordNotifyRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRecordNotifyRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRecordNotifyRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveRecordVodConfigsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_num = page_num
        # The number of entries per page. Default value: **10**. Valid values: **5 to 100**.
        self.page_size = page_size
        self.region_id = region_id
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        auto_compose: str = None,
        compose_vod_transcode_group_id: str = None,
        create_time: str = None,
        cycle_duration: int = None,
        domain_name: str = None,
        on_demand: int = None,
        storage_location: str = None,
        stream_name: str = None,
        vod_transcode_group_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # Indicates whether automatic merging is enabled. Valid values:
        # 
        # *   **ON**\
        # *   **OFF**\
        self.auto_compose = auto_compose
        # The ID of the transcoding template group that was used to automatically merge the VOD files created from the live streams.
        # 
        # >  This parameter is returned if the value of the AutoCompose parameter is ON.
        self.compose_vod_transcode_group_id = compose_vod_transcode_group_id
        # The time when the live stream was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The recording cycle. Unit: seconds. Default value: **3600**. Valid values: **300 to 21600**.
        self.cycle_duration = cycle_duration
        # The main streaming domain.
        self.domain_name = domain_name
        # Indicates whether on-demand recording is enabled. Valid values:
        # 
        # *   **0** (default): On-demand recording is disabled.
        # *   **1**: On-demand recording is enabled by using the HTTP callback method.
        self.on_demand = on_demand
        # The storage location.
        self.storage_location = storage_location
        # The name of the live stream.
        self.stream_name = stream_name
        # The ID of the transcoding template group in ApsaraVideo VOD.
        self.vod_transcode_group_id = vod_transcode_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_compose is not None:
            result['AutoCompose'] = self.auto_compose
        if self.compose_vod_transcode_group_id is not None:
            result['ComposeVodTranscodeGroupId'] = self.compose_vod_transcode_group_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.vod_transcode_group_id is not None:
            result['VodTranscodeGroupId'] = self.vod_transcode_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoCompose') is not None:
            self.auto_compose = m.get('AutoCompose')
        if m.get('ComposeVodTranscodeGroupId') is not None:
            self.compose_vod_transcode_group_id = m.get('ComposeVodTranscodeGroupId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VodTranscodeGroupId') is not None:
            self.vod_transcode_group_id = m.get('VodTranscodeGroupId')
        return self


class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs(TeaModel):
    def __init__(
        self,
        live_record_vod_config: List[DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig] = None,
    ):
        self.live_record_vod_config = live_record_vod_config

    def validate(self):
        if self.live_record_vod_config:
            for k in self.live_record_vod_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveRecordVodConfig'] = []
        if self.live_record_vod_config is not None:
            for k in self.live_record_vod_config:
                result['LiveRecordVodConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_record_vod_config = []
        if m.get('LiveRecordVodConfig') is not None:
            for k in m.get('LiveRecordVodConfig'):
                temp_model = DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig()
                self.live_record_vod_config.append(temp_model.from_map(k))
        return self


class DescribeLiveRecordVodConfigsResponseBody(TeaModel):
    def __init__(
        self,
        live_record_vod_configs: DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total: str = None,
    ):
        # The configurations.
        self.live_record_vod_configs = live_record_vod_configs
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.live_record_vod_configs:
            self.live_record_vod_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_record_vod_configs is not None:
            result['LiveRecordVodConfigs'] = self.live_record_vod_configs.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveRecordVodConfigs') is not None:
            temp_model = DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs()
            self.live_record_vod_configs = temp_model.from_map(m['LiveRecordVodConfigs'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveRecordVodConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveRecordVodConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveRecordVodConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveShiftConfigsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveShiftConfigsResponseBodyContentConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        ignore_transcode: bool = None,
        stream_name: str = None,
        vision: int = None,
    ):
        # The application for which you configure time shifting.
        self.app_name = app_name
        # The domain name for which you configure time shifting.
        self.domain_name = domain_name
        # Whether to ignore time shift generation for the transcode stream.
        # 
        # *   true: Ignore time shifting generation.
        # *   false: Generate time shifting.
        # 
        # The default value is true.
        self.ignore_transcode = ignore_transcode
        # The name of the live stream for which you configure time shifting.
        self.stream_name = stream_name
        # The number of days for which the time shifting configurations are retained.
        self.vision = vision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ignore_transcode is not None:
            result['IgnoreTranscode'] = self.ignore_transcode
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.vision is not None:
            result['Vision'] = self.vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IgnoreTranscode') is not None:
            self.ignore_transcode = m.get('IgnoreTranscode')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Vision') is not None:
            self.vision = m.get('Vision')
        return self


class DescribeLiveShiftConfigsResponseBodyContent(TeaModel):
    def __init__(
        self,
        config: List[DescribeLiveShiftConfigsResponseBodyContentConfig] = None,
    ):
        self.config = config

    def validate(self):
        if self.config:
            for k in self.config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Config'] = []
        if self.config is not None:
            for k in self.config:
                result['Config'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config = []
        if m.get('Config') is not None:
            for k in m.get('Config'):
                temp_model = DescribeLiveShiftConfigsResponseBodyContentConfig()
                self.config.append(temp_model.from_map(k))
        return self


class DescribeLiveShiftConfigsResponseBody(TeaModel):
    def __init__(
        self,
        content: DescribeLiveShiftConfigsResponseBodyContent = None,
        request_id: str = None,
    ):
        # The time shifting configurations.
        self.content = content
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = DescribeLiveShiftConfigsResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveShiftConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveShiftConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveShiftConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSnapshotConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The sort order. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_num = page_num
        # The number of entries per page. Valid values: **5 to 30**. Default value: **10**.
        self.page_size = page_size
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        callback: str = None,
        create_time: str = None,
        domain_name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        overwrite_oss_object: str = None,
        sequence_oss_object: str = None,
        time_interval: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The callback URL that is used to receive notifications about snapshot capture.
        self.callback = callback
        # The time when the configuration was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The main streaming domain.
        self.domain_name = domain_name
        # The name of the Object Storage Service (OSS) bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.
        self.overwrite_oss_object = overwrite_oss_object
        # The naming format of snapshots that are stored in sequence, which means that a new snapshot does not overwrite the previous snapshot.
        self.sequence_oss_object = sequence_oss_object
        # The interval at which snapshots are captured. Unit: seconds.
        self.time_interval = time_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.overwrite_oss_object is not None:
            result['OverwriteOssObject'] = self.overwrite_oss_object
        if self.sequence_oss_object is not None:
            result['SequenceOssObject'] = self.sequence_oss_object
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OverwriteOssObject') is not None:
            self.overwrite_oss_object = m.get('OverwriteOssObject')
        if m.get('SequenceOssObject') is not None:
            self.sequence_oss_object = m.get('SequenceOssObject')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList(TeaModel):
    def __init__(
        self,
        live_stream_snapshot_config: List[DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig] = None,
    ):
        self.live_stream_snapshot_config = live_stream_snapshot_config

    def validate(self):
        if self.live_stream_snapshot_config:
            for k in self.live_stream_snapshot_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamSnapshotConfig'] = []
        if self.live_stream_snapshot_config is not None:
            for k in self.live_stream_snapshot_config:
                result['LiveStreamSnapshotConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_snapshot_config = []
        if m.get('LiveStreamSnapshotConfig') is not None:
            for k in m.get('LiveStreamSnapshotConfig'):
                temp_model = DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig()
                self.live_stream_snapshot_config.append(temp_model.from_map(k))
        return self


class DescribeLiveSnapshotConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_snapshot_config_list: DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The snapshot configurations.
        self.live_stream_snapshot_config_list = live_stream_snapshot_config_list
        # The sort order.
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.live_stream_snapshot_config_list:
            self.live_stream_snapshot_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_stream_snapshot_config_list is not None:
            result['LiveStreamSnapshotConfigList'] = self.live_stream_snapshot_config_list.to_map()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamSnapshotConfigList') is not None:
            temp_model = DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList()
            self.live_stream_snapshot_config_list = temp_model.from_map(m['LiveStreamSnapshotConfigList'])
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveSnapshotConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveSnapshotConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSnapshotConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSnapshotDetectPornConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The order in which the entries are sorted based on creation time. Valid values:
        # 
        # *   **Asc** (default): ascending order
        # *   **Desc**: descending order
        # 
        # Enumerated values:
        # 
        # *   asc
        # *   desc
        self.order = order
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_num = page_num
        # The number of entries per page. Valid values: **5 to 30**. Default value: **10**.
        self.page_size = page_size
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes(TeaModel):
    def __init__(
        self,
        scene: List[str] = None,
    ):
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        interval: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        scenes: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes = None,
    ):
        # The application name.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The interval at which snapshots are captured from the live stream. Unit: seconds.
        self.interval = interval
        # The name of the OSS bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the storage file in Object Storage Service (OSS).
        self.oss_object = oss_object
        # The moderation scenario array.
        self.scenes = scenes

    def validate(self):
        if self.scenes:
            self.scenes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.scenes is not None:
            result['Scenes'] = self.scenes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('Scenes') is not None:
            temp_model = DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes()
            self.scenes = temp_model.from_map(m['Scenes'])
        return self


class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList(TeaModel):
    def __init__(
        self,
        live_snapshot_detect_porn_config: List[DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig] = None,
    ):
        self.live_snapshot_detect_porn_config = live_snapshot_detect_porn_config

    def validate(self):
        if self.live_snapshot_detect_porn_config:
            for k in self.live_snapshot_detect_porn_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveSnapshotDetectPornConfig'] = []
        if self.live_snapshot_detect_porn_config is not None:
            for k in self.live_snapshot_detect_porn_config:
                result['LiveSnapshotDetectPornConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_snapshot_detect_porn_config = []
        if m.get('LiveSnapshotDetectPornConfig') is not None:
            for k in m.get('LiveSnapshotDetectPornConfig'):
                temp_model = DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig()
                self.live_snapshot_detect_porn_config.append(temp_model.from_map(k))
        return self


class DescribeLiveSnapshotDetectPornConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_snapshot_detect_porn_config_list: DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The list of video moderation configurations.
        self.live_snapshot_detect_porn_config_list = live_snapshot_detect_porn_config_list
        # The sort order.
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.live_snapshot_detect_porn_config_list:
            self.live_snapshot_detect_porn_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_snapshot_detect_porn_config_list is not None:
            result['LiveSnapshotDetectPornConfigList'] = self.live_snapshot_detect_porn_config_list.to_map()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveSnapshotDetectPornConfigList') is not None:
            temp_model = DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList()
            self.live_snapshot_detect_porn_config_list = temp_model.from_map(m['LiveSnapshotDetectPornConfigList'])
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveSnapshotDetectPornConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveSnapshotDetectPornConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSnapshotDetectPornConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSnapshotNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveSnapshotNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_auth_key: str = None,
        notify_req_auth: str = None,
        notify_url: str = None,
        request_id: str = None,
    ):
        # The main streaming domain.
        self.domain_name = domain_name
        # The callback authentication key.
        self.notify_auth_key = notify_auth_key
        # Indicates whether callback authentication is enabled. Valid values:
        # 
        # *   **yes**: Callback authentication is enabled.
        # *   **no**: Callback authentication is disabled.
        self.notify_req_auth = notify_req_auth
        # The callback URL.
        self.notify_url = notify_url
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveSnapshotNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveSnapshotNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSnapshotNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamAuthCheckingRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        url: str = None,
    ):
        # The ingest domain or streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The complete ingest URL or streaming URL. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a URL.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeLiveStreamAuthCheckingResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The error message for failed authentication.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # Indicates whether the signed URL is valid. Valid values:
        # 
        # *   pass: valid.
        # *   false: invalid.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveStreamAuthCheckingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamAuthCheckingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamAuthCheckingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamBitRateDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        self.owner_id = owner_id
        self.security_token = security_token
        # The beginning of the time range to query. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(TeaModel):
    def __init__(
        self,
        audio_frame_rate: float = None,
        bit_rate: float = None,
        stream_url: str = None,
        time: str = None,
        video_frame_rate: float = None,
    ):
        # The audio frame rate of the live stream. Unit: FPS.
        self.audio_frame_rate = audio_frame_rate
        # The bitrate of the live stream. Unit: bit/s.
        self.bit_rate = bit_rate
        # The URL of the live stream.
        self.stream_url = stream_url
        # The time when the data was collected. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time = time
        # The video frame rate of the live stream. Unit: frames per second (FPS).
        self.video_frame_rate = video_frame_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_frame_rate is not None:
            result['AudioFrameRate'] = self.audio_frame_rate
        if self.bit_rate is not None:
            result['BitRate'] = self.bit_rate
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        if self.time is not None:
            result['Time'] = self.time
        if self.video_frame_rate is not None:
            result['VideoFrameRate'] = self.video_frame_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFrameRate') is not None:
            self.audio_frame_rate = m.get('AudioFrameRate')
        if m.get('BitRate') is not None:
            self.bit_rate = m.get('BitRate')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('VideoFrameRate') is not None:
            self.video_frame_rate = m.get('VideoFrameRate')
        return self


class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos(TeaModel):
    def __init__(
        self,
        frame_rate_and_bit_rate_info: List[DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo] = None,
    ):
        self.frame_rate_and_bit_rate_info = frame_rate_and_bit_rate_info

    def validate(self):
        if self.frame_rate_and_bit_rate_info:
            for k in self.frame_rate_and_bit_rate_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrameRateAndBitRateInfo'] = []
        if self.frame_rate_and_bit_rate_info is not None:
            for k in self.frame_rate_and_bit_rate_info:
                result['FrameRateAndBitRateInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.frame_rate_and_bit_rate_info = []
        if m.get('FrameRateAndBitRateInfo') is not None:
            for k in m.get('FrameRateAndBitRateInfo'):
                temp_model = DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo()
                self.frame_rate_and_bit_rate_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamBitRateDataResponseBody(TeaModel):
    def __init__(
        self,
        frame_rate_and_bit_rate_infos: DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos = None,
        request_id: str = None,
    ):
        # The frame rates and bitrates of the live stream.
        self.frame_rate_and_bit_rate_infos = frame_rate_and_bit_rate_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.frame_rate_and_bit_rate_infos:
            self.frame_rate_and_bit_rate_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_rate_and_bit_rate_infos is not None:
            result['FrameRateAndBitRateInfos'] = self.frame_rate_and_bit_rate_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameRateAndBitRateInfos') is not None:
            temp_model = DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos()
            self.frame_rate_and_bit_rate_infos = temp_model.from_map(m['FrameRateAndBitRateInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamBitRateDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamBitRateDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamBitRateDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamCountRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail(TeaModel):
    def __init__(
        self,
        count: int = None,
        format: str = None,
        video_data_rate: int = None,
    ):
        # The number of online streams.
        self.count = count
        # The video codec. Valid values:
        # 
        # *   **h264**\
        # *   **h265**\
        self.format = format
        # The video bitrate. This parameter is returned only for transcoded streams.
        self.video_data_rate = video_data_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.format is not None:
            result['Format'] = self.format
        if self.video_data_rate is not None:
            result['VideoDataRate'] = self.video_data_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('VideoDataRate') is not None:
            self.video_data_rate = m.get('VideoDataRate')
        return self


class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails(TeaModel):
    def __init__(
        self,
        stream_count_detail: List[DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail] = None,
    ):
        self.stream_count_detail = stream_count_detail

    def validate(self):
        if self.stream_count_detail:
            for k in self.stream_count_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamCountDetail'] = []
        if self.stream_count_detail is not None:
            for k in self.stream_count_detail:
                result['StreamCountDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_count_detail = []
        if m.get('StreamCountDetail') is not None:
            for k in m.get('StreamCountDetail'):
                temp_model = DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail()
                self.stream_count_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo(TeaModel):
    def __init__(
        self,
        count: int = None,
        limit: int = None,
        stream_count_details: DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails = None,
        type: str = None,
    ):
        # The number of online streams.
        self.count = count
        # The maximum allowed number of concurrently ingested streams. This parameter is available only to users in the whitelist.
        self.limit = limit
        # The information about the live streams.
        self.stream_count_details = stream_count_details
        # The type of the live stream. Valid values:
        # 
        # *   **raw**: source streams
        # *   **trans**: transcoded streams
        self.type = type

    def validate(self):
        if self.stream_count_details:
            self.stream_count_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.stream_count_details is not None:
            result['StreamCountDetails'] = self.stream_count_details.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('StreamCountDetails') is not None:
            temp_model = DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails()
            self.stream_count_details = temp_model.from_map(m['StreamCountDetails'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveStreamCountResponseBodyStreamCountInfos(TeaModel):
    def __init__(
        self,
        stream_count_info: List[DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo] = None,
    ):
        self.stream_count_info = stream_count_info

    def validate(self):
        if self.stream_count_info:
            for k in self.stream_count_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamCountInfo'] = []
        if self.stream_count_info is not None:
            for k in self.stream_count_info:
                result['StreamCountInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_count_info = []
        if m.get('StreamCountInfo') is not None:
            for k in m.get('StreamCountInfo'):
                temp_model = DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo()
                self.stream_count_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stream_count_infos: DescribeLiveStreamCountResponseBodyStreamCountInfos = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The statistics of the live streams.
        self.stream_count_infos = stream_count_infos

    def validate(self):
        if self.stream_count_infos:
            self.stream_count_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_count_infos is not None:
            result['StreamCountInfos'] = self.stream_count_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamCountInfos') is not None:
            temp_model = DescribeLiveStreamCountResponseBodyStreamCountInfos()
            self.stream_count_infos = temp_model.from_map(m['StreamCountInfos'])
        return self


class DescribeLiveStreamCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamDelayConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig(TeaModel):
    def __init__(
        self,
        delay: int = None,
        level: str = None,
    ):
        # The playback latency. Unit: seconds.
        self.delay = delay
        # The latency level. Valid values:
        # 
        # *   **short**: The latency is less than or equal to 4 seconds.
        # *   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
        # *   **long**: The latency is greater than 8 seconds.
        self.level = level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig(TeaModel):
    def __init__(
        self,
        delay: int = None,
        level: str = None,
    ):
        # The playback latency. Unit: seconds.
        self.delay = delay
        # The latency level. Valid values:
        # 
        # *   **short**: The latency is less than or equal to 4 seconds.
        # *   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
        # *   **long**: The latency is greater than 8 seconds.
        self.level = level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig(TeaModel):
    def __init__(
        self,
        delay: int = None,
        level: str = None,
    ):
        # The playback latency. Unit: seconds.
        self.delay = delay
        # The latency level. Valid values:
        # 
        # *   **short**: The latency is less than or equal to 4 seconds.
        # *   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
        # *   **long**: The latency is greater than 8 seconds.
        self.level = level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeLiveStreamDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_flv_delay_config: DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig = None,
        live_stream_hls_delay_config: DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig = None,
        live_stream_rtmp_delay_config: DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig = None,
        request_id: str = None,
    ):
        # The latency of FLV-based playback.
        self.live_stream_flv_delay_config = live_stream_flv_delay_config
        # The latency of HLS-based playback.
        self.live_stream_hls_delay_config = live_stream_hls_delay_config
        # The latency of RTMP-based playback.
        self.live_stream_rtmp_delay_config = live_stream_rtmp_delay_config
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_stream_flv_delay_config:
            self.live_stream_flv_delay_config.validate()
        if self.live_stream_hls_delay_config:
            self.live_stream_hls_delay_config.validate()
        if self.live_stream_rtmp_delay_config:
            self.live_stream_rtmp_delay_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_stream_flv_delay_config is not None:
            result['LiveStreamFlvDelayConfig'] = self.live_stream_flv_delay_config.to_map()
        if self.live_stream_hls_delay_config is not None:
            result['LiveStreamHlsDelayConfig'] = self.live_stream_hls_delay_config.to_map()
        if self.live_stream_rtmp_delay_config is not None:
            result['LiveStreamRtmpDelayConfig'] = self.live_stream_rtmp_delay_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamFlvDelayConfig') is not None:
            temp_model = DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig()
            self.live_stream_flv_delay_config = temp_model.from_map(m['LiveStreamFlvDelayConfig'])
        if m.get('LiveStreamHlsDelayConfig') is not None:
            temp_model = DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig()
            self.live_stream_hls_delay_config = temp_model.from_map(m['LiveStreamHlsDelayConfig'])
        if m.get('LiveStreamRtmpDelayConfig') is not None:
            temp_model = DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig()
            self.live_stream_rtmp_delay_config = temp_model.from_map(m['LiveStreamRtmpDelayConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamDetailFrameRateAndBitRateDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ingest domain or streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  If the StartTime and EndTime parameters are invalid, or if the StartTime and EndTime parameters are not specified, data in the last hour is queried by default.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos(TeaModel):
    def __init__(
        self,
        audio_bit_rate: float = None,
        audio_frame_rate: float = None,
        bit_rate: float = None,
        stream_url: str = None,
        time: str = None,
        video_bit_rate: float = None,
        video_frame_rate: float = None,
    ):
        # The audio bitrate of the live stream. Unit: bit/s.
        self.audio_bit_rate = audio_bit_rate
        # The audio frame rate of the live stream. Unit: FPS.
        self.audio_frame_rate = audio_frame_rate
        # The bitrate of the live stream. Unit: bit/s.
        self.bit_rate = bit_rate
        # The URL of the live stream.
        self.stream_url = stream_url
        # The time when the data was collected. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time = time
        # The video bitrate of the live stream. Unit: bit/s.
        self.video_bit_rate = video_bit_rate
        # The video frame rate of the live stream. Unit: frames per second (FPS).
        self.video_frame_rate = video_frame_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bit_rate is not None:
            result['AudioBitRate'] = self.audio_bit_rate
        if self.audio_frame_rate is not None:
            result['AudioFrameRate'] = self.audio_frame_rate
        if self.bit_rate is not None:
            result['BitRate'] = self.bit_rate
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        if self.time is not None:
            result['Time'] = self.time
        if self.video_bit_rate is not None:
            result['VideoBitRate'] = self.video_bit_rate
        if self.video_frame_rate is not None:
            result['VideoFrameRate'] = self.video_frame_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitRate') is not None:
            self.audio_bit_rate = m.get('AudioBitRate')
        if m.get('AudioFrameRate') is not None:
            self.audio_frame_rate = m.get('AudioFrameRate')
        if m.get('BitRate') is not None:
            self.bit_rate = m.get('BitRate')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('VideoBitRate') is not None:
            self.video_bit_rate = m.get('VideoBitRate')
        if m.get('VideoFrameRate') is not None:
            self.video_frame_rate = m.get('VideoFrameRate')
        return self


class DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody(TeaModel):
    def __init__(
        self,
        frame_rate_and_bit_rate_infos: List[DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos] = None,
        request_id: str = None,
    ):
        # The audio and video frame rates and bitrates at each time granularity.
        self.frame_rate_and_bit_rate_infos = frame_rate_and_bit_rate_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.frame_rate_and_bit_rate_infos:
            for k in self.frame_rate_and_bit_rate_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrameRateAndBitRateInfos'] = []
        if self.frame_rate_and_bit_rate_infos is not None:
            for k in self.frame_rate_and_bit_rate_infos:
                result['FrameRateAndBitRateInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.frame_rate_and_bit_rate_infos = []
        if m.get('FrameRateAndBitRateInfos') is not None:
            for k in m.get('FrameRateAndBitRateInfos'):
                temp_model = DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos()
                self.frame_rate_and_bit_rate_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamDetailFrameRateAndBitRateDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamHistoryUserNumRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  The time range specified by the StartTime and EndTime parameters cannot exceed one day. The end time must not be later than the current time.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.security_token = security_token
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  You can query data in the last **30** days.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo(TeaModel):
    def __init__(
        self,
        stream_time: str = None,
        user_num: str = None,
    ):
        # The time when the stream started. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.stream_time = stream_time
        # The number of users at the current point in time.
        self.user_num = user_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stream_time is not None:
            result['StreamTime'] = self.stream_time
        if self.user_num is not None:
            result['UserNum'] = self.user_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StreamTime') is not None:
            self.stream_time = m.get('StreamTime')
        if m.get('UserNum') is not None:
            self.user_num = m.get('UserNum')
        return self


class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos(TeaModel):
    def __init__(
        self,
        live_stream_user_num_info: List[DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo] = None,
    ):
        self.live_stream_user_num_info = live_stream_user_num_info

    def validate(self):
        if self.live_stream_user_num_info:
            for k in self.live_stream_user_num_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamUserNumInfo'] = []
        if self.live_stream_user_num_info is not None:
            for k in self.live_stream_user_num_info:
                result['LiveStreamUserNumInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_user_num_info = []
        if m.get('LiveStreamUserNumInfo') is not None:
            for k in m.get('LiveStreamUserNumInfo'):
                temp_model = DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo()
                self.live_stream_user_num_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamHistoryUserNumResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_user_num_infos: DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos = None,
        request_id: str = None,
    ):
        # The number of historical online users for the live stream.
        self.live_stream_user_num_infos = live_stream_user_num_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_stream_user_num_infos:
            self.live_stream_user_num_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_stream_user_num_infos is not None:
            result['LiveStreamUserNumInfos'] = self.live_stream_user_num_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamUserNumInfos') is not None:
            temp_model = DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos()
            self.live_stream_user_num_infos = temp_model.from_map(m['LiveStreamUserNumInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamHistoryUserNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamHistoryUserNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamHistoryUserNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamMergeRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        protocol: str = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application that generates the output stream. You can view the application name on the [Primary/Secondary Stream Mixing Settings](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The streaming protocol. Valid values:
        # 
        # *   **rtmp**: This is the default value.
        # *   **rtc**\
        self.protocol = protocol
        self.region_id = region_id
        # The name of the output stream. You can view the stream name on the [Primary/Secondary Stream Mixing Settings](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        app_using: str = None,
        domain_name: str = None,
        end_time: str = None,
        extra_in_app_streams: str = None,
        in_app_name_1: str = None,
        in_app_name_2: str = None,
        in_stream_name_1: str = None,
        in_stream_name_2: str = None,
        live_merger: str = None,
        merge_parameters: str = None,
        protocol: str = None,
        start_time: str = None,
        stream_name: str = None,
        stream_using: str = None,
    ):
        # The name of the application that generates the output stream.
        self.app_name = app_name
        # The application that is being used.
        self.app_using = app_using
        # The streaming domain.
        self.domain_name = domain_name
        # The end time of the stream mixing.
        self.end_time = end_time
        # The names of the applications that generate the input additional streams other than the primary stream and secondary stream, and the names of these additional streams.
        self.extra_in_app_streams = extra_in_app_streams
        # The name of the application that generates the input primary stream.
        self.in_app_name_1 = in_app_name_1
        # The name of the application that generates the input secondary stream.
        self.in_app_name_2 = in_app_name_2
        # The name of the input primary stream.
        self.in_stream_name_1 = in_stream_name_1
        # The name of the input secondary stream.
        self.in_stream_name_2 = in_stream_name_2
        self.live_merger = live_merger
        self.merge_parameters = merge_parameters
        # The streaming protocol.
        self.protocol = protocol
        # The start time of the stream mixing.
        self.start_time = start_time
        # The name of the output stream.
        self.stream_name = stream_name
        # The stream that is being used.
        self.stream_using = stream_using

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_using is not None:
            result['AppUsing'] = self.app_using
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.extra_in_app_streams is not None:
            result['ExtraInAppStreams'] = self.extra_in_app_streams
        if self.in_app_name_1 is not None:
            result['InAppName1'] = self.in_app_name_1
        if self.in_app_name_2 is not None:
            result['InAppName2'] = self.in_app_name_2
        if self.in_stream_name_1 is not None:
            result['InStreamName1'] = self.in_stream_name_1
        if self.in_stream_name_2 is not None:
            result['InStreamName2'] = self.in_stream_name_2
        if self.live_merger is not None:
            result['LiveMerger'] = self.live_merger
        if self.merge_parameters is not None:
            result['MergeParameters'] = self.merge_parameters
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.stream_using is not None:
            result['StreamUsing'] = self.stream_using
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppUsing') is not None:
            self.app_using = m.get('AppUsing')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExtraInAppStreams') is not None:
            self.extra_in_app_streams = m.get('ExtraInAppStreams')
        if m.get('InAppName1') is not None:
            self.in_app_name_1 = m.get('InAppName1')
        if m.get('InAppName2') is not None:
            self.in_app_name_2 = m.get('InAppName2')
        if m.get('InStreamName1') is not None:
            self.in_stream_name_1 = m.get('InStreamName1')
        if m.get('InStreamName2') is not None:
            self.in_stream_name_2 = m.get('InStreamName2')
        if m.get('LiveMerger') is not None:
            self.live_merger = m.get('LiveMerger')
        if m.get('MergeParameters') is not None:
            self.merge_parameters = m.get('MergeParameters')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('StreamUsing') is not None:
            self.stream_using = m.get('StreamUsing')
        return self


class DescribeLiveStreamMergeResponseBodyLiveStreamMergeList(TeaModel):
    def __init__(
        self,
        live_stream_merge: List[DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge] = None,
    ):
        self.live_stream_merge = live_stream_merge

    def validate(self):
        if self.live_stream_merge:
            for k in self.live_stream_merge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamMerge'] = []
        if self.live_stream_merge is not None:
            for k in self.live_stream_merge:
                result['LiveStreamMerge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_merge = []
        if m.get('LiveStreamMerge') is not None:
            for k in m.get('LiveStreamMerge'):
                temp_model = DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge()
                self.live_stream_merge.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamMergeResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_merge_list: DescribeLiveStreamMergeResponseBodyLiveStreamMergeList = None,
        request_id: str = None,
    ):
        # Live stream information list.
        self.live_stream_merge_list = live_stream_merge_list
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.live_stream_merge_list:
            self.live_stream_merge_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_stream_merge_list is not None:
            result['LiveStreamMergeList'] = self.live_stream_merge_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamMergeList') is not None:
            temp_model = DescribeLiveStreamMergeResponseBodyLiveStreamMergeList()
            self.live_stream_merge_list = temp_model.from_map(m['LiveStreamMergeList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamMergeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamMergeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamMergeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamMetricDetailDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        owner_id: int = None,
        protocol: str = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application for which you want to query the monitoring data of streams.
        # 
        # >  If you specify the StreamName parameter, you must also specify the AppName parameter.
        self.app_name = app_name
        # *   The accelerated domain name. You can specify only one domain name. If you specify multiple domain names, an error occurs.
        # *   If you do not specify the AppName and StreamName parameters, monitoring data of all streams for the domain name is returned.
        # *   If you leave this parameter empty, monitoring data of streams under all domain names is returned.
        # *   If you specify the DomainName parameter and set both the AppName and StreamName parameters to all, monitoring data of all streams in all applications under the specified domain name is returned.
        # *   When you specify the DomainName parameter, make sure that the domain name is a domain name used for live streaming and that you have the permissions on the domain name.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time, and the maximum time range that can be specified is one day. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The token used to query data by page. Up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, a token that determines the start point of the next query is provided in the response. If you specify this parameter, data continues to be obtained from the end of the previous query.
        self.next_page_token = next_page_token
        self.owner_id = owner_id
        # The streaming protocol. Valid values: **flv**, **hls**, **rtmp**, **rts**, and **p2p**.
        # 
        # You can specify multiple protocols. Separate multiple protocols with commas (,). However, data over multiple protocols is not aggregated and is returned based on the stream.
        self.protocol = protocol
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the stream. The stream must belong to the application that is specified by the AppName parameter.
        # 
        # >  If you specify the StreamName parameter, you must also specify the AppName parameter.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        bps: float = None,
        count: int = None,
        flv_bps: float = None,
        flv_count: int = None,
        flv_traffic: int = None,
        hls_bps: float = None,
        hls_count: int = None,
        hls_traffic: int = None,
        new_conns: str = None,
        p_2p_bps: float = None,
        p_2p_count: int = None,
        p_2p_traffic: int = None,
        rtmp_bps: float = None,
        rtmp_count: int = None,
        rtmp_traffic: int = None,
        rts_bps: float = None,
        rts_count: int = None,
        rts_traffic: int = None,
        stream_name: str = None,
        time_stamp: str = None,
        traffic: int = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The total bandwidth consumed by the stream per minute. Unit: bit/s.
        self.bps = bps
        # The total number of online viewers for the stream per minute.
        self.count = count
        # The bandwidth over the Flash Video (FLV) protocol. Unit: bit/s.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.flv_bps = flv_bps
        # The number of online viewers over the FLV protocol.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.flv_count = flv_count
        # The amount of traffic over the FLV protocol. Unit: bytes.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.flv_traffic = flv_traffic
        # The bandwidth over the HTTP Live Streaming (HLS) protocol. Unit: bit/s.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.hls_bps = hls_bps
        # The number of online viewers over the HLS protocol.
        # 
        # >  Currently, this parameter is not supported.
        self.hls_count = hls_count
        # The amount of traffic over the HLS protocol. Unit: bytes.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.hls_traffic = hls_traffic
        # Number of new connections established per minute.
        self.new_conns = new_conns
        # The bandwidth over the P2P protocol. Unit: bit/s.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.p_2p_bps = p_2p_bps
        # The number of online viewers over the P2P protocol.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.p_2p_count = p_2p_count
        # The amount of traffic over the peer-to-peer (P2P) protocol. Unit: bytes.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.p_2p_traffic = p_2p_traffic
        # The bandwidth over the Real-Time Messaging Protocol (RTMP) protocol. Unit: bit/s.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rtmp_bps = rtmp_bps
        # The number of online viewers over the RTMP protocol.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rtmp_count = rtmp_count
        # The amount of traffic over the RTMP protocol. Unit: bytes.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rtmp_traffic = rtmp_traffic
        # The bandwidth over the RTS protocol. Unit: bit/s.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rts_bps = rts_bps
        # The number of online viewers over the Real-Time Streaming (RTS) protocol.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rts_count = rts_count
        # The amount of traffic over the RTS protocol. Unit: bytes.
        # 
        # >  This parameter is not returned if no traffic is generated over the protocol.
        self.rts_traffic = rts_traffic
        # The name of the stream.
        self.stream_name = stream_name
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The total amount of traffic consumed by the stream per minute. Unit: bytes.
        self.traffic = traffic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.bps is not None:
            result['Bps'] = self.bps
        if self.count is not None:
            result['Count'] = self.count
        if self.flv_bps is not None:
            result['FlvBps'] = self.flv_bps
        if self.flv_count is not None:
            result['FlvCount'] = self.flv_count
        if self.flv_traffic is not None:
            result['FlvTraffic'] = self.flv_traffic
        if self.hls_bps is not None:
            result['HlsBps'] = self.hls_bps
        if self.hls_count is not None:
            result['HlsCount'] = self.hls_count
        if self.hls_traffic is not None:
            result['HlsTraffic'] = self.hls_traffic
        if self.new_conns is not None:
            result['NewConns'] = self.new_conns
        if self.p_2p_bps is not None:
            result['P2pBps'] = self.p_2p_bps
        if self.p_2p_count is not None:
            result['P2pCount'] = self.p_2p_count
        if self.p_2p_traffic is not None:
            result['P2pTraffic'] = self.p_2p_traffic
        if self.rtmp_bps is not None:
            result['RtmpBps'] = self.rtmp_bps
        if self.rtmp_count is not None:
            result['RtmpCount'] = self.rtmp_count
        if self.rtmp_traffic is not None:
            result['RtmpTraffic'] = self.rtmp_traffic
        if self.rts_bps is not None:
            result['RtsBps'] = self.rts_bps
        if self.rts_count is not None:
            result['RtsCount'] = self.rts_count
        if self.rts_traffic is not None:
            result['RtsTraffic'] = self.rts_traffic
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.traffic is not None:
            result['Traffic'] = self.traffic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Bps') is not None:
            self.bps = m.get('Bps')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FlvBps') is not None:
            self.flv_bps = m.get('FlvBps')
        if m.get('FlvCount') is not None:
            self.flv_count = m.get('FlvCount')
        if m.get('FlvTraffic') is not None:
            self.flv_traffic = m.get('FlvTraffic')
        if m.get('HlsBps') is not None:
            self.hls_bps = m.get('HlsBps')
        if m.get('HlsCount') is not None:
            self.hls_count = m.get('HlsCount')
        if m.get('HlsTraffic') is not None:
            self.hls_traffic = m.get('HlsTraffic')
        if m.get('NewConns') is not None:
            self.new_conns = m.get('NewConns')
        if m.get('P2pBps') is not None:
            self.p_2p_bps = m.get('P2pBps')
        if m.get('P2pCount') is not None:
            self.p_2p_count = m.get('P2pCount')
        if m.get('P2pTraffic') is not None:
            self.p_2p_traffic = m.get('P2pTraffic')
        if m.get('RtmpBps') is not None:
            self.rtmp_bps = m.get('RtmpBps')
        if m.get('RtmpCount') is not None:
            self.rtmp_count = m.get('RtmpCount')
        if m.get('RtmpTraffic') is not None:
            self.rtmp_traffic = m.get('RtmpTraffic')
        if m.get('RtsBps') is not None:
            self.rts_bps = m.get('RtsBps')
        if m.get('RtsCount') is not None:
            self.rts_count = m.get('RtsCount')
        if m.get('RtsTraffic') is not None:
            self.rts_traffic = m.get('RtsTraffic')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Traffic') is not None:
            self.traffic = m.get('Traffic')
        return self


class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData(TeaModel):
    def __init__(
        self,
        stream_data: List[DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData] = None,
    ):
        self.stream_data = stream_data

    def validate(self):
        if self.stream_data:
            for k in self.stream_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamData'] = []
        if self.stream_data is not None:
            for k in self.stream_data:
                result['StreamData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_data = []
        if m.get('StreamData') is not None:
            for k in m.get('StreamData'):
                temp_model = DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData()
                self.stream_data.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamMetricDetailDataResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        page_size: int = None,
        request_id: str = None,
        start_time: str = None,
        stream_detail_data: DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData = None,
    ):
        # The accelerated domain name.
        self.domain_name = domain_name
        # The end of the time range during which data was queried.
        self.end_time = end_time
        # The token that determines the start point of the next query. This parameter is returned if more data results are available.
        self.next_page_token = next_page_token
        # The number of rows returned.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range during which data was queried.
        self.start_time = start_time
        # The data array returned.
        self.stream_detail_data = stream_detail_data

    def validate(self):
        if self.stream_detail_data:
            self.stream_detail_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_detail_data is not None:
            result['StreamDetailData'] = self.stream_detail_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamDetailData') is not None:
            temp_model = DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData()
            self.stream_detail_data = temp_model.from_map(m['StreamDetailData'])
        return self


class DescribeLiveStreamMetricDetailDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamMetricDetailDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamMetricDetailDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamMonitorListRequest(TeaModel):
    def __init__(
        self,
        monitor_id: str = None,
        order_rule: int = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        status: int = None,
    ):
        # The ID of the monitoring session.
        # 
        # >  You can obtain the monitoring session ID from the response parameter MonitorId of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation. If you leave this parameter empty, the data of all monitoring sessions is returned.
        self.monitor_id = monitor_id
        # The sorting order of monitoring sessions. Valid values:
        # 
        # *   0: Monitoring sessions are sorted by status.
        # *   1: Monitoring sessions are sorted by start time in descending order.
        # *   2: Monitoring sessions are sorted by start time in ascending order.
        self.order_rule = order_rule
        self.owner_id = owner_id
        # The page number.
        self.page_num = page_num
        # The number of monitoring sessions to return per page.
        self.page_size = page_size
        self.region_id = region_id
        # The status of the monitoring session. Valid values:
        # 
        # *   1: Monitoring
        # *   0: Unmonitored
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.order_rule is not None:
            result['OrderRule'] = self.order_rule
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('OrderRule') is not None:
            self.order_rule = m.get('OrderRule')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig(TeaModel):
    def __init__(
        self,
        fill_mode: str = None,
        position_normalized: List[float] = None,
        position_refer: str = None,
        size_normalized: List[float] = None,
    ):
        # The fill type. Set this value to none.
        self.fill_mode = fill_mode
        # The position of the layer, in the format of [unk][x,y][unk]. The values of x and y need to be normalized.
        self.position_normalized = position_normalized
        # The reference position of the element. Valid values:
        # 
        # *   topLeft
        # *   topRight
        # *   bottomLeft
        # *   bottomRight
        self.position_refer = position_refer
        # The size of the layer. Unit: bytes.
        self.size_normalized = size_normalized

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fill_mode is not None:
            result['FillMode'] = self.fill_mode
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.size_normalized is not None:
            result['SizeNormalized'] = self.size_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FillMode') is not None:
            self.fill_mode = m.get('FillMode')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('SizeNormalized') is not None:
            self.size_normalized = m.get('SizeNormalized')
        return self


class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig(TeaModel):
    def __init__(
        self,
        volume_rate: float = None,
    ):
        # The volume. Valid values: 0 to 1. The value is rounded to two decimal places.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList(TeaModel):
    def __init__(
        self,
        index: int = None,
        input_url: str = None,
        layout_config: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig = None,
        layout_id: int = None,
        play_config: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig = None,
        stream_name: str = None,
    ):
        # The index.
        self.index = index
        # The URL of the input stream.
        self.input_url = input_url
        # The layout information.
        self.layout_config = layout_config
        # The layout ID, which must start from 1.
        self.layout_id = layout_id
        # The playback configurations.
        self.play_config = play_config
        # The display name of the monitored stream.
        self.stream_name = stream_name

    def validate(self):
        if self.layout_config:
            self.layout_config.validate()
        if self.play_config:
            self.play_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.layout_config is not None:
            result['LayoutConfig'] = self.layout_config.to_map()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.play_config is not None:
            result['PlayConfig'] = self.play_config.to_map()
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('LayoutConfig') is not None:
            temp_model = DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig()
            self.layout_config = temp_model.from_map(m['LayoutConfig'])
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('PlayConfig') is not None:
            temp_model = DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig()
            self.play_config = temp_model.from_map(m['PlayConfig'])
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls(TeaModel):
    def __init__(
        self,
        flv_url: str = None,
        rtmp_url: str = None,
    ):
        # The output URL in the Flash Video (FLV) format.
        self.flv_url = flv_url
        # The output URL in the Real-Time Messaging Protocol (RTMP) format.
        self.rtmp_url = rtmp_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flv_url is not None:
            result['FlvUrl'] = self.flv_url
        if self.rtmp_url is not None:
            result['RtmpUrl'] = self.rtmp_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FlvUrl') is not None:
            self.flv_url = m.get('FlvUrl')
        if m.get('RtmpUrl') is not None:
            self.rtmp_url = m.get('RtmpUrl')
        return self


class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList(TeaModel):
    def __init__(
        self,
        audio_from: int = None,
        callback_url: str = None,
        ding_talk_web_hook_url: str = None,
        domain: str = None,
        input_list: List[DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList] = None,
        monitor_config: str = None,
        monitor_id: str = None,
        monitor_name: str = None,
        output_template: str = None,
        output_urls: DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls = None,
        region: str = None,
        start_time: str = None,
        status: int = None,
        stop_time: str = None,
    ):
        # The audio source in the layout.
        self.audio_from = audio_from
        # The callback URL that sends monitoring alerts.
        self.callback_url = callback_url
        # The URL of the DingTalk chatbot.
        self.ding_talk_web_hook_url = ding_talk_web_hook_url
        # The domain name.
        self.domain = domain
        # The list of monitored input streams.
        self.input_list = input_list
        # The monitoring alert thresholds. The following fields are included:
        # 
        # *   fpsLowThres: the video frame rate alert threshold. The value is a floating-point number.
        # *   brHighThres: the audio/video bitrate alert threshold. The value is a floating-point number.
        # *   eofDurationThresSec: the interruption duration alert threshold. The value is a floating-point number.
        self.monitor_config = monitor_config
        # The ID of the monitoring session.
        self.monitor_id = monitor_id
        # The name of the monitoring session.
        self.monitor_name = monitor_name
        # The output resolution template. Valid values:
        # 
        # *   **lp_ld**: low definition
        # *   **lp_sd**: standard definition
        # *   **lp_hd**: high definition
        # *   **lp_ud**: ultra-high definition
        self.output_template = output_template
        # The output URLs.
        self.output_urls = output_urls
        # The ID of the region. Valid values:
        # 
        # *   cn-shanghai: China (Shanghai)
        # *   cn-beijing: China (Beijing)
        # *   ap-southeast-1: Singapore
        self.region = region
        # The start time of live monitoring. The time is displayed in UTC.
        self.start_time = start_time
        # The status of the monitoring session. Valid values:
        # 
        # *   1: Monitoring
        # *   0: Unmonitored
        self.status = status
        # The end time of live monitoring. The time is displayed in UTC.
        self.stop_time = stop_time

    def validate(self):
        if self.input_list:
            for k in self.input_list:
                if k:
                    k.validate()
        if self.output_urls:
            self.output_urls.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_from is not None:
            result['AudioFrom'] = self.audio_from
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.ding_talk_web_hook_url is not None:
            result['DingTalkWebHookUrl'] = self.ding_talk_web_hook_url
        if self.domain is not None:
            result['Domain'] = self.domain
        result['InputList'] = []
        if self.input_list is not None:
            for k in self.input_list:
                result['InputList'].append(k.to_map() if k else None)
        if self.monitor_config is not None:
            result['MonitorConfig'] = self.monitor_config
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.monitor_name is not None:
            result['MonitorName'] = self.monitor_name
        if self.output_template is not None:
            result['OutputTemplate'] = self.output_template
        if self.output_urls is not None:
            result['OutputUrls'] = self.output_urls.to_map()
        if self.region is not None:
            result['Region'] = self.region
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFrom') is not None:
            self.audio_from = m.get('AudioFrom')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('DingTalkWebHookUrl') is not None:
            self.ding_talk_web_hook_url = m.get('DingTalkWebHookUrl')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        self.input_list = []
        if m.get('InputList') is not None:
            for k in m.get('InputList'):
                temp_model = DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList()
                self.input_list.append(temp_model.from_map(k))
        if m.get('MonitorConfig') is not None:
            self.monitor_config = m.get('MonitorConfig')
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('MonitorName') is not None:
            self.monitor_name = m.get('MonitorName')
        if m.get('OutputTemplate') is not None:
            self.output_template = m.get('OutputTemplate')
        if m.get('OutputUrls') is not None:
            temp_model = DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls()
            self.output_urls = temp_model.from_map(m['OutputUrls'])
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        return self


class DescribeLiveStreamMonitorListResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_monitor_list: List[DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList] = None,
        request_id: str = None,
        total: int = None,
    ):
        # The list of monitoring sessions.
        self.live_stream_monitor_list = live_stream_monitor_list
        # The request ID.
        self.request_id = request_id
        # The number of monitoring sessions.
        self.total = total

    def validate(self):
        if self.live_stream_monitor_list:
            for k in self.live_stream_monitor_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamMonitorList'] = []
        if self.live_stream_monitor_list is not None:
            for k in self.live_stream_monitor_list:
                result['LiveStreamMonitorList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_monitor_list = []
        if m.get('LiveStreamMonitorList') is not None:
            for k in m.get('LiveStreamMonitorList'):
                temp_model = DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList()
                self.live_stream_monitor_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveStreamMonitorListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamMonitorListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamMonitorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamPreloadTasksRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        play_url: str = None,
        region_id: str = None,
        start_time: str = None,
        status: str = None,
        task_id: str = None,
    ):
        # The streaming domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-30T19:00:00Z. The interval between the start time and end time cannot exceed three days.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_num = page_num
        # The number of entries per page. Valid values: 1 to 100.
        self.page_size = page_size
        # The streaming URL. You can specify up to 100 streaming URLs in a request. Separate multiple streaming URLs with commas (,).
        self.play_url = play_url
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-29T19:00:00Z. You can query only data in the previous three days.
        self.start_time = start_time
        # The status of the prefetch task. Valid values:
        # 
        # *   complete
        # *   pending
        # *   preloading
        # *   failed
        self.status = status
        # The ID of the prefetch task. The task ID is returned when you call the [SetLiveStreamPreloadTasks](https://help.aliyun.com/document_detail/2519938.html) operation to configure the prefetch task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.play_url is not None:
            result['PlayUrl'] = self.play_url
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PlayUrl') is not None:
            self.play_url = m.get('PlayUrl')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask(TeaModel):
    def __init__(
        self,
        area: str = None,
        create_time: str = None,
        description: str = None,
        domain_name: str = None,
        play_url: str = None,
        preloaded_end_time: str = None,
        preloaded_start_time: str = None,
        process: str = None,
        status: str = None,
        task_id: str = None,
    ):
        # The acceleration region where the live content is prefetched. Valid values:
        # 
        # *   domestic: regions in the Chinese mainland.
        # *   overseas: regions outside the Chinese mainland.
        # *   global: regions in and outside the Chinese mainland.
        # 
        # >  If this parameter is left empty, the acceleration region configured for the domain name is returned.
        self.area = area
        # The time when the prefetch task was created.
        self.create_time = create_time
        # Indicates whether the prefetch task is successful. Valid values:
        # 
        # *   Successfully
        # *   InternalError
        self.description = description
        # The streaming domain name.
        self.domain_name = domain_name
        # The streaming URL.
        self.play_url = play_url
        # The time when the prefetch task ended.
        self.preloaded_end_time = preloaded_end_time
        # The time when the prefetch task started.
        self.preloaded_start_time = preloaded_start_time
        # The progress of the prefetch task.
        self.process = process
        # The status of the prefetch task. Valid values:
        # 
        # *   Success
        # *   Failed
        # 
        # >  Success is returned only if the prefetch task is configured for all streaming URLs.
        self.status = status
        # The ID of the prefetch task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.play_url is not None:
            result['PlayUrl'] = self.play_url
        if self.preloaded_end_time is not None:
            result['PreloadedEndTime'] = self.preloaded_end_time
        if self.preloaded_start_time is not None:
            result['PreloadedStartTime'] = self.preloaded_start_time
        if self.process is not None:
            result['Process'] = self.process
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('PlayUrl') is not None:
            self.play_url = m.get('PlayUrl')
        if m.get('PreloadedEndTime') is not None:
            self.preloaded_end_time = m.get('PreloadedEndTime')
        if m.get('PreloadedStartTime') is not None:
            self.preloaded_start_time = m.get('PreloadedStartTime')
        if m.get('Process') is not None:
            self.process = m.get('Process')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks(TeaModel):
    def __init__(
        self,
        preload_task: List[DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask] = None,
    ):
        self.preload_task = preload_task

    def validate(self):
        if self.preload_task:
            for k in self.preload_task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PreloadTask'] = []
        if self.preload_task is not None:
            for k in self.preload_task:
                result['PreloadTask'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preload_task = []
        if m.get('PreloadTask') is not None:
            for k in m.get('PreloadTask'):
                temp_model = DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask()
                self.preload_task.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamPreloadTasksResponseBody(TeaModel):
    def __init__(
        self,
        page_num: int = None,
        page_size: int = None,
        preload_tasks: DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The details of the prefetch task.
        self.preload_tasks = preload_tasks
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.preload_tasks:
            self.preload_tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.preload_tasks is not None:
            result['PreloadTasks'] = self.preload_tasks.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PreloadTasks') is not None:
            temp_model = DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks()
            self.preload_tasks = temp_model.from_map(m['PreloadTasks'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamPreloadTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamPreloadTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamPreloadTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamPushMetricDetailDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The stream-level data of this application is returned.
        self.app_name = app_name
        # *   The accelerated domain name. You can specify only one domain name. If you specify multiple domain names, an error occurs.
        # *   If you do not specify the AppName and StreamName parameters, data of all streams under the specified domain name is returned. The data is not aggregated.
        # *   If you specify the DomainName parameter and set both the AppName and StreamName parameters to all, data of all streams in all applications under the specified domain name is aggregated and returned.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time, and the maximum time range that can be specified is one day. Specify the time in the ISO 8601 standard
        # 
        # in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.
        # 
        # When you specify the token in the next query, data continues to be obtained from the end of the previous query.
        self.next_page_token = next_page_token
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream. The data of the stream in the specified application is returned. If the StreamName parameter is specified, the AppName parameter must also be specified.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        req_bps: float = None,
        req_traffic: int = None,
        stream_name: str = None,
        time_stamp: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The total bandwidth consumed by the stream per minute. Unit: bit/s.
        self.req_bps = req_bps
        # The total amount of traffic consumed by the stream per minute. Unit: bytes.
        self.req_traffic = req_traffic
        # The name of the stream.
        self.stream_name = stream_name
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.req_bps is not None:
            result['ReqBps'] = self.req_bps
        if self.req_traffic is not None:
            result['ReqTraffic'] = self.req_traffic
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ReqBps') is not None:
            self.req_bps = m.get('ReqBps')
        if m.get('ReqTraffic') is not None:
            self.req_traffic = m.get('ReqTraffic')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData(TeaModel):
    def __init__(
        self,
        stream_data: List[DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData] = None,
    ):
        self.stream_data = stream_data

    def validate(self):
        if self.stream_data:
            for k in self.stream_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamData'] = []
        if self.stream_data is not None:
            for k in self.stream_data:
                result['StreamData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_data = []
        if m.get('StreamData') is not None:
            for k in m.get('StreamData'):
                temp_model = DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData()
                self.stream_data.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamPushMetricDetailDataResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        page_size: int = None,
        request_id: str = None,
        start_time: str = None,
        stream_detail_data: DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData = None,
    ):
        # The accelerated domain name.
        self.domain_name = domain_name
        # The end of the time range that was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time
        # A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.
        # 
        # When you specify the token in the next query, data continues to be obtained from the end of the previous query.
        self.next_page_token = next_page_token
        # The number of rows returned.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range that was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time
        # The data array returned.
        self.stream_detail_data = stream_detail_data

    def validate(self):
        if self.stream_detail_data:
            self.stream_detail_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_detail_data is not None:
            result['StreamDetailData'] = self.stream_detail_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamDetailData') is not None:
            temp_model = DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData()
            self.stream_detail_data = temp_model.from_map(m['StreamDetailData'])
        return self


class DescribeLiveStreamPushMetricDetailDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamPushMetricDetailDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamPushMetricDetailDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamRecordContentRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The operation that you want to perform. Set the value to **DescribeLiveStreamRecordContent**.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The beginning of the time range to query. You can only query the recordings in the last 6 months. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.security_token = security_token
        # The name of the live stream.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo(TeaModel):
    def __init__(
        self,
        duration: float = None,
        end_time: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object_prefix: str = None,
        start_time: str = None,
    ):
        # The beginning of the time range for which the recordings were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.duration = duration
        # The recordings.
        self.end_time = end_time
        # The recording length. Unit: seconds.
        self.oss_bucket = oss_bucket
        # The naming rule of recordings in OSS.
        self.oss_endpoint = oss_endpoint
        # The name of the Object Storage Service (OSS) bucket.
        self.oss_object_prefix = oss_object_prefix
        # The end of the time range for which the recordings were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList(TeaModel):
    def __init__(
        self,
        record_content_info: List[DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo] = None,
    ):
        self.record_content_info = record_content_info

    def validate(self):
        if self.record_content_info:
            for k in self.record_content_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordContentInfo'] = []
        if self.record_content_info is not None:
            for k in self.record_content_info:
                result['RecordContentInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_content_info = []
        if m.get('RecordContentInfo') is not None:
            for k in m.get('RecordContentInfo'):
                temp_model = DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo()
                self.record_content_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamRecordContentResponseBody(TeaModel):
    def __init__(
        self,
        record_content_info_list: DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList = None,
        request_id: str = None,
    ):
        # The ID of the request.
        self.record_content_info_list = record_content_info_list
        # The end of the time range to query. The time range that is specified by the StartTime and EndTime parameters cannot exceed 4 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.request_id = request_id

    def validate(self):
        if self.record_content_info_list:
            self.record_content_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_content_info_list is not None:
            result['RecordContentInfoList'] = self.record_content_info_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordContentInfoList') is not None:
            temp_model = DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList()
            self.record_content_info_list = temp_model.from_map(m['RecordContentInfoList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamRecordContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamRecordContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamRecordContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamRecordIndexFileRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        record_id: str = None,
        security_token: str = None,
        stream_name: str = None,
    ):
        # System-defined parameter. Value: **DescribeLiveStreamRecordIndexFile**.
        # 
        # This parameter is required.
        self.app_name = app_name
        # ## [](#)Usage notes
        # 
        # ApsaraVideo Live stores the configuration information of an M3U8 index file for six months. You can query only index files created in the previous six months. M3U8 index files are stored in Object Storage Service (OSS) buckets. The retention period is determined by the storage configuration of the OSS buckets.
        # 
        # ## [](#qps-)QPS limit
        # 
        # You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The ID of the index file.
        # 
        # >  You can call the [DescribeLiveStreamRecordIndexFiles](https://help.aliyun.com/document_detail/2847890.html) operation to query the ID.
        # 
        # This parameter is required.
        self.record_id = record_id
        self.security_token = security_token
        # The main domain of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        create_time: str = None,
        domain_name: str = None,
        duration: float = None,
        end_time: str = None,
        format: str = None,
        height: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        record_id: str = None,
        record_url: str = None,
        start_time: str = None,
        stream_name: str = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The time when the index file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The main streaming domain.
        self.domain_name = domain_name
        # The recording length. Unit: seconds.
        self.duration = duration
        # The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The video format.
        self.format = format
        # The video height.
        self.height = height
        # The name of the Object Storage Service (OSS) bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the storage file in OSS.
        self.oss_object = oss_object
        # The ID of the index file.
        self.record_id = record_id
        # The URL of the index file.
        self.record_url = record_url
        # The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The video width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.format is not None:
            result['Format'] = self.format
        if self.height is not None:
            result['Height'] = self.height
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.record_url is not None:
            result['RecordUrl'] = self.record_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RecordUrl') is not None:
            self.record_url = m.get('RecordUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class DescribeLiveStreamRecordIndexFileResponseBody(TeaModel):
    def __init__(
        self,
        record_index_info: DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo = None,
        request_id: str = None,
    ):
        # The information about the index file.
        self.record_index_info = record_index_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.record_index_info:
            self.record_index_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_index_info is not None:
            result['RecordIndexInfo'] = self.record_index_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordIndexInfo') is not None:
            temp_model = DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo()
            self.record_index_info = temp_model.from_map(m['RecordIndexInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamRecordIndexFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamRecordIndexFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamRecordIndexFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamRecordIndexFilesRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # System-defined parameter. Value: **DescribeLiveStreamRecordIndexFiles**.
        # 
        # This parameter is required.
        self.app_name = app_name
        # ## [](#)Usage notes
        # 
        # *   ApsaraVideo Live stores the information about an M3U8 index file for six months. You can query only the information of index files created in the previous six months.
        # *   M3U8 index files are stored in Object Storage Service (OSS) buckets. The retention period is determined by the storage configuration of the OSS buckets.
        # 
        # ## [](#qps-)QPS limit
        # 
        # You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the live stream.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The order in which the entries are sorted based on creation time. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_num = page_num
        # The number of entries per page. Valid values: **5 to 30**. Default value: **10**.
        self.page_size = page_size
        self.security_token = security_token
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The main streaming domain.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        create_time: str = None,
        domain_name: str = None,
        duration: float = None,
        end_time: str = None,
        format: str = None,
        height: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        record_id: str = None,
        record_url: str = None,
        start_time: str = None,
        stream_name: str = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The time when the index file was created.
        self.create_time = create_time
        # The main streaming domain.
        self.domain_name = domain_name
        # The recording length. Unit: seconds.
        self.duration = duration
        # The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # The video format.
        self.format = format
        # The video height.
        self.height = height
        # The name of the Object Storage Service (OSS) bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the storage file in OSS.
        self.oss_object = oss_object
        # The ID of the index file.
        self.record_id = record_id
        # The URL of the index file.
        self.record_url = record_url
        # The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The video width.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.format is not None:
            result['Format'] = self.format
        if self.height is not None:
            result['Height'] = self.height
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.record_id is not None:
            result['RecordId'] = self.record_id
        if self.record_url is not None:
            result['RecordUrl'] = self.record_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('RecordId') is not None:
            self.record_id = m.get('RecordId')
        if m.get('RecordUrl') is not None:
            self.record_url = m.get('RecordUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList(TeaModel):
    def __init__(
        self,
        record_index_info: List[DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo] = None,
    ):
        self.record_index_info = record_index_info

    def validate(self):
        if self.record_index_info:
            for k in self.record_index_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordIndexInfo'] = []
        if self.record_index_info is not None:
            for k in self.record_index_info:
                result['RecordIndexInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_index_info = []
        if m.get('RecordIndexInfo') is not None:
            for k in m.get('RecordIndexInfo'):
                temp_model = DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo()
                self.record_index_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamRecordIndexFilesResponseBody(TeaModel):
    def __init__(
        self,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        record_index_info_list: DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The sort order.
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The index files.
        self.record_index_info_list = record_index_info_list
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.record_index_info_list:
            self.record_index_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.record_index_info_list is not None:
            result['RecordIndexInfoList'] = self.record_index_info_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RecordIndexInfoList') is not None:
            temp_model = DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList()
            self.record_index_info_list = temp_model.from_map(m['RecordIndexInfoList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamRecordIndexFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamRecordIndexFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamRecordIndexFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamSnapshotInfoRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        limit: int = None,
        order: str = None,
        owner_id: int = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The time range specified by the EndTime and StartTime parameters cannot exceed **one** day. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The number of snapshots to return per call. Valid values: **1 to 100**. Default value: **10**.
        self.limit = limit
        # The sort order. Valid values:
        # 
        # *   **asc** (default): ascending order
        # *   **desc**: descending order
        self.order = order
        self.owner_id = owner_id
        self.security_token = security_token
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_timestamp: int = None,
        is_overlay: bool = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
    ):
        # The time when the snapshot was captured. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.create_time = create_time
        # The timestamp when the snapshot file was created. Unit: milliseconds.
        self.create_timestamp = create_timestamp
        # The snapshot mode. Valid values:
        # 
        # *   **true**: overwrite mode, which means that a new snapshot overwrites the previous snapshot.
        # *   **false**: sequence mode, which means that a new snapshot does not overwrite the previous snapshot.
        self.is_overlay = is_overlay
        # The name of the OSS bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the snapshot stored in Object Storage Service (OSS).
        self.oss_object = oss_object

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_timestamp is not None:
            result['CreateTimestamp'] = self.create_timestamp
        if self.is_overlay is not None:
            result['IsOverlay'] = self.is_overlay
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateTimestamp') is not None:
            self.create_timestamp = m.get('CreateTimestamp')
        if m.get('IsOverlay') is not None:
            self.is_overlay = m.get('IsOverlay')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        return self


class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList(TeaModel):
    def __init__(
        self,
        live_stream_snapshot_info: List[DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo] = None,
    ):
        self.live_stream_snapshot_info = live_stream_snapshot_info

    def validate(self):
        if self.live_stream_snapshot_info:
            for k in self.live_stream_snapshot_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamSnapshotInfo'] = []
        if self.live_stream_snapshot_info is not None:
            for k in self.live_stream_snapshot_info:
                result['LiveStreamSnapshotInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_snapshot_info = []
        if m.get('LiveStreamSnapshotInfo') is not None:
            for k in m.get('LiveStreamSnapshotInfo'):
                temp_model = DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo()
                self.live_stream_snapshot_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamSnapshotInfoResponseBody(TeaModel):
    def __init__(
        self,
        live_stream_snapshot_info_list: DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList = None,
        next_start_time: str = None,
        request_id: str = None,
    ):
        # The snapshots.
        self.live_stream_snapshot_info_list = live_stream_snapshot_info_list
        # The time when the next call occurred. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        # 
        # >  If the number of snapshots that were captured within the specified time period exceeds the value of the Limit parameter, this parameter is returned. It indicates the time when the DescribeLiveStreamSnapshotInfo operation was called again. If this parameter is not returned, the number of snapshots that are captured within the specified time period does not exceed the specified limit.
        self.next_start_time = next_start_time
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_stream_snapshot_info_list:
            self.live_stream_snapshot_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_stream_snapshot_info_list is not None:
            result['LiveStreamSnapshotInfoList'] = self.live_stream_snapshot_info_list.to_map()
        if self.next_start_time is not None:
            result['NextStartTime'] = self.next_start_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamSnapshotInfoList') is not None:
            temp_model = DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList()
            self.live_stream_snapshot_info_list = temp_model.from_map(m['LiveStreamSnapshotInfoList'])
        if m.get('NextStartTime') is not None:
            self.next_start_time = m.get('NextStartTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamSnapshotInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamSnapshotInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamSnapshotInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamStateRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain or ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamStateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stream_state: str = None,
        type: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The status of the stream. Valid values:
        # 
        # *   online: The stream is being ingested.
        # *   offline: The stream is offline. This may be caused by failed or completed stream ingest. For the specific reason, check the stream ingest callback. This operation does not provide detailed information.
        self.stream_state = stream_state
        # The mode of the stream. Valid values:
        # 
        # *   push: stream ingest
        # *   pull: triggered stream pulling
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_state is not None:
            result['StreamState'] = self.stream_state
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamState') is not None:
            self.stream_state = m.get('StreamState')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLiveStreamStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamTranscodeInfoRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_transcode_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_transcode_name = domain_transcode_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_transcode_name is not None:
            result['DomainTranscodeName'] = self.domain_transcode_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainTranscodeName') is not None:
            self.domain_transcode_name = m.get('DomainTranscodeName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters(TeaModel):
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channel_num: int = None,
        audio_codec: str = None,
        audio_profile: str = None,
        audio_rate: int = None,
        bframes: str = None,
        bitrate_with_source: Dict[str, Any] = None,
        de_interlaced: bool = None,
        ext_with_source: Dict[str, Any] = None,
        fps: int = None,
        fps_with_source: Dict[str, Any] = None,
        gop: str = None,
        height: int = None,
        res_with_source: Dict[str, Any] = None,
        rts_flag: str = None,
        template_type: str = None,
        video_bitrate: int = None,
        video_profile: str = None,
        width: int = None,
    ):
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: **1 to 1000**.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values:
        # 
        # *   **1**: mono
        # *   **2**: binaural
        self.audio_channel_num = audio_channel_num
        # The audio encoding format.
        self.audio_codec = audio_codec
        # The audio encoding profile. Valid values:
        # 
        # *   **aac_low**\
        # *   **aac_he**\
        # *   **aac_he_v2**\
        # *   **aac_ld**\
        self.audio_profile = audio_profile
        # The audio sampling rate. Valid values: **22050 to 96000**.
        # 
        # >  If the value of AudioProfile is **aac_ld**, the audio sampling rate cannot exceed 44100.
        self.audio_rate = audio_rate
        # Indicates whether B-frame removal is enabled. Fixed value: **0**.
        self.bframes = bframes
        # The source-based bitrate settings.
        self.bitrate_with_source = bitrate_with_source
        self.de_interlaced = de_interlaced
        # Other source-based settings.
        self.ext_with_source = ext_with_source
        # The frame rate of the output video. Unit: frames per second (FPS).
        self.fps = fps
        # The source-based frame rate settings.
        self.fps_with_source = fps_with_source
        # The group of pictures (GOP) size of the output video. Unit: frames. Valid values: **1 to 3000**.
        self.gop = gop
        # The height of the output video.
        self.height = height
        # The source-based resolution settings.
        self.res_with_source = res_with_source
        # The Real-Time Transcoding (RTS) flag. Fixed value: **true**.
        # 
        # >  This parameter is returned only if RTS is used for transcoding.
        self.rts_flag = rts_flag
        # The type of the custom transcoding template. Valid values:
        # 
        # *   **h264**: custom H.264 standard transcoding
        # *   **h264-nbhd**: custom H.264 Narrowband HD transcoding
        # *   **h265**: custom H.265 standard transcoding
        # *   **h265-nbhd**: custom H.265 Narrowband HD transcoding
        # *   **audio**: audio-only transcoding
        self.template_type = template_type
        # The bitrate of the output video. Unit: Kbit/s.
        self.video_bitrate = video_bitrate
        # The video encoding profile. Valid values:
        # 
        # *   **baseline**: suitable for mobile devices.
        # *   **main**: suitable for standard-definition devices.
        # *   **high**: suitable for high-definition devices.
        self.video_profile = video_profile
        # The width of the output video.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channel_num is not None:
            result['AudioChannelNum'] = self.audio_channel_num
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_profile is not None:
            result['AudioProfile'] = self.audio_profile
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.bframes is not None:
            result['Bframes'] = self.bframes
        if self.bitrate_with_source is not None:
            result['BitrateWithSource'] = self.bitrate_with_source
        if self.de_interlaced is not None:
            result['DeInterlaced'] = self.de_interlaced
        if self.ext_with_source is not None:
            result['ExtWithSource'] = self.ext_with_source
        if self.fps is not None:
            result['FPS'] = self.fps
        if self.fps_with_source is not None:
            result['FpsWithSource'] = self.fps_with_source
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.res_with_source is not None:
            result['ResWithSource'] = self.res_with_source
        if self.rts_flag is not None:
            result['RtsFlag'] = self.rts_flag
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.video_profile is not None:
            result['VideoProfile'] = self.video_profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannelNum') is not None:
            self.audio_channel_num = m.get('AudioChannelNum')
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioProfile') is not None:
            self.audio_profile = m.get('AudioProfile')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('Bframes') is not None:
            self.bframes = m.get('Bframes')
        if m.get('BitrateWithSource') is not None:
            self.bitrate_with_source = m.get('BitrateWithSource')
        if m.get('DeInterlaced') is not None:
            self.de_interlaced = m.get('DeInterlaced')
        if m.get('ExtWithSource') is not None:
            self.ext_with_source = m.get('ExtWithSource')
        if m.get('FPS') is not None:
            self.fps = m.get('FPS')
        if m.get('FpsWithSource') is not None:
            self.fps_with_source = m.get('FpsWithSource')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ResWithSource') is not None:
            self.res_with_source = m.get('ResWithSource')
        if m.get('RtsFlag') is not None:
            self.rts_flag = m.get('RtsFlag')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('VideoProfile') is not None:
            self.video_profile = m.get('VideoProfile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters(TeaModel):
    def __init__(
        self,
        encrypt_type: str = None,
        kms_key_expire_interval: str = None,
        kms_key_id: str = None,
    ):
        # The type of encryption. Fixed value: **aliyun**.
        self.encrypt_type = encrypt_type
        # The rotation period of the CMK. Valid values: **60 to 3600**. Unit: seconds.
        self.kms_key_expire_interval = kms_key_expire_interval
        # The ID of the customer master key (CMK) in Key Management Service (KMS).
        self.kms_key_id = kms_key_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.kms_key_expire_interval is not None:
            result['KmsKeyExpireInterval'] = self.kms_key_expire_interval
        if self.kms_key_id is not None:
            result['KmsKeyID'] = self.kms_key_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('KmsKeyExpireInterval') is not None:
            self.kms_key_expire_interval = m.get('KmsKeyExpireInterval')
        if m.get('KmsKeyID') is not None:
            self.kms_key_id = m.get('KmsKeyID')
        return self


class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo(TeaModel):
    def __init__(
        self,
        custom_transcode_parameters: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters = None,
        encrypt_parameters: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters = None,
        is_lazy: bool = None,
        transcode_app: str = None,
        transcode_name: str = None,
        transcode_template: str = None,
    ):
        # The custom transcoding configuration.
        self.custom_transcode_parameters = custom_transcode_parameters
        # The encryption settings.
        self.encrypt_parameters = encrypt_parameters
        # Indicates whether forcible transcoding is used. Valid values:
        # 
        # *   **true**: Delayed transcoding is used.
        # *   **false**: Forcible transcoding is used.
        self.is_lazy = is_lazy
        # The application name.
        self.transcode_app = transcode_app
        # The main streaming domain.
        self.transcode_name = transcode_name
        # The transcoding template ID. Valid values:
        # 
        # *   **Standard transcoding**:
        # 
        #     *   **lld**: low definition
        #     *   **lsd**: standard definition
        #     *   **lhd**: high definition
        #     *   **lud**: ultra-high definition
        # 
        # *   **Narrowband HD transcoding**:
        # 
        #     *   **ld**: low definition
        #     *   **sd**: standard definition
        #     *   **hd**: high definition
        #     *   **ud**: ultra-high definition
        self.transcode_template = transcode_template

    def validate(self):
        if self.custom_transcode_parameters:
            self.custom_transcode_parameters.validate()
        if self.encrypt_parameters:
            self.encrypt_parameters.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_transcode_parameters is not None:
            result['CustomTranscodeParameters'] = self.custom_transcode_parameters.to_map()
        if self.encrypt_parameters is not None:
            result['EncryptParameters'] = self.encrypt_parameters.to_map()
        if self.is_lazy is not None:
            result['IsLazy'] = self.is_lazy
        if self.transcode_app is not None:
            result['TranscodeApp'] = self.transcode_app
        if self.transcode_name is not None:
            result['TranscodeName'] = self.transcode_name
        if self.transcode_template is not None:
            result['TranscodeTemplate'] = self.transcode_template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTranscodeParameters') is not None:
            temp_model = DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters()
            self.custom_transcode_parameters = temp_model.from_map(m['CustomTranscodeParameters'])
        if m.get('EncryptParameters') is not None:
            temp_model = DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters()
            self.encrypt_parameters = temp_model.from_map(m['EncryptParameters'])
        if m.get('IsLazy') is not None:
            self.is_lazy = m.get('IsLazy')
        if m.get('TranscodeApp') is not None:
            self.transcode_app = m.get('TranscodeApp')
        if m.get('TranscodeName') is not None:
            self.transcode_name = m.get('TranscodeName')
        if m.get('TranscodeTemplate') is not None:
            self.transcode_template = m.get('TranscodeTemplate')
        return self


class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList(TeaModel):
    def __init__(
        self,
        domain_transcode_info: List[DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo] = None,
    ):
        self.domain_transcode_info = domain_transcode_info

    def validate(self):
        if self.domain_transcode_info:
            for k in self.domain_transcode_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainTranscodeInfo'] = []
        if self.domain_transcode_info is not None:
            for k in self.domain_transcode_info:
                result['DomainTranscodeInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_transcode_info = []
        if m.get('DomainTranscodeInfo') is not None:
            for k in m.get('DomainTranscodeInfo'):
                temp_model = DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo()
                self.domain_transcode_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamTranscodeInfoResponseBody(TeaModel):
    def __init__(
        self,
        domain_transcode_list: DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList = None,
        request_id: str = None,
    ):
        # The transcoding configurations.
        self.domain_transcode_list = domain_transcode_list
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.domain_transcode_list:
            self.domain_transcode_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_transcode_list is not None:
            result['DomainTranscodeList'] = self.domain_transcode_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainTranscodeList') is not None:
            temp_model = DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList()
            self.domain_transcode_list = temp_model.from_map(m['DomainTranscodeList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamTranscodeInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamTranscodeInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamTranscodeInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamTranscodeMetricDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The domain name. You can specify only one domain name in each request.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.
        # 
        # When you specify the token in the next query, data continues to be obtained from the end of the previous query.
        self.next_page_token = next_page_token
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        duration: int = None,
        fps: str = None,
        region: str = None,
        resolution: str = None,
        stream_name: str = None,
        time_stamp: str = None,
        transcode_type: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The duration. Unit: seconds.
        self.duration = duration
        # The frame rate.
        # 
        # Valid values:
        # 
        # *   <!-- -->
        # 
        #     <!-- -->
        # 
        #     normal
        # 
        #     <!-- -->
        # 
        # *   <!-- -->
        # 
        #     <!-- -->
        # 
        #     high
        # 
        #     <!-- -->
        # 
        # *   <!-- -->
        # 
        #     <!-- -->
        # 
        #     def
        # 
        #     <!-- -->
        self.fps = fps
        # The region.
        self.region = region
        # The resolution. Valid values:
        # 
        # *   2K: 2K resolution
        # *   4K: 4K resolution
        # *   LD: low definition
        # *   SD: standard definition
        # *   HD: high definition
        # *   def: audio
        self.resolution = resolution
        # The name of the stream.
        self.stream_name = stream_name
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The transcoding type. Valid values:
        # 
        # *   H264STD: standard transcoding based on H.264
        # *   H264NBHD: Narrowband HD transcoding based on H.264
        # *   H265STD: standard transcoding based on H.265
        # *   AUDIO: audio transcoding
        self.transcode_type = transcode_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.region is not None:
            result['Region'] = self.region
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.transcode_type is not None:
            result['TranscodeType'] = self.transcode_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TranscodeType') is not None:
            self.transcode_type = m.get('TranscodeType')
        return self


class DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData(TeaModel):
    def __init__(
        self,
        stream_data: List[DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData] = None,
    ):
        self.stream_data = stream_data

    def validate(self):
        if self.stream_data:
            for k in self.stream_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamData'] = []
        if self.stream_data is not None:
            for k in self.stream_data:
                result['StreamData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_data = []
        if m.get('StreamData') is not None:
            for k in m.get('StreamData'):
                temp_model = DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData()
                self.stream_data.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamTranscodeMetricDataResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        next_page_token: str = None,
        page_size: int = None,
        request_id: str = None,
        start_time: str = None,
        stream_detail_data: DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.end_time = end_time
        # A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.
        # 
        # When you specify the token in the next query, data continues to be obtained from the end of the previous query.
        self.next_page_token = next_page_token
        # The number of rows returned.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time
        # The data array returned.
        self.stream_detail_data = stream_detail_data

    def validate(self):
        if self.stream_detail_data:
            self.stream_detail_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_detail_data is not None:
            result['StreamDetailData'] = self.stream_detail_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamDetailData') is not None:
            temp_model = DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData()
            self.stream_detail_data = temp_model.from_map(m['StreamDetailData'])
        return self


class DescribeLiveStreamTranscodeMetricDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamTranscodeMetricDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamTranscodeMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamTranscodeStreamNumRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        split_type: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The grouping method.
        # 
        # *   Domain name (default)
        # *   Template
        # 
        # Valid values:
        # 
        # *   domain
        # *   template
        self.split_type = split_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.split_type is not None:
            result['SplitType'] = self.split_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SplitType') is not None:
            self.split_type = m.get('SplitType')
        return self


class DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails(TeaModel):
    def __init__(
        self,
        count: int = None,
        template: str = None,
    ):
        # The number of streams that use the transcoding template.
        self.count = count
        # The name of the transcoding template.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class DescribeLiveStreamTranscodeStreamNumResponseBody(TeaModel):
    def __init__(
        self,
        lazy_transcoded_number: int = None,
        request_id: str = None,
        total: int = None,
        transcode_stream_count_details: List[DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails] = None,
        transcoded_number: int = None,
        untranscode_number: int = None,
    ):
        # The number of streams for which transcoding is triggered by stream pulling.
        self.lazy_transcoded_number = lazy_transcoded_number
        # The request ID.
        self.request_id = request_id
        # The total number of streams.
        self.total = total
        # The details about the transcoding templates.
        self.transcode_stream_count_details = transcode_stream_count_details
        # The number of streams that are transcoded.
        self.transcoded_number = transcoded_number
        # The number of streams that are not transcoded.
        self.untranscode_number = untranscode_number

    def validate(self):
        if self.transcode_stream_count_details:
            for k in self.transcode_stream_count_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lazy_transcoded_number is not None:
            result['LazyTranscodedNumber'] = self.lazy_transcoded_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        result['TranscodeStreamCountDetails'] = []
        if self.transcode_stream_count_details is not None:
            for k in self.transcode_stream_count_details:
                result['TranscodeStreamCountDetails'].append(k.to_map() if k else None)
        if self.transcoded_number is not None:
            result['TranscodedNumber'] = self.transcoded_number
        if self.untranscode_number is not None:
            result['UntranscodeNumber'] = self.untranscode_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LazyTranscodedNumber') is not None:
            self.lazy_transcoded_number = m.get('LazyTranscodedNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.transcode_stream_count_details = []
        if m.get('TranscodeStreamCountDetails') is not None:
            for k in m.get('TranscodeStreamCountDetails'):
                temp_model = DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails()
                self.transcode_stream_count_details.append(temp_model.from_map(k))
        if m.get('TranscodedNumber') is not None:
            self.transcoded_number = m.get('TranscodedNumber')
        if m.get('UntranscodeNumber') is not None:
            self.untranscode_number = m.get('UntranscodeNumber')
        return self


class DescribeLiveStreamTranscodeStreamNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamTranscodeStreamNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamTranscodeStreamNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamWatermarkRulesRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        self.domain = domain
        self.owner_id = owner_id
        # The page number. If you do not specify this parameter, the default value 1 is used.
        self.page_number = page_number
        # The number of entries per page. If you do not specify this parameter, the default value 100 is used.
        self.page_size = page_size
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo(TeaModel):
    def __init__(
        self,
        app: str = None,
        description: str = None,
        domain: str = None,
        name: str = None,
        rule_id: str = None,
        stream: str = None,
        template_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The description of the custom rule.
        self.description = description
        # The streaming domain.
        self.domain = domain
        # The name of the custom rule.
        self.name = name
        # The ID of the watermark rule.
        # 
        # >  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.
        self.rule_id = rule_id
        # The name of the live stream. The following matching rules apply:
        # 
        # *   A stream name can be exactly matched. Example: liveStreamA.
        # *   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
        # *   You can place the asterisk before or after an approximate string.
        # 
        # > 
        # 
        # *   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).
        # 
        # *   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.
        self.stream = stream
        # The ID of the watermark template.
        # 
        # >  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/2848096.html) operation.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList(TeaModel):
    def __init__(
        self,
        rule_info: List[DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo] = None,
    ):
        self.rule_info = rule_info

    def validate(self):
        if self.rule_info:
            for k in self.rule_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RuleInfo'] = []
        if self.rule_info is not None:
            for k in self.rule_info:
                result['RuleInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rule_info = []
        if m.get('RuleInfo') is not None:
            for k in m.get('RuleInfo'):
                temp_model = DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo()
                self.rule_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamWatermarkRulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_info_list: DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList = None,
        total: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The watermark rules.
        self.rule_info_list = rule_info_list
        # The total number of entries that meet the specified conditions.
        self.total = total

    def validate(self):
        if self.rule_info_list:
            self.rule_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_info_list is not None:
            result['RuleInfoList'] = self.rule_info_list.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleInfoList') is not None:
            temp_model = DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList()
            self.rule_info_list = temp_model.from_map(m['RuleInfoList'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveStreamWatermarkRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamWatermarkRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamWatermarkRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamWatermarksRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        key_word: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The name of the main streaming domain.
        self.domain = domain
        # The keyword used in the query. You can specify the template ID or name. Fuzzy search is supported for the name.
        self.key_word = key_word
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of templates per page. Default value: 100.
        self.page_size = page_size
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark(TeaModel):
    def __init__(
        self,
        description: str = None,
        height: int = None,
        name: str = None,
        offset_corner: str = None,
        picture_url: str = None,
        ref_height: int = None,
        ref_width: int = None,
        rule_count: int = None,
        template_id: str = None,
        transparency: int = None,
        type: int = None,
        xoffset: float = None,
        yoffset: float = None,
    ):
        # The description of the watermark.
        self.description = description
        # The height of the watermark. Unit: pixels.
        self.height = height
        # The name of the watermark.
        self.name = name
        # The position of the watermark.
        # 
        # *   TopLeft: the upper-left corner.
        # *   TopRight: the upper-right corner.
        # *   BottomLeft: the lower-left corner.
        # *   BottomRight: the lower-right corner.
        self.offset_corner = offset_corner
        # The URL of the watermark image.
        self.picture_url = picture_url
        # The height of the background video. Unit: pixels.
        self.ref_height = ref_height
        # The width of the background video. Unit: pixels.
        self.ref_width = ref_width
        # The number of watermark rules configured for the domain name.
        self.rule_count = rule_count
        # The ID of the watermark template.
        self.template_id = template_id
        # The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.
        self.transparency = transparency
        # The watermark type.
        # 
        # *   0: image. Only image watermarks are supported.
        # *   1: text.
        self.type = type
        # The offset of the watermark along the x-axis. Unit: pixels.
        # 
        # >  The value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.
        self.xoffset = xoffset
        # The offset of the watermark along the y-axis. Unit: pixels.
        # 
        # >  The value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.
        self.yoffset = yoffset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.offset_corner is not None:
            result['OffsetCorner'] = self.offset_corner
        if self.picture_url is not None:
            result['PictureUrl'] = self.picture_url
        if self.ref_height is not None:
            result['RefHeight'] = self.ref_height
        if self.ref_width is not None:
            result['RefWidth'] = self.ref_width
        if self.rule_count is not None:
            result['RuleCount'] = self.rule_count
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.transparency is not None:
            result['Transparency'] = self.transparency
        if self.type is not None:
            result['Type'] = self.type
        if self.xoffset is not None:
            result['XOffset'] = self.xoffset
        if self.yoffset is not None:
            result['YOffset'] = self.yoffset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OffsetCorner') is not None:
            self.offset_corner = m.get('OffsetCorner')
        if m.get('PictureUrl') is not None:
            self.picture_url = m.get('PictureUrl')
        if m.get('RefHeight') is not None:
            self.ref_height = m.get('RefHeight')
        if m.get('RefWidth') is not None:
            self.ref_width = m.get('RefWidth')
        if m.get('RuleCount') is not None:
            self.rule_count = m.get('RuleCount')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Transparency') is not None:
            self.transparency = m.get('Transparency')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('XOffset') is not None:
            self.xoffset = m.get('XOffset')
        if m.get('YOffset') is not None:
            self.yoffset = m.get('YOffset')
        return self


class DescribeLiveStreamWatermarksResponseBodyWatermarkList(TeaModel):
    def __init__(
        self,
        watermark: List[DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark] = None,
    ):
        self.watermark = watermark

    def validate(self):
        if self.watermark:
            for k in self.watermark:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Watermark'] = []
        if self.watermark is not None:
            for k in self.watermark:
                result['Watermark'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.watermark = []
        if m.get('Watermark') is not None:
            for k in m.get('Watermark'):
                temp_model = DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark()
                self.watermark.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamWatermarksResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        total: int = None,
        watermark_list: DescribeLiveStreamWatermarksResponseBodyWatermarkList = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The total number of watermark templates that meet the specified conditions.
        self.total = total
        # Details of the watermark templates.
        self.watermark_list = watermark_list

    def validate(self):
        if self.watermark_list:
            self.watermark_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        if self.watermark_list is not None:
            result['WatermarkList'] = self.watermark_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('WatermarkList') is not None:
            temp_model = DescribeLiveStreamWatermarksResponseBodyWatermarkList()
            self.watermark_list = temp_model.from_map(m['WatermarkList'])
        return self


class DescribeLiveStreamWatermarksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamWatermarksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamWatermarksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsBlockListRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The number of the page to return. Default value: **1**.
        self.page_num = page_num
        # The number of entries to return on each page. Valid values: 1 to 3000. Default value: 2000.
        self.page_size = page_size
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class DescribeLiveStreamsBlockListResponseBodyStreamUrls(TeaModel):
    def __init__(
        self,
        stream_url: List[str] = None,
    ):
        self.stream_url = stream_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class DescribeLiveStreamsBlockListResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        stream_urls: DescribeLiveStreamsBlockListResponseBodyStreamUrls = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The main streaming domain.
        self.domain_name = domain_name
        # The page number of the returned page.
        self.page_num = page_num
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The complete URL of each live stream.
        self.stream_urls = stream_urls
        # The total number of live stream URLs that meet the specified conditions.
        self.total_num = total_num
        # The total number of returned pages.
        self.total_page = total_page

    def validate(self):
        if self.stream_urls:
            self.stream_urls.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_urls is not None:
            result['StreamUrls'] = self.stream_urls.to_map()
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamUrls') is not None:
            temp_model = DescribeLiveStreamsBlockListResponseBodyStreamUrls()
            self.stream_urls = temp_model.from_map(m['StreamUrls'])
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamsBlockListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsBlockListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsBlockListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsControlHistoryRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The application name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo(TeaModel):
    def __init__(
        self,
        action: str = None,
        client_ip: str = None,
        stream_name: str = None,
        time_stamp: str = None,
    ):
        # The name of the operation performed.
        self.action = action
        # The IP address that is used by the client for live streaming.
        self.client_ip = client_ip
        # The name of the live stream.
        self.stream_name = stream_name
        # The time when the operation was performed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.client_ip is not None:
            result['ClientIP'] = self.client_ip
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('ClientIP') is not None:
            self.client_ip = m.get('ClientIP')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeLiveStreamsControlHistoryResponseBodyControlInfo(TeaModel):
    def __init__(
        self,
        live_stream_control_info: List[DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo] = None,
    ):
        self.live_stream_control_info = live_stream_control_info

    def validate(self):
        if self.live_stream_control_info:
            for k in self.live_stream_control_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamControlInfo'] = []
        if self.live_stream_control_info is not None:
            for k in self.live_stream_control_info:
                result['LiveStreamControlInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_control_info = []
        if m.get('LiveStreamControlInfo') is not None:
            for k in m.get('LiveStreamControlInfo'):
                temp_model = DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo()
                self.live_stream_control_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamsControlHistoryResponseBody(TeaModel):
    def __init__(
        self,
        control_info: DescribeLiveStreamsControlHistoryResponseBodyControlInfo = None,
        request_id: str = None,
    ):
        # The operation records.
        self.control_info = control_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.control_info:
            self.control_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.control_info is not None:
            result['ControlInfo'] = self.control_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ControlInfo') is not None:
            temp_model = DescribeLiveStreamsControlHistoryResponseBodyControlInfo()
            self.control_info = temp_model.from_map(m['ControlInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamsControlHistoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsControlHistoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsControlHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsNotifyRecordsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
        status: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Default value: 20. Maximum value: 500. Valid values: integers from 1 to 500.
        self.page_size = page_size
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The start time must be in the last seven days.
        # 
        # This parameter is required.
        self.start_time = start_time
        # Specifies whether to return the records of successful or failed callbacks. Valid values:
        # 
        # *   success
        # *   failed
        self.status = status
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        description: str = None,
        domain_name: str = None,
        notify_content: str = None,
        notify_response: str = None,
        notify_result: str = None,
        notify_time: str = None,
        notify_type: str = None,
        notify_url: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.
        self.description = description
        # The ingest domain.
        self.domain_name = domain_name
        # The callback content.
        self.notify_content = notify_content
        self.notify_response = notify_response
        # The callback result. Valid values:
        # 
        # *   success
        # *   failed
        self.notify_result = notify_result
        # The time when the callback was invoked. The time is displayed in UTC.
        self.notify_time = notify_time
        # The event. Valid values:
        # 
        # *   publish: The stream ingest starts.
        # *   publish_done: The stream ingest is interrupted.
        self.notify_type = notify_type
        # The callback URL.
        self.notify_url = notify_url
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_content is not None:
            result['NotifyContent'] = self.notify_content
        if self.notify_response is not None:
            result['NotifyResponse'] = self.notify_response
        if self.notify_result is not None:
            result['NotifyResult'] = self.notify_result
        if self.notify_time is not None:
            result['NotifyTime'] = self.notify_time
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyContent') is not None:
            self.notify_content = m.get('NotifyContent')
        if m.get('NotifyResponse') is not None:
            self.notify_response = m.get('NotifyResponse')
        if m.get('NotifyResult') is not None:
            self.notify_result = m.get('NotifyResult')
        if m.get('NotifyTime') is not None:
            self.notify_time = m.get('NotifyTime')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo(TeaModel):
    def __init__(
        self,
        live_stream_notify_records_info: List[DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo] = None,
    ):
        self.live_stream_notify_records_info = live_stream_notify_records_info

    def validate(self):
        if self.live_stream_notify_records_info:
            for k in self.live_stream_notify_records_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamNotifyRecordsInfo'] = []
        if self.live_stream_notify_records_info is not None:
            for k in self.live_stream_notify_records_info:
                result['LiveStreamNotifyRecordsInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_notify_records_info = []
        if m.get('LiveStreamNotifyRecordsInfo') is not None:
            for k in m.get('LiveStreamNotifyRecordsInfo'):
                temp_model = DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo()
                self.live_stream_notify_records_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamsNotifyRecordsResponseBody(TeaModel):
    def __init__(
        self,
        notify_records_info: DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The stream ingest callback records.
        self.notify_records_info = notify_records_info
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.notify_records_info:
            self.notify_records_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_records_info is not None:
            result['NotifyRecordsInfo'] = self.notify_records_info.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyRecordsInfo') is not None:
            temp_model = DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo()
            self.notify_records_info = temp_model.from_map(m['NotifyRecordsInfo'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamsNotifyRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsNotifyRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsNotifyRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsNotifyUrlConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        exception_notify_url: str = None,
        notify_auth_key: str = None,
        notify_req_auth: str = None,
        notify_url: str = None,
    ):
        # The ingest domain.
        self.domain_name = domain_name
        # Exception event callback URL.
        self.exception_notify_url = exception_notify_url
        # The authentication key.
        self.notify_auth_key = notify_auth_key
        # Indicates whether callback authentication is enabled. Valid values:
        # 
        # *   yes
        # *   no
        self.notify_req_auth = notify_req_auth
        # The callback URL.
        self.notify_url = notify_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.exception_notify_url is not None:
            result['ExceptionNotifyUrl'] = self.exception_notify_url
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExceptionNotifyUrl') is not None:
            self.exception_notify_url = m.get('ExceptionNotifyUrl')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        return self


class DescribeLiveStreamsNotifyUrlConfigResponseBody(TeaModel):
    def __init__(
        self,
        live_streams_notify_config: DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig = None,
        request_id: str = None,
    ):
        # The callback configuration.
        self.live_streams_notify_config = live_streams_notify_config
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.live_streams_notify_config:
            self.live_streams_notify_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_streams_notify_config is not None:
            result['LiveStreamsNotifyConfig'] = self.live_streams_notify_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveStreamsNotifyConfig') is not None:
            temp_model = DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig()
            self.live_streams_notify_config = temp_model.from_map(m['LiveStreamsNotifyConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveStreamsNotifyUrlConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsNotifyUrlConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsNotifyUrlConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsOnlineListRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        only_stream: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        query_type: str = None,
        region_id: str = None,
        stream_name: str = None,
        stream_type: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to return only specific parameters. Valid values:
        # 
        # *   **yes**: returns only the DomainName, AppName, StreamName, and PublishTime parameters.
        # *   **no**: returns all parameters. This is the default value.
        self.only_stream = only_stream
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_num = page_num
        # The number of entries per page. Valid values: 1 to 3000. Default value: 2000.
        self.page_size = page_size
        # The mode in which stream names are matched. Valid values:
        # 
        # *   **fuzzy** (default): fuzzy match
        # *   **strict**: exact match
        self.query_type = query_type
        self.region_id = region_id
        # The name of the live stream. You can specify only one live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name
        # The type of the streams to query. Valid values:
        # 
        # *   **all** (default): all streams
        # *   **raw**: source streams
        # *   **trans**: transcoded streams
        self.stream_type = stream_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.only_stream is not None:
            result['OnlyStream'] = self.only_stream
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OnlyStream') is not None:
            self.only_stream = m.get('OnlyStream')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        return self


class DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        audio_codec_id: int = None,
        audio_data_rate: int = None,
        client_ip: str = None,
        domain_name: str = None,
        frame_rate: int = None,
        height: int = None,
        publish_domain: str = None,
        publish_time: str = None,
        publish_type: str = None,
        publish_url: str = None,
        server_ip: str = None,
        stream_name: str = None,
        transcoded: str = None,
        video_codec_id: int = None,
        video_data_rate: int = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The ID of the audio codec.
        self.audio_codec_id = audio_codec_id
        # The audio bitrate of the live stream. Unit: Kbit/s.
        # 
        # >  This parameter can be returned after you submit a ticket for whitelist configuration. For more information about how to submit a ticket, see Contact us.
        self.audio_data_rate = audio_data_rate
        # The IP address of the client for stream ingest.
        self.client_ip = client_ip
        # The main streaming domain.
        self.domain_name = domain_name
        # The frame rate. Unit: FPS.
        self.frame_rate = frame_rate
        # The height of the video resolution. Unit: pixels.
        self.height = height
        # The ingest domain. If live center ingest was used, the streaming domain is returned.
        self.publish_domain = publish_domain
        # The start time of stream ingest. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.publish_time = publish_time
        # The ingest type. Valid values:
        # 
        # *   **edge**: edge ingest.
        # *   **center**: live center ingest.
        self.publish_type = publish_type
        # The complete URL that was used to ingest the stream.
        self.publish_url = publish_url
        # The IP address of the ingest node.
        self.server_ip = server_ip
        # The name of the live stream.
        self.stream_name = stream_name
        # Indicates whether the stream was transcoded. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.transcoded = transcoded
        # The ID of the video codec.
        self.video_codec_id = video_codec_id
        # The video bitrate of the live stream. Unit: Kbit/s.
        # 
        # >  This parameter can be returned after you submit a ticket for whitelist configuration. For more information about how to submit a ticket, see Contact us.
        self.video_data_rate = video_data_rate
        # The width of the video resolution. Unit: pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.audio_codec_id is not None:
            result['AudioCodecId'] = self.audio_codec_id
        if self.audio_data_rate is not None:
            result['AudioDataRate'] = self.audio_data_rate
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.frame_rate is not None:
            result['FrameRate'] = self.frame_rate
        if self.height is not None:
            result['Height'] = self.height
        if self.publish_domain is not None:
            result['PublishDomain'] = self.publish_domain
        if self.publish_time is not None:
            result['PublishTime'] = self.publish_time
        if self.publish_type is not None:
            result['PublishType'] = self.publish_type
        if self.publish_url is not None:
            result['PublishUrl'] = self.publish_url
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transcoded is not None:
            result['Transcoded'] = self.transcoded
        if self.video_codec_id is not None:
            result['VideoCodecId'] = self.video_codec_id
        if self.video_data_rate is not None:
            result['VideoDataRate'] = self.video_data_rate
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AudioCodecId') is not None:
            self.audio_codec_id = m.get('AudioCodecId')
        if m.get('AudioDataRate') is not None:
            self.audio_data_rate = m.get('AudioDataRate')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FrameRate') is not None:
            self.frame_rate = m.get('FrameRate')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('PublishDomain') is not None:
            self.publish_domain = m.get('PublishDomain')
        if m.get('PublishTime') is not None:
            self.publish_time = m.get('PublishTime')
        if m.get('PublishType') is not None:
            self.publish_type = m.get('PublishType')
        if m.get('PublishUrl') is not None:
            self.publish_url = m.get('PublishUrl')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Transcoded') is not None:
            self.transcoded = m.get('Transcoded')
        if m.get('VideoCodecId') is not None:
            self.video_codec_id = m.get('VideoCodecId')
        if m.get('VideoDataRate') is not None:
            self.video_data_rate = m.get('VideoDataRate')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class DescribeLiveStreamsOnlineListResponseBodyOnlineInfo(TeaModel):
    def __init__(
        self,
        live_stream_online_info: List[DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo] = None,
    ):
        self.live_stream_online_info = live_stream_online_info

    def validate(self):
        if self.live_stream_online_info:
            for k in self.live_stream_online_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamOnlineInfo'] = []
        if self.live_stream_online_info is not None:
            for k in self.live_stream_online_info:
                result['LiveStreamOnlineInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_online_info = []
        if m.get('LiveStreamOnlineInfo') is not None:
            for k in m.get('LiveStreamOnlineInfo'):
                temp_model = DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo()
                self.live_stream_online_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamsOnlineListResponseBody(TeaModel):
    def __init__(
        self,
        online_info: DescribeLiveStreamsOnlineListResponseBodyOnlineInfo = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The information about the live streams that are being ingested.
        self.online_info = online_info
        # The page number of the returned page.
        self.page_num = page_num
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of streams that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages returned.
        self.total_page = total_page

    def validate(self):
        if self.online_info:
            self.online_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.online_info is not None:
            result['OnlineInfo'] = self.online_info.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OnlineInfo') is not None:
            temp_model = DescribeLiveStreamsOnlineListResponseBodyOnlineInfo()
            self.online_info = temp_model.from_map(m['OnlineInfo'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamsOnlineListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsOnlineListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsOnlineListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsPublishListRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        order_by: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        query_type: str = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
        stream_type: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The ingest domain or main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The time range specified by the StartTime and EndTime parameters cannot exceed 30 days.
        # 
        # Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The sorting method. Valid values:
        # 
        # *   **stream_name_desc**: sorts the entries in descending order by stream name.
        # *   **stream_name_asc**: sorts the entries in ascending order by stream name.
        # *   **publish_time_desc**: sorts the entries in descending order by stream ingest time.
        # *   **publish_time_asc** (default): sorts the entries in ascending order by stream ingest time.
        self.order_by = order_by
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Valid values: **1 to 3000**. Default value: **2000**.
        self.page_size = page_size
        # The mode in which stream names are matched. Valid values:
        # 
        # *   **fuzzy** (default): fuzzy match
        # *   **strict**: exact match
        self.query_type = query_type
        self.region_id = region_id
        # The beginning of the time range to query.
        # 
        # Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The type of the streams to query. Valid values:
        # 
        # *   An empty value****: source streams
        # *   **all**: all streams
        # *   **trans**: transcoded streams
        self.stream_type = stream_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        return self


class DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo(TeaModel):
    def __init__(
        self,
        ali_inner_error_flags: str = None,
        app_name: str = None,
        client_addr: str = None,
        domain_name: str = None,
        edge_node_addr: str = None,
        publish_domain: str = None,
        publish_time: str = None,
        publish_type: str = None,
        publish_url: str = None,
        stop_time: str = None,
        stream_name: str = None,
        stream_url: str = None,
        transcode_id: str = None,
        transcoded: str = None,
    ):
        # Internal error
        self.ali_inner_error_flags = ali_inner_error_flags
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The IP address of the client that ingested the live stream.
        self.client_addr = client_addr
        # The ingest domain or main streaming domain.
        self.domain_name = domain_name
        # The IP address of the CDN point of presence (POP) to which the stream was ingested.
        self.edge_node_addr = edge_node_addr
        # The ingest domain.
        self.publish_domain = publish_domain
        # The time when the stream ingest was started. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.publish_time = publish_time
        # The type of the stream ingest. Valid values:
        # 
        # *   **edge**: edge ingest
        # *   **center**: live center ingest
        self.publish_type = publish_type
        # The complete ingest URL.
        self.publish_url = publish_url
        # The time when the stream ingest was stopped. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.stop_time = stop_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The streaming URL.
        self.stream_url = stream_url
        # The ID of the transcoding template.
        # 
        # >  This parameter is not returned if the value of the Transcoded parameter is no.
        self.transcode_id = transcode_id
        # Indicates whether the stream was a transcoded stream.
        self.transcoded = transcoded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_inner_error_flags is not None:
            result['AliInnerErrorFlags'] = self.ali_inner_error_flags
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.client_addr is not None:
            result['ClientAddr'] = self.client_addr
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.edge_node_addr is not None:
            result['EdgeNodeAddr'] = self.edge_node_addr
        if self.publish_domain is not None:
            result['PublishDomain'] = self.publish_domain
        if self.publish_time is not None:
            result['PublishTime'] = self.publish_time
        if self.publish_type is not None:
            result['PublishType'] = self.publish_type
        if self.publish_url is not None:
            result['PublishUrl'] = self.publish_url
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        if self.transcode_id is not None:
            result['TranscodeId'] = self.transcode_id
        if self.transcoded is not None:
            result['Transcoded'] = self.transcoded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliInnerErrorFlags') is not None:
            self.ali_inner_error_flags = m.get('AliInnerErrorFlags')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClientAddr') is not None:
            self.client_addr = m.get('ClientAddr')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EdgeNodeAddr') is not None:
            self.edge_node_addr = m.get('EdgeNodeAddr')
        if m.get('PublishDomain') is not None:
            self.publish_domain = m.get('PublishDomain')
        if m.get('PublishTime') is not None:
            self.publish_time = m.get('PublishTime')
        if m.get('PublishType') is not None:
            self.publish_type = m.get('PublishType')
        if m.get('PublishUrl') is not None:
            self.publish_url = m.get('PublishUrl')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        if m.get('TranscodeId') is not None:
            self.transcode_id = m.get('TranscodeId')
        if m.get('Transcoded') is not None:
            self.transcoded = m.get('Transcoded')
        return self


class DescribeLiveStreamsPublishListResponseBodyPublishInfo(TeaModel):
    def __init__(
        self,
        live_stream_publish_info: List[DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo] = None,
    ):
        self.live_stream_publish_info = live_stream_publish_info

    def validate(self):
        if self.live_stream_publish_info:
            for k in self.live_stream_publish_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveStreamPublishInfo'] = []
        if self.live_stream_publish_info is not None:
            for k in self.live_stream_publish_info:
                result['LiveStreamPublishInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.live_stream_publish_info = []
        if m.get('LiveStreamPublishInfo') is not None:
            for k in m.get('LiveStreamPublishInfo'):
                temp_model = DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo()
                self.live_stream_publish_info.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamsPublishListResponseBody(TeaModel):
    def __init__(
        self,
        page_num: int = None,
        page_size: int = None,
        publish_info: DescribeLiveStreamsPublishListResponseBodyPublishInfo = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The information about the stream ingest records.
        self.publish_info = publish_info
        # The request ID.
        self.request_id = request_id
        # The total number of entries that meet the specified conditions.
        self.total_num = total_num
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.publish_info:
            self.publish_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.publish_info is not None:
            result['PublishInfo'] = self.publish_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PublishInfo') is not None:
            temp_model = DescribeLiveStreamsPublishListResponseBodyPublishInfo()
            self.publish_info = temp_model.from_map(m['PublishInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeLiveStreamsPublishListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsPublishListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsPublishListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveStreamsTotalCountRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        typ: str = None,
    ):
        # The ingest domain or streaming domain. This parameter is required if you want to query data based on domain names. You can specify up to 10 domain names. Separate multiple domain names with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The maximum time range for a query is 15 days. The end time must be earlier than the current time. Data of the current day can be queried on the next day.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  You can query data in the last 18 months.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The type of data that you want to query. If you leave this parameter empty, data is returned by domain name. If you want to query data by UID, specify the UID for this parameter.
        self.typ = typ

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.typ is not None:
            result['Typ'] = self.typ
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Typ') is not None:
            self.typ = m.get('Typ')
        return self


class DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos(TeaModel):
    def __init__(
        self,
        count: int = None,
        timestamp: str = None,
    ):
        # The total number of live streams.
        self.count = count
        # The timestamp.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeLiveStreamsTotalCountResponseBodyStreamCountList(TeaModel):
    def __init__(
        self,
        stream_count_infos: List[DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos] = None,
    ):
        self.stream_count_infos = stream_count_infos

    def validate(self):
        if self.stream_count_infos:
            for k in self.stream_count_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamCountInfos'] = []
        if self.stream_count_infos is not None:
            for k in self.stream_count_infos:
                result['StreamCountInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_count_infos = []
        if m.get('StreamCountInfos') is not None:
            for k in m.get('StreamCountInfos'):
                temp_model = DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos()
                self.stream_count_infos.append(temp_model.from_map(k))
        return self


class DescribeLiveStreamsTotalCountResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stream_count_list: DescribeLiveStreamsTotalCountResponseBodyStreamCountList = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The statistics about the live streams.
        self.stream_count_list = stream_count_list

    def validate(self):
        if self.stream_count_list:
            self.stream_count_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_count_list is not None:
            result['StreamCountList'] = self.stream_count_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamCountList') is not None:
            temp_model = DescribeLiveStreamsTotalCountResponseBodyStreamCountList()
            self.stream_count_list = temp_model.from_map(m['StreamCountList'])
        return self


class DescribeLiveStreamsTotalCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveStreamsTotalCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveStreamsTotalCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveTopDomainsByFlowRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        limit: int = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The maximum number of domain names that you want to retrieve. Valid values: 1 to 100. Default value: 20.
        self.limit = limit
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum data granularity is 5 minutes. If you do not specify this parameter, the data of the current month is returned.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        max_bps: int = None,
        max_bps_time: str = None,
        rank: int = None,
        total_access: int = None,
        total_traffic: str = None,
        traffic_percent: str = None,
    ):
        # The domain name.
        self.domain_name = domain_name
        # The peak bandwidth of the domain name.
        self.max_bps = max_bps
        # The time when the bandwidth reached the peak value.
        self.max_bps_time = max_bps_time
        # The ranking of the domain name.
        self.rank = rank
        # The number of visits to the domain name.
        self.total_access = total_access
        # The total traffic.
        self.total_traffic = total_traffic
        # The traffic share of the domain name relative to the total traffic.
        self.traffic_percent = traffic_percent

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.max_bps is not None:
            result['MaxBps'] = self.max_bps
        if self.max_bps_time is not None:
            result['MaxBpsTime'] = self.max_bps_time
        if self.rank is not None:
            result['Rank'] = self.rank
        if self.total_access is not None:
            result['TotalAccess'] = self.total_access
        if self.total_traffic is not None:
            result['TotalTraffic'] = self.total_traffic
        if self.traffic_percent is not None:
            result['TrafficPercent'] = self.traffic_percent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('MaxBps') is not None:
            self.max_bps = m.get('MaxBps')
        if m.get('MaxBpsTime') is not None:
            self.max_bps_time = m.get('MaxBpsTime')
        if m.get('Rank') is not None:
            self.rank = m.get('Rank')
        if m.get('TotalAccess') is not None:
            self.total_access = m.get('TotalAccess')
        if m.get('TotalTraffic') is not None:
            self.total_traffic = m.get('TotalTraffic')
        if m.get('TrafficPercent') is not None:
            self.traffic_percent = m.get('TrafficPercent')
        return self


class DescribeLiveTopDomainsByFlowResponseBodyTopDomains(TeaModel):
    def __init__(
        self,
        top_domain: List[DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain] = None,
    ):
        self.top_domain = top_domain

    def validate(self):
        if self.top_domain:
            for k in self.top_domain:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TopDomain'] = []
        if self.top_domain is not None:
            for k in self.top_domain:
                result['TopDomain'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.top_domain = []
        if m.get('TopDomain') is not None:
            for k in m.get('TopDomain'):
                temp_model = DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain()
                self.top_domain.append(temp_model.from_map(k))
        return self


class DescribeLiveTopDomainsByFlowResponseBody(TeaModel):
    def __init__(
        self,
        domain_count: int = None,
        domain_online_count: int = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
        top_domains: DescribeLiveTopDomainsByFlowResponseBodyTopDomains = None,
    ):
        # The total number of domain names in your account.
        self.domain_count = domain_count
        # The total number of domain names that are in the Enabled state in your account.
        self.domain_online_count = domain_online_count
        # The end of the time range for which data was queried.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The beginning of the time range for which data was queried.
        self.start_time = start_time
        # The top domain names ranked by traffic.
        self.top_domains = top_domains

    def validate(self):
        if self.top_domains:
            self.top_domains.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_count is not None:
            result['DomainCount'] = self.domain_count
        if self.domain_online_count is not None:
            result['DomainOnlineCount'] = self.domain_online_count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.top_domains is not None:
            result['TopDomains'] = self.top_domains.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainCount') is not None:
            self.domain_count = m.get('DomainCount')
        if m.get('DomainOnlineCount') is not None:
            self.domain_online_count = m.get('DomainOnlineCount')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TopDomains') is not None:
            temp_model = DescribeLiveTopDomainsByFlowResponseBodyTopDomains()
            self.top_domains = temp_model.from_map(m['TopDomains'])
        return self


class DescribeLiveTopDomainsByFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveTopDomainsByFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveTopDomainsByFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveTrafficDomainLogRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        self.end_time = end_time
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        self.end_time = end_time
        self.log_name = log_name
        self.log_path = log_path
        self.log_size = log_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.page_index = page_index
        self.page_size = page_size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        self.log_count = log_count
        self.log_infos = log_infos
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveTrafficDomainLogResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        self.domain_log_details = domain_log_details
        self.domain_name = domain_name
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveTrafficDomainLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveTrafficDomainLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveTrafficDomainLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUpVideoAudioInfoRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream: str = None,
    ):
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the stream that you want to query. Specify this parameter in the following format: `rtmp://Ingest domain/Application name/Stream name`.
        self.start_time = start_time
        # The operation that you want to perform. Set the value to **DescribeLiveUpVideoAudioInfo**.
        # 
        # This parameter is required.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The number of AAC headers in the audio.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders(TeaModel):
    def __init__(
        self,
        aac_headers: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders] = None,
    ):
        self.aac_headers = aac_headers

    def validate(self):
        if self.aac_headers:
            for k in self.aac_headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AacHeaders'] = []
        if self.aac_headers is not None:
            for k in self.aac_headers:
                result['AacHeaders'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aac_headers = []
        if m.get('AacHeaders') is not None:
            for k in m.get('AacHeaders'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders()
                self.aac_headers.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The bitrate of the audio. Unit: bit/s.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate(TeaModel):
    def __init__(
        self,
        audio_bit_rate: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate] = None,
    ):
        self.audio_bit_rate = audio_bit_rate

    def validate(self):
        if self.audio_bit_rate:
            for k in self.audio_bit_rate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioBitRate'] = []
        if self.audio_bit_rate is not None:
            for k in self.audio_bit_rate:
                result['AudioBitRate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_bit_rate = []
        if m.get('AudioBitRate') is not None:
            for k in m.get('AudioBitRate'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate()
                self.audio_bit_rate.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The frame rate of the audio. Unit: frames.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames(TeaModel):
    def __init__(
        self,
        audio_frames: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames] = None,
    ):
        self.audio_frames = audio_frames

    def validate(self):
        if self.audio_frames:
            for k in self.audio_frames:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioFrames'] = []
        if self.audio_frames is not None:
            for k in self.audio_frames:
                result['AudioFrames'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_frames = []
        if m.get('AudioFrames') is not None:
            for k in m.get('AudioFrames'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames()
                self.audio_frames.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The maximum audio frame interval. Unit: milliseconds.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval(TeaModel):
    def __init__(
        self,
        audio_interval: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval] = None,
    ):
        self.audio_interval = audio_interval

    def validate(self):
        if self.audio_interval:
            for k in self.audio_interval:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioInterval'] = []
        if self.audio_interval is not None:
            for k in self.audio_interval:
                result['AudioInterval'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_interval = []
        if m.get('AudioInterval') is not None:
            for k in m.get('AudioInterval'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval()
                self.audio_interval.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The audio timestamp. Unit: milliseconds.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps(TeaModel):
    def __init__(
        self,
        audio_stamps: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps] = None,
    ):
        self.audio_stamps = audio_stamps

    def validate(self):
        if self.audio_stamps:
            for k in self.audio_stamps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStamps'] = []
        if self.audio_stamps is not None:
            for k in self.audio_stamps:
                result['AudioStamps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_stamps = []
        if m.get('AudioStamps') is not None:
            for k in m.get('AudioStamps'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps()
                self.audio_stamps.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The number of AVC headers in the audio.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders(TeaModel):
    def __init__(
        self,
        avc_headers: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders] = None,
    ):
        self.avc_headers = avc_headers

    def validate(self):
        if self.avc_headers:
            for k in self.avc_headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvcHeaders'] = []
        if self.avc_headers is not None:
            for k in self.avc_headers:
                result['AvcHeaders'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.avc_headers = []
        if m.get('AvcHeaders') is not None:
            for k in m.get('AvcHeaders'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders()
                self.avc_headers.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The number of times the error code that indicates interrupted stream ingest was returned.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags(TeaModel):
    def __init__(
        self,
        error_flags: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags] = None,
    ):
        self.error_flags = error_flags

    def validate(self):
        if self.error_flags:
            for k in self.error_flags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ErrorFlags'] = []
        if self.error_flags is not None:
            for k in self.error_flags:
                result['ErrorFlags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.error_flags = []
        if m.get('ErrorFlags') is not None:
            for k in m.get('ErrorFlags'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags()
                self.error_flags.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The difference between the audio and video timestamps. Unit: milliseconds.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp(TeaModel):
    def __init__(
        self,
        v_astamp: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp] = None,
    ):
        self.v_astamp = v_astamp

    def validate(self):
        if self.v_astamp:
            for k in self.v_astamp:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['V_AStamp'] = []
        if self.v_astamp is not None:
            for k in self.v_astamp:
                result['V_AStamp'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.v_astamp = []
        if m.get('V_AStamp') is not None:
            for k in m.get('V_AStamp'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp()
                self.v_astamp.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The bitrate of the video. Unit: bit/s.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate(TeaModel):
    def __init__(
        self,
        video_bit_rate: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate] = None,
    ):
        self.video_bit_rate = video_bit_rate

    def validate(self):
        if self.video_bit_rate:
            for k in self.video_bit_rate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoBitRate'] = []
        if self.video_bit_rate is not None:
            for k in self.video_bit_rate:
                result['VideoBitRate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_bit_rate = []
        if m.get('VideoBitRate') is not None:
            for k in m.get('VideoBitRate'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate()
                self.video_bit_rate.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The frame rate of the video. Unit: frames.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames(TeaModel):
    def __init__(
        self,
        video_frames: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames] = None,
    ):
        self.video_frames = video_frames

    def validate(self):
        if self.video_frames:
            for k in self.video_frames:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoFrames'] = []
        if self.video_frames is not None:
            for k in self.video_frames:
                result['VideoFrames'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_frames = []
        if m.get('VideoFrames') is not None:
            for k in m.get('VideoFrames'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames()
                self.video_frames.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The maximum video frame interval. Unit: milliseconds.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval(TeaModel):
    def __init__(
        self,
        video_interval: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval] = None,
    ):
        self.video_interval = video_interval

    def validate(self):
        if self.video_interval:
            for k in self.video_interval:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoInterval'] = []
        if self.video_interval is not None:
            for k in self.video_interval:
                result['VideoInterval'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_interval = []
        if m.get('VideoInterval') is not None:
            for k in m.get('VideoInterval'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval()
                self.video_interval.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: int = None,
    ):
        # The video timestamp. Unit: milliseconds.
        self.time = time
        # The query time. The value is a UNIX timestamp in milliseconds.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps(TeaModel):
    def __init__(
        self,
        video_stamps: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps] = None,
    ):
        self.video_stamps = video_stamps

    def validate(self):
        if self.video_stamps:
            for k in self.video_stamps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoStamps'] = []
        if self.video_stamps is not None:
            for k in self.video_stamps:
                result['VideoStamps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.video_stamps = []
        if m.get('VideoStamps') is not None:
            for k in m.get('VideoStamps'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps()
                self.video_stamps.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem(TeaModel):
    def __init__(
        self,
        aac_headers: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders = None,
        app_name: str = None,
        audio_bit_rate: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate = None,
        audio_frames: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames = None,
        audio_interval: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval = None,
        audio_stamps: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps = None,
        avc_headers: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders = None,
        codec_info: str = None,
        domain_name: str = None,
        error_flags: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags = None,
        publish_interval: str = None,
        publish_ip: str = None,
        publish_status: str = None,
        publish_time: str = None,
        stop_time: str = None,
        stream_name: str = None,
        unique_id: str = None,
        video_and_audio_stamp: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp = None,
        video_bit_rate: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate = None,
        video_frames: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames = None,
        video_interval: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval = None,
        video_stamps: DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps = None,
    ):
        # The details about the audio and video data of the stream ingest occurrences.
        self.aac_headers = aac_headers
        # The metric value at a granularity of seconds at the query time.
        self.app_name = app_name
        # The name of the application to which the ingested stream belongs.
        self.audio_bit_rate = audio_bit_rate
        # The metric value at a granularity of seconds at the query time.
        self.audio_frames = audio_frames
        # The metric value at a granularity of seconds at the query time.
        self.audio_interval = audio_interval
        # The metric value at a granularity of seconds at the query time.
        self.audio_stamps = audio_stamps
        # The metric value at a granularity of seconds at the query time.
        self.avc_headers = avc_headers
        # The metric value at a granularity of seconds at the query time.
        self.codec_info = codec_info
        # The audio and video encoding information.
        self.domain_name = domain_name
        # The ingest domain.
        self.error_flags = error_flags
        # The metric value at a granularity of seconds at the query time.
        self.publish_interval = publish_interval
        # The stream ingest duration. Unit: seconds. A hyphen (-) indicates that the stream is being ingested and the duration cannot be returned.
        self.publish_ip = publish_ip
        # The IP address of the stream ingest client.
        self.publish_status = publish_status
        # The stream ingest status. A value of 1 indicates that the stream is being ingested. A value of 0 indicates that the stream was ingested.
        self.publish_time = publish_time
        # The start time of stream ingest. The time is displayed in UTC.
        self.stop_time = stop_time
        # The end time of stream ingest. The time is displayed in UTC.
        self.stream_name = stream_name
        # The name of the stream.
        self.unique_id = unique_id
        # The unique ID of each stream ingest occurrence.
        self.video_and_audio_stamp = video_and_audio_stamp
        # The metric value at a granularity of seconds at the query time.
        self.video_bit_rate = video_bit_rate
        # The metric value at a granularity of seconds at the query time.
        self.video_frames = video_frames
        # The metric value at a granularity of seconds at the query time.
        self.video_interval = video_interval
        # The metric value at a granularity of seconds at the query time.
        self.video_stamps = video_stamps

    def validate(self):
        if self.aac_headers:
            self.aac_headers.validate()
        if self.audio_bit_rate:
            self.audio_bit_rate.validate()
        if self.audio_frames:
            self.audio_frames.validate()
        if self.audio_interval:
            self.audio_interval.validate()
        if self.audio_stamps:
            self.audio_stamps.validate()
        if self.avc_headers:
            self.avc_headers.validate()
        if self.error_flags:
            self.error_flags.validate()
        if self.video_and_audio_stamp:
            self.video_and_audio_stamp.validate()
        if self.video_bit_rate:
            self.video_bit_rate.validate()
        if self.video_frames:
            self.video_frames.validate()
        if self.video_interval:
            self.video_interval.validate()
        if self.video_stamps:
            self.video_stamps.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aac_headers is not None:
            result['AacHeaders'] = self.aac_headers.to_map()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.audio_bit_rate is not None:
            result['AudioBitRate'] = self.audio_bit_rate.to_map()
        if self.audio_frames is not None:
            result['AudioFrames'] = self.audio_frames.to_map()
        if self.audio_interval is not None:
            result['AudioInterval'] = self.audio_interval.to_map()
        if self.audio_stamps is not None:
            result['AudioStamps'] = self.audio_stamps.to_map()
        if self.avc_headers is not None:
            result['AvcHeaders'] = self.avc_headers.to_map()
        if self.codec_info is not None:
            result['CodecInfo'] = self.codec_info
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.error_flags is not None:
            result['ErrorFlags'] = self.error_flags.to_map()
        if self.publish_interval is not None:
            result['PublishInterval'] = self.publish_interval
        if self.publish_ip is not None:
            result['PublishIp'] = self.publish_ip
        if self.publish_status is not None:
            result['PublishStatus'] = self.publish_status
        if self.publish_time is not None:
            result['PublishTime'] = self.publish_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.unique_id is not None:
            result['UniqueId'] = self.unique_id
        if self.video_and_audio_stamp is not None:
            result['VideoAndAudioStamp'] = self.video_and_audio_stamp.to_map()
        if self.video_bit_rate is not None:
            result['VideoBitRate'] = self.video_bit_rate.to_map()
        if self.video_frames is not None:
            result['VideoFrames'] = self.video_frames.to_map()
        if self.video_interval is not None:
            result['VideoInterval'] = self.video_interval.to_map()
        if self.video_stamps is not None:
            result['VideoStamps'] = self.video_stamps.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AacHeaders') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders()
            self.aac_headers = temp_model.from_map(m['AacHeaders'])
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AudioBitRate') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate()
            self.audio_bit_rate = temp_model.from_map(m['AudioBitRate'])
        if m.get('AudioFrames') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames()
            self.audio_frames = temp_model.from_map(m['AudioFrames'])
        if m.get('AudioInterval') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval()
            self.audio_interval = temp_model.from_map(m['AudioInterval'])
        if m.get('AudioStamps') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps()
            self.audio_stamps = temp_model.from_map(m['AudioStamps'])
        if m.get('AvcHeaders') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders()
            self.avc_headers = temp_model.from_map(m['AvcHeaders'])
        if m.get('CodecInfo') is not None:
            self.codec_info = m.get('CodecInfo')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ErrorFlags') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags()
            self.error_flags = temp_model.from_map(m['ErrorFlags'])
        if m.get('PublishInterval') is not None:
            self.publish_interval = m.get('PublishInterval')
        if m.get('PublishIp') is not None:
            self.publish_ip = m.get('PublishIp')
        if m.get('PublishStatus') is not None:
            self.publish_status = m.get('PublishStatus')
        if m.get('PublishTime') is not None:
            self.publish_time = m.get('PublishTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('UniqueId') is not None:
            self.unique_id = m.get('UniqueId')
        if m.get('VideoAndAudioStamp') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp()
            self.video_and_audio_stamp = temp_model.from_map(m['VideoAndAudioStamp'])
        if m.get('VideoBitRate') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate()
            self.video_bit_rate = temp_model.from_map(m['VideoBitRate'])
        if m.get('VideoFrames') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames()
            self.video_frames = temp_model.from_map(m['VideoFrames'])
        if m.get('VideoInterval') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval()
            self.video_interval = temp_model.from_map(m['VideoInterval'])
        if m.get('VideoStamps') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps()
            self.video_stamps = temp_model.from_map(m['VideoStamps'])
        return self


class DescribeLiveUpVideoAudioInfoResponseBodyUpItems(TeaModel):
    def __init__(
        self,
        publish_item: List[DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem] = None,
    ):
        self.publish_item = publish_item

    def validate(self):
        if self.publish_item:
            for k in self.publish_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PublishItem'] = []
        if self.publish_item is not None:
            for k in self.publish_item:
                result['PublishItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.publish_item = []
        if m.get('PublishItem') is not None:
            for k in m.get('PublishItem'):
                temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem()
                self.publish_item.append(temp_model.from_map(k))
        return self


class DescribeLiveUpVideoAudioInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        up_items: DescribeLiveUpVideoAudioInfoResponseBodyUpItems = None,
    ):
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.request_id = request_id
        # The request ID.
        self.up_items = up_items

    def validate(self):
        if self.up_items:
            self.up_items.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.up_items is not None:
            result['UpItems'] = self.up_items.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UpItems') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBodyUpItems()
            self.up_items = temp_model.from_map(m['UpItems'])
        return self


class DescribeLiveUpVideoAudioInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUpVideoAudioInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUpVideoAudioInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUserBillPredictionRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd**THH:mm:ssZ* format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem(TeaModel):
    def __init__(
        self,
        area: str = None,
        time_stp: str = None,
        value: float = None,
    ):
        # The billable region. Valid values:
        # 
        # *   CN: Chinese mainland
        # *   OverSeas: countries and regions outside the Chinese mainland
        # *   AP1: Asia Pacific 1, including Hong Kong (China), Macao (China), Taiwan (China), Japan, and other Southeast Asia countries and regions except Vietnam and Indonesia
        # *   AP2: Asia Pacific 2, including Indonesia, South Korea, and Vietnam
        # *   AP3: Asia Pacific 3, including Australia and New Zealand
        # *   NA: North America, including US and Canada
        # *   SA: South America, specifically meaning Brazil
        # *   EU: Europe, including Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany
        # *   MEAA: Middle East and Africa, including South Africa, Oman, UAE, and Kuwait
        # 
        # By default, data of all regions is aggregated and returned.
        self.area = area
        # The time at which the estimated value occurs. This parameter is returned only if the metering method is pay by 95th percentile bandwidth, pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00, or pay by 4th peak bandwidth per month.
        self.time_stp = time_stp
        # The estimated value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.time_stp is not None:
            result['TimeStp'] = self.time_stp
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('TimeStp') is not None:
            self.time_stp = m.get('TimeStp')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUserBillPredictionResponseBodyBillPredictionData(TeaModel):
    def __init__(
        self,
        bill_prediction_data_item: List[DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem] = None,
    ):
        self.bill_prediction_data_item = bill_prediction_data_item

    def validate(self):
        if self.bill_prediction_data_item:
            for k in self.bill_prediction_data_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BillPredictionDataItem'] = []
        if self.bill_prediction_data_item is not None:
            for k in self.bill_prediction_data_item:
                result['BillPredictionDataItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.bill_prediction_data_item = []
        if m.get('BillPredictionDataItem') is not None:
            for k in m.get('BillPredictionDataItem'):
                temp_model = DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem()
                self.bill_prediction_data_item.append(temp_model.from_map(k))
        return self


class DescribeLiveUserBillPredictionResponseBody(TeaModel):
    def __init__(
        self,
        bill_prediction_data: DescribeLiveUserBillPredictionResponseBodyBillPredictionData = None,
        bill_type: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The estimated bill data.
        self.bill_prediction_data = bill_prediction_data
        # The metering method. Valid values:
        # 
        # *   hour_flow: pay by hourly data transfer
        # *   day_bandwidth: pay by daily bandwidth
        # *   month_95: pay by monthly 95th percentile bandwidth
        # *   month_avg_day_bandwidth: pay by average daily peak bandwidth per month
        # *   month_4th_day_bandwidth: pay by 4th peak bandwidth per month
        # *   month_avg_day_95: pay by average daily 95th percentile bandwidth per month
        # *   month_95_night_half: pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00
        # *   hour_vas: pay by value-added services per hour
        # *   day_count: pay by daily requests
        self.bill_type = bill_type
        # The end time. If you do not specify the request parameter EndTime, the end time is the current time by default. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time
        # The request ID.
        self.request_id = request_id
        # The start time. If you do not specify the request parameter StartTime, the start time is 00:00 on the first day of the month by default. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time

    def validate(self):
        if self.bill_prediction_data:
            self.bill_prediction_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bill_prediction_data is not None:
            result['BillPredictionData'] = self.bill_prediction_data.to_map()
        if self.bill_type is not None:
            result['BillType'] = self.bill_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BillPredictionData') is not None:
            temp_model = DescribeLiveUserBillPredictionResponseBodyBillPredictionData()
            self.bill_prediction_data = temp_model.from_map(m['BillPredictionData'])
        if m.get('BillType') is not None:
            self.bill_type = m.get('BillType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveUserBillPredictionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUserBillPredictionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUserBillPredictionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUserDomainsRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUserDomainsRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_search_type: str = None,
        domain_status: str = None,
        live_domain_type: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_name: str = None,
        resource_group_id: str = None,
        security_token: str = None,
        tag: List[DescribeLiveUserDomainsRequestTag] = None,
    ):
        # The domain name that is used as a keyword to filter domain names. Fuzzy match is supported.
        # 
        # > 
        # 
        # *   If you set LiveDomainType to liveVideo and leave this parameter empty, the streaming domains are queried. - If you set LiveDomainType to liveEdge and leave this parameter empty, the ingest domains are queried.
        self.domain_name = domain_name
        # The search mode. Valid values:
        # 
        # *   **fuzzy_match** (default): fuzzy match
        # *   **pre_match**: prefix match
        # *   **suf_match**: suffix match
        # *   **full_match**: exact match
        self.domain_search_type = domain_search_type
        # The status of the domain name. Valid values:
        # 
        # *   **online**\
        # *   **offline**\
        # *   **configuring**\
        self.domain_status = domain_status
        # The type of the domain name. Valid values:
        # 
        # *   **liveVideo**: streaming domain
        # *   **liveEdge**: ingest domain
        # 
        # >  If you leave this parameter empty, all ingest domains and streaming domains within your Alibaba Cloud account are queried by default.
        self.live_domain_type = live_domain_type
        self.owner_id = owner_id
        # The page number. Valid values: **1 to 100000**.
        self.page_number = page_number
        # The number of entries per page. Default value: **20**. Maximum value: **50**.
        self.page_size = page_size
        # The ID of the region in which the domain name resides.
        self.region_name = region_name
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        self.security_token = security_token
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_search_type is not None:
            result['DomainSearchType'] = self.domain_search_type
        if self.domain_status is not None:
            result['DomainStatus'] = self.domain_status
        if self.live_domain_type is not None:
            result['LiveDomainType'] = self.live_domain_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainSearchType') is not None:
            self.domain_search_type = m.get('DomainSearchType')
        if m.get('DomainStatus') is not None:
            self.domain_status = m.get('DomainStatus')
        if m.get('LiveDomainType') is not None:
            self.live_domain_type = m.get('LiveDomainType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeLiveUserDomainsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeLiveUserDomainsResponseBodyDomainsPageData(TeaModel):
    def __init__(
        self,
        cname: str = None,
        description: str = None,
        domain_name: str = None,
        gmt_created: str = None,
        gmt_modified: str = None,
        live_domain_status: str = None,
        live_domain_type: str = None,
        region_name: str = None,
        resource_group_id: str = None,
    ):
        # The CNAME generated for the domain name.
        self.cname = cname
        # The description.
        self.description = description
        # The domain name.
        self.domain_name = domain_name
        # The time when the domain name was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_created = gmt_created
        # The time when the domain name was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_modified = gmt_modified
        # The status of the domain name. Valid values:
        # 
        # *   **online**\
        # *   **offline**\
        # *   **configuring**\
        self.live_domain_status = live_domain_status
        # The type of the domain name. Valid values:
        # 
        # *   **liveVideo**: streaming domain
        # *   **liveEdge**: ingest domain
        self.live_domain_type = live_domain_type
        # The ID of the region in which the domain name resides.
        self.region_name = region_name
        # The ID of the resource group.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cname is not None:
            result['Cname'] = self.cname
        if self.description is not None:
            result['Description'] = self.description
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_created is not None:
            result['GmtCreated'] = self.gmt_created
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.live_domain_status is not None:
            result['LiveDomainStatus'] = self.live_domain_status
        if self.live_domain_type is not None:
            result['LiveDomainType'] = self.live_domain_type
        if self.region_name is not None:
            result['RegionName'] = self.region_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cname') is not None:
            self.cname = m.get('Cname')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreated') is not None:
            self.gmt_created = m.get('GmtCreated')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('LiveDomainStatus') is not None:
            self.live_domain_status = m.get('LiveDomainStatus')
        if m.get('LiveDomainType') is not None:
            self.live_domain_type = m.get('LiveDomainType')
        if m.get('RegionName') is not None:
            self.region_name = m.get('RegionName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class DescribeLiveUserDomainsResponseBodyDomains(TeaModel):
    def __init__(
        self,
        page_data: List[DescribeLiveUserDomainsResponseBodyDomainsPageData] = None,
    ):
        self.page_data = page_data

    def validate(self):
        if self.page_data:
            for k in self.page_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PageData'] = []
        if self.page_data is not None:
            for k in self.page_data:
                result['PageData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.page_data = []
        if m.get('PageData') is not None:
            for k in m.get('PageData'):
                temp_model = DescribeLiveUserDomainsResponseBodyDomainsPageData()
                self.page_data.append(temp_model.from_map(k))
        return self


class DescribeLiveUserDomainsResponseBody(TeaModel):
    def __init__(
        self,
        domains: DescribeLiveUserDomainsResponseBodyDomains = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The domain names.
        self.domains = domains
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries.
        self.total_count = total_count

    def validate(self):
        if self.domains:
            self.domains.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domains is not None:
            result['Domains'] = self.domains.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domains') is not None:
            temp_model = DescribeLiveUserDomainsResponseBodyDomains()
            self.domains = temp_model.from_map(m['Domains'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLiveUserDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUserDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUserDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUserStreamMetricDataRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        page_number: int = None,
        page_size: int = None,
        protocol: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        self.app_name = app_name
        self.domain_name = domain_name
        # This parameter is required.
        self.end_time = end_time
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.protocol = protocol
        # This parameter is required.
        self.start_time = start_time
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        bps: float = None,
        count: int = None,
        flv_bps: float = None,
        flv_count: int = None,
        flv_traffic: float = None,
        hls_bps: float = None,
        hls_count: int = None,
        hls_traffic: float = None,
        new_conns: int = None,
        p_2p_bps: float = None,
        p_2p_count: int = None,
        p_2p_traffic: float = None,
        rtmp_bps: float = None,
        rtmp_count: int = None,
        rtmp_traffic: float = None,
        rts_bps: float = None,
        rts_count: int = None,
        rts_traffic: float = None,
        stream_name: str = None,
        time_stamp: str = None,
        traffic: float = None,
    ):
        self.app_name = app_name
        self.bps = bps
        self.count = count
        self.flv_bps = flv_bps
        self.flv_count = flv_count
        self.flv_traffic = flv_traffic
        self.hls_bps = hls_bps
        self.hls_count = hls_count
        self.hls_traffic = hls_traffic
        self.new_conns = new_conns
        self.p_2p_bps = p_2p_bps
        self.p_2p_count = p_2p_count
        self.p_2p_traffic = p_2p_traffic
        self.rtmp_bps = rtmp_bps
        self.rtmp_count = rtmp_count
        self.rtmp_traffic = rtmp_traffic
        self.rts_bps = rts_bps
        self.rts_count = rts_count
        self.rts_traffic = rts_traffic
        self.stream_name = stream_name
        self.time_stamp = time_stamp
        self.traffic = traffic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.bps is not None:
            result['Bps'] = self.bps
        if self.count is not None:
            result['Count'] = self.count
        if self.flv_bps is not None:
            result['FlvBps'] = self.flv_bps
        if self.flv_count is not None:
            result['FlvCount'] = self.flv_count
        if self.flv_traffic is not None:
            result['FlvTraffic'] = self.flv_traffic
        if self.hls_bps is not None:
            result['HlsBps'] = self.hls_bps
        if self.hls_count is not None:
            result['HlsCount'] = self.hls_count
        if self.hls_traffic is not None:
            result['HlsTraffic'] = self.hls_traffic
        if self.new_conns is not None:
            result['NewConns'] = self.new_conns
        if self.p_2p_bps is not None:
            result['P2pBps'] = self.p_2p_bps
        if self.p_2p_count is not None:
            result['P2pCount'] = self.p_2p_count
        if self.p_2p_traffic is not None:
            result['P2pTraffic'] = self.p_2p_traffic
        if self.rtmp_bps is not None:
            result['RtmpBps'] = self.rtmp_bps
        if self.rtmp_count is not None:
            result['RtmpCount'] = self.rtmp_count
        if self.rtmp_traffic is not None:
            result['RtmpTraffic'] = self.rtmp_traffic
        if self.rts_bps is not None:
            result['RtsBps'] = self.rts_bps
        if self.rts_count is not None:
            result['RtsCount'] = self.rts_count
        if self.rts_traffic is not None:
            result['RtsTraffic'] = self.rts_traffic
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.traffic is not None:
            result['Traffic'] = self.traffic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Bps') is not None:
            self.bps = m.get('Bps')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FlvBps') is not None:
            self.flv_bps = m.get('FlvBps')
        if m.get('FlvCount') is not None:
            self.flv_count = m.get('FlvCount')
        if m.get('FlvTraffic') is not None:
            self.flv_traffic = m.get('FlvTraffic')
        if m.get('HlsBps') is not None:
            self.hls_bps = m.get('HlsBps')
        if m.get('HlsCount') is not None:
            self.hls_count = m.get('HlsCount')
        if m.get('HlsTraffic') is not None:
            self.hls_traffic = m.get('HlsTraffic')
        if m.get('NewConns') is not None:
            self.new_conns = m.get('NewConns')
        if m.get('P2pBps') is not None:
            self.p_2p_bps = m.get('P2pBps')
        if m.get('P2pCount') is not None:
            self.p_2p_count = m.get('P2pCount')
        if m.get('P2pTraffic') is not None:
            self.p_2p_traffic = m.get('P2pTraffic')
        if m.get('RtmpBps') is not None:
            self.rtmp_bps = m.get('RtmpBps')
        if m.get('RtmpCount') is not None:
            self.rtmp_count = m.get('RtmpCount')
        if m.get('RtmpTraffic') is not None:
            self.rtmp_traffic = m.get('RtmpTraffic')
        if m.get('RtsBps') is not None:
            self.rts_bps = m.get('RtsBps')
        if m.get('RtsCount') is not None:
            self.rts_count = m.get('RtsCount')
        if m.get('RtsTraffic') is not None:
            self.rts_traffic = m.get('RtsTraffic')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('Traffic') is not None:
            self.traffic = m.get('Traffic')
        return self


class DescribeLiveUserStreamMetricDataResponseBody(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        start_time: str = None,
        stream_detail_data: List[DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData] = None,
        total_count: int = None,
    ):
        self.domain_name = domain_name
        # YYYY-MM-DDThh:mm:ssZ
        self.end_time = end_time
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.start_time = start_time
        self.stream_detail_data = stream_detail_data
        self.total_count = total_count

    def validate(self):
        if self.stream_detail_data:
            for k in self.stream_detail_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['StreamDetailData'] = []
        if self.stream_detail_data is not None:
            for k in self.stream_detail_data:
                result['StreamDetailData'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.stream_detail_data = []
        if m.get('StreamDetailData') is not None:
            for k in m.get('StreamDetailData'):
                temp_model = DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData()
                self.stream_detail_data.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLiveUserStreamMetricDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUserStreamMetricDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUserStreamMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUserTagsRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveUserTagsResponseBodyTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: List[str] = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLiveUserTagsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        tags: List[DescribeLiveUserTagsResponseBodyTags] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeLiveUserTagsResponseBodyTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeLiveUserTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUserTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUserTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveUserTrafficLogRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        self.end_time = end_time
        self.owner_id = owner_id
        self.page_number = page_number
        self.page_size = page_size
        self.region_id = region_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        log_name: str = None,
        log_path: str = None,
        log_size: int = None,
        start_time: str = None,
    ):
        self.end_time = end_time
        self.log_name = log_name
        self.log_path = log_path
        self.log_size = log_size
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.log_name is not None:
            result['LogName'] = self.log_name
        if self.log_path is not None:
            result['LogPath'] = self.log_path
        if self.log_size is not None:
            result['LogSize'] = self.log_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('LogName') is not None:
            self.log_name = m.get('LogName')
        if m.get('LogPath') is not None:
            self.log_path = m.get('LogPath')
        if m.get('LogSize') is not None:
            self.log_size = m.get('LogSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(TeaModel):
    def __init__(
        self,
        log_info_detail: List[DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail] = None,
    ):
        self.log_info_detail = log_info_detail

    def validate(self):
        if self.log_info_detail:
            for k in self.log_info_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfoDetail'] = []
        if self.log_info_detail is not None:
            for k in self.log_info_detail:
                result['LogInfoDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info_detail = []
        if m.get('LogInfoDetail') is not None:
            for k in m.get('LogInfoDetail'):
                temp_model = DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail()
                self.log_info_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.page_index = page_index
        self.page_size = page_size
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail(TeaModel):
    def __init__(
        self,
        log_count: int = None,
        log_infos: DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos = None,
        page_infos: DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos = None,
    ):
        self.log_count = log_count
        self.log_infos = log_infos
        self.page_infos = page_infos

    def validate(self):
        if self.log_infos:
            self.log_infos.validate()
        if self.page_infos:
            self.page_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_count is not None:
            result['LogCount'] = self.log_count
        if self.log_infos is not None:
            result['LogInfos'] = self.log_infos.to_map()
        if self.page_infos is not None:
            result['PageInfos'] = self.page_infos.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogCount') is not None:
            self.log_count = m.get('LogCount')
        if m.get('LogInfos') is not None:
            temp_model = DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos()
            self.log_infos = temp_model.from_map(m['LogInfos'])
        if m.get('PageInfos') is not None:
            temp_model = DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos()
            self.page_infos = temp_model.from_map(m['PageInfos'])
        return self


class DescribeLiveUserTrafficLogResponseBodyDomainLogDetails(TeaModel):
    def __init__(
        self,
        domain_log_detail: List[DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail] = None,
    ):
        self.domain_log_detail = domain_log_detail

    def validate(self):
        if self.domain_log_detail:
            for k in self.domain_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainLogDetail'] = []
        if self.domain_log_detail is not None:
            for k in self.domain_log_detail:
                result['DomainLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_log_detail = []
        if m.get('DomainLogDetail') is not None:
            for k in m.get('DomainLogDetail'):
                temp_model = DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail()
                self.domain_log_detail.append(temp_model.from_map(k))
        return self


class DescribeLiveUserTrafficLogResponseBody(TeaModel):
    def __init__(
        self,
        domain_log_details: DescribeLiveUserTrafficLogResponseBodyDomainLogDetails = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        self.domain_log_details = domain_log_details
        self.domain_name = domain_name
        self.request_id = request_id

    def validate(self):
        if self.domain_log_details:
            self.domain_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_log_details is not None:
            result['DomainLogDetails'] = self.domain_log_details.to_map()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainLogDetails') is not None:
            temp_model = DescribeLiveUserTrafficLogResponseBodyDomainLogDetails()
            self.domain_log_details = temp_model.from_map(m['DomainLogDetails'])
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveUserTrafficLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveUserTrafficLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveUserTrafficLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveVerifyContentRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The domain name. You can specify only one domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLiveVerifyContentResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        request_id: str = None,
    ):
        # The verification content.
        self.content = content
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveVerifyContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLiveVerifyContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveVerifyContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterLiveBypassDurationRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: str = None,
        interval: str = None,
        start_time: str = None,
    ):
        # The ID of the application. You can view the application ID on the [Applications](https://help.aliyun.com/document_detail/2355593.html) page in the ApsaraVideo Real-time Communication (ARTC) section of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The time range that can be specified is greater than or equal to 5 minutes and less than or equal to 31 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The time granularity of the query. Unit: seconds. Valid values:
        # 
        # *   300
        # *   3600
        # *   86400
        # 
        # If you specify an invalid value or do not specify this parameter, the default value 3600 is used.
        self.interval = interval
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMeterLiveBypassDurationResponseBodyData(TeaModel):
    def __init__(
        self,
        audio_duration: int = None,
        single_audio: int = None,
        single_video: int = None,
        timestamp: str = None,
        total_duration: int = None,
        v_1080duration: int = None,
        v_480duration: int = None,
        v_720duration: int = None,
    ):
        # The audio-only duration. Audio-only is a basic specification. Unit: minutes.
        self.audio_duration = audio_duration
        # The single-stream relay duration for audio. Unit: minutes.
        self.single_audio = single_audio
        # The single-stream relay duration for video. Unit: minutes.
        self.single_video = single_video
        # The timestamp of the data returned.
        self.timestamp = timestamp
        # The duration. Unit: minutes.
        self.total_duration = total_duration
        # The Full HD duration. The video resolution is 1920  1080 or lower. Unit: minutes.
        self.v_1080duration = v_1080duration
        # The SD duration. The video resolution is 640  480 or lower. Unit: minutes.
        self.v_480duration = v_480duration
        # The HD duration. The video resolution is 1280  720 or lower. Unit: minutes.
        self.v_720duration = v_720duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_duration is not None:
            result['AudioDuration'] = self.audio_duration
        if self.single_audio is not None:
            result['Single_Audio'] = self.single_audio
        if self.single_video is not None:
            result['Single_Video'] = self.single_video
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_duration is not None:
            result['TotalDuration'] = self.total_duration
        if self.v_1080duration is not None:
            result['V1080Duration'] = self.v_1080duration
        if self.v_480duration is not None:
            result['V480Duration'] = self.v_480duration
        if self.v_720duration is not None:
            result['V720Duration'] = self.v_720duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDuration') is not None:
            self.audio_duration = m.get('AudioDuration')
        if m.get('Single_Audio') is not None:
            self.single_audio = m.get('Single_Audio')
        if m.get('Single_Video') is not None:
            self.single_video = m.get('Single_Video')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalDuration') is not None:
            self.total_duration = m.get('TotalDuration')
        if m.get('V1080Duration') is not None:
            self.v_1080duration = m.get('V1080Duration')
        if m.get('V480Duration') is not None:
            self.v_480duration = m.get('V480Duration')
        if m.get('V720Duration') is not None:
            self.v_720duration = m.get('V720Duration')
        return self


class DescribeMeterLiveBypassDurationResponseBody(TeaModel):
    def __init__(
        self,
        audio_summary_duration: int = None,
        data: List[DescribeMeterLiveBypassDurationResponseBodyData] = None,
        request_id: str = None,
        single_audio_summary_duration: int = None,
        single_video_summary_duration: int = None,
        total_summary_duration: int = None,
        v_1080summary_duration: int = None,
        v_480summary_duration: int = None,
        v_720summary_duration: int = None,
    ):
        # The total audio-only duration. Audio-only is a basic specification. Unit: minutes.
        self.audio_summary_duration = audio_summary_duration
        # The usage statistics for each time granularity.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # The total single-stream relay duration for audio. Unit: minutes.
        self.single_audio_summary_duration = single_audio_summary_duration
        # The total single-stream relay duration for video. Unit: minutes.
        self.single_video_summary_duration = single_video_summary_duration
        # The total duration. Unit: minutes.
        self.total_summary_duration = total_summary_duration
        # The total Full HD duration. The video resolution is 1920  1080 or lower. Unit: minutes.
        self.v_1080summary_duration = v_1080summary_duration
        # The total standard definition (SD) duration. The video resolution is 640  480 or lower. Unit: minutes.
        self.v_480summary_duration = v_480summary_duration
        # The total high definition (HD) duration. The video resolution is 1280  720 or lower. Unit: minutes.
        self.v_720summary_duration = v_720summary_duration

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_summary_duration is not None:
            result['AudioSummaryDuration'] = self.audio_summary_duration
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.single_audio_summary_duration is not None:
            result['SingleAudioSummaryDuration'] = self.single_audio_summary_duration
        if self.single_video_summary_duration is not None:
            result['SingleVideoSummaryDuration'] = self.single_video_summary_duration
        if self.total_summary_duration is not None:
            result['TotalSummaryDuration'] = self.total_summary_duration
        if self.v_1080summary_duration is not None:
            result['V1080SummaryDuration'] = self.v_1080summary_duration
        if self.v_480summary_duration is not None:
            result['V480SummaryDuration'] = self.v_480summary_duration
        if self.v_720summary_duration is not None:
            result['V720SummaryDuration'] = self.v_720summary_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioSummaryDuration') is not None:
            self.audio_summary_duration = m.get('AudioSummaryDuration')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterLiveBypassDurationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SingleAudioSummaryDuration') is not None:
            self.single_audio_summary_duration = m.get('SingleAudioSummaryDuration')
        if m.get('SingleVideoSummaryDuration') is not None:
            self.single_video_summary_duration = m.get('SingleVideoSummaryDuration')
        if m.get('TotalSummaryDuration') is not None:
            self.total_summary_duration = m.get('TotalSummaryDuration')
        if m.get('V1080SummaryDuration') is not None:
            self.v_1080summary_duration = m.get('V1080SummaryDuration')
        if m.get('V480SummaryDuration') is not None:
            self.v_480summary_duration = m.get('V480SummaryDuration')
        if m.get('V720SummaryDuration') is not None:
            self.v_720summary_duration = m.get('V720SummaryDuration')
        return self


class DescribeMeterLiveBypassDurationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMeterLiveBypassDurationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterLiveBypassDurationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMixStreamListRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        mix_stream_id: str = None,
        owner_id: int = None,
        page_no: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.
        self.mix_stream_id = mix_stream_id
        self.owner_id = owner_id
        # The number of the page to return. Valid values: an integer that is greater than **0** and does not exceed the maximum value of the INTEGER data type. Default value: **1**.
        self.page_no = page_no
        # The number of entries to return on each page. Default value: **1000**.
        self.page_size = page_size
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The name of the output stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeMixStreamListResponseBodyMixStreamList(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        input_stream_number: int = None,
        layout_id: str = None,
        mix_stream_template: str = None,
        mixstream_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The time when the stream mixing task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_create = gmt_create
        # The time when the stream mixing task was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
        self.gmt_modified = gmt_modified
        # The number of input streams.
        self.input_stream_number = input_stream_number
        # The ID of the layout.
        self.layout_id = layout_id
        # The stream mixing template.
        self.mix_stream_template = mix_stream_template
        # The ID of the stream mixing task. You can specify this parameter in a request to delete the steam mixing task.
        self.mixstream_id = mixstream_id
        # The name of the output stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.input_stream_number is not None:
            result['InputStreamNumber'] = self.input_stream_number
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.mix_stream_template is not None:
            result['MixStreamTemplate'] = self.mix_stream_template
        if self.mixstream_id is not None:
            result['MixstreamId'] = self.mixstream_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('InputStreamNumber') is not None:
            self.input_stream_number = m.get('InputStreamNumber')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('MixStreamTemplate') is not None:
            self.mix_stream_template = m.get('MixStreamTemplate')
        if m.get('MixstreamId') is not None:
            self.mixstream_id = m.get('MixstreamId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeMixStreamListResponseBody(TeaModel):
    def __init__(
        self,
        mix_stream_list: List[DescribeMixStreamListResponseBodyMixStreamList] = None,
        request_id: str = None,
        total: int = None,
    ):
        # Details about the stream mixing tasks.
        self.mix_stream_list = mix_stream_list
        # The ID of the request.
        self.request_id = request_id
        # The total number of tasks.
        self.total = total

    def validate(self):
        if self.mix_stream_list:
            for k in self.mix_stream_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MixStreamList'] = []
        if self.mix_stream_list is not None:
            for k in self.mix_stream_list:
                result['MixStreamList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mix_stream_list = []
        if m.get('MixStreamList') is not None:
            for k in m.get('MixStreamList'):
                temp_model = DescribeMixStreamListResponseBodyMixStreamList()
                self.mix_stream_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMixStreamListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMixStreamListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMixStreamListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRTSNativeSDKFirstFrameCostRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list: List[str] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list = domain_name_list
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list is not None:
            result['DomainNameList'] = self.domain_name_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameCostShrinkRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list_shrink: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list_shrink = domain_name_list_shrink
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list_shrink is not None:
            result['DomainNameList'] = self.domain_name_list_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list_shrink = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData(TeaModel):
    def __init__(
        self,
        connected: str = None,
        finish_get_stream_info: str = None,
        first_frame_complete: str = None,
        first_packet: str = None,
        initialized: str = None,
        time_stamp: str = None,
    ):
        # The time elapsed from initialization to connection establishment.
        self.connected = connected
        # The time elapsed from connection establishment to subscription.
        self.finish_get_stream_info = finish_get_stream_info
        # The time elapsed from first packet processing to display of the first frame.
        self.first_frame_complete = first_frame_complete
        # The time elapsed from subscription to first packet processing.
        self.first_packet = first_packet
        # The time consumed by initialization.
        self.initialized = initialized
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connected is not None:
            result['Connected'] = self.connected
        if self.finish_get_stream_info is not None:
            result['FinishGetStreamInfo'] = self.finish_get_stream_info
        if self.first_frame_complete is not None:
            result['FirstFrameComplete'] = self.first_frame_complete
        if self.first_packet is not None:
            result['FirstPacket'] = self.first_packet
        if self.initialized is not None:
            result['Initialized'] = self.initialized
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Connected') is not None:
            self.connected = m.get('Connected')
        if m.get('FinishGetStreamInfo') is not None:
            self.finish_get_stream_info = m.get('FinishGetStreamInfo')
        if m.get('FirstFrameComplete') is not None:
            self.first_frame_complete = m.get('FirstFrameComplete')
        if m.get('FirstPacket') is not None:
            self.first_packet = m.get('FirstPacket')
        if m.get('Initialized') is not None:
            self.initialized = m.get('Initialized')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeRTSNativeSDKFirstFrameCostResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        end_time: str = None,
        first_frame_cost_data: List[DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData] = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The end of the time range for which the data was queried.
        self.end_time = end_time
        # The average latency of first frames at each interval. Unit: milliseconds.
        self.first_frame_cost_data = first_frame_cost_data
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.first_frame_cost_data:
            for k in self.first_frame_cost_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['FirstFrameCostData'] = []
        if self.first_frame_cost_data is not None:
            for k in self.first_frame_cost_data:
                result['FirstFrameCostData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.first_frame_cost_data = []
        if m.get('FirstFrameCostData') is not None:
            for k in m.get('FirstFrameCostData'):
                temp_model = DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData()
                self.first_frame_cost_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameCostResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRTSNativeSDKFirstFrameCostResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRTSNativeSDKFirstFrameCostResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRTSNativeSDKFirstFrameDelayRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list: List[str] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list = domain_name_list
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list is not None:
            result['DomainNameList'] = self.domain_name_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list_shrink: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list_shrink = domain_name_list_shrink
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list_shrink is not None:
            result['DomainNameList'] = self.domain_name_list_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list_shrink = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData(TeaModel):
    def __init__(
        self,
        frame_delay: str = None,
        time_stamp: str = None,
    ):
        # The average latency of first frames within the period of time.
        self.frame_delay = frame_delay
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.frame_delay is not None:
            result['FrameDelay'] = self.frame_delay
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FrameDelay') is not None:
            self.frame_delay = m.get('FrameDelay')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeRTSNativeSDKFirstFrameDelayResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        end_time: str = None,
        frame_delay_data: List[DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData] = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The end of the time range for which the data was queried.
        self.end_time = end_time
        # The average latency of first frames at each interval. Unit: milliseconds.
        self.frame_delay_data = frame_delay_data
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.frame_delay_data:
            for k in self.frame_delay_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['FrameDelayData'] = []
        if self.frame_delay_data is not None:
            for k in self.frame_delay_data:
                result['FrameDelayData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.frame_delay_data = []
        if m.get('FrameDelayData') is not None:
            for k in m.get('FrameDelayData'):
                temp_model = DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData()
                self.frame_delay_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKFirstFrameDelayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRTSNativeSDKFirstFrameDelayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRTSNativeSDKFirstFrameDelayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRTSNativeSDKPlayFailStatusRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list: List[str] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list = domain_name_list
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list is not None:
            result['DomainNameList'] = self.domain_name_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayFailStatusShrinkRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list_shrink: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list_shrink = domain_name_list_shrink
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list_shrink is not None:
            result['DomainNameList'] = self.domain_name_list_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list_shrink = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        v_20001: str = None,
        v_20002: str = None,
        v_20011: str = None,
        v_20012: str = None,
        v_20013: str = None,
        v_20052: str = None,
    ):
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The status code that indicates failed DNS resolution.
        self.v_20001 = v_20001
        # The status code that indicates failed authentication.
        self.v_20002 = v_20002
        # The status code that indicates a connection signaling timeout.
        self.v_20011 = v_20011
        # The status code that indicates a subscription signaling error.
        self.v_20012 = v_20012
        # The status code indicating that the stream to subscribe to does not exist.
        self.v_20013 = v_20013
        # The status code that indicates a media packet collection timeout.
        self.v_20052 = v_20052

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.v_20001 is not None:
            result['V20001'] = self.v_20001
        if self.v_20002 is not None:
            result['V20002'] = self.v_20002
        if self.v_20011 is not None:
            result['V20011'] = self.v_20011
        if self.v_20012 is not None:
            result['V20012'] = self.v_20012
        if self.v_20013 is not None:
            result['V20013'] = self.v_20013
        if self.v_20052 is not None:
            result['V20052'] = self.v_20052
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('V20001') is not None:
            self.v_20001 = m.get('V20001')
        if m.get('V20002') is not None:
            self.v_20002 = m.get('V20002')
        if m.get('V20011') is not None:
            self.v_20011 = m.get('V20011')
        if m.get('V20012') is not None:
            self.v_20012 = m.get('V20012')
        if m.get('V20013') is not None:
            self.v_20013 = m.get('V20013')
        if m.get('V20052') is not None:
            self.v_20052 = m.get('V20052')
        return self


class DescribeRTSNativeSDKPlayFailStatusResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        end_time: str = None,
        play_fail_status: List[DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus] = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The end of the time range for which the data was queried.
        self.end_time = end_time
        # The number of error status codes at each interval.
        self.play_fail_status = play_fail_status
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.play_fail_status:
            for k in self.play_fail_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['PlayFailStatus'] = []
        if self.play_fail_status is not None:
            for k in self.play_fail_status:
                result['PlayFailStatus'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.play_fail_status = []
        if m.get('PlayFailStatus') is not None:
            for k in m.get('PlayFailStatus'):
                temp_model = DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus()
                self.play_fail_status.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayFailStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRTSNativeSDKPlayFailStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRTSNativeSDKPlayFailStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRTSNativeSDKPlayTimeRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list: List[str] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list = domain_name_list
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list is not None:
            result['DomainNameList'] = self.domain_name_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayTimeShrinkRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list_shrink: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.
        self.domain_name_list_shrink = domain_name_list_shrink
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list_shrink is not None:
            result['DomainNameList'] = self.domain_name_list_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list_shrink = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData(TeaModel):
    def __init__(
        self,
        play_time: str = None,
        stall_time: str = None,
        time_stamp: str = None,
    ):
        # The average playback duration within the period of time.
        self.play_time = play_time
        # The average stuttering duration within the period of time.
        self.stall_time = stall_time
        # The timestamp of the returned data.
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.play_time is not None:
            result['PlayTime'] = self.play_time
        if self.stall_time is not None:
            result['StallTime'] = self.stall_time
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PlayTime') is not None:
            self.play_time = m.get('PlayTime')
        if m.get('StallTime') is not None:
            self.stall_time = m.get('StallTime')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeRTSNativeSDKPlayTimeResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        end_time: str = None,
        play_time_data: List[DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData] = None,
        request_id: str = None,
        start_time: str = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The end of the time range for which the data was queried.
        self.end_time = end_time
        # The average playback duration and average stuttering duration at each interval. Unit: milliseconds.
        self.play_time_data = play_time_data
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the data was queried.
        self.start_time = start_time

    def validate(self):
        if self.play_time_data:
            for k in self.play_time_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['PlayTimeData'] = []
        if self.play_time_data is not None:
            for k in self.play_time_data:
                result['PlayTimeData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.play_time_data = []
        if m.get('PlayTimeData') is not None:
            for k in m.get('PlayTimeData'):
                temp_model = DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData()
                self.play_time_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKPlayTimeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRTSNativeSDKPlayTimeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRTSNativeSDKPlayTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRTSNativeSDKVvDataRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list: List[str] = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # The array of domain names.
        self.domain_name_list = domain_name_list
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list is not None:
            result['DomainNameList'] = self.domain_name_list
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKVvDataShrinkRequest(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        domain_name_list_shrink: str = None,
        end_time: str = None,
        start_time: str = None,
    ):
        # The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.
        self.data_interval = data_interval
        # The array of domain names.
        self.domain_name_list_shrink = domain_name_list_shrink
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.domain_name_list_shrink is not None:
            result['DomainNameList'] = self.domain_name_list_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('DomainNameList') is not None:
            self.domain_name_list_shrink = m.get('DomainNameList')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRTSNativeSDKVvDataResponseBodyVvData(TeaModel):
    def __init__(
        self,
        time_stamp: str = None,
        vv_success: str = None,
        vv_total: str = None,
    ):
        # The timestamp of the returned data.
        self.time_stamp = time_stamp
        # The number of successful playbacks within the period of time.
        self.vv_success = vv_success
        # The total number of playbacks within the period of time.
        self.vv_total = vv_total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.vv_success is not None:
            result['VvSuccess'] = self.vv_success
        if self.vv_total is not None:
            result['VvTotal'] = self.vv_total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('VvSuccess') is not None:
            self.vv_success = m.get('VvSuccess')
        if m.get('VvTotal') is not None:
            self.vv_total = m.get('VvTotal')
        return self


class DescribeRTSNativeSDKVvDataResponseBody(TeaModel):
    def __init__(
        self,
        data_interval: str = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
        vv_data: List[DescribeRTSNativeSDKVvDataResponseBodyVvData] = None,
    ):
        # The time granularity.
        self.data_interval = data_interval
        # The end of the time range for which the data was queried.
        self.end_time = end_time
        # The ID of the request.
        self.request_id = request_id
        # The beginning of the time range for which the data was queried.
        self.start_time = start_time
        # The total number of playbacks and the number of successful playbacks at each interval.
        self.vv_data = vv_data

    def validate(self):
        if self.vv_data:
            for k in self.vv_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_interval is not None:
            result['DataInterval'] = self.data_interval
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['VvData'] = []
        if self.vv_data is not None:
            for k in self.vv_data:
                result['VvData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataInterval') is not None:
            self.data_interval = m.get('DataInterval')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.vv_data = []
        if m.get('VvData') is not None:
            for k in m.get('VvData'):
                temp_model = DescribeRTSNativeSDKVvDataResponseBodyVvData()
                self.vv_data.append(temp_model.from_map(k))
        return self


class DescribeRTSNativeSDKVvDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRTSNativeSDKVvDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRTSNativeSDKVvDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcCloudRecordingFilesRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileListVodMediaList(TeaModel):
    def __init__(
        self,
        media_ids: List[str] = None,
        merged_ids: List[str] = None,
        stream: str = None,
    ):
        self.media_ids = media_ids
        self.merged_ids = merged_ids
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.merged_ids is not None:
            result['MergedIds'] = self.merged_ids
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('MergedIds') is not None:
            self.merged_ids = m.get('MergedIds')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList(TeaModel):
    def __init__(
        self,
        hls_file_list: List[str] = None,
        mp_3file_list: List[str] = None,
        mp_4file_list: List[str] = None,
        vod_media_list: List[DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileListVodMediaList] = None,
    ):
        self.hls_file_list = hls_file_list
        self.mp_3file_list = mp_3file_list
        self.mp_4file_list = mp_4file_list
        self.vod_media_list = vod_media_list

    def validate(self):
        if self.vod_media_list:
            for k in self.vod_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hls_file_list is not None:
            result['HlsFileList'] = self.hls_file_list
        if self.mp_3file_list is not None:
            result['Mp3FileList'] = self.mp_3file_list
        if self.mp_4file_list is not None:
            result['Mp4FileList'] = self.mp_4file_list
        result['VodMediaList'] = []
        if self.vod_media_list is not None:
            for k in self.vod_media_list:
                result['VodMediaList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HlsFileList') is not None:
            self.hls_file_list = m.get('HlsFileList')
        if m.get('Mp3FileList') is not None:
            self.mp_3file_list = m.get('Mp3FileList')
        if m.get('Mp4FileList') is not None:
            self.mp_4file_list = m.get('Mp4FileList')
        self.vod_media_list = []
        if m.get('VodMediaList') is not None:
            for k in m.get('VodMediaList'):
                temp_model = DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileListVodMediaList()
                self.vod_media_list.append(temp_model.from_map(k))
        return self


class DescribeRtcCloudRecordingFilesResponseBodyTaskInfo(TeaModel):
    def __init__(
        self,
        record_file_list: DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList = None,
        status: str = None,
        task_id: str = None,
    ):
        self.record_file_list = record_file_list
        self.status = status
        self.task_id = task_id

    def validate(self):
        if self.record_file_list:
            self.record_file_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.record_file_list is not None:
            result['RecordFileList'] = self.record_file_list.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RecordFileList') is not None:
            temp_model = DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList()
            self.record_file_list = temp_model.from_map(m['RecordFileList'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeRtcCloudRecordingFilesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_info: DescribeRtcCloudRecordingFilesResponseBodyTaskInfo = None,
    ):
        self.request_id = request_id
        self.task_info = task_info

    def validate(self):
        if self.task_info:
            self.task_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_info is not None:
            result['TaskInfo'] = self.task_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskInfo') is not None:
            temp_model = DescribeRtcCloudRecordingFilesResponseBodyTaskInfo()
            self.task_info = temp_model.from_map(m['TaskInfo'])
        return self


class DescribeRtcCloudRecordingFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcCloudRecordingFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcCloudRecordingFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcMPUEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of your application.
        # 
        # > The ID can be up to 64 characters in length and can contain letters, digits, underscores, and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeRtcMPUEventSubResponseBodySubInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_ids: str = None,
        create_time: str = None,
        sub_id: str = None,
    ):
        # The application ID. You can specify only one application ID.
        self.app_id = app_id
        # The callback URL.
        self.callback_url = callback_url
        # The ID of the channel to which mixed-stream relay event callbacks are sent. Multiple channel IDs are separated by commas (,). If this parameter is not returned, mixed-stream relay event callbacks are sent to all channels.
        self.channel_ids = channel_ids
        # The time when the event callback was fired. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the subscription.
        self.sub_id = sub_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        return self


class DescribeRtcMPUEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        sub_info: DescribeRtcMPUEventSubResponseBodySubInfo = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the subscription.
        self.sub_info = sub_info

    def validate(self):
        if self.sub_info:
            self.sub_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_info is not None:
            result['SubInfo'] = self.sub_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubInfo') is not None:
            temp_model = DescribeRtcMPUEventSubResponseBodySubInfo()
            self.sub_info = temp_model.from_map(m['SubInfo'])
        return self


class DescribeRtcMPUEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcMPUEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcMPUEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeShowListRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo(TeaModel):
    def __init__(
        self,
        live_input_type: int = None,
        resource_id: str = None,
        resource_type: str = None,
        resource_url: str = None,
    ):
        # The custom type label.
        self.live_input_type = live_input_type
        # The ID of the video-on-demand (VOD) file.
        self.resource_id = resource_id
        # The type of the resource.
        self.resource_type = resource_type
        # The URL of the resource.
        self.resource_url = resource_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_input_type is not None:
            result['LiveInputType'] = self.live_input_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.resource_url is not None:
            result['ResourceUrl'] = self.resource_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveInputType') is not None:
            self.live_input_type = m.get('LiveInputType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('ResourceUrl') is not None:
            self.resource_url = m.get('ResourceUrl')
        return self


class DescribeShowListResponseBodyShowListInfoShowListShow(TeaModel):
    def __init__(
        self,
        duration: int = None,
        repeat_times: int = None,
        resource_info: DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo = None,
        show_id: str = None,
        show_name: str = None,
    ):
        # The duration of the episode. Unit: seconds.
        self.duration = duration
        # The number of times the episode repeats after the first playback is complete.
        # 
        # For example, if you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.
        self.repeat_times = repeat_times
        # The resource information.
        self.resource_info = resource_info
        # The ID of the episode.
        self.show_id = show_id
        # The name of the episode.
        self.show_name = show_name

    def validate(self):
        if self.resource_info:
            self.resource_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.repeat_times is not None:
            result['RepeatTimes'] = self.repeat_times
        if self.resource_info is not None:
            result['ResourceInfo'] = self.resource_info.to_map()
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.show_name is not None:
            result['ShowName'] = self.show_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('RepeatTimes') is not None:
            self.repeat_times = m.get('RepeatTimes')
        if m.get('ResourceInfo') is not None:
            temp_model = DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo()
            self.resource_info = temp_model.from_map(m['ResourceInfo'])
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('ShowName') is not None:
            self.show_name = m.get('ShowName')
        return self


class DescribeShowListResponseBodyShowListInfoShowList(TeaModel):
    def __init__(
        self,
        show: List[DescribeShowListResponseBodyShowListInfoShowListShow] = None,
    ):
        self.show = show

    def validate(self):
        if self.show:
            for k in self.show:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Show'] = []
        if self.show is not None:
            for k in self.show:
                result['Show'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.show = []
        if m.get('Show') is not None:
            for k in m.get('Show'):
                temp_model = DescribeShowListResponseBodyShowListInfoShowListShow()
                self.show.append(temp_model.from_map(k))
        return self


class DescribeShowListResponseBodyShowListInfo(TeaModel):
    def __init__(
        self,
        background: str = None,
        current_show_id: str = None,
        high_priority_show_id: str = None,
        high_priority_show_start_time: str = None,
        show_list: DescribeShowListResponseBodyShowListInfoShowList = None,
        show_list_repeat_times: int = None,
        total_show_list_repeat_times: int = None,
    ):
        # The background of the episode list.
        self.background = background
        # The ID of the episode that is playing.
        self.current_show_id = current_show_id
        # The episode of the highest priority.
        # 
        # > You can configure this parameter only before the episode list starts playing.
        self.high_priority_show_id = high_priority_show_id
        # The time at which the episode of the highest priority is played. Format: yyyy-MM-dd\\"T\\"HH:mm:ss.
        # 
        # > You can configure this parameter only before the episode list starts playing. After you configure this parameter, when the specified point in time is reached, any episode that is playing stops and the episode of the highest priority in the episode list starts to play.
        self.high_priority_show_start_time = high_priority_show_start_time
        # The episodes in the episode list.
        self.show_list = show_list
        # The number of additional times the episode list is played by default. The value is 0.
        self.show_list_repeat_times = show_list_repeat_times
        # The number of additional times the episode list is played.
        self.total_show_list_repeat_times = total_show_list_repeat_times

    def validate(self):
        if self.show_list:
            self.show_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background is not None:
            result['Background'] = self.background
        if self.current_show_id is not None:
            result['CurrentShowId'] = self.current_show_id
        if self.high_priority_show_id is not None:
            result['HighPriorityShowId'] = self.high_priority_show_id
        if self.high_priority_show_start_time is not None:
            result['HighPriorityShowStartTime'] = self.high_priority_show_start_time
        if self.show_list is not None:
            result['ShowList'] = self.show_list.to_map()
        if self.show_list_repeat_times is not None:
            result['ShowListRepeatTimes'] = self.show_list_repeat_times
        if self.total_show_list_repeat_times is not None:
            result['TotalShowListRepeatTimes'] = self.total_show_list_repeat_times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Background') is not None:
            self.background = m.get('Background')
        if m.get('CurrentShowId') is not None:
            self.current_show_id = m.get('CurrentShowId')
        if m.get('HighPriorityShowId') is not None:
            self.high_priority_show_id = m.get('HighPriorityShowId')
        if m.get('HighPriorityShowStartTime') is not None:
            self.high_priority_show_start_time = m.get('HighPriorityShowStartTime')
        if m.get('ShowList') is not None:
            temp_model = DescribeShowListResponseBodyShowListInfoShowList()
            self.show_list = temp_model.from_map(m['ShowList'])
        if m.get('ShowListRepeatTimes') is not None:
            self.show_list_repeat_times = m.get('ShowListRepeatTimes')
        if m.get('TotalShowListRepeatTimes') is not None:
            self.total_show_list_repeat_times = m.get('TotalShowListRepeatTimes')
        return self


class DescribeShowListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        show_list: str = None,
        show_list_info: DescribeShowListResponseBodyShowListInfo = None,
    ):
        # The request ID.
        self.request_id = request_id
        # ****Details of the episode list.
        # 
        # Show indicates the information about a specific episode. For more information, see the **Show** parameter.
        self.show_list = show_list
        # The information about the episode list.
        self.show_list_info = show_list_info

    def validate(self):
        if self.show_list_info:
            self.show_list_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.show_list is not None:
            result['ShowList'] = self.show_list
        if self.show_list_info is not None:
            result['ShowListInfo'] = self.show_list_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShowList') is not None:
            self.show_list = m.get('ShowList')
        if m.get('ShowListInfo') is not None:
            temp_model = DescribeShowListResponseBodyShowListInfo()
            self.show_list_info = temp_model.from_map(m['ShowListInfo'])
        return self


class DescribeShowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeShowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeShowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStreamLocationBlockRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        block_type: str = None,
        domain_name: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app_name = app_name
        # The blocking type. Valid values:
        # 
        # *   blacklist
        # *   whitelist
        self.block_type = block_type
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_num = page_num
        # The number of entries per page. Valid values: integers from 1 to 100.
        self.page_size = page_size
        self.region_id = region_id
        # The name of the live stream.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        block_type: str = None,
        domain_name: str = None,
        location_list: str = None,
        release_time: str = None,
        status: int = None,
        stream_name: str = None,
        update_time: str = None,
    ):
        # The name of the application in which the blocking applies.
        self.app_name = app_name
        # The blocking type. Valid values:
        # 
        # *   blacklist
        # *   whitelist
        self.block_type = block_type
        # The accelerated domain name.
        self.domain_name = domain_name
        # The blocked region. If multiple regions are specified, such as CN and AS, they are separated by commas (,).
        self.location_list = location_list
        # The time when the blocking ends. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.release_time = release_time
        # The blocking status. Valid values: 0 (not started), 1 (blocking), 2 (successful), 3 (failed), 4 (expired), and 5 (deleting).
        self.status = status
        # The name of the stream.
        self.stream_name = stream_name
        # The time when the configuration was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.location_list is not None:
            result['LocationList'] = self.location_list
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LocationList') is not None:
            self.location_list = m.get('LocationList')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeStreamLocationBlockResponseBodyStreamBlockList(TeaModel):
    def __init__(
        self,
        stream_block: List[DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock] = None,
    ):
        self.stream_block = stream_block

    def validate(self):
        if self.stream_block:
            for k in self.stream_block:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamBlock'] = []
        if self.stream_block is not None:
            for k in self.stream_block:
                result['StreamBlock'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_block = []
        if m.get('StreamBlock') is not None:
            for k in m.get('StreamBlock'):
                temp_model = DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock()
                self.stream_block.append(temp_model.from_map(k))
        return self


class DescribeStreamLocationBlockResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        page_num: int = None,
        page_size: int = None,
        request_id: str = None,
        stream_block_list: DescribeStreamLocationBlockResponseBodyStreamBlockList = None,
        total_page: int = None,
    ):
        # The total number of entries that meet the specified conditions.
        self.count = count
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The configurations.
        self.stream_block_list = stream_block_list
        # The total number of pages.
        self.total_page = total_page

    def validate(self):
        if self.stream_block_list:
            self.stream_block_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_block_list is not None:
            result['StreamBlockList'] = self.stream_block_list.to_map()
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamBlockList') is not None:
            temp_model = DescribeStreamLocationBlockResponseBodyStreamBlockList()
            self.stream_block_list = temp_model.from_map(m['StreamBlockList'])
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeStreamLocationBlockResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStreamLocationBlockResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStreamLocationBlockResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStudioLayoutsRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio instance.
        # 
        # *   If you call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio instance, you can obtain the instance ID from the CasterId parameter in the response.
        # *   If you create a production studio instance in the ApsaraVideo Live console, perform the following operations to obtain the instance ID: Log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane. Then, view the instance ID on the **Production Studio Management** page.
        # 
        # >  The value displayed in the Name column for an instance on the Production Studio Management page is the ID of the instance.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the layout.
        # 
        # You can specify multiple layout IDs and separate them with commas (,). If you leave this parameter empty, all layouts of the production studio are returned.
        # 
        # If you call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure a layout for a virtual studio, you can obtain the ID of the layout from the LayoutId parameter in the response.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig(TeaModel):
    def __init__(
        self,
        id: str = None,
        image_url: str = None,
        location_id: str = None,
        material_id: str = None,
    ):
        # The unique ID of the material.
        self.id = id
        # The URL of the material.
        self.image_url = image_url
        # The position ID.
        self.location_id = location_id
        # The ID of the material in ApsaraVideo VOD.
        self.material_id = material_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.location_id is not None:
            result['LocationId'] = self.location_id
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LocationId') is not None:
            self.location_id = m.get('LocationId')
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        video_resource_id: str = None,
    ):
        # The ID of the channel that is bound to the video resource.
        self.channel_id = channel_id
        # The ID of the video resource.
        self.video_resource_id = video_resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.video_resource_id is not None:
            result['VideoResourceId'] = self.video_resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('VideoResourceId') is not None:
            self.video_resource_id = m.get('VideoResourceId')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # The unique ID of the resource.
        self.id = id
        # The type of the resource. Valid values:
        # 
        # *   **background**: background material
        # *   **media**: multimedia material
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        fill_mode: str = None,
        height_normalized: float = None,
        id: str = None,
        image_material_id: str = None,
        index: int = None,
        position_normalized: List[float] = None,
        position_refer: str = None,
        video_resource_id: str = None,
        width_normalized: float = None,
    ):
        # The ID of the channel that is bound to the video resource.
        self.channel_id = channel_id
        # The fill type. Default value: none.
        self.fill_mode = fill_mode
        # The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The unique ID of the multimedia material.
        self.id = id
        # The ID of the image in ApsaraVideo VOD.
        self.image_material_id = image_material_id
        # The sequence number of the multimedia material. This parameter is displayed on the frontend but not used in the operation logic.
        self.index = index
        # The normalized value of the position of the material, in the format of [unk][x,y][unk]. Valid values of x and y: **0 to 1**. For example, [unk][0.1,0.2][unk] indicates that the material is horizontally offset by 10% and vertically offset by 20% towards the upper-left corner.
        self.position_normalized = position_normalized
        # The coordinate origin for the material. Default value: topLeft. topLeft indicates that the upper-left corner is used as the coordinate origin.
        self.position_refer = position_refer
        # The ID of the video resource.
        self.video_resource_id = video_resource_id
        # The normalized value of the material width. The value indicates the ratio of the material width to the width of the background. Valid values: **0 to 1**.
        self.width_normalized = width_normalized

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.fill_mode is not None:
            result['FillMode'] = self.fill_mode
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.id is not None:
            result['Id'] = self.id
        if self.image_material_id is not None:
            result['ImageMaterialId'] = self.image_material_id
        if self.index is not None:
            result['Index'] = self.index
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.video_resource_id is not None:
            result['VideoResourceId'] = self.video_resource_id
        if self.width_normalized is not None:
            result['WidthNormalized'] = self.width_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('FillMode') is not None:
            self.fill_mode = m.get('FillMode')
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageMaterialId') is not None:
            self.image_material_id = m.get('ImageMaterialId')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('VideoResourceId') is not None:
            self.video_resource_id = m.get('VideoResourceId')
        if m.get('WidthNormalized') is not None:
            self.width_normalized = m.get('WidthNormalized')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig(TeaModel):
    def __init__(
        self,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # The corresponding channel.
        self.valid_channel = valid_channel
        # The volume.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList(TeaModel):
    def __init__(
        self,
        audio_config: DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig = None,
        channel_id: str = None,
        color: str = None,
        height_normalized: float = None,
        id: str = None,
        index: int = None,
        only_audio: bool = None,
        portrait_type: int = None,
        position_x: str = None,
        position_y: str = None,
        video_resource_id: str = None,
    ):
        # The audio configurations.
        self.audio_config = audio_config
        # The ID of the channel that is bound to the video resource.
        self.channel_id = channel_id
        # The color gamut for chroma key. Valid values:
        # 
        # *   **blue**\
        # *   **green**\
        # *   **auto**: automatic recognition
        # *   **complex**: background replacement
        self.color = color
        # The normalized value of the height. The value indicates the ratio of the height of the keyed portrait to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The unique ID of the chroma key source.
        self.id = id
        # The sequence number of the chroma key source. This parameter is displayed on the frontend but not used in the operation logic.
        self.index = index
        # Indicates whether only audio exists.
        self.only_audio = only_audio
        # The portrait type. Valid values:
        # 
        # *   **0**: half body
        # *   **1**: full body
        self.portrait_type = portrait_type
        # The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_x = position_x
        # The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_y = position_y
        # The ID of the video resource.
        self.video_resource_id = video_resource_id

    def validate(self):
        if self.audio_config:
            self.audio_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_config is not None:
            result['AudioConfig'] = self.audio_config.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.color is not None:
            result['Color'] = self.color
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.id is not None:
            result['Id'] = self.id
        if self.index is not None:
            result['Index'] = self.index
        if self.only_audio is not None:
            result['OnlyAudio'] = self.only_audio
        if self.portrait_type is not None:
            result['PortraitType'] = self.portrait_type
        if self.position_x is not None:
            result['PositionX'] = self.position_x
        if self.position_y is not None:
            result['PositionY'] = self.position_y
        if self.video_resource_id is not None:
            result['VideoResourceId'] = self.video_resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioConfig') is not None:
            temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig()
            self.audio_config = temp_model.from_map(m['AudioConfig'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('OnlyAudio') is not None:
            self.only_audio = m.get('OnlyAudio')
        if m.get('PortraitType') is not None:
            self.portrait_type = m.get('PortraitType')
        if m.get('PositionX') is not None:
            self.position_x = m.get('PositionX')
        if m.get('PositionY') is not None:
            self.position_y = m.get('PositionY')
        if m.get('VideoResourceId') is not None:
            self.video_resource_id = m.get('VideoResourceId')
        return self


class DescribeStudioLayoutsResponseBodyStudioLayouts(TeaModel):
    def __init__(
        self,
        bg_image_config: DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig = None,
        common_config: DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig = None,
        layer_order_config_list: List[DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList] = None,
        layout_id: str = None,
        layout_name: str = None,
        layout_type: str = None,
        media_input_config_list: List[DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList] = None,
        screen_input_config_list: List[DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList] = None,
    ):
        # The background material configurations.
        self.bg_image_config = bg_image_config
        # The common layout configurations. This parameter is returned only for a common layout.
        self.common_config = common_config
        # The layer sorting configurations.
        self.layer_order_config_list = layer_order_config_list
        # The ID of the layout.
        self.layout_id = layout_id
        # The name of the layout.
        self.layout_name = layout_name
        # The type of the layout. Valid values:
        # 
        # *   **common**\
        # *   **studio**\
        self.layout_type = layout_type
        # The multimedia input configurations.
        self.media_input_config_list = media_input_config_list
        # The input configurations for chroma key.
        self.screen_input_config_list = screen_input_config_list

    def validate(self):
        if self.bg_image_config:
            self.bg_image_config.validate()
        if self.common_config:
            self.common_config.validate()
        if self.layer_order_config_list:
            for k in self.layer_order_config_list:
                if k:
                    k.validate()
        if self.media_input_config_list:
            for k in self.media_input_config_list:
                if k:
                    k.validate()
        if self.screen_input_config_list:
            for k in self.screen_input_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_image_config is not None:
            result['BgImageConfig'] = self.bg_image_config.to_map()
        if self.common_config is not None:
            result['CommonConfig'] = self.common_config.to_map()
        result['LayerOrderConfigList'] = []
        if self.layer_order_config_list is not None:
            for k in self.layer_order_config_list:
                result['LayerOrderConfigList'].append(k.to_map() if k else None)
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.layout_name is not None:
            result['LayoutName'] = self.layout_name
        if self.layout_type is not None:
            result['LayoutType'] = self.layout_type
        result['MediaInputConfigList'] = []
        if self.media_input_config_list is not None:
            for k in self.media_input_config_list:
                result['MediaInputConfigList'].append(k.to_map() if k else None)
        result['ScreenInputConfigList'] = []
        if self.screen_input_config_list is not None:
            for k in self.screen_input_config_list:
                result['ScreenInputConfigList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgImageConfig') is not None:
            temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig()
            self.bg_image_config = temp_model.from_map(m['BgImageConfig'])
        if m.get('CommonConfig') is not None:
            temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig()
            self.common_config = temp_model.from_map(m['CommonConfig'])
        self.layer_order_config_list = []
        if m.get('LayerOrderConfigList') is not None:
            for k in m.get('LayerOrderConfigList'):
                temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList()
                self.layer_order_config_list.append(temp_model.from_map(k))
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('LayoutName') is not None:
            self.layout_name = m.get('LayoutName')
        if m.get('LayoutType') is not None:
            self.layout_type = m.get('LayoutType')
        self.media_input_config_list = []
        if m.get('MediaInputConfigList') is not None:
            for k in m.get('MediaInputConfigList'):
                temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList()
                self.media_input_config_list.append(temp_model.from_map(k))
        self.screen_input_config_list = []
        if m.get('ScreenInputConfigList') is not None:
            for k in m.get('ScreenInputConfigList'):
                temp_model = DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList()
                self.screen_input_config_list.append(temp_model.from_map(k))
        return self


class DescribeStudioLayoutsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        studio_layouts: List[DescribeStudioLayoutsResponseBodyStudioLayouts] = None,
        total: int = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The layout information.
        self.studio_layouts = studio_layouts
        # The total number of layouts.
        self.total = total

    def validate(self):
        if self.studio_layouts:
            for k in self.studio_layouts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StudioLayouts'] = []
        if self.studio_layouts is not None:
            for k in self.studio_layouts:
                result['StudioLayouts'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.studio_layouts = []
        if m.get('StudioLayouts') is not None:
            for k in m.get('StudioLayouts'):
                temp_model = DescribeStudioLayoutsResponseBodyStudioLayouts()
                self.studio_layouts.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeStudioLayoutsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStudioLayoutsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStudioLayoutsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeToutiaoLivePlayRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The end of the time range to query. The end time must be later than the start time. The time span cannot be greater than 10 hours. If you do not configure StartTime and EndTime, the data within the previous hour is queried. Specify the time in the ISO 8601 standard. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeToutiaoLivePlayResponseBodyContent(TeaModel):
    def __init__(
        self,
        app: str = None,
        bandwidth: float = None,
        cdn_name: str = None,
        domain: str = None,
        play_num: int = None,
        stream_name: str = None,
        timestamp: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The bandwidth. Unit: Mbit/s.
        self.bandwidth = bandwidth
        # The Content Delivery Network (CDN) name.
        self.cdn_name = cdn_name
        # The streaming domain.
        self.domain = domain
        # The number of viewers.
        self.play_num = play_num
        # The name of the live stream.
        self.stream_name = stream_name
        # The timestamp.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.cdn_name is not None:
            result['CdnName'] = self.cdn_name
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.play_num is not None:
            result['PlayNum'] = self.play_num
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CdnName') is not None:
            self.cdn_name = m.get('CdnName')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('PlayNum') is not None:
            self.play_num = m.get('PlayNum')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeToutiaoLivePlayResponseBody(TeaModel):
    def __init__(
        self,
        content: List[DescribeToutiaoLivePlayResponseBodyContent] = None,
        description: str = None,
        request_id: str = None,
    ):
        # The information about the live stream.
        self.content = content
        # The description of the response status.
        self.description = description
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = DescribeToutiaoLivePlayResponseBodyContent()
                self.content.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeToutiaoLivePlayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeToutiaoLivePlayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeToutiaoLivePlayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeToutiaoLivePublishRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified is 10 hours. If you specify neither StartTime nor EndTime, the data of the last hour is queried by default.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the ingested stream.
        # 
        # This parameter is required.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class DescribeToutiaoLivePublishResponseBodyContent(TeaModel):
    def __init__(
        self,
        app: str = None,
        bitrate: float = None,
        bw_diff: float = None,
        cdn_name: str = None,
        domain: str = None,
        flr: float = None,
        fps: float = None,
        stream_name: str = None,
        timestamp: int = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The bitrate. Unit: bit/s.
        self.bitrate = bitrate
        # The bitrate difference.
        self.bw_diff = bw_diff
        # The name of the content delivery network (CDN) service.
        self.cdn_name = cdn_name
        # The ingest domain.
        self.domain = domain
        # The number of dropped frames.
        self.flr = flr
        # The frame rate.
        self.fps = fps
        # The name of the ingested stream.
        self.stream_name = stream_name
        # The timestamp.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bw_diff is not None:
            result['BwDiff'] = self.bw_diff
        if self.cdn_name is not None:
            result['CdnName'] = self.cdn_name
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.flr is not None:
            result['Flr'] = self.flr
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('BwDiff') is not None:
            self.bw_diff = m.get('BwDiff')
        if m.get('CdnName') is not None:
            self.cdn_name = m.get('CdnName')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Flr') is not None:
            self.flr = m.get('Flr')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeToutiaoLivePublishResponseBody(TeaModel):
    def __init__(
        self,
        content: List[DescribeToutiaoLivePublishResponseBodyContent] = None,
        description: str = None,
        request_id: str = None,
    ):
        # The stream ingest details.
        self.content = content
        # The description of the response status.
        self.description = description
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.content:
            for k in self.content:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Content'] = []
        if self.content is not None:
            for k in self.content:
                result['Content'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.content = []
        if m.get('Content') is not None:
            for k in m.get('Content'):
                temp_model = DescribeToutiaoLivePublishResponseBodyContent()
                self.content.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeToutiaoLivePublishResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeToutiaoLivePublishResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeToutiaoLivePublishResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUidOnlineStreamsRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        self.app_name = app_name
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeUidOnlineStreamsResponseBodyData(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        stream_name: str = None,
    ):
        self.app_name = app_name
        self.domain_name = domain_name
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeUidOnlineStreamsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[DescribeUidOnlineStreamsResponseBodyData] = None,
        request_id: str = None,
        total_num: int = None,
    ):
        self.data = data
        self.request_id = request_id
        self.total_num = total_num

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeUidOnlineStreamsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        return self


class DescribeUidOnlineStreamsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUidOnlineStreamsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUidOnlineStreamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUpBpsPeakDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_switch: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The accelerated domain name.
        self.domain_name = domain_name
        # Specifies whether to collect statistics at the domain name level. Valid values:
        # 
        # *   on: collects statistics at the domain name level.
        # *   off: collects statistics at the user level. This is the default value.
        self.domain_switch = domain_switch
        # The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_switch is not None:
            result['DomainSwitch'] = self.domain_switch
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainSwitch') is not None:
            self.domain_switch = m.get('DomainSwitch')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic(TeaModel):
    def __init__(
        self,
        band_width: str = None,
        peak_time: str = None,
        query_time: str = None,
        stat_name: str = None,
    ):
        # The daily peak inbound bandwidth.
        self.band_width = band_width
        # The time when the daily peak bandwidth is reached.
        self.peak_time = peak_time
        # The time queried on the day.
        self.query_time = query_time
        # The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.
        self.stat_name = stat_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_width is not None:
            result['BandWidth'] = self.band_width
        if self.peak_time is not None:
            result['PeakTime'] = self.peak_time
        if self.query_time is not None:
            result['QueryTime'] = self.query_time
        if self.stat_name is not None:
            result['StatName'] = self.stat_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWidth') is not None:
            self.band_width = m.get('BandWidth')
        if m.get('PeakTime') is not None:
            self.peak_time = m.get('PeakTime')
        if m.get('QueryTime') is not None:
            self.query_time = m.get('QueryTime')
        if m.get('StatName') is not None:
            self.stat_name = m.get('StatName')
        return self


class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics(TeaModel):
    def __init__(
        self,
        describe_up_peak_traffic: List[DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic] = None,
    ):
        self.describe_up_peak_traffic = describe_up_peak_traffic

    def validate(self):
        if self.describe_up_peak_traffic:
            for k in self.describe_up_peak_traffic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DescribeUpPeakTraffic'] = []
        if self.describe_up_peak_traffic is not None:
            for k in self.describe_up_peak_traffic:
                result['DescribeUpPeakTraffic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.describe_up_peak_traffic = []
        if m.get('DescribeUpPeakTraffic') is not None:
            for k in m.get('DescribeUpPeakTraffic'):
                temp_model = DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic()
                self.describe_up_peak_traffic.append(temp_model.from_map(k))
        return self


class DescribeUpBpsPeakDataResponseBody(TeaModel):
    def __init__(
        self,
        describe_up_peak_traffics: DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics = None,
        request_id: str = None,
    ):
        # The information about peak inbound bandwidth on each day.
        self.describe_up_peak_traffics = describe_up_peak_traffics
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.describe_up_peak_traffics:
            self.describe_up_peak_traffics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.describe_up_peak_traffics is not None:
            result['DescribeUpPeakTraffics'] = self.describe_up_peak_traffics.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DescribeUpPeakTraffics') is not None:
            temp_model = DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics()
            self.describe_up_peak_traffics = temp_model.from_map(m['DescribeUpPeakTraffics'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUpBpsPeakDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUpBpsPeakDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUpBpsPeakDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUpBpsPeakOfLineRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_switch: str = None,
        end_time: str = None,
        line: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The accelerated domain name.
        self.domain_name = domain_name
        # Specifies whether to collect statistics at the domain name level. Valid values:
        # 
        # *   on: collects statistics at the domain name level.
        # *   off (default): collects statistics at the user level.
        self.domain_switch = domain_switch
        # The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The leased line. Valid values: integers from 0 to 9.
        # 
        # This parameter is required.
        self.line = line
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_switch is not None:
            result['DomainSwitch'] = self.domain_switch
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.line is not None:
            result['Line'] = self.line
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainSwitch') is not None:
            self.domain_switch = m.get('DomainSwitch')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine(TeaModel):
    def __init__(
        self,
        band_width: float = None,
        peak_time: str = None,
        query_time: str = None,
        stat_name: str = None,
    ):
        # The daily peak inbound bandwidth of the leased line.
        self.band_width = band_width
        # The time when the daily peak bandwidth of the leased line is reached.
        self.peak_time = peak_time
        # The time queried on the day.
        self.query_time = query_time
        # The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.
        self.stat_name = stat_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_width is not None:
            result['BandWidth'] = self.band_width
        if self.peak_time is not None:
            result['PeakTime'] = self.peak_time
        if self.query_time is not None:
            result['QueryTime'] = self.query_time
        if self.stat_name is not None:
            result['StatName'] = self.stat_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWidth') is not None:
            self.band_width = m.get('BandWidth')
        if m.get('PeakTime') is not None:
            self.peak_time = m.get('PeakTime')
        if m.get('QueryTime') is not None:
            self.query_time = m.get('QueryTime')
        if m.get('StatName') is not None:
            self.stat_name = m.get('StatName')
        return self


class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines(TeaModel):
    def __init__(
        self,
        describe_up_bps_peak_of_line: List[DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine] = None,
    ):
        self.describe_up_bps_peak_of_line = describe_up_bps_peak_of_line

    def validate(self):
        if self.describe_up_bps_peak_of_line:
            for k in self.describe_up_bps_peak_of_line:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DescribeUpBpsPeakOfLine'] = []
        if self.describe_up_bps_peak_of_line is not None:
            for k in self.describe_up_bps_peak_of_line:
                result['DescribeUpBpsPeakOfLine'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.describe_up_bps_peak_of_line = []
        if m.get('DescribeUpBpsPeakOfLine') is not None:
            for k in m.get('DescribeUpBpsPeakOfLine'):
                temp_model = DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine()
                self.describe_up_bps_peak_of_line.append(temp_model.from_map(k))
        return self


class DescribeUpBpsPeakOfLineResponseBody(TeaModel):
    def __init__(
        self,
        describe_up_bps_peak_of_lines: DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines = None,
        request_id: str = None,
    ):
        # The information about peak inbound bandwidth of the leased line on each day.
        self.describe_up_bps_peak_of_lines = describe_up_bps_peak_of_lines
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.describe_up_bps_peak_of_lines:
            self.describe_up_bps_peak_of_lines.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.describe_up_bps_peak_of_lines is not None:
            result['DescribeUpBpsPeakOfLines'] = self.describe_up_bps_peak_of_lines.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DescribeUpBpsPeakOfLines') is not None:
            temp_model = DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines()
            self.describe_up_bps_peak_of_lines = temp_model.from_map(m['DescribeUpBpsPeakOfLines'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUpBpsPeakOfLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUpBpsPeakOfLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUpBpsPeakOfLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUpPeakPublishStreamDataRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        domain_switch: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The accelerated domain name.
        self.domain_name = domain_name
        # Specifies whether to collect statistics at the domain name level. Valid values:
        # 
        # *   on: collects statistics at the domain name level.
        # *   off (default): collects statistics at the user level.
        self.domain_switch = domain_switch
        # The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_switch is not None:
            result['DomainSwitch'] = self.domain_switch
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainSwitch') is not None:
            self.domain_switch = m.get('DomainSwitch')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData(TeaModel):
    def __init__(
        self,
        band_width: str = None,
        peak_time: str = None,
        publish_stream_num: int = None,
        query_time: str = None,
        stat_name: str = None,
    ):
        # The daily peak inbound bandwidth.
        self.band_width = band_width
        # The time when the daily peak number of concurrently ingested streams is reached.
        self.peak_time = peak_time
        # The daily peak number of concurrently ingested streams.
        self.publish_stream_num = publish_stream_num
        # The time queried on the day.
        self.query_time = query_time
        # The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.
        self.stat_name = stat_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.band_width is not None:
            result['BandWidth'] = self.band_width
        if self.peak_time is not None:
            result['PeakTime'] = self.peak_time
        if self.publish_stream_num is not None:
            result['PublishStreamNum'] = self.publish_stream_num
        if self.query_time is not None:
            result['QueryTime'] = self.query_time
        if self.stat_name is not None:
            result['StatName'] = self.stat_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BandWidth') is not None:
            self.band_width = m.get('BandWidth')
        if m.get('PeakTime') is not None:
            self.peak_time = m.get('PeakTime')
        if m.get('PublishStreamNum') is not None:
            self.publish_stream_num = m.get('PublishStreamNum')
        if m.get('QueryTime') is not None:
            self.query_time = m.get('QueryTime')
        if m.get('StatName') is not None:
            self.stat_name = m.get('StatName')
        return self


class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas(TeaModel):
    def __init__(
        self,
        describe_up_peak_publish_stream_data: List[DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData] = None,
    ):
        self.describe_up_peak_publish_stream_data = describe_up_peak_publish_stream_data

    def validate(self):
        if self.describe_up_peak_publish_stream_data:
            for k in self.describe_up_peak_publish_stream_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DescribeUpPeakPublishStreamData'] = []
        if self.describe_up_peak_publish_stream_data is not None:
            for k in self.describe_up_peak_publish_stream_data:
                result['DescribeUpPeakPublishStreamData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.describe_up_peak_publish_stream_data = []
        if m.get('DescribeUpPeakPublishStreamData') is not None:
            for k in m.get('DescribeUpPeakPublishStreamData'):
                temp_model = DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData()
                self.describe_up_peak_publish_stream_data.append(temp_model.from_map(k))
        return self


class DescribeUpPeakPublishStreamDataResponseBody(TeaModel):
    def __init__(
        self,
        describe_up_peak_publish_stream_datas: DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas = None,
        request_id: str = None,
    ):
        # The information about the peak number of concurrently ingested streams on each day.
        self.describe_up_peak_publish_stream_datas = describe_up_peak_publish_stream_datas
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.describe_up_peak_publish_stream_datas:
            self.describe_up_peak_publish_stream_datas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.describe_up_peak_publish_stream_datas is not None:
            result['DescribeUpPeakPublishStreamDatas'] = self.describe_up_peak_publish_stream_datas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DescribeUpPeakPublishStreamDatas') is not None:
            temp_model = DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas()
            self.describe_up_peak_publish_stream_datas = temp_model.from_map(m['DescribeUpPeakPublishStreamDatas'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUpPeakPublishStreamDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUpPeakPublishStreamDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUpPeakPublishStreamDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableLiveRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain for which you want to suspend real-time log delivery. Separate multiple streaming domains with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DisableLiveRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableLiveRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableLiveRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableLiveRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DynamicUpdateWaterMarkStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
        template_id: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the stream that contains the watermark.
        # 
        # This parameter is required.
        self.stream = stream
        # The watermark template ID. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
        # 
        # >  The TemplateId parameter is used to replace the watermark template ID during live streaming.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DynamicUpdateWaterMarkStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DynamicUpdateWaterMarkStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DynamicUpdateWaterMarkStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DynamicUpdateWaterMarkStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditPlaylistRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_config: str = None,
        program_id: str = None,
        program_items: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The configurations of the episode list. For more information, see the **ProgramConfig** section of this topic.
        self.program_config = program_config
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        # The episodes that you want to add to the production studio. The value is a JSON string. For more information, see the **InputProgramItem** section of this topic.
        # 
        # This parameter is required.
        self.program_items = program_items
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_config is not None:
            result['ProgramConfig'] = self.program_config
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_items is not None:
            result['ProgramItems'] = self.program_items
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramConfig') is not None:
            self.program_config = m.get('ProgramConfig')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramItems') is not None:
            self.program_items = m.get('ProgramItems')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EditPlaylistResponseBodyItemsFailedItems(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        item_name: str = None,
    ):
        # The ID of the episode.
        self.item_id = item_id
        # The name of the episode.
        self.item_name = item_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        return self


class EditPlaylistResponseBodyItemsSuccessItems(TeaModel):
    def __init__(
        self,
        item_id: str = None,
        item_name: str = None,
    ):
        # The ID of the episode.
        self.item_id = item_id
        # The name of the episode.
        self.item_name = item_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.item_name is not None:
            result['ItemName'] = self.item_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ItemName') is not None:
            self.item_name = m.get('ItemName')
        return self


class EditPlaylistResponseBodyItems(TeaModel):
    def __init__(
        self,
        failed_items: List[EditPlaylistResponseBodyItemsFailedItems] = None,
        success_items: List[EditPlaylistResponseBodyItemsSuccessItems] = None,
    ):
        # The episodes that failed to be added.
        self.failed_items = failed_items
        # The episodes that were added.
        self.success_items = success_items

    def validate(self):
        if self.failed_items:
            for k in self.failed_items:
                if k:
                    k.validate()
        if self.success_items:
            for k in self.success_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FailedItems'] = []
        if self.failed_items is not None:
            for k in self.failed_items:
                result['FailedItems'].append(k.to_map() if k else None)
        result['SuccessItems'] = []
        if self.success_items is not None:
            for k in self.success_items:
                result['SuccessItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.failed_items = []
        if m.get('FailedItems') is not None:
            for k in m.get('FailedItems'):
                temp_model = EditPlaylistResponseBodyItemsFailedItems()
                self.failed_items.append(temp_model.from_map(k))
        self.success_items = []
        if m.get('SuccessItems') is not None:
            for k in m.get('SuccessItems'):
                temp_model = EditPlaylistResponseBodyItemsSuccessItems()
                self.success_items.append(temp_model.from_map(k))
        return self


class EditPlaylistResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        items: EditPlaylistResponseBodyItems = None,
        program_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to configure callbacks or add a virtual studio layout.
        self.caster_id = caster_id
        # The information about the episodes.
        self.items = items
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to delete the episode list, query the information about the episode list, start the episode list, or stop the episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.items:
            self.items.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.items is not None:
            result['Items'] = self.items.to_map()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('Items') is not None:
            temp_model = EditPlaylistResponseBodyItems()
            self.items = temp_model.from_map(m['Items'])
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EditPlaylistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditPlaylistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditPlaylistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditShowAndReplaceRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        end_time: float = None,
        owner_id: int = None,
        region_id: str = None,
        show_id: str = None,
        start_time: float = None,
        storage_info: str = None,
        user_data: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The end time of the editing task. Unit: seconds.
        # 
        # > 
        # 
        # *   The valid values range from 0 to the value indicated by the total length of the episode.
        # 
        # *   By default, this parameter is set to the value that indicates the total length of the episode. The editing period cannot exceed the total length of the episode.
        # 
        # *   If you want to edit a VOD file from the 2nd second to the 5th second, set the StartTime parameter to 2.0 and the EndTime parameter to 5.0.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the episode to be edited.
        # 
        # >  You can obtain the ID from the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) operation.
        # 
        # This parameter is required.
        self.show_id = show_id
        # The start time of the editing task. Unit: seconds.
        # 
        # > 
        # 
        # *   The valid values range from 0 to the value indicated by the total length of the episode. By default, the editing task starts from the beginning of the episode. Default value: 0.0.
        # 
        # *   If you want to edit a VOD file from the 2nd second to the 5th second, set the StartTime parameter to 2.0 and the EndTime parameter to 5.0.
        self.start_time = start_time
        # The storage information of the episode. The following fields are included:
        # 
        # *   **StorageLocation**: the storage location of ApsaraVideo VOD.
        # *   **FileName**: the custom file name.
        # 
        # >  Editing outputs must be stored in the VOD bucket within the same account that is used to access both ApsaraVideo VOD and ApsaraVideo Live. For more information about how to obtain the storage location, see [Manage VOD resources](https://help.aliyun.com/document_detail/86097.html).
        self.storage_info = storage_info
        # The user information.
        self.user_data = user_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.storage_info is not None:
            result['StorageInfo'] = self.storage_info
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StorageInfo') is not None:
            self.storage_info = m.get('StorageInfo')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class EditShowAndReplaceResponseBody(TeaModel):
    def __init__(
        self,
        job_info: str = None,
        request_id: str = None,
    ):
        # The information about the editing task. The following fields are included:
        # 
        # *   **vodId**: the ID of the VOD file.
        # *   **mediaid**: the ID of the media file.
        # *   **jobId**: the ID of the editing task.
        self.job_info = job_info
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_info is not None:
            result['JobInfo'] = self.job_info
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobInfo') is not None:
            self.job_info = m.get('JobInfo')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EditShowAndReplaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditShowAndReplaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditShowAndReplaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EffectCasterUrgentRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene. This parameter takes effect only if the scene is a PGM scene.
        # 
        # You can call the [DescribeCasterScenes](https://help.aliyun.com/document_detail/2848039.html) operation to query the scene ID.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class EffectCasterUrgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EffectCasterUrgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EffectCasterUrgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EffectCasterUrgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EffectCasterVideoResourceRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        resource_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The resource ID. If you call the [DescribeCasterChannels](https://help.aliyun.com/document_detail/2848046.html) operation to query the channels of the production studio, you can obtain the ID of the resource in a specific channel from the ResourceId parameter in the response.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The ID of the scene. You can call the [DescribeCasterScenes](~~60262#doc-api-live-DescribeCasterScenes~~ "Queries information about the scenes of a production studio.") operation to get the ID.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class EffectCasterVideoResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EffectCasterVideoResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EffectCasterVideoResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EffectCasterVideoResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableLiveRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The streaming domain for which you want to enable real-time log delivery.
        # 
        # Separate multiple streaming domains with commas (,).
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EnableLiveRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableLiveRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableLiveRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableLiveRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ForbidLiveStreamRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        live_stream_type: str = None,
        oneshot: str = None,
        owner_id: int = None,
        region_id: str = None,
        resume_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether the live stream is ingested by a streamer or played by a viewer. Set the value to **publisher**.
        # 
        # This parameter is required.
        self.live_stream_type = live_stream_type
        # Specifies whether to only interrupt the live stream without adding the ingest URL of the live stream to the blacklist. Valid values:
        # 
        # *   **yes**: interrupts the live stream but does not add the ingest URL of the live stream to the blacklist. This value is available only when the live stream is ingested or played in the upstream.
        # *   **no**: disables the live stream and adds the ingest URL of the live stream to the blacklist.
        # 
        # >  If you do not specify this parameter, the default value no is used.
        self.oneshot = oneshot
        self.owner_id = owner_id
        self.region_id = region_id
        # The time when the live stream is resumed. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # > 
        # 
        # *   If you set the **Oneshot** parameter to **no** and do not specify this parameter, the live stream is disabled for six months by default.
        # 
        # *   If you specify this parameter, the live stream is resumed at the specified point in time.
        self.resume_time = resume_time
        # The name of the ingested stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_stream_type is not None:
            result['LiveStreamType'] = self.live_stream_type
        if self.oneshot is not None:
            result['Oneshot'] = self.oneshot
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resume_time is not None:
            result['ResumeTime'] = self.resume_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveStreamType') is not None:
            self.live_stream_type = m.get('LiveStreamType')
        if m.get('Oneshot') is not None:
            self.oneshot = m.get('Oneshot')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResumeTime') is not None:
            self.resume_time = m.get('ResumeTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class ForbidLiveStreamResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ForbidLiveStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ForbidLiveStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ForbidLiveStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAllCustomTemplatesRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        user_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetAllCustomTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        custom_templates: str = None,
        request_id: str = None,
    ):
        # The template names and template configurations returned.
        self.custom_templates = custom_templates
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_templates is not None:
            result['CustomTemplates'] = self.custom_templates
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTemplates') is not None:
            self.custom_templates = m.get('CustomTemplates')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAllCustomTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAllCustomTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAllCustomTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomTemplateRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        template: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the custom template that you want to query. The value is a string.
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class GetCustomTemplateResponseBody(TeaModel):
    def __init__(
        self,
        custom_template: str = None,
        request_id: str = None,
        template: str = None,
    ):
        # The configurations of the template.
        self.custom_template = custom_template
        # The request ID.
        self.request_id = request_id
        # The name of the template.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            self.custom_template = m.get('CustomTemplate')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class GetCustomTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        job_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the edge transcoding task.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetEdgeTranscodeJobResponseBodyJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        last_start_at: str = None,
        last_stop_at: str = None,
        name: str = None,
        status: str = None,
        stream_input: str = None,
        stream_output: str = None,
        template_id: str = None,
        template_name: str = None,
        type: str = None,
    ):
        # The time when the task was created.
        self.create_time = create_time
        # The ID of the task.
        self.job_id = job_id
        # The time when the task was last started.
        self.last_start_at = last_start_at
        # The time when the task was last stopped.
        self.last_stop_at = last_stop_at
        # The name of the task.
        self.name = name
        # The status of the task. Valid values:
        # 
        # *   0: not started
        # *   1: in progress
        self.status = status
        # The URL of the input stream.
        self.stream_input = stream_input
        # The URL of the output stream.
        self.stream_output = stream_output
        # The ID of the edge transcoding template used by the task.
        self.template_id = template_id
        # The name of the edge transcoding template used by the task.
        self.template_name = template_name
        # The type of edge transcoding. Valid values:
        # 
        # *   common: standard transcoding and Narrowband HD 1.0 transcoding
        # *   nbhd-2: Narrowband HD 2.0 transcoding
        # *   ultra-hd: ultra-high definition transcoding
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.last_start_at is not None:
            result['LastStartAt'] = self.last_start_at
        if self.last_stop_at is not None:
            result['LastStopAt'] = self.last_stop_at
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input
        if self.stream_output is not None:
            result['StreamOutput'] = self.stream_output
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LastStartAt') is not None:
            self.last_start_at = m.get('LastStartAt')
        if m.get('LastStopAt') is not None:
            self.last_stop_at = m.get('LastStopAt')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            self.stream_input = m.get('StreamInput')
        if m.get('StreamOutput') is not None:
            self.stream_output = m.get('StreamOutput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job: GetEdgeTranscodeJobResponseBodyJob = None,
        request_id: str = None,
    ):
        # The details of the edge transcoding task.
        self.job = job
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Job') is not None:
            temp_model = GetEdgeTranscodeJobResponseBodyJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        template_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The template ID.
        # 
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetEdgeTranscodeTemplateResponseBodyTemplate(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        create_time: str = None,
        fps: str = None,
        gop: str = None,
        name: str = None,
        resolution: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The bitrate. If a numeric value is returned, a fixed bitrate is configured for the output stream. If ws is returned, the output stream maintains the same bitrate as the input stream.
        self.bitrate = bitrate
        # The video encoding format. Valid values:
        # 
        # *   H.264
        # *   H.265
        self.codec = codec
        # The time when the template was created.
        self.create_time = create_time
        # The frame rate. If a numeric value is returned, a fixed frame rate is configured for the output stream. If ws is returned, the output stream maintains the same frame rate as the input stream.
        self.fps = fps
        # The group of pictures (GOP) size. The GOP size can be defined by the number of frames or the time interval between I-frames. If ws is returned, the output stream maintains the same GOP size as the input stream.
        self.gop = gop
        # The template name.
        self.name = name
        # The resolution. If width and height values are returned, a fixed resolution is configured for the output stream. If ws is returned, the output stream maintains the same resolution as the input stream.
        # 
        # >  If the width value is -1, the width of the output stream is adapted to the height. If the height value is -2, the height of the output stream is adapted to the width.
        self.resolution = resolution
        # The template ID.
        self.template_id = template_id
        # The type of edge transcoding.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.name is not None:
            result['Name'] = self.name
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEdgeTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template: GetEdgeTranscodeTemplateResponseBodyTemplate = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the edge transcoding template.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = GetEdgeTranscodeTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class GetEdgeTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEditingJobInfoRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        show_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the episode for which you want to query editing tasks.
        # 
        # >  You can obtain the ID from the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html) operation.
        self.show_id = show_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        return self


class GetEditingJobInfoResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        editing_tasks_info: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio.
        self.caster_id = caster_id
        # The information about editing tasks. The following fields are returned for each editing task:
        # 
        # *   **OutputVodId**: the ID of the output video-on-demand (VOD) file.
        # *   **TaskStatus**: the status of the editing task. Valid values: -1, 0, 1, 2, and 3. A value of -1 indicates that the editing task fails. A value of 0 indicates that the editing task is being initialized. A value of 1 indicates that editing is in progress. A value of 2 indicates that the output VOD file is being uploaded. A value of 3 indicates that the editing task is successful.
        # *   **StorageLocation**: the storage location in ApsaraVideo VOD.
        # *   **FileName**: the name of the file that is edited.
        # *   **ShowId**: the ID of the episode.
        self.editing_tasks_info = editing_tasks_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.editing_tasks_info is not None:
            result['EditingTasksInfo'] = self.editing_tasks_info
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EditingTasksInfo') is not None:
            self.editing_tasks_info = m.get('EditingTasksInfo')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEditingJobInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEditingJobInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEditingJobInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        app_config: Dict[str, str] = None,
        app_id: str = None,
        app_name: str = None,
        create_time: int = None,
        extension: Dict[str, str] = None,
        status: int = None,
    ):
        # The configurations of the application.
        self.app_config = app_config
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The time when the interactive messaging application was created. The time is displayed in UTC.
        self.create_time = create_time
        # The extended field.
        self.extension = extension
        # The status of the interactive message application. A value of 1 indicates that the application is normal.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetMessageAppResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = GetMessageAppResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class GetMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class GetMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_id: str = None,
        extension: Dict[str, Any] = None,
        group_id: str = None,
        is_mute_all: bool = None,
        status: int = None,
    ):
        # The time when the message group was created. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the creator.
        self.creator_id = creator_id
        # The extended field.
        self.extension = extension
        # The ID of the message group.
        self.group_id = group_id
        # Indicates whether the message group is muted.
        # 
        # *   true: The message group is muted.
        # *   false: The message group is not muted.
        self.is_mute_all = is_mute_all
        # The status of the message group. The default value is **1**, which indicates that the message group is normal.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.is_mute_all is not None:
            result['IsMuteAll'] = self.is_mute_all
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsMuteAll') is not None:
            self.is_mute_all = m.get('IsMuteAll')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = GetMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class GetMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMessageTokenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        device_id: str = None,
        device_type: str = None,
        user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the device. Each device has a unique ID. You can specify a custom ID. The ID can be up to 64 characters in length and can contain lowercase letters, digits, underscores (_), and hyphen (-). You can specify multiple device IDs. We recommend that you obtain the IDs from the devices and pass the IDs to the server.
        # 
        # This parameter is required.
        self.device_id = device_id
        # The type of the device. Valid values:
        # 
        # *   ios
        # *   android
        # *   web
        # *   pc
        # 
        # This parameter is required.
        self.device_type = device_type
        # The ID of the user. Each user has a unique ID in the application. The ID can be up to 32 characters in length and can contain lowercase letters, digits, underscores (_), and periods (.). You can specify multiple user IDs.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_type is not None:
            result['DeviceType'] = self.device_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceType') is not None:
            self.device_type = m.get('DeviceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetMessageTokenResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        access_token_expired_time: int = None,
        refresh_token: str = None,
    ):
        # The token used to establish a persistent connection.
        self.access_token = access_token
        # Indicates how long until the token expires. Unit: milliseconds.
        self.access_token_expired_time = access_token_expired_time
        # The updated token. If a token expires, you can call RefreshToken to obtain a new token.
        self.refresh_token = refresh_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['AccessToken'] = self.access_token
        if self.access_token_expired_time is not None:
            result['AccessTokenExpiredTime'] = self.access_token_expired_time
        if self.refresh_token is not None:
            result['RefreshToken'] = self.refresh_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessToken') is not None:
            self.access_token = m.get('AccessToken')
        if m.get('AccessTokenExpiredTime') is not None:
            self.access_token_expired_time = m.get('AccessTokenExpiredTime')
        if m.get('RefreshToken') is not None:
            self.refresh_token = m.get('RefreshToken')
        return self


class GetMessageTokenResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: GetMessageTokenResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = GetMessageTokenResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class GetMessageTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMessageTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMessageTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTranscodeTaskStatusRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        push_domain: str = None,
        security_token: str = None,
        stream_name: str = None,
        transcoding_template: str = None,
    ):
        self.app = app
        self.push_domain = push_domain
        self.security_token = security_token
        self.stream_name = stream_name
        self.transcoding_template = transcoding_template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.push_domain is not None:
            result['PushDomain'] = self.push_domain
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transcoding_template is not None:
            result['TranscodingTemplate'] = self.transcoding_template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('PushDomain') is not None:
            self.push_domain = m.get('PushDomain')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TranscodingTemplate') is not None:
            self.transcoding_template = m.get('TranscodingTemplate')
        return self


class GetTranscodeTaskStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTranscodeTaskStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTranscodeTaskStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTranscodeTaskStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HotLiveRtcStreamRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        audio_msid: str = None,
        connection_timeout: str = None,
        domain_name: str = None,
        media_timeout: str = None,
        owner_id: int = None,
        region_code: str = None,
        region_id: str = None,
        stream_name: str = None,
        video_msid: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The audio MSID.
        # 
        # This parameter is required.
        self.audio_msid = audio_msid
        # The duration for which the prefetch connection is maintained. Unit: milliseconds. Default value: 0, which specifies that the prefetch connection is always maintained.
        self.connection_timeout = connection_timeout
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The custom period after which a timeout event is triggered. Unit: milliseconds.
        self.media_timeout = media_timeout
        self.owner_id = owner_id
        # The code of the region in which the live stream is prefetched. For more information, see the following tables that list available region codes.
        # 
        # >  Region codes include provincial codes for China and country codes for all countries.
        # 
        # This parameter is required.
        self.region_code = region_code
        self.region_id = region_id
        # The name of the live stream that you want to prefetch.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The video MSID.
        # 
        # This parameter is required.
        self.video_msid = video_msid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.audio_msid is not None:
            result['AudioMsid'] = self.audio_msid
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.media_timeout is not None:
            result['MediaTimeout'] = self.media_timeout
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_code is not None:
            result['RegionCode'] = self.region_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.video_msid is not None:
            result['VideoMsid'] = self.video_msid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AudioMsid') is not None:
            self.audio_msid = m.get('AudioMsid')
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('MediaTimeout') is not None:
            self.media_timeout = m.get('MediaTimeout')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionCode') is not None:
            self.region_code = m.get('RegionCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VideoMsid') is not None:
            self.video_msid = m.get('VideoMsid')
        return self


class HotLiveRtcStreamResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class HotLiveRtcStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: HotLiveRtcStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HotLiveRtcStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InitializeAutoShowListTaskRequest(TeaModel):
    def __init__(
        self,
        call_back_url: str = None,
        caster_config: str = None,
        domain_name: str = None,
        end_time: int = None,
        owner_id: int = None,
        region_id: str = None,
        resource_ids: str = None,
        start_time: int = None,
    ):
        # The callback URL.
        self.call_back_url = call_back_url
        # The configurations of the production studio. The following configurations are involved:
        # 
        # *   CasterTemplate: required. The output resolution.
        # *   LiveTemplate: optional. The templates to be used for transcoding.
        # 
        # >  Set the value to a JSON string. Use upper camel case for fields of the string.
        # 
        # This parameter is required.
        self.caster_config = caster_config
        # The output streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The end timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The IDs of on-demand media asset files in the playlist. Only on-demand video files are supported. You can specify up to three video files in the playlist. The video files in the playlist are automatically played in sequence. The playback stops at the point in time specified by the EndTime parameter.
        # 
        # > 
        # 
        # *   You can obtain the ID of a video file in the ApsaraVideo Live console or by calling an API operation. For more information, see [Media asset management](https://help.aliyun.com/document_detail/86057.html) or [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html). - If the video files are all played before the time specified by EndTime, the final frame of the final video file is played until the time specified by EndTime arrives.
        self.resource_ids = resource_ids
        # The start timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back_url is not None:
            result['CallBackUrl'] = self.call_back_url
        if self.caster_config is not None:
            result['CasterConfig'] = self.caster_config
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBackUrl') is not None:
            self.call_back_url = m.get('CallBackUrl')
        if m.get('CasterConfig') is not None:
            self.caster_config = m.get('CasterConfig')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class InitializeAutoShowListTaskResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
        stream_list: str = None,
    ):
        # The ID of the production studio.
        # 
        # >  The value of this parameter can be used as the value of a request parameter to query the streaming URL of the production studio, start the production studio, add video resources to the production studio, add a production studio layout, query production studio layouts, add a production studio component, and add a production studio playlist.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id
        # The list of output video streams.
        # 
        # *   videoFormat: the format of the streaming URL.
        # *   outputStreamUrl: the source URL.
        # *   transcodeConfig: the output resolution specified for video transcoding of the source URL.
        self.stream_list = stream_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_list is not None:
            result['StreamList'] = self.stream_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamList') is not None:
            self.stream_list = m.get('StreamList')
        return self


class InitializeAutoShowListTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InitializeAutoShowListTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InitializeAutoShowListTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_statistics: bool = None,
        broad_cast_type: int = None,
        group_id: str = None,
        user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to broadcast statistical messages. If you set the value to true, statistical messages of the message group are broadcasted after the users join the message group. The client can receive and process these messages. Valid values:
        # 
        # *   true: broadcasts statistical messages.
        # *   false: does not broadcast statistical messages.
        self.broad_cast_statistics = broad_cast_statistics
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The ID of the message group to join.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user. Each user has a unique ID in the application. The ID can be up to 32 characters in length and can contain lowercase letters, digits, underscores (_), and periods (.). You can specify multiple user IDs.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_statistics is not None:
            result['BroadCastStatistics'] = self.broad_cast_statistics
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastStatistics') is not None:
            self.broad_cast_statistics = m.get('BroadCastStatistics')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class JoinMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the users successfully joined the message group. Valid values:
        # 
        # *   true: The users successfully joined the message group.
        # *   false: The users failed to join the message group.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class JoinMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: JoinMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = JoinMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class JoinMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class KickLiveMessageGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        kickoff_user: str = None,
    ):
        # The ID of the interactive messaging application to which the interactive messaging group belongs.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the interactive messaging group from which you want to remove the user.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The user that you want to remove.
        # 
        # This parameter is required.
        self.kickoff_user = kickoff_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.kickoff_user is not None:
            result['KickoffUser'] = self.kickoff_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('KickoffUser') is not None:
            self.kickoff_user = m.get('KickoffUser')
        return self


class KickLiveMessageGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class KickLiveMessageGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: KickLiveMessageGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = KickLiveMessageGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LeaveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_statistics: bool = None,
        broad_cast_type: int = None,
        group_id: str = None,
        user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to broadcast statistical messages. If you set the value to true, statistical messages of the message group are broadcasted after the users join the message group. The client can receive and process these messages. Valid values:
        # 
        # *   true: broadcasts statistical messages.
        # *   false: does not broadcast statistical messages.
        self.broad_cast_statistics = broad_cast_statistics
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user. Each user has a unique ID in the application.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_statistics is not None:
            result['BroadCastStatistics'] = self.broad_cast_statistics
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastStatistics') is not None:
            self.broad_cast_statistics = m.get('BroadCastStatistics')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class LeaveMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the user left the message group. Valid values:
        # 
        # *   true: The user left the message group.
        # *   false: The user failed to leave the message group.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class LeaveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: LeaveMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = LeaveMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class LeaveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LeaveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LeaveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        keyword: str = None,
        owner_id: int = None,
        page_no: int = None,
        page_size: int = None,
        region_id: str = None,
        sort_by: str = None,
        status: int = None,
        type: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The keyword of the query.
        # 
        # *   You can specify a task ID for an exact match.
        # *   You can specify a task name for a fuzzy match.
        self.keyword = keyword
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Maximum value: 100.
        self.page_size = page_size
        self.region_id = region_id
        # The sort order of the tasks by creation time. Default value: desc. Valid values:
        # 
        # *   desc: descending order
        # *   asc: ascending order
        self.sort_by = sort_by
        # The task status. Valid values:
        # 
        # *   0: not started
        # *   1: running
        self.status = status
        # The type of edge transcoding. Valid values:
        # 
        # *   common: standard transcoding and Narrowband HD 1.0 transcoding.
        # *   nbhd-2: Narrowband HD 2.0 transcoding
        # *   ultra-hd: ultra-high definition transcoding
        # 
        # >  If you do not specify this parameter, the query results are filtered based on the types of edge transcoding on which you are granted permissions.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEdgeTranscodeJobResponseBodyJobListJob(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        job_id: str = None,
        last_start_at: str = None,
        last_stop_at: str = None,
        name: str = None,
        status: str = None,
        stream_input: str = None,
        stream_output: str = None,
        template_id: str = None,
        template_name: str = None,
        type: str = None,
    ):
        # The time when the task was created.
        self.create_time = create_time
        # The ID of the task.
        self.job_id = job_id
        # The time when the task was last started.
        self.last_start_at = last_start_at
        # The time when the task was last stopped.
        self.last_stop_at = last_stop_at
        # The name of the task.
        self.name = name
        # The status of the task. Valid values:
        # 
        # *   0: not started
        # *   1: in progress
        self.status = status
        # The URL of the input stream.
        self.stream_input = stream_input
        # The URL of the output stream.
        self.stream_output = stream_output
        # The ID of the edge transcoding template used by the task.
        self.template_id = template_id
        # The name of the edge transcoding template used by the task.
        self.template_name = template_name
        # The type of edge transcoding. Valid values:
        # 
        # *   common: standard transcoding and Narrowband HD 1.0 transcoding.
        # *   nbhd-2: Narrowband HD 2.0 transcoding
        # *   ultra-hd: ultra-high definition transcoding
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.last_start_at is not None:
            result['LastStartAt'] = self.last_start_at
        if self.last_stop_at is not None:
            result['LastStopAt'] = self.last_stop_at
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input
        if self.stream_output is not None:
            result['StreamOutput'] = self.stream_output
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LastStartAt') is not None:
            self.last_start_at = m.get('LastStartAt')
        if m.get('LastStopAt') is not None:
            self.last_stop_at = m.get('LastStopAt')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            self.stream_input = m.get('StreamInput')
        if m.get('StreamOutput') is not None:
            self.stream_output = m.get('StreamOutput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEdgeTranscodeJobResponseBodyJobList(TeaModel):
    def __init__(
        self,
        job: List[ListEdgeTranscodeJobResponseBodyJobListJob] = None,
    ):
        self.job = job

    def validate(self):
        if self.job:
            for k in self.job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Job'] = []
        if self.job is not None:
            for k in self.job:
                result['Job'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.job = []
        if m.get('Job') is not None:
            for k in m.get('Job'):
                temp_model = ListEdgeTranscodeJobResponseBodyJobListJob()
                self.job.append(temp_model.from_map(k))
        return self


class ListEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_list: ListEdgeTranscodeJobResponseBodyJobList = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The edge transcoding tasks.
        self.job_list = job_list
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.job_list:
            self.job_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_list is not None:
            result['JobList'] = self.job_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobList') is not None:
            temp_model = ListEdgeTranscodeJobResponseBodyJobList()
            self.job_list = temp_model.from_map(m['JobList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEdgeTranscodeTemplateRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        keyword: str = None,
        owner_id: int = None,
        page_no: int = None,
        page_size: int = None,
        region_id: str = None,
        sort_by: str = None,
        type: str = None,
        video_codec: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The keyword of the query.
        # 
        # *   You can specify a template ID for an exact match.
        # *   You can also specify a template name for a fuzzy match.
        self.keyword = keyword
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        self.region_id = region_id
        # The sorting order of the templates by creation time. Default value: desc. Valid values:
        # 
        # *   desc: descending order.
        # *   asc: ascending order.
        self.sort_by = sort_by
        # The type of edge transcoding. Valid values:
        # 
        # *   **common**: standard transcoding and Narrowband HD 1.0 transcoding.
        # *   **nbhd-2**: Narrowband HD 2.0 transcoding.
        # *   **ultra-hd**: ultra-high definition transcoding.
        # 
        # >  If you do not specify this parameter, the query result is filtered based on the type of edge transcoding on which you are granted permissions.
        self.type = type
        # The video encoding format. Valid values:
        # 
        # *   H.264
        # *   H.265
        # 
        # >  If you do not specify this parameter, the query result is filtered based on the video encoding format on which you are granted permissions.
        self.video_codec = video_codec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        return self


class ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate(TeaModel):
    def __init__(
        self,
        bitrate: str = None,
        codec: str = None,
        create_time: str = None,
        fps: str = None,
        gop: str = None,
        name: str = None,
        resolution: str = None,
        template_id: str = None,
        type: str = None,
    ):
        # The bitrate. If a numeric value is returned, a fixed bitrate is configured for the output stream. If ws is returned, the output stream maintains the same bitrate as the input stream.
        self.bitrate = bitrate
        # The video encoding format. Valid values:
        # 
        # *   H.264
        # *   H.265
        self.codec = codec
        # The time when the image template was created.
        self.create_time = create_time
        # The frame rate. If a numeric value is returned, a fixed frame rate is configured for the output stream. If ws is returned, the output stream maintains the same frame rate as the input stream.
        self.fps = fps
        # The group of pictures (GOP) size. The GOP size can be defined by the number of frames or the time interval between I-frames. If ws is returned, the output stream maintains the same GOP size as the input stream.
        self.gop = gop
        # The template name.
        self.name = name
        # The resolution. If width and height values are returned, a fixed resolution is configured for the output stream. If ws is returned, the output stream maintains the same resolution as the input stream.
        # 
        # >  If the width value is -1, the width of the output video is adapted to a fixed height. If the height value is -2, the height of the output video is adapted to a fixed width.
        self.resolution = resolution
        # The ID of the edge transcoding template.
        self.template_id = template_id
        # The type of edge transcoding.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.name is not None:
            result['Name'] = self.name
        if self.resolution is not None:
            result['Resolution'] = self.resolution
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Resolution') is not None:
            self.resolution = m.get('Resolution')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListEdgeTranscodeTemplateResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        template: List[ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate] = None,
    ):
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class ListEdgeTranscodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_list: ListEdgeTranscodeTemplateResponseBodyTemplateList = None,
        total_count: int = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the edge transcoding templates.
        self.template_list = template_list
        # The total number of templates returned.
        self.total_count = total_count

    def validate(self):
        if self.template_list:
            self.template_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_list is not None:
            result['TemplateList'] = self.template_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateList') is not None:
            temp_model = ListEdgeTranscodeTemplateResponseBodyTemplateList()
            self.template_list = temp_model.from_map(m['TemplateList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListEdgeTranscodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEdgeTranscodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEdgeTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ListEventSubResponseBodySubscribers(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        channel_id: str = None,
        create_time: str = None,
        events: List[str] = None,
        modify_time: str = None,
        roles: int = None,
        sub_id: str = None,
        users: List[str] = None,
    ):
        # The callback URL.
        self.callback_url = callback_url
        # The ID of the channel to which you subscribe.
        self.channel_id = channel_id
        # The time when the subscription was created. The time is displayed in UTC+8. Format: yyyy-MM-dd hh:mm:ss.
        self.create_time = create_time
        # The type of the event. Valid values:
        # 
        # *   ChannelEvent: channel event. For example, the channel is opened or closed.
        # *   UserEvent: user event. For example, a user joins or leaves the channel.
        self.events = events
        # The time when the subscription was modified. The time is displayed in UTC+8. Format: yyyy-MM-dd hh:mm:ss.
        self.modify_time = modify_time
        # The role of the user whose events are returned. Valid values:
        # 
        # *   1: streamer
        # *   2: viewer
        # 
        # An empty value or a value other than 1 and 2 indicates that events of all users in the channel are returned.
        # 
        # >  This parameter is deprecated. When you create a subscription, this parameter is no longer supported.
        self.roles = roles
        # The ID of the event.
        self.sub_id = sub_id
        # The user whose events are returned. We recommend that you use either this parameter or Roles.
        self.users = users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.events is not None:
            result['Events'] = self.events
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Events') is not None:
            self.events = m.get('Events')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class ListEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscribers: List[ListEventSubResponseBodySubscribers] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The events.
        self.subscribers = subscribers

    def validate(self):
        if self.subscribers:
            for k in self.subscribers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Subscribers'] = []
        if self.subscribers is not None:
            for k in self.subscribers:
                result['Subscribers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.subscribers = []
        if m.get('Subscribers') is not None:
            for k in m.get('Subscribers'):
                temp_model = ListEventSubResponseBodySubscribers()
                self.subscribers.append(temp_model.from_map(k))
        return self


class ListEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventSubEventRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: int = None,
        page_no: int = None,
        page_size: int = None,
        start_time: int = None,
        subscribe_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The page number.
        # 
        # This parameter is required.
        self.page_no = page_no
        # The number of callback records to return on each page. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.
        self.subscribe_id = subscribe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        return self


class ListEventSubEventResponseBodyLogs(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        code: int = None,
        cost: int = None,
        data: str = None,
        message_id: str = None,
        sub_id: str = None,
        time: str = None,
        url: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The HTTP status code. A value of 200 indicates that the callback was successful.
        self.code = code
        # The callback duration. Unit: milliseconds.
        self.cost = cost
        # The details about the callback.
        self.data = data
        # The ID of the callback record.
        self.message_id = message_id
        # The subscription ID.
        self.sub_id = sub_id
        # The time when the callback was generated.
        self.time = time
        # The callback URL.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.code is not None:
            result['Code'] = self.code
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        if self.time is not None:
            result['Time'] = self.time
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListEventSubEventResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        has_more: bool = None,
        logs: List[ListEventSubEventResponseBodyLogs] = None,
        request_id: str = None,
    ):
        # The total number of callback records returned on the current page.
        self.count = count
        # Indicates whether the current page is followed by a page.
        self.has_more = has_more
        # The callback records.
        self.logs = logs
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = ListEventSubEventResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEventSubEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventSubEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventSubEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveDelayConfigRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        # The page number. Default value: 1.
        self.page_num = page_num
        # The number of entries per page. Valid values: 5 to 30. Default value: 10.
        self.page_size = page_size
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig(TeaModel):
    def __init__(
        self,
        app: str = None,
        delay_time: str = None,
        domain: str = None,
        stream: str = None,
        task_trigger_mode: str = None,
    ):
        # The name of the application to which the live stream belongs.
        self.app = app
        # The duration for which the playback of the live stream is delayed. Unit: seconds.
        self.delay_time = delay_time
        # The main streaming domain.
        self.domain = domain
        # The name of the live stream.
        self.stream = stream
        # The trigger mode. Valid values:
        # 
        # *   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
        # *   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
        # *   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.
        self.task_trigger_mode = task_trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.task_trigger_mode is not None:
            result['TaskTriggerMode'] = self.task_trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TaskTriggerMode') is not None:
            self.task_trigger_mode = m.get('TaskTriggerMode')
        return self


class ListLiveDelayConfigResponseBodyDelayConfigList(TeaModel):
    def __init__(
        self,
        delay_config: List[ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig] = None,
    ):
        self.delay_config = delay_config

    def validate(self):
        if self.delay_config:
            for k in self.delay_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DelayConfig'] = []
        if self.delay_config is not None:
            for k in self.delay_config:
                result['DelayConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.delay_config = []
        if m.get('DelayConfig') is not None:
            for k in m.get('DelayConfig'):
                temp_model = ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig()
                self.delay_config.append(temp_model.from_map(k))
        return self


class ListLiveDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        delay_config_list: ListLiveDelayConfigResponseBodyDelayConfigList = None,
        request_id: str = None,
        total: int = None,
    ):
        # The stream delay configurations.
        self.delay_config_list = delay_config_list
        # The request ID.
        self.request_id = request_id
        # The number of stream delay configurations.
        self.total = total

    def validate(self):
        if self.delay_config_list:
            self.delay_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay_config_list is not None:
            result['DelayConfigList'] = self.delay_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DelayConfigList') is not None:
            temp_model = ListLiveDelayConfigResponseBodyDelayConfigList()
            self.delay_config_list = temp_model.from_map(m['DelayConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListLiveDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveMessageAppsRequest(TeaModel):
    def __init__(
        self,
        data_center: str = None,
        next_page_token: int = None,
        sort_type: int = None,
    ):
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The starting page number for the query. If you leave this parameter empty or set this parameter to -1, the query starts from the first page.
        self.next_page_token = next_page_token
        # The sort order based on the creation time. Valid values:
        # 
        # *   1: ascending order
        # *   2: descending order
        # 
        # This parameter is required.
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListLiveMessageAppsResponseBodyAppList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_key: str = None,
        app_name: str = None,
        app_sign: str = None,
        create_time: int = None,
        data_center: str = None,
        disable: str = None,
        modify_time: int = None,
        msg_life_cycle: int = None,
    ):
        # The ID of the interactive messaging application queried.
        self.app_id = app_id
        # The AppKey of the interactive messaging application. It is used to authorize operations related to the application ID.
        self.app_key = app_key
        # The name of the application.
        self.app_name = app_name
        # The signature of the interactive messaging application. It is required by the interactive messaging SDK.
        self.app_sign = app_sign
        # The time when the application was created. The value is a UNIX timestamp. Unit: seconds.
        self.create_time = create_time
        # The live center.
        self.data_center = data_center
        # Indicates whether the interactive messaging application is disabled.
        self.disable = disable
        # The time when the application was last modified. The value is a UNIX timestamp. Unit: seconds.
        self.modify_time = modify_time
        # The retention period of group messages in the application. Valid values:
        # 
        # *   0 (default): 30 days
        # *   1: 90 days
        # *   2: 180 days
        self.msg_life_cycle = msg_life_cycle

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.disable is not None:
            result['Disable'] = self.disable
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.msg_life_cycle is not None:
            result['MsgLifeCycle'] = self.msg_life_cycle
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('Disable') is not None:
            self.disable = m.get('Disable')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('MsgLifeCycle') is not None:
            self.msg_life_cycle = m.get('MsgLifeCycle')
        return self


class ListLiveMessageAppsResponseBody(TeaModel):
    def __init__(
        self,
        app_list: List[ListLiveMessageAppsResponseBodyAppList] = None,
        has_more: bool = None,
        next_page_token: int = None,
        request_id: str = None,
    ):
        # The interactive messaging applications.
        self.app_list = app_list
        # Indicates whether the current page is followed by a page.
        self.has_more = has_more
        # The starting page number for the next query. This parameter is returned only if the value of HasMore is true.
        self.next_page_token = next_page_token
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.app_list:
            for k in self.app_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppList'] = []
        if self.app_list is not None:
            for k in self.app_list:
                result['AppList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_list = []
        if m.get('AppList') is not None:
            for k in m.get('AppList'):
                temp_model = ListLiveMessageAppsResponseBodyAppList()
                self.app_list.append(temp_model.from_map(k))
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveMessageAppsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveMessageAppsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveMessageAppsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveMessageGroupByPageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_status: int = None,
        page_number: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The status of the groups to query. Default value: 0. Valid values:
        # 
        # *   0: all groups
        # *   1: existing groups
        # *   2: deleted groups
        self.group_status = group_status
        # The page number. Valid values: [1,10000].
        # 
        # Default value: 1.
        self.page_number = page_number
        # The number of entries per page. Valid values:[1,50].
        # 
        # Default value: 20.
        self.page_size = page_size
        # The sort order based on the time when the groups were created. Valid values:
        # 
        # *   1: ascending order
        # *   2: descending order
        # 
        # This parameter is required.
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_status is not None:
            result['GroupStatus'] = self.group_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupStatus') is not None:
            self.group_status = m.get('GroupStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListLiveMessageGroupByPageResponseBodyGroupList(TeaModel):
    def __init__(
        self,
        admin_list: List[str] = None,
        createtime: int = None,
        creator_id: str = None,
        delete: bool = None,
        group_id: str = None,
        group_info: str = None,
        group_name: str = None,
    ):
        # The list of administrators.
        self.admin_list = admin_list
        # The time when the group was created. The value is a UNIX timestamp. Unit: seconds.
        self.createtime = createtime
        # The ID of the user who created the group.
        self.creator_id = creator_id
        # Indicates whether the group is deleted.
        self.delete = delete
        # The ID of the interactive messaging group.
        self.group_id = group_id
        # The additional information about the group.
        self.group_info = group_info
        # The name of the group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_list is not None:
            result['AdminList'] = self.admin_list
        if self.createtime is not None:
            result['Createtime'] = self.createtime
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.delete is not None:
            result['Delete'] = self.delete
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminList') is not None:
            self.admin_list = m.get('AdminList')
        if m.get('Createtime') is not None:
            self.createtime = m.get('Createtime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Delete') is not None:
            self.delete = m.get('Delete')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListLiveMessageGroupByPageResponseBody(TeaModel):
    def __init__(
        self,
        group_list: List[ListLiveMessageGroupByPageResponseBodyGroupList] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The list of groups.
        self.group_list = group_list
        # The page number.
        self.page_number = page_number
        # The number of entries returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.group_list:
            for k in self.group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupList'] = []
        if self.group_list is not None:
            for k in self.group_list:
                result['GroupList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_list = []
        if m.get('GroupList') is not None:
            for k in m.get('GroupList'):
                temp_model = ListLiveMessageGroupByPageResponseBodyGroupList()
                self.group_list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveMessageGroupByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveMessageGroupByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveMessageGroupByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveMessageGroupMessagesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        begin_time: int = None,
        data_center: str = None,
        end_time: int = None,
        group_id: str = None,
        msg_type: int = None,
        next_page_token: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The ID of the interactive messaging application to query.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter empty, the earliest available time is used.
        self.begin_time = begin_time
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter empty, the latest available time is used.
        self.end_time = end_time
        # The ID of the group to query.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The type of messages that you want to query. If you leave this parameter empty, all types of messages are queried.
        self.msg_type = msg_type
        # The starting page number for the query. If you leave this parameter empty, the query starts from the first page.
        self.next_page_token = next_page_token
        # The number of entries per page. Valid values: **10 to 50**.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The sort order based on the time when the messages were sent. Valid values:
        # 
        # *   1: ascending order
        # *   2: descending order
        # 
        # This parameter is required.
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.msg_type is not None:
            result['MsgType'] = self.msg_type
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MsgType') is not None:
            self.msg_type = m.get('MsgType')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListLiveMessageGroupMessagesResponseBodyMessageListSender(TeaModel):
    def __init__(
        self,
        user_id: str = None,
        user_info: str = None,
    ):
        # The ID of the user who sent the message.
        self.user_id = user_id
        # The additional information about the user who sent the message.
        self.user_info = user_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_info is not None:
            result['UserInfo'] = self.user_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserInfo') is not None:
            self.user_info = m.get('UserInfo')
        return self


class ListLiveMessageGroupMessagesResponseBodyMessageList(TeaModel):
    def __init__(
        self,
        body: str = None,
        msg_tid: str = None,
        msg_type: int = None,
        sender: ListLiveMessageGroupMessagesResponseBodyMessageListSender = None,
        seq_number: int = None,
        timestamp: int = None,
        total_messages: int = None,
    ):
        # The message body.
        self.body = body
        # The ID of the message.
        self.msg_tid = msg_tid
        # The type of the message.
        self.msg_type = msg_type
        # The details about the user who sent the message.
        self.sender = sender
        # The sequence number of the message.
        self.seq_number = seq_number
        # The time when the message was sent. The value is a UNIX timestamp. Unit: seconds.
        self.timestamp = timestamp
        # The total number of messages.
        self.total_messages = total_messages

    def validate(self):
        if self.sender:
            self.sender.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.msg_tid is not None:
            result['MsgTid'] = self.msg_tid
        if self.msg_type is not None:
            result['MsgType'] = self.msg_type
        if self.sender is not None:
            result['Sender'] = self.sender.to_map()
        if self.seq_number is not None:
            result['SeqNumber'] = self.seq_number
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_messages is not None:
            result['TotalMessages'] = self.total_messages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('MsgTid') is not None:
            self.msg_tid = m.get('MsgTid')
        if m.get('MsgType') is not None:
            self.msg_type = m.get('MsgType')
        if m.get('Sender') is not None:
            temp_model = ListLiveMessageGroupMessagesResponseBodyMessageListSender()
            self.sender = temp_model.from_map(m['Sender'])
        if m.get('SeqNumber') is not None:
            self.seq_number = m.get('SeqNumber')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalMessages') is not None:
            self.total_messages = m.get('TotalMessages')
        return self


class ListLiveMessageGroupMessagesResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        hasmore: bool = None,
        message_list: List[ListLiveMessageGroupMessagesResponseBodyMessageList] = None,
        next_page_token: int = None,
        request_id: str = None,
    ):
        # The ID of the group queried.
        self.group_id = group_id
        # Indicates whether the current page is followed by another page.
        self.hasmore = hasmore
        # Details about the messages.
        self.message_list = message_list
        # The starting page number for the next query. A value of 0 indicates that no further pages can be queried.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.message_list:
            for k in self.message_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.hasmore is not None:
            result['Hasmore'] = self.hasmore
        result['MessageList'] = []
        if self.message_list is not None:
            for k in self.message_list:
                result['MessageList'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Hasmore') is not None:
            self.hasmore = m.get('Hasmore')
        self.message_list = []
        if m.get('MessageList') is not None:
            for k in m.get('MessageList'):
                temp_model = ListLiveMessageGroupMessagesResponseBodyMessageList()
                self.message_list.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveMessageGroupMessagesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveMessageGroupMessagesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveMessageGroupMessagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveMessageGroupUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        next_page_token: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The ID of the interactive messaging application to query.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group to query.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The starting page number for the query. If you leave this parameter empty, the query starts from the first page.
        self.next_page_token = next_page_token
        # The number of entries per page. Valid values: **10 to 50**.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The sort order based on the time when the users joined the group. Valid values:
        # 
        # *   1: ascending order
        # *   2: descending order
        # 
        # This parameter is required.
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListLiveMessageGroupUsersResponseBodyUserList(TeaModel):
    def __init__(
        self,
        user_id: str = None,
        user_info: str = None,
    ):
        # The ID of the user.
        self.user_id = user_id
        # The additional information about the user.
        self.user_info = user_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_info is not None:
            result['UserInfo'] = self.user_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserInfo') is not None:
            self.user_info = m.get('UserInfo')
        return self


class ListLiveMessageGroupUsersResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        hasmore: bool = None,
        next_page_token: int = None,
        request_id: str = None,
        user_list: List[ListLiveMessageGroupUsersResponseBodyUserList] = None,
    ):
        # The ID of the group queried.
        self.group_id = group_id
        # Indicates whether the current page is followed by another page.
        self.hasmore = hasmore
        # The starting page number for the next query. A value of 0 indicates that no further pages can be queried.
        self.next_page_token = next_page_token
        # The request ID.
        self.request_id = request_id
        # Details about the users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.hasmore is not None:
            result['Hasmore'] = self.hasmore
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Hasmore') is not None:
            self.hasmore = m.get('Hasmore')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = ListLiveMessageGroupUsersResponseBodyUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class ListLiveMessageGroupUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveMessageGroupUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveMessageGroupUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveMessageGroupsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_status: int = None,
        next_page_token: int = None,
        sort_type: int = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The status of the groups to query. Default value: 0. Valid values:
        # 
        # *   0: all groups
        # *   1: existing groups
        # *   2: deleted groups
        self.group_status = group_status
        # The starting page number for the query. If you leave this parameter empty, the query starts from the first page.
        self.next_page_token = next_page_token
        # The sort order based on the time when the groups were created. Valid values:
        # 
        # *   1: ascending order
        # *   2: descending order
        # 
        # This parameter is required.
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_status is not None:
            result['GroupStatus'] = self.group_status
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupStatus') is not None:
            self.group_status = m.get('GroupStatus')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListLiveMessageGroupsResponseBodyGroupList(TeaModel):
    def __init__(
        self,
        admin_list: List[str] = None,
        createtime: int = None,
        creator_id: str = None,
        delete: bool = None,
        group_id: str = None,
        group_info: str = None,
        group_name: str = None,
    ):
        # The list of the IDs of the group administrators.
        self.admin_list = admin_list
        # The time when the group was created. The value is a UNIX timestamp. Unit: seconds.
        self.createtime = createtime
        # The ID of the group creator.
        self.creator_id = creator_id
        # Indicates whether the group is deleted.
        self.delete = delete
        # The ID of the group.
        self.group_id = group_id
        # The additional information about the group.
        self.group_info = group_info
        # The name of the group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_list is not None:
            result['AdminList'] = self.admin_list
        if self.createtime is not None:
            result['Createtime'] = self.createtime
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.delete is not None:
            result['Delete'] = self.delete
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminList') is not None:
            self.admin_list = m.get('AdminList')
        if m.get('Createtime') is not None:
            self.createtime = m.get('Createtime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Delete') is not None:
            self.delete = m.get('Delete')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListLiveMessageGroupsResponseBody(TeaModel):
    def __init__(
        self,
        group_list: List[ListLiveMessageGroupsResponseBodyGroupList] = None,
        hasmore: bool = None,
        nextpage_token: str = None,
        request_id: str = None,
    ):
        # Details about the groups.
        self.group_list = group_list
        # Indicates whether the current page is followed by another page.
        self.hasmore = hasmore
        # The starting page number for the next query. This parameter is returned only if the value of Hasmore is true.
        self.nextpage_token = nextpage_token
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.group_list:
            for k in self.group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupList'] = []
        if self.group_list is not None:
            for k in self.group_list:
                result['GroupList'].append(k.to_map() if k else None)
        if self.hasmore is not None:
            result['Hasmore'] = self.hasmore
        if self.nextpage_token is not None:
            result['NextpageToken'] = self.nextpage_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_list = []
        if m.get('GroupList') is not None:
            for k in m.get('GroupList'):
                temp_model = ListLiveMessageGroupsResponseBodyGroupList()
                self.group_list.append(temp_model.from_map(k))
        if m.get('Hasmore') is not None:
            self.hasmore = m.get('Hasmore')
        if m.get('NextpageToken') is not None:
            self.nextpage_token = m.get('NextpageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveMessageGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveMessageGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveMessageGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        live_openapi_reserve: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # This parameter has no practical significance.
        self.live_openapi_reserve = live_openapi_reserve
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_openapi_reserve is not None:
            result['LiveOpenapiReserve'] = self.live_openapi_reserve
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveOpenapiReserve') is not None:
            self.live_openapi_reserve = m.get('LiveOpenapiReserve')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo(TeaModel):
    def __init__(
        self,
        dm_id: int = None,
        domain_name: str = None,
        logstore: str = None,
        project: str = None,
        region: str = None,
        status: str = None,
    ):
        # The ID of the domain name.
        self.dm_id = dm_id
        # The streaming domain.
        self.domain_name = domain_name
        # The name of the Logstore to which log entries are delivered.
        self.logstore = logstore
        # The name of the Log Service project that is used for real-time log delivery.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        self.region = region
        # The status of real-time log delivery. Valid values:
        # 
        # *   **online**: enabled
        # *   **offline**: disabled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dm_id is not None:
            result['DmId'] = self.dm_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DmId') is not None:
            self.dm_id = m.get('DmId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLiveRealtimeLogDeliveryResponseBodyContent(TeaModel):
    def __init__(
        self,
        realtime_log_delivery_info: List[ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo] = None,
    ):
        self.realtime_log_delivery_info = realtime_log_delivery_info

    def validate(self):
        if self.realtime_log_delivery_info:
            for k in self.realtime_log_delivery_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RealtimeLogDeliveryInfo'] = []
        if self.realtime_log_delivery_info is not None:
            for k in self.realtime_log_delivery_info:
                result['RealtimeLogDeliveryInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.realtime_log_delivery_info = []
        if m.get('RealtimeLogDeliveryInfo') is not None:
            for k in m.get('RealtimeLogDeliveryInfo'):
                temp_model = ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo()
                self.realtime_log_delivery_info.append(temp_model.from_map(k))
        return self


class ListLiveRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        content: ListLiveRealtimeLogDeliveryResponseBodyContent = None,
        request_id: str = None,
    ):
        # The configurations of real-time log delivery.
        self.content = content
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = ListLiveRealtimeLogDeliveryResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRealtimeLogDeliveryDomainsRequest(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        owner_id: int = None,
        project: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The name of the Logstore to which log entries are delivered.
        # 
        # This parameter is required.
        self.logstore = logstore
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery.
        # 
        # This parameter is required.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        status: str = None,
    ):
        # The streaming domain.
        self.domain_name = domain_name
        # The status of real-time log delivery. Valid values:
        # 
        # *   **online**: enabled
        # *   **offline**: disabled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLiveRealtimeLogDeliveryDomainsResponseBodyContent(TeaModel):
    def __init__(
        self,
        domains: List[ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains] = None,
    ):
        self.domains = domains

    def validate(self):
        if self.domains:
            for k in self.domains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Domains'] = []
        if self.domains is not None:
            for k in self.domains:
                result['Domains'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domains = []
        if m.get('Domains') is not None:
            for k in m.get('Domains'):
                temp_model = ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains()
                self.domains.append(temp_model.from_map(k))
        return self


class ListLiveRealtimeLogDeliveryDomainsResponseBody(TeaModel):
    def __init__(
        self,
        content: ListLiveRealtimeLogDeliveryDomainsResponseBodyContent = None,
        request_id: str = None,
    ):
        # The domain names.
        self.content = content
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = ListLiveRealtimeLogDeliveryDomainsResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveRealtimeLogDeliveryDomainsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRealtimeLogDeliveryDomainsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRealtimeLogDeliveryDomainsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRealtimeLogDeliveryInfosRequest(TeaModel):
    def __init__(
        self,
        live_openapi_reserve: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # This parameter has no practical significance.
        self.live_openapi_reserve = live_openapi_reserve
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_openapi_reserve is not None:
            result['LiveOpenapiReserve'] = self.live_openapi_reserve
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LiveOpenapiReserve') is not None:
            self.live_openapi_reserve = m.get('LiveOpenapiReserve')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region: str = None,
    ):
        # The name of the Logstore to which log entries are delivered.
        self.logstore = logstore
        # The name of the Log Service project that is used for real-time log delivery.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        self.region = region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class ListLiveRealtimeLogDeliveryInfosResponseBodyContent(TeaModel):
    def __init__(
        self,
        realtime_log_delivery_infos: List[ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos] = None,
    ):
        self.realtime_log_delivery_infos = realtime_log_delivery_infos

    def validate(self):
        if self.realtime_log_delivery_infos:
            for k in self.realtime_log_delivery_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RealtimeLogDeliveryInfos'] = []
        if self.realtime_log_delivery_infos is not None:
            for k in self.realtime_log_delivery_infos:
                result['RealtimeLogDeliveryInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.realtime_log_delivery_infos = []
        if m.get('RealtimeLogDeliveryInfos') is not None:
            for k in m.get('RealtimeLogDeliveryInfos'):
                temp_model = ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos()
                self.realtime_log_delivery_infos.append(temp_model.from_map(k))
        return self


class ListLiveRealtimeLogDeliveryInfosResponseBody(TeaModel):
    def __init__(
        self,
        content: ListLiveRealtimeLogDeliveryInfosResponseBodyContent = None,
        request_id: str = None,
    ):
        # Details about the configuration of real-time log delivery.
        self.content = content
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = ListLiveRealtimeLogDeliveryInfosResponseBodyContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListLiveRealtimeLogDeliveryInfosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLiveRealtimeLogDeliveryInfosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRealtimeLogDeliveryInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        page_num: int = None,
        page_size: int = None,
        sort_type: int = None,
        type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The number of the page to return. Default value: 1. Valid values: 1 to 100000.
        # 
        # This parameter is required.
        self.page_num = page_num
        # The number of entries to return on each page. Default value: 20. Valid values: 1 to 50.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The sort order. Valid values:
        # 
        # *   0: ascending order by time
        # *   1: descending order by time
        self.sort_type = sort_type
        # The type of the custom message. Valid values: integers greater than 10000.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMessageResponseBodyResultMessageList(TeaModel):
    def __init__(
        self,
        data: str = None,
        group_id: str = None,
        message_id: str = None,
        sender_id: str = None,
        type: int = None,
    ):
        # The message body. The value is a JSON string.
        self.data = data
        # The ID of the message group.
        self.group_id = group_id
        # The ID of the message.
        self.message_id = message_id
        # The ID of the user who sent the message.
        self.sender_id = sender_id
        # The type of the message.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMessageResponseBodyResult(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        message_list: List[ListMessageResponseBodyResultMessageList] = None,
    ):
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true: The current page is followed by another page.
        # *   false: The current page is not followed by another page.
        self.has_more = has_more
        # Details about the messages.
        self.message_list = message_list

    def validate(self):
        if self.message_list:
            for k in self.message_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        result['MessageList'] = []
        if self.message_list is not None:
            for k in self.message_list:
                result['MessageList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        self.message_list = []
        if m.get('MessageList') is not None:
            for k in m.get('MessageList'):
                temp_model = ListMessageResponseBodyResultMessageList()
                self.message_list.append(temp_model.from_map(k))
        return self


class ListMessageResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMessageResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMessageResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMessageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageAppRequest(TeaModel):
    def __init__(
        self,
        page_num: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The number of the page to return. Default value: 1. Valid values: 1 to 100000.
        # 
        # This parameter is required.
        self.page_num = page_num
        # The number of applications to return on each page. Default value: 20. Valid values: 1 to 50.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The sort order. Valid values:
        # 
        # *   0: ascending order by time
        # *   1: descending order by time
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListMessageAppResponseBodyResultAppList(TeaModel):
    def __init__(
        self,
        app_config: Dict[str, str] = None,
        app_id: str = None,
        app_name: str = None,
        create_time: int = None,
        extension: Dict[str, str] = None,
        status: int = None,
    ):
        # The configurations of the application.
        self.app_config = app_config
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The time when the interactive messaging application was created. The time is displayed in UTC.
        self.create_time = create_time
        # The extended field.
        self.extension = extension
        # The status of the interactive message application. A value of **1** indicates that the application is normal.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        app_list: List[ListMessageAppResponseBodyResultAppList] = None,
        has_more: bool = None,
        total: int = None,
    ):
        # Details about the applications.
        self.app_list = app_list
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true: The current page is followed by another page.
        # *   false: The current page is not followed by another page.
        self.has_more = has_more
        # The total number of interactive message applications.
        self.total = total

    def validate(self):
        if self.app_list:
            for k in self.app_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppList'] = []
        if self.app_list is not None:
            for k in self.app_list:
                result['AppList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_list = []
        if m.get('AppList') is not None:
            for k in m.get('AppList'):
                temp_model = ListMessageAppResponseBodyResultAppList()
                self.app_list.append(temp_model.from_map(k))
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMessageAppResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMessageAppResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_num: int = None,
        page_size: int = None,
        sort_type: int = None,
        user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The number of the page to return. Default value: 1. Valid values: 1 to 100000.
        # 
        # This parameter is required.
        self.page_num = page_num
        # The number of message groups to return on each page. Default value: 20.
        # 
        # Valid values: 1 to 50.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The sort order. Valid values:
        # 
        # *   0: ascending order by time
        # *   1: descending order by time
        self.sort_type = sort_type
        # The ID of the user. Each user has a unique ID in the application. You can specify multiple user IDs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListMessageGroupResponseBodyResultGroupList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: int = None,
        creator_id: str = None,
        extension: Dict[str, str] = None,
        group_id: str = None,
        status: int = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The time when the message group was created. The time is displayed in UTC.
        self.create_time = create_time
        # The ID of the creator.
        self.creator_id = creator_id
        # The extended field.
        self.extension = extension
        # The ID of the message group.
        self.group_id = group_id
        # The status of the message group. The default value is **1**, which indicates that the status of the message group is normal.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        group_list: List[ListMessageGroupResponseBodyResultGroupList] = None,
        has_more: bool = None,
        total: int = None,
    ):
        # The list of message groups.
        self.group_list = group_list
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true: The current page is followed by another page.
        # *   false: The current page is not followed by another page.
        self.has_more = has_more
        # The total number of message groups.
        self.total = total

    def validate(self):
        if self.group_list:
            for k in self.group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupList'] = []
        if self.group_list is not None:
            for k in self.group_list:
                result['GroupList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_list = []
        if m.get('GroupList') is not None:
            for k in m.get('GroupList'):
                temp_model = ListMessageGroupResponseBodyResultGroupList()
                self.group_list.append(temp_model.from_map(k))
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        page_num: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The number of the page to return. Default value: 1.
        # 
        # Valid values: 1 to 100000.
        self.page_num = page_num
        # The number of members to return on each page. Default value: 20.
        # 
        # Valid values: 1 to 50.
        self.page_size = page_size
        # The sort order. Valid values:
        # 
        # *   0: ascending order by time
        # *   1: descending order by time
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class ListMessageGroupUserResponseBodyResultUserList(TeaModel):
    def __init__(
        self,
        join_time: int = None,
        user_id: str = None,
    ):
        # The time when the user joined the message group. The value is a UTC timestamp.
        self.join_time = join_time
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_time is not None:
            result['JoinTime'] = self.join_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTime') is not None:
            self.join_time = m.get('JoinTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListMessageGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        total: int = None,
        user_list: List[ListMessageGroupUserResponseBodyResultUserList] = None,
    ):
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true: The current page is followed by another page.
        # *   false: The current page is not followed by another page.
        self.has_more = has_more
        # The total number of users in the message group.
        self.total = total
        # Details about the users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total is not None:
            result['Total'] = self.total
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = ListMessageGroupUserResponseBodyResultUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class ListMessageGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMessageGroupUserResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMessageGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMessageGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMessageGroupUserByIdRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        user_id_list: List[str] = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The list of users.
        # 
        # This parameter is required.
        self.user_id_list = user_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class ListMessageGroupUserByIdShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        user_id_list_shrink: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The list of users.
        # 
        # This parameter is required.
        self.user_id_list_shrink = user_id_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.user_id_list_shrink is not None:
            result['UserIdList'] = self.user_id_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UserIdList') is not None:
            self.user_id_list_shrink = m.get('UserIdList')
        return self


class ListMessageGroupUserByIdResponseBodyResultUserList(TeaModel):
    def __init__(
        self,
        is_mute: bool = None,
        mute_by: List[str] = None,
        user_avatar: str = None,
        user_extension: str = None,
        user_id: str = None,
        user_nick: str = None,
    ):
        # Indicates whether the user is muted. Valid values:
        # 
        # *   true: The user is muted.
        # *   false: The user is not muted.
        self.is_mute = is_mute
        # The type of the mute. Valid values:
        # 
        # *   group: All members in the message group are muted.
        # *   user: Specific members in the message group are muted.
        self.mute_by = mute_by
        # The URL of the profile picture of the user.
        self.user_avatar = user_avatar
        # The custom information about the user.
        self.user_extension = user_extension
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_mute is not None:
            result['IsMute'] = self.is_mute
        if self.mute_by is not None:
            result['MuteBy'] = self.mute_by
        if self.user_avatar is not None:
            result['UserAvatar'] = self.user_avatar
        if self.user_extension is not None:
            result['UserExtension'] = self.user_extension
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsMute') is not None:
            self.is_mute = m.get('IsMute')
        if m.get('MuteBy') is not None:
            self.mute_by = m.get('MuteBy')
        if m.get('UserAvatar') is not None:
            self.user_avatar = m.get('UserAvatar')
        if m.get('UserExtension') is not None:
            self.user_extension = m.get('UserExtension')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class ListMessageGroupUserByIdResponseBodyResult(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        total: int = None,
        user_list: List[ListMessageGroupUserByIdResponseBodyResultUserList] = None,
    ):
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true
        # *   false
        self.has_more = has_more
        # The total number of users returned.
        self.total = total
        # The list of users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total is not None:
            result['Total'] = self.total
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = ListMessageGroupUserByIdResponseBodyResultUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class ListMessageGroupUserByIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMessageGroupUserByIdResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned results.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMessageGroupUserByIdResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMessageGroupUserByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMessageGroupUserByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMessageGroupUserByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMuteGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        group_id: str = None,
        operator_user_id: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the messaging group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id
        # The page number. Default value: 1. Valid values: 1 to 100000.
        # 
        # This parameter is required.
        self.page_num = page_num
        # The number of entries per page. Default value: 20. Valid values: 1 to 50.
        # 
        # This parameter is required.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListMuteGroupUserResponseBodyResultUserList(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        # The ID of the muted user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListMuteGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        has_more: bool = None,
        total: int = None,
        user_list: List[ListMuteGroupUserResponseBodyResultUserList] = None,
    ):
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true
        # *   false
        self.has_more = has_more
        # The total number of muted members.
        self.total = total
        # The list of muted users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total is not None:
            result['Total'] = self.total
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = ListMuteGroupUserResponseBodyResultUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class ListMuteGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: ListMuteGroupUserResponseBodyResult = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = ListMuteGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class ListMuteGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMuteGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMuteGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPlaylistRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        page: int = None,
        page_size: int = None,
        program_id: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the episode list. If you set this parameter, only the information about the specified episode lists is returned. If you do not set this parameter, the information about all episode lists that belong to the account is returned. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        self.program_id = program_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListPlaylistResponseBodyProgramList(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        domain_name: str = None,
        program_id: str = None,
        program_name: str = None,
        repeat_number: int = None,
        status: int = None,
    ):
        # The ID of the production studio to which the episode list belongs. You can use the ID as a request parameter in the API operation that is used to add a layout to the virtual studio, delete a layout in the virtual studio, modify a layout of the virtual studio, or query layouts of the virtual studio.
        self.caster_id = caster_id
        # The main streaming domain.
        self.domain_name = domain_name
        # The ID of the episode list.
        self.program_id = program_id
        # The name of the episode list.
        self.program_name = program_name
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   **0** (default): specifies that the episode list is played only once.
        # *   **-1**: specifies that the episode list is played in loop mode.
        # *   Positive integer: specifies the number of times the episode list repeats after the first playback is complete.
        self.repeat_number = repeat_number
        # The status of the episode list. Valid values:
        # 
        # *   **0**: stopped
        # *   **1**: running
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPlaylistResponseBody(TeaModel):
    def __init__(
        self,
        program_list: List[ListPlaylistResponseBodyProgramList] = None,
        request_id: str = None,
        total: int = None,
    ):
        # The episode lists.
        self.program_list = program_list
        # The request ID.
        self.request_id = request_id
        # The total number of episode lists returned.
        self.total = total

    def validate(self):
        if self.program_list:
            for k in self.program_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProgramList'] = []
        if self.program_list is not None:
            for k in self.program_list:
                result['ProgramList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.program_list = []
        if m.get('ProgramList') is not None:
            for k in m.get('ProgramList'):
                temp_model = ListPlaylistResponseBodyProgramList()
                self.program_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListPlaylistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPlaylistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPlaylistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPlaylistItemsRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_id: str = None,
        program_item_ids: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        # The IDs of the episodes that you want to query. Separate episode IDs with commas (,). If you set this parameter, only the information about the specified episodes is returned. If you do not set this parameter, the information about all episodes in the episode list is returned.
        self.program_item_ids = program_item_ids
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_item_ids is not None:
            result['ProgramItemIds'] = self.program_item_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramItemIds') is not None:
            self.program_item_ids = m.get('ProgramItemIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListPlaylistItemsResponseBodyProgramItems(TeaModel):
    def __init__(
        self,
        index: int = None,
        program_id: str = None,
        program_item_id: str = None,
        program_item_name: str = None,
        resource_type: str = None,
        resource_value: str = None,
    ):
        # The sequence number of the episode in the query result.
        self.index = index
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to edit the episode list, delete the episode list, query the information about the episode list, start the episode list, or stop the episode list.
        self.program_id = program_id
        # The ID of the episode.
        self.program_item_id = program_item_id
        # The name of the episode.
        self.program_item_name = program_item_name
        # The resource type.
        self.resource_type = resource_type
        # The resource ID.
        self.resource_value = resource_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.program_item_id is not None:
            result['ProgramItemId'] = self.program_item_id
        if self.program_item_name is not None:
            result['ProgramItemName'] = self.program_item_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.resource_value is not None:
            result['ResourceValue'] = self.resource_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('ProgramItemId') is not None:
            self.program_item_id = m.get('ProgramItemId')
        if m.get('ProgramItemName') is not None:
            self.program_item_name = m.get('ProgramItemName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('ResourceValue') is not None:
            self.resource_value = m.get('ResourceValue')
        return self


class ListPlaylistItemsResponseBody(TeaModel):
    def __init__(
        self,
        program_items: List[ListPlaylistItemsResponseBodyProgramItems] = None,
        request_id: str = None,
        total: int = None,
    ):
        # The episodes.
        self.program_items = program_items
        # The request ID.
        self.request_id = request_id
        # The total number of episodes.
        self.total = total

    def validate(self):
        if self.program_items:
            for k in self.program_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProgramItems'] = []
        if self.program_items is not None:
            for k in self.program_items:
                result['ProgramItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.program_items = []
        if m.get('ProgramItems') is not None:
            for k in m.get('ProgramItems'):
                temp_model = ListPlaylistItemsResponseBodyProgramItems()
                self.program_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListPlaylistItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPlaylistItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPlaylistItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRTCLiveRoomsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.page_no = page_no
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListRTCLiveRoomsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rooms: List[str] = None,
        total: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.rooms = rooms
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rooms is not None:
            result['Rooms'] = self.rooms
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Rooms') is not None:
            self.rooms = m.get('Rooms')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListRTCLiveRoomsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRTCLiveRoomsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRTCLiveRoomsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRtcMPUEventSubRecordRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: str = None,
        page_no: int = None,
        page_size: int = None,
        start_time: str = None,
        sub_id: str = None,
    ):
        # The ID of the application.
        # 
        # >  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The page number.
        # 
        # This parameter is required.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The ID of the subscription.
        self.sub_id = sub_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        return self


class ListRtcMPUEventSubRecordResponseBodyLogs(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        cost: int = None,
        data: str = None,
        httpcode: str = None,
        msg_id: str = None,
        sub_id: str = None,
        time: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The callback URL.
        self.callback_url = callback_url
        # The callback duration. Unit: milliseconds.
        self.cost = cost
        # For more information about the callback, see [CreateRtcMPUEventSub](https://help.aliyun.com/document_detail/2804583.html).
        self.data = data
        # The HTTP status code. 200 indicates that the callback is successful.
        self.httpcode = httpcode
        # The ID of the callback record.
        self.msg_id = msg_id
        # The ID of the subscription.
        self.sub_id = sub_id
        # The time when the callback was invoked. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.cost is not None:
            result['Cost'] = self.cost
        if self.data is not None:
            result['Data'] = self.data
        if self.httpcode is not None:
            result['HTTPCode'] = self.httpcode
        if self.msg_id is not None:
            result['MsgId'] = self.msg_id
        if self.sub_id is not None:
            result['SubId'] = self.sub_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('Cost') is not None:
            self.cost = m.get('Cost')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HTTPCode') is not None:
            self.httpcode = m.get('HTTPCode')
        if m.get('MsgId') is not None:
            self.msg_id = m.get('MsgId')
        if m.get('SubId') is not None:
            self.sub_id = m.get('SubId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class ListRtcMPUEventSubRecordResponseBody(TeaModel):
    def __init__(
        self,
        count: int = None,
        has_more: bool = None,
        logs: List[ListRtcMPUEventSubRecordResponseBodyLogs] = None,
        request_id: str = None,
    ):
        # The number of entries per page.
        self.count = count
        # Indicates whether the current page is followed by a page.
        self.has_more = has_more
        # The callback records.
        self.logs = logs
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = ListRtcMPUEventSubRecordResponseBodyLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRtcMPUEventSubRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRtcMPUEventSubRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRtcMPUEventSubRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRtcMPUTaskDetailRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_no: int = None,
        page_size: int = None,
        task_id: str = None,
    ):
        # The ID of the application.
        # 
        # >  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The page number.
        self.page_no = page_no
        # The number of entries per page. Valid values: 1 to 100.
        # 
        # >  If you do not specify TaskId, you must specify PageSize and PageNo. Then, the parameters of all stream relay tasks for the specified application are returned in pages.
        self.page_size = page_size
        # The task ID.
        # 
        # > 
        # 
        # *   The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # *   If you specify TaskId, the parameters of the specified tasks are returned.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL(TeaModel):
    def __init__(
        self,
        is_ali_cdn: bool = None,
        url: str = None,
    ):
        # Indicates whether stream relay is performed by using Alibaba Cloud CDN. Valid values:
        # 
        # *   false: Stream relay is performed by using a CDN service that is not Alibaba Cloud CDN.
        # *   true: Stream relay is performed by using Alibaba Cloud CDN.
        self.is_ali_cdn = is_ali_cdn
        # The ingest URL.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_ali_cdn is not None:
            result['IsAliCdn'] = self.is_ali_cdn
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsAliCdn') is not None:
            self.is_ali_cdn = m.get('IsAliCdn')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
    ):
        # Indicates whether to add SEI messages to Instantaneous Decoder Refresh (IDR) frames. Valid values:
        # 
        # *   0: does not add SEI messages.
        # *   1: adds SEI messages.
        self.follow_idr = follow_idr
        # The interval at which the SEI messages are added. Unit: milliseconds.
        self.interval = interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
        payload_content: str = None,
        payload_content_key: str = None,
    ):
        # Indicates whether to add SEI messages to Instantaneous Decoder Refresh (IDR) frames. Valid values:
        # 
        # *   0: does not add SEI messages.
        # *   1: adds SEI messages.
        self.follow_idr = follow_idr
        # The interval at which the SEI messages are added. Unit: milliseconds.
        self.interval = interval
        # The payload content of the custom SEI.
        self.payload_content = payload_content
        # The key of the payload content. Default value: udd.
        self.payload_content_key = payload_content_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.payload_content is not None:
            result['PayloadContent'] = self.payload_content
        if self.payload_content_key is not None:
            result['PayloadContentKey'] = self.payload_content_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PayloadContent') is not None:
            self.payload_content = m.get('PayloadContent')
        if m.get('PayloadContentKey') is not None:
            self.payload_content_key = m.get('PayloadContentKey')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams(TeaModel):
    def __init__(
        self,
        layout_volume: ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume = None,
        pass_through: ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough = None,
        payload_type: str = None,
    ):
        # The layout and volume SEI. If the return value is an empty string, the default layout and volume SEI is used.
        self.layout_volume = layout_volume
        # The custom SEI.
        self.pass_through = pass_through
        # The custom payload type. Valid values: 100 to 254. Default value: 5.
        self.payload_type = payload_type

    def validate(self):
        if self.layout_volume:
            self.layout_volume.validate()
        if self.pass_through:
            self.pass_through.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_volume is not None:
            result['LayoutVolume'] = self.layout_volume.to_map()
        if self.pass_through is not None:
            result['PassThrough'] = self.pass_through.to_map()
        if self.payload_type is not None:
            result['PayloadType'] = self.payload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutVolume') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume()
            self.layout_volume = temp_model.from_map(m['LayoutVolume'])
        if m.get('PassThrough') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough()
            self.pass_through = temp_model.from_map(m['PassThrough'])
        if m.get('PayloadType') is not None:
            self.payload_type = m.get('PayloadType')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams(TeaModel):
    def __init__(
        self,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:
        # 
        # *   camera (default): captures the video by using a camera.
        # *   shareScreen: captures the content displayed on a screen.
        self.source_type = source_type
        # The type of the stream that is relayed. Valid values:
        # 
        # *   0 (default): the original stream.
        # *   1: the audio-only stream.
        # *   2: the video-only stream.
        self.stream_type = stream_type
        # The ID of the user whose stream is relayed. In single-stream relay mode, you can relay only one stream in a request.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground(TeaModel):
    def __init__(
        self,
        render_mode: str = None,
        url: str = None,
    ):
        # The display mode. Valid values:
        # 
        # *   0: proportionally scales the video or background image to fit the pane. Black bars are added to fill the extra space.
        # *   1 (default): crops the video or background image to fit the pane.
        self.render_mode = render_mode
        # The URL of the global background image.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams(TeaModel):
    def __init__(
        self,
        audio_bitrate: str = None,
        audio_channels: str = None,
        audio_only: str = None,
        audio_sample_rate: str = None,
        enhanced_param: str = None,
        video_bitrate: str = None,
        video_codec: str = None,
        video_framerate: str = None,
        video_gop: str = None,
        video_height: str = None,
        video_width: str = None,
    ):
        # The bitrate of the audio. Unit: Kbit/s.
        self.audio_bitrate = audio_bitrate
        # The number of audio channels. Valid values: 1 and 2.
        self.audio_channels = audio_channels
        # Indicates whether the output stream is an audio-only stream. Valid values:
        # 
        # *   true
        # *   false (default)
        self.audio_only = audio_only
        # The audio sampling rate. Unit: Hz.
        self.audio_sample_rate = audio_sample_rate
        # The parameter for advanced video encoding. The value is a JSON string. Optional fields:
        # 
        # *   profile: the encoding level. If the video encoding format is set to H.264, the valid values of this field are baseline, main, and high.
        # *   preset: adjusts the trade-off between encoding speed and video quality. Valid values: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.
        self.enhanced_param = enhanced_param
        # The bitrate of the video. Unit: Kbit/s.
        self.video_bitrate = video_bitrate
        # The video encoding format. Default value: H.264.
        self.video_codec = video_codec
        # The frame rate of the video. Unit: frames per second (FPS).
        self.video_framerate = video_framerate
        # The group of pictures (GOP) size of the video.
        self.video_gop = video_gop
        # The height of the video. Unit: pixels.
        self.video_height = video_height
        # The width of the video. Unit: pixels.
        self.video_width = video_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channels is not None:
            result['AudioChannels'] = self.audio_channels
        if self.audio_only is not None:
            result['AudioOnly'] = self.audio_only
        if self.audio_sample_rate is not None:
            result['AudioSampleRate'] = self.audio_sample_rate
        if self.enhanced_param is not None:
            result['EnhancedParam'] = self.enhanced_param
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_framerate is not None:
            result['VideoFramerate'] = self.video_framerate
        if self.video_gop is not None:
            result['VideoGop'] = self.video_gop
        if self.video_height is not None:
            result['VideoHeight'] = self.video_height
        if self.video_width is not None:
            result['VideoWidth'] = self.video_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannels') is not None:
            self.audio_channels = m.get('AudioChannels')
        if m.get('AudioOnly') is not None:
            self.audio_only = m.get('AudioOnly')
        if m.get('AudioSampleRate') is not None:
            self.audio_sample_rate = m.get('AudioSampleRate')
        if m.get('EnhancedParam') is not None:
            self.enhanced_param = m.get('EnhancedParam')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoFramerate') is not None:
            self.video_framerate = m.get('VideoFramerate')
        if m.get('VideoGop') is not None:
            self.video_gop = m.get('VideoGop')
        if m.get('VideoHeight') is not None:
            self.video_height = m.get('VideoHeight')
        if m.get('VideoWidth') is not None:
            self.video_width = m.get('VideoWidth')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the user is.
        self.channel_id = channel_id
        # The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:
        # 
        # *   camera (default): captures the video by using a camera.
        # *   shareScreen: captures the content displayed on a screen.
        self.source_type = source_type
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes(TeaModel):
    def __init__(
        self,
        background_image_url: str = None,
        height: str = None,
        render_mode: str = None,
        user_info: ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo = None,
        width: str = None,
        x: str = None,
        y: str = None,
        zorder: str = None,
    ):
        # The URL of the background image of the pane. This image is displayed if the user turns off the camera or is not present in the channel.
        self.background_image_url = background_image_url
        # The height of the pane. The value is normalized.
        self.height = height
        # The display mode. Valid values:
        # 
        # *   0: proportionally scales the video or background image to fit the pane. Black bars are added to fill the extra space.
        # *   1 (default): crops the video or background image to fit the pane.
        self.render_mode = render_mode
        # The information about the user whose stream is played in the pane.
        self.user_info = user_info
        # The width of the pane. The value is normalized.
        self.width = width
        # The x-coordinate of the pane. The value is normalized.
        self.x = x
        # The y-coordinate of the pane. The value is normalized.
        self.y = y
        # The layer of the pane. A value of 0 indicates that the pane is placed at the bottom layer. A larger value indicates a higher layer.
        self.zorder = zorder

    def validate(self):
        if self.user_info:
            self.user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_image_url is not None:
            result['BackgroundImageUrl'] = self.background_image_url
        if self.height is not None:
            result['Height'] = self.height
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.user_info is not None:
            result['UserInfo'] = self.user_info.to_map()
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundImageUrl') is not None:
            self.background_image_url = m.get('BackgroundImageUrl')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('UserInfo') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo()
            self.user_info = temp_model.from_map(m['UserInfo'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout(TeaModel):
    def __init__(
        self,
        user_panes: List[ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes] = None,
    ):
        # The information about the panes.
        self.user_panes = user_panes

    def validate(self):
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the user is.
        self.channel_id = channel_id
        # The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:
        # 
        # *   camera (default): captures the video by using a camera.
        # *   shareScreen: captures the content displayed on a screen.
        self.source_type = source_type
        # The type of the stream that is relayed. Valid values:
        # 
        # *   0 (default): the original stream.
        # *   1: the audio-only stream.
        # *   2: the video-only stream.
        self.stream_type = stream_type
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams(TeaModel):
    def __init__(
        self,
        background: ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground = None,
        encode_params: ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams = None,
        layout: ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout = None,
        user_infos: List[ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos] = None,
    ):
        # The global background image.
        self.background = background
        # The encoding parameters of the output stream.
        self.encode_params = encode_params
        # The video layout information.
        # 
        # >  The video layout information includes the x-coordinate, y-coordinate, width, height, and layer of the pane. For audio-only transcoding, no video layout information is returned.
        self.layout = layout
        # The information about the user whose stream is mixed. If an empty value is returned, streams from all users are mixed.
        self.user_infos = user_infos

    def validate(self):
        if self.background:
            self.background.validate()
        if self.encode_params:
            self.encode_params.validate()
        if self.layout:
            self.layout.validate()
        if self.user_infos:
            for k in self.user_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background is not None:
            result['Background'] = self.background.to_map()
        if self.encode_params is not None:
            result['EncodeParams'] = self.encode_params.to_map()
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        result['UserInfos'] = []
        if self.user_infos is not None:
            for k in self.user_infos:
                result['UserInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Background') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground()
            self.background = temp_model.from_map(m['Background'])
        if m.get('EncodeParams') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams()
            self.encode_params = temp_model.from_map(m['EncodeParams'])
        if m.get('Layout') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout()
            self.layout = temp_model.from_map(m['Layout'])
        self.user_infos = []
        if m.get('UserInfos') is not None:
            for k in m.get('UserInfos'):
                temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos()
                self.user_infos.append(temp_model.from_map(k))
        return self


class ListRtcMPUTaskDetailResponseBodyMPUTasks(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        max_idle_time: str = None,
        mix_mode: str = None,
        multi_stream_url: List[ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL] = None,
        region: str = None,
        sei_params: ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams = None,
        single_sub_params: ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams = None,
        stream_url: str = None,
        task_id: str = None,
        transcode_params: ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The ID of the channel.
        self.channel_id = channel_id
        # The timeout period of an idle connection. Unit: seconds.
        # 
        # >  If the task is idle for a period of time longer than the duration specified by the MaxIdleTime parameter, the task is automatically stopped. If the parameter is not specified, the task is stopped after the channel is closed.
        self.max_idle_time = max_idle_time
        # The stream mixing mode. Valid values:
        # 
        # *   0: relays the original single stream without mixing streams. If the value of this parameter is 0, the TranscodeParams parameter is empty.
        # *   1 (default): mixes multiple streams into a single stream and relays the mixed stream.
        self.mix_mode = mix_mode
        # The multiple ingest URLs relayed.
        self.multi_stream_url = multi_stream_url
        # The region in which the streams are mixed. Valid values:
        # 
        # *   **CN-shanghai**\
        # *   **AP-Singapore (default)**\
        # *   **EMAA-Saudi**\
        self.region = region
        # The supplemental enhancement information (SEI) parameters.
        self.sei_params = sei_params
        # The parameters of the single-stream relay task.
        self.single_sub_params = single_sub_params
        # The ingest URL.
        self.stream_url = stream_url
        # The ID of the stream relay task.
        self.task_id = task_id
        # The mixed-stream relay parameters.
        self.transcode_params = transcode_params

    def validate(self):
        if self.multi_stream_url:
            for k in self.multi_stream_url:
                if k:
                    k.validate()
        if self.sei_params:
            self.sei_params.validate()
        if self.single_sub_params:
            self.single_sub_params.validate()
        if self.transcode_params:
            self.transcode_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        result['MultiStreamURL'] = []
        if self.multi_stream_url is not None:
            for k in self.multi_stream_url:
                result['MultiStreamURL'].append(k.to_map() if k else None)
        if self.region is not None:
            result['Region'] = self.region
        if self.sei_params is not None:
            result['SeiParams'] = self.sei_params.to_map()
        if self.single_sub_params is not None:
            result['SingleSubParams'] = self.single_sub_params.to_map()
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.transcode_params is not None:
            result['TranscodeParams'] = self.transcode_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        self.multi_stream_url = []
        if m.get('MultiStreamURL') is not None:
            for k in m.get('MultiStreamURL'):
                temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL()
                self.multi_stream_url.append(temp_model.from_map(k))
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SeiParams') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams()
            self.sei_params = temp_model.from_map(m['SeiParams'])
        if m.get('SingleSubParams') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams()
            self.single_sub_params = temp_model.from_map(m['SingleSubParams'])
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TranscodeParams') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams()
            self.transcode_params = temp_model.from_map(m['TranscodeParams'])
        return self


class ListRtcMPUTaskDetailResponseBody(TeaModel):
    def __init__(
        self,
        mputasks: List[ListRtcMPUTaskDetailResponseBodyMPUTasks] = None,
        request_id: str = None,
    ):
        # The parameters that you configured when you called the StartLiveMPUTask operation to create the tasks.
        self.mputasks = mputasks
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.mputasks:
            for k in self.mputasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MPUTasks'] = []
        if self.mputasks is not None:
            for k in self.mputasks:
                result['MPUTasks'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.mputasks = []
        if m.get('MPUTasks') is not None:
            for k in m.get('MPUTasks'):
                temp_model = ListRtcMPUTaskDetailResponseBodyMPUTasks()
                self.mputasks.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListRtcMPUTaskDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRtcMPUTaskDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRtcMPUTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LiveUpstreamQosDataRequest(TeaModel):
    def __init__(
        self,
        cdn_domains: List[str] = None,
        cdn_isps: List[str] = None,
        cdn_provinces: List[str] = None,
        end_time: str = None,
        kwai_sidcs: List[str] = None,
        kwai_tsc: List[int] = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        start_time: str = None,
        upstream_domains: List[str] = None,
    ):
        self.cdn_domains = cdn_domains
        self.cdn_isps = cdn_isps
        self.cdn_provinces = cdn_provinces
        # This parameter is required.
        self.end_time = end_time
        self.kwai_sidcs = kwai_sidcs
        self.kwai_tsc = kwai_tsc
        self.owner_id = owner_id
        self.region = region
        self.region_id = region_id
        # This parameter is required.
        self.start_time = start_time
        self.upstream_domains = upstream_domains

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cdn_domains is not None:
            result['CdnDomains'] = self.cdn_domains
        if self.cdn_isps is not None:
            result['CdnIsps'] = self.cdn_isps
        if self.cdn_provinces is not None:
            result['CdnProvinces'] = self.cdn_provinces
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.kwai_sidcs is not None:
            result['KwaiSidcs'] = self.kwai_sidcs
        if self.kwai_tsc is not None:
            result['KwaiTsc'] = self.kwai_tsc
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.upstream_domains is not None:
            result['UpstreamDomains'] = self.upstream_domains
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CdnDomains') is not None:
            self.cdn_domains = m.get('CdnDomains')
        if m.get('CdnIsps') is not None:
            self.cdn_isps = m.get('CdnIsps')
        if m.get('CdnProvinces') is not None:
            self.cdn_provinces = m.get('CdnProvinces')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('KwaiSidcs') is not None:
            self.kwai_sidcs = m.get('KwaiSidcs')
        if m.get('KwaiTsc') is not None:
            self.kwai_tsc = m.get('KwaiTsc')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UpstreamDomains') is not None:
            self.upstream_domains = m.get('UpstreamDomains')
        return self


class LiveUpstreamQosDataShrinkRequest(TeaModel):
    def __init__(
        self,
        cdn_domains_shrink: str = None,
        cdn_isps_shrink: str = None,
        cdn_provinces_shrink: str = None,
        end_time: str = None,
        kwai_sidcs_shrink: str = None,
        kwai_tsc_shrink: str = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        start_time: str = None,
        upstream_domains_shrink: str = None,
    ):
        self.cdn_domains_shrink = cdn_domains_shrink
        self.cdn_isps_shrink = cdn_isps_shrink
        self.cdn_provinces_shrink = cdn_provinces_shrink
        # This parameter is required.
        self.end_time = end_time
        self.kwai_sidcs_shrink = kwai_sidcs_shrink
        self.kwai_tsc_shrink = kwai_tsc_shrink
        self.owner_id = owner_id
        self.region = region
        self.region_id = region_id
        # This parameter is required.
        self.start_time = start_time
        self.upstream_domains_shrink = upstream_domains_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cdn_domains_shrink is not None:
            result['CdnDomains'] = self.cdn_domains_shrink
        if self.cdn_isps_shrink is not None:
            result['CdnIsps'] = self.cdn_isps_shrink
        if self.cdn_provinces_shrink is not None:
            result['CdnProvinces'] = self.cdn_provinces_shrink
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.kwai_sidcs_shrink is not None:
            result['KwaiSidcs'] = self.kwai_sidcs_shrink
        if self.kwai_tsc_shrink is not None:
            result['KwaiTsc'] = self.kwai_tsc_shrink
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.upstream_domains_shrink is not None:
            result['UpstreamDomains'] = self.upstream_domains_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CdnDomains') is not None:
            self.cdn_domains_shrink = m.get('CdnDomains')
        if m.get('CdnIsps') is not None:
            self.cdn_isps_shrink = m.get('CdnIsps')
        if m.get('CdnProvinces') is not None:
            self.cdn_provinces_shrink = m.get('CdnProvinces')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('KwaiSidcs') is not None:
            self.kwai_sidcs_shrink = m.get('KwaiSidcs')
        if m.get('KwaiTsc') is not None:
            self.kwai_tsc_shrink = m.get('KwaiTsc')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UpstreamDomains') is not None:
            self.upstream_domains_shrink = m.get('UpstreamDomains')
        return self


class LiveUpstreamQosDataResponseBodyDataDetailData(TeaModel):
    def __init__(
        self,
        connect_dur: int = None,
        connect_failed_count: int = None,
        count: int = None,
        first_data_dur: int = None,
        first_data_failed_count: int = None,
        first_frame_dur: int = None,
        first_frame_success_count: int = None,
        status_code_2xx: int = None,
        status_code_3xx: int = None,
        status_code_4xx: int = None,
        status_code_5xx: int = None,
        timestamp: str = None,
    ):
        self.connect_dur = connect_dur
        self.connect_failed_count = connect_failed_count
        self.count = count
        self.first_data_dur = first_data_dur
        self.first_data_failed_count = first_data_failed_count
        self.first_frame_dur = first_frame_dur
        self.first_frame_success_count = first_frame_success_count
        self.status_code_2xx = status_code_2xx
        self.status_code_3xx = status_code_3xx
        self.status_code_4xx = status_code_4xx
        self.status_code_5xx = status_code_5xx
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_dur is not None:
            result['ConnectDur'] = self.connect_dur
        if self.connect_failed_count is not None:
            result['ConnectFailedCount'] = self.connect_failed_count
        if self.count is not None:
            result['Count'] = self.count
        if self.first_data_dur is not None:
            result['FirstDataDur'] = self.first_data_dur
        if self.first_data_failed_count is not None:
            result['FirstDataFailedCount'] = self.first_data_failed_count
        if self.first_frame_dur is not None:
            result['FirstFrameDur'] = self.first_frame_dur
        if self.first_frame_success_count is not None:
            result['FirstFrameSuccessCount'] = self.first_frame_success_count
        if self.status_code_2xx is not None:
            result['StatusCode2Xx'] = self.status_code_2xx
        if self.status_code_3xx is not None:
            result['StatusCode3Xx'] = self.status_code_3xx
        if self.status_code_4xx is not None:
            result['StatusCode4Xx'] = self.status_code_4xx
        if self.status_code_5xx is not None:
            result['StatusCode5Xx'] = self.status_code_5xx
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectDur') is not None:
            self.connect_dur = m.get('ConnectDur')
        if m.get('ConnectFailedCount') is not None:
            self.connect_failed_count = m.get('ConnectFailedCount')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FirstDataDur') is not None:
            self.first_data_dur = m.get('FirstDataDur')
        if m.get('FirstDataFailedCount') is not None:
            self.first_data_failed_count = m.get('FirstDataFailedCount')
        if m.get('FirstFrameDur') is not None:
            self.first_frame_dur = m.get('FirstFrameDur')
        if m.get('FirstFrameSuccessCount') is not None:
            self.first_frame_success_count = m.get('FirstFrameSuccessCount')
        if m.get('StatusCode2Xx') is not None:
            self.status_code_2xx = m.get('StatusCode2Xx')
        if m.get('StatusCode3Xx') is not None:
            self.status_code_3xx = m.get('StatusCode3Xx')
        if m.get('StatusCode4Xx') is not None:
            self.status_code_4xx = m.get('StatusCode4Xx')
        if m.get('StatusCode5Xx') is not None:
            self.status_code_5xx = m.get('StatusCode5Xx')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class LiveUpstreamQosDataResponseBodyData(TeaModel):
    def __init__(
        self,
        cdn_domain: str = None,
        cdn_isp: str = None,
        cdn_ocid: str = None,
        cdn_province: str = None,
        detail_data: List[LiveUpstreamQosDataResponseBodyDataDetailData] = None,
        kwai_sidc: str = None,
        kwai_tsc: int = None,
        upstream_domain: str = None,
    ):
        self.cdn_domain = cdn_domain
        self.cdn_isp = cdn_isp
        self.cdn_ocid = cdn_ocid
        self.cdn_province = cdn_province
        self.detail_data = detail_data
        self.kwai_sidc = kwai_sidc
        self.kwai_tsc = kwai_tsc
        self.upstream_domain = upstream_domain

    def validate(self):
        if self.detail_data:
            for k in self.detail_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cdn_domain is not None:
            result['CdnDomain'] = self.cdn_domain
        if self.cdn_isp is not None:
            result['CdnIsp'] = self.cdn_isp
        if self.cdn_ocid is not None:
            result['CdnOcid'] = self.cdn_ocid
        if self.cdn_province is not None:
            result['CdnProvince'] = self.cdn_province
        result['DetailData'] = []
        if self.detail_data is not None:
            for k in self.detail_data:
                result['DetailData'].append(k.to_map() if k else None)
        if self.kwai_sidc is not None:
            result['KwaiSidc'] = self.kwai_sidc
        if self.kwai_tsc is not None:
            result['KwaiTsc'] = self.kwai_tsc
        if self.upstream_domain is not None:
            result['UpstreamDomain'] = self.upstream_domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CdnDomain') is not None:
            self.cdn_domain = m.get('CdnDomain')
        if m.get('CdnIsp') is not None:
            self.cdn_isp = m.get('CdnIsp')
        if m.get('CdnOcid') is not None:
            self.cdn_ocid = m.get('CdnOcid')
        if m.get('CdnProvince') is not None:
            self.cdn_province = m.get('CdnProvince')
        self.detail_data = []
        if m.get('DetailData') is not None:
            for k in m.get('DetailData'):
                temp_model = LiveUpstreamQosDataResponseBodyDataDetailData()
                self.detail_data.append(temp_model.from_map(k))
        if m.get('KwaiSidc') is not None:
            self.kwai_sidc = m.get('KwaiSidc')
        if m.get('KwaiTsc') is not None:
            self.kwai_tsc = m.get('KwaiTsc')
        if m.get('UpstreamDomain') is not None:
            self.upstream_domain = m.get('UpstreamDomain')
        return self


class LiveUpstreamQosDataResponseBody(TeaModel):
    def __init__(
        self,
        data: List[LiveUpstreamQosDataResponseBodyData] = None,
        end_time: str = None,
        request_id: str = None,
        start_time: str = None,
    ):
        self.data = data
        self.end_time = end_time
        self.request_id = request_id
        self.start_time = start_time

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = LiveUpstreamQosDataResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class LiveUpstreamQosDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LiveUpstreamQosDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LiveUpstreamQosDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MiguLivePullToPushStartRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        migu_data: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        # This parameter is required.
        self.migu_data = migu_data
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.migu_data is not None:
            result['MiguData'] = self.migu_data
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('MiguData') is not None:
            self.migu_data = m.get('MiguData')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class MiguLivePullToPushStartResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        timestamp: str = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class MiguLivePullToPushStartResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MiguLivePullToPushStartResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MiguLivePullToPushStartResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MiguLivePullToPushStatusRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        migu_data: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.domain_name = domain_name
        # This parameter is required.
        self.migu_data = migu_data
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.migu_data is not None:
            result['MiguData'] = self.migu_data
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('MiguData') is not None:
            self.migu_data = m.get('MiguData')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class MiguLivePullToPushStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        status: str = None,
    ):
        self.message = message
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['message'] = self.message
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class MiguLivePullToPushStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: MiguLivePullToPushStatusResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        timestamp: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.timestamp = timestamp

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = MiguLivePullToPushStatusResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class MiguLivePullToPushStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MiguLivePullToPushStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MiguLivePullToPushStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCasterComponentRequest(TeaModel):
    def __init__(
        self,
        caption_layer_content: str = None,
        caster_id: str = None,
        component_id: str = None,
        component_layer: str = None,
        component_name: str = None,
        component_type: str = None,
        effect: str = None,
        image_layer_content: str = None,
        owner_id: int = None,
        region_id: str = None,
        text_layer_content: str = None,
    ):
        # The information about the subtitle component. The value must be a JSON string. This parameter contains the following fields:
        # 
        # >  This parameter is required if you set ComponentType to caption.
        # 
        # *   **SizeNormalized**: the normalized value of the font size. The value of this field equals the font size divided by the output height. Valid values: `0 to 1`. The maximum font size is 1,024, even if the font size calculated based on this field is greater than 1,024.
        # *   **BorderWidthNormalized**: the normalized value of the border width. The value of this field equals the border width divided by the font size. Valid values: `0 to 1`. Default value: 0. The maximum border width is 16, even if the border width calculated based on this field is greater than 16.
        # *   **FontName**: the font name. Default value: KaiTi. For more information about the valid values, see **Fonts used in a production studio**.
        # *   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is left empty. In this case, the color of the text border is transparent.
        # *   **LocationId**: the channel ID of the source subtitles.
        # *   **SourceLan**: the source language of the subtitles in the video. Valid values: en (English), cn (Chinese), es (Spanish), and ru (Russian). Default value: cn.
        # *   **TargetLan**: the target language of the subtitles in the video. If you do not specify this field, speech recognition is used. If you specify this field, translation is used. Valid values: en (English), cn (Chinese), es (Spanish), and ru (Russian).
        # *   **ShowSourceLan**: specifies whether to display the source language. A value of true specifies that the source language is displayed. A value of false specifies that the source language is not displayed. Default value: false.
        # *   **Truncation**: specifies whether to allow subtitle truncation. A value of true specifies that the subtitles can be truncated. A value of false specifies that the subtitles cannot be truncated. Default value: false.
        # *   **SourceLanPerLineWordCount**: the number of words displayed in each line of the source language. This field takes effect only if you set Truncation to true. Default value: 20.
        # *   **TargetLanPerLineWordCount**: the number of words displayed in each line of the target language. This field takes effect only if you set Truncation to true. Default value: 20.
        self.caption_layer_content = caption_layer_content
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the component. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.
        # 
        # This parameter is required.
        self.component_id = component_id
        # The information about the component layer, such as the size and layout, The value must be a JSON string. This parameter contains the following fields:
        # 
        # *   **HeightNormalized**: the normalized value of the height of the component layer.
        # *   **WidthNormalized**: the normalized value of the width of the component layer.
        # *   **PositionNormalized**: the normalized value of the position of the component layer.
        # *   **PositionRefer**: the reference coordinates of the component layer.
        self.component_layer = component_layer
        # The name of the component. By default, the name is the ID of the component.
        self.component_name = component_name
        # The type of the component. Valid values:
        # 
        # *   **text**: text component. The TextLayerContent parameter is required if you set ComponentType to text.
        # *   **image**: image component. The ImageLayerContent parameter is required if you set ComponentType to image.
        # *   **caption**: subtitle component. The CaptionLayerContent parameter is required if you set ComponentType to caption.
        self.component_type = component_type
        # The display effect for the component. Valid values:
        # 
        # *   **none** (default)
        # *   **animateH**: horizontal scrolling
        # *   **animateV**: vertical scrolling
        self.effect = effect
        # The information about the image component. The value must be a JSON string.
        # 
        # >  This parameter is required if you set ComponentType to image.
        # 
        # The MaterialId field specifies the ID of the material from the media asset library.
        self.image_layer_content = image_layer_content
        self.owner_id = owner_id
        self.region_id = region_id
        # The information about the text component. The value must be a JSON string. This parameter contains the following fields:
        # 
        # >  This parameter is required if you set ComponentType to text.
        # 
        # *   **SizeNormalized**: the normalized value of the font size. The value of this field equals the font size divided by the output height. Valid values: `0 to 1`. The maximum font size is 1,024, even if the font size calculated based on this field is greater than 1,024.
        # *   **BorderWidthNormalized**: the normalized value of the border width. The value of this field equals the border width divided by the font size. Valid values: `0 to 1`. Default value: 0. The maximum border width is 16, even if the border width calculated based on this field is greater than 16.
        # *   **FontName**: the font name. Default value: KaiTi. For more information about the valid values, see **Fonts used in a production studio**.
        # *   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is left empty. In this case, the color of the text border is transparent.
        # *   **Text**: the content of the text. By default, this parameter is left empty. In this case, the text contains no content.
        # *   **Color**: the color of the text. The default value is 0xff0000, which indicates that the text is in red.
        self.text_layer_content = text_layer_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caption_layer_content is not None:
            result['CaptionLayerContent'] = self.caption_layer_content
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.component_layer is not None:
            result['ComponentLayer'] = self.component_layer
        if self.component_name is not None:
            result['ComponentName'] = self.component_name
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.image_layer_content is not None:
            result['ImageLayerContent'] = self.image_layer_content
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.text_layer_content is not None:
            result['TextLayerContent'] = self.text_layer_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CaptionLayerContent') is not None:
            self.caption_layer_content = m.get('CaptionLayerContent')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('ComponentLayer') is not None:
            self.component_layer = m.get('ComponentLayer')
        if m.get('ComponentName') is not None:
            self.component_name = m.get('ComponentName')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('ImageLayerContent') is not None:
            self.image_layer_content = m.get('ImageLayerContent')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TextLayerContent') is not None:
            self.text_layer_content = m.get('TextLayerContent')
        return self


class ModifyCasterComponentResponseBody(TeaModel):
    def __init__(
        self,
        component_id: str = None,
        request_id: str = None,
    ):
        # The ID of the component. You can use the ID as a request parameter in the API operation that is called to query components in a production studio.
        self.component_id = component_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCasterComponentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCasterComponentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCasterComponentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCasterEpisodeRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: List[str] = None,
        end_time: str = None,
        episode_id: str = None,
        episode_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        resource_id: str = None,
        start_time: str = None,
        switch_type: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The components. Components in the production studio are listed from the bottom to the top in an array. When the production studio switches to another video resource, the components are also switched.
        # 
        # *   This parameter takes effect and is required only when the EpisodeType parameter is set to **Component**.
        # *   This parameter is optional when the EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.
        # 
        # >  The variable N specifies the sequence number of the component. For example, ComponentId.1 specifies the ID of the first component and ComponentId.2 specifies the ID of the second component.
        self.component_id = component_id
        # The time when the episode ends. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the episode. It is included in the response when you call the [AddCasterEpisode](~~94745#doc-api-live-AddCasterEpisode~~ "Adds an episode to a production studio.") operation.
        # 
        # This parameter is required.
        self.episode_id = episode_id
        # The name of the episode.
        self.episode_name = episode_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the video resource. It is included in the response when you call the [AddCasterVideoResource](~~60250#doc-api-live-AddCasterVideoResource~~ "Adds a video resource to a production studio.") operation.
        # 
        # *   This parameter takes effect and is required only when the EpisodeType is set to **Resource**.
        # *   If the EpisodeType parameter is set to **Component**, this parameter is invalid.
        self.resource_id = resource_id
        # The time when the episode starts. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The policy for switching episodes. This parameter takes effect only when the EpisodeType parameter is set to **Resource**. Valid values:
        # 
        # *   **TimeFirst**: The episode starts when the preceding episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This parameter must be set to TimeFirst when the video resource is a live stream.
        # *   **ContentFirst**: The episode starts and ends as scheduled.
        self.switch_type = switch_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.episode_name is not None:
            result['EpisodeName'] = self.episode_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('EpisodeName') is not None:
            self.episode_name = m.get('EpisodeName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class ModifyCasterEpisodeResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episode_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to copy the configurations of a scene, update the configurations of a scene, query the scenes of a production studio, query the audio configurations of a scene, start a scene in the production studio, or stop a scene in the production studio.
        self.caster_id = caster_id
        # The ID of the episode. You can use the ID as a request parameter in the API operation that is used to delete an episode list from a production studio, add episodes to an episode list, remove episodes from an episode list, query the information about episodes in an episode list, update episodes in an episode list, delete an episode list, query the information about an episode list, start an episode list, or stop an episode list.
        self.episode_id = episode_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCasterEpisodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCasterEpisodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCasterEpisodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCasterLayoutRequestAudioLayer(TeaModel):
    def __init__(
        self,
        fixed_delay_duration: int = None,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles. Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.
        self.fixed_delay_duration = fixed_delay_duration
        # The sound channels that are used for volume input in the audio layer. Valid values:
        # 
        # *   **leftChannel**: the left channel
        # *   **rightChannel**: the right channel
        # *   **all** (default): both the left and right channels
        self.valid_channel = valid_channel
        # The normalized value of the height of the audio layer. The width of the audio layer is proportionally scaled based on this parameter.
        # 
        # The default value is **0**, which indicates that the audio layer is not scaled.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class ModifyCasterLayoutRequestVideoLayer(TeaModel):
    def __init__(
        self,
        fill_mode: str = None,
        fixed_delay_duration: int = None,
        height_normalized: float = None,
        position_normalized: List[float] = None,
        position_refer: str = None,
        width_normalized: float = None,
    ):
        # The scaling mode of the video layer. Valid values:
        # 
        # *   **none** (default): indicates that the video layer is not scaled. The video layer is displayed based on its original size.
        # *   **fit**: indicates that the video layer is adapted to the fill area. In this case, the video layer is scaled proportionally, with its original aspect ratio retained. The video layer is placed in the center, with its longer sides aligned with the fill area. If the aspect ratio of the video layer is different from that of the fill area, the content of the lower layer is displayed alongside the shorter sides. If there is no lower layer, black bars are displayed instead.
        self.fill_mode = fill_mode
        # The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles. Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.
        self.fixed_delay_duration = fixed_delay_duration
        # The normalized value of the height of the video layer.
        # 
        # *   If the FillMode parameter of the video layer is set to none, the width of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
        # *   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.
        self.height_normalized = height_normalized
        # The normalized value of the position of the video layer, in the format of `[x,y]`. Default value: `[0,0]`.
        # 
        # >  The values of x and y are normalized.
        self.position_normalized = position_normalized
        # The reference coordinates of the video layer. Valid values:
        # 
        # *   **topLeft** (default): the upper-left corner
        # *   **topRight**: the upper-right corner
        # *   **bottomLeft**: the lower-left corner
        # *   **bottomRight**: the lower-right corner
        # *   **center**: the center
        # *   **topCenter**: the upper center
        # *   **bottomCenter**: the lower center
        # *   **leftCenter**: the left center
        # *   **rightCenter**: the right center
        self.position_refer = position_refer
        # The normalized value of the width of the video layer.
        # 
        # *   If the FillMode parameter of the video layer is set to none, the height of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
        # *   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.
        self.width_normalized = width_normalized

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fill_mode is not None:
            result['FillMode'] = self.fill_mode
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.position_refer is not None:
            result['PositionRefer'] = self.position_refer
        if self.width_normalized is not None:
            result['WidthNormalized'] = self.width_normalized
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FillMode') is not None:
            self.fill_mode = m.get('FillMode')
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('PositionRefer') is not None:
            self.position_refer = m.get('PositionRefer')
        if m.get('WidthNormalized') is not None:
            self.width_normalized = m.get('WidthNormalized')
        return self


class ModifyCasterLayoutRequest(TeaModel):
    def __init__(
        self,
        audio_layer: List[ModifyCasterLayoutRequestAudioLayer] = None,
        blend_list: List[str] = None,
        caster_id: str = None,
        layout_id: str = None,
        mix_list: List[str] = None,
        owner_id: int = None,
        region_id: str = None,
        video_layer: List[ModifyCasterLayoutRequestVideoLayer] = None,
    ):
        # The audio layers.
        # 
        # This parameter is required.
        self.audio_layer = audio_layer
        # The location IDs of the video layers, which are in the same order as the video layers.
        # 
        # For more information, see [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html).
        # 
        # This parameter is required.
        self.blend_list = blend_list
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the layout. If the layout was added by calling the [AddCasterLayout](https://help.aliyun.com/document_detail/2848025.html) operation, check the value of the response parameter LayoutId to obtain the ID.
        # 
        # This parameter is required.
        self.layout_id = layout_id
        # The location IDs of the audio layers, which are in the same order as the audio layers.
        # 
        # For more information, see [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html).
        # 
        # This parameter is required.
        self.mix_list = mix_list
        self.owner_id = owner_id
        self.region_id = region_id
        # The video layers.
        # 
        # This parameter is required.
        self.video_layer = video_layer

    def validate(self):
        if self.audio_layer:
            for k in self.audio_layer:
                if k:
                    k.validate()
        if self.video_layer:
            for k in self.video_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioLayer'] = []
        if self.audio_layer is not None:
            for k in self.audio_layer:
                result['AudioLayer'].append(k.to_map() if k else None)
        if self.blend_list is not None:
            result['BlendList'] = self.blend_list
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.mix_list is not None:
            result['MixList'] = self.mix_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['VideoLayer'] = []
        if self.video_layer is not None:
            for k in self.video_layer:
                result['VideoLayer'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_layer = []
        if m.get('AudioLayer') is not None:
            for k in m.get('AudioLayer'):
                temp_model = ModifyCasterLayoutRequestAudioLayer()
                self.audio_layer.append(temp_model.from_map(k))
        if m.get('BlendList') is not None:
            self.blend_list = m.get('BlendList')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('MixList') is not None:
            self.mix_list = m.get('MixList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.video_layer = []
        if m.get('VideoLayer') is not None:
            for k in m.get('VideoLayer'):
                temp_model = ModifyCasterLayoutRequestVideoLayer()
                self.video_layer.append(temp_model.from_map(k))
        return self


class ModifyCasterLayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        request_id: str = None,
    ):
        # The ID of the layout. You can use this ID to query information about the layout.
        self.layout_id = layout_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCasterLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCasterLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCasterLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCasterProgramRequestEpisode(TeaModel):
    def __init__(
        self,
        component_id: List[str] = None,
        end_time: str = None,
        episode_id: str = None,
        episode_name: str = None,
        episode_type: str = None,
        resource_id: str = None,
        start_time: str = None,
        switch_type: str = None,
    ):
        # The components. Components in the production studio are listed from the bottom to the top in an array. When the production studio switches to another video resource, the components are also switched.
        # 
        # *   This parameter is required and available only when EpisodeType is set to **Component**.
        # *   This parameter is optional when EpisodeType is set to **Resource**. This indicates that the components are bound to and switched together with video resources.
        self.component_id = component_id
        # The end time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.end_time = end_time
        # The ID of the episode. If the episode was added by calling the [AddCasterEpisode](https://help.aliyun.com/document_detail/2848068.html) operation, check the value of the response parameter EpisodeId to obtain the ID.
        self.episode_id = episode_id
        # The name of the episode.
        self.episode_name = episode_name
        # The type of the episode. Valid values:
        # 
        # *   **Resource**: a video resource
        # *   **Component**: a component
        self.episode_type = episode_type
        # The ID of the video resource. If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html) operation, check the value of the response parameter ResourceId to obtain the ID.
        self.resource_id = resource_id
        # The start time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        self.start_time = start_time
        # The policy for switching episodes. This parameter takes effect only when EpisodeType is set to **Resource**. Valid values:
        # 
        # *   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
        # *   **ContentFirst**: The episode starts and ends as scheduled.
        self.switch_type = switch_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.episode_id is not None:
            result['EpisodeId'] = self.episode_id
        if self.episode_name is not None:
            result['EpisodeName'] = self.episode_name
        if self.episode_type is not None:
            result['EpisodeType'] = self.episode_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.switch_type is not None:
            result['SwitchType'] = self.switch_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EpisodeId') is not None:
            self.episode_id = m.get('EpisodeId')
        if m.get('EpisodeName') is not None:
            self.episode_name = m.get('EpisodeName')
        if m.get('EpisodeType') is not None:
            self.episode_type = m.get('EpisodeType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SwitchType') is not None:
            self.switch_type = m.get('SwitchType')
        return self


class ModifyCasterProgramRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        episode: List[ModifyCasterProgramRequestEpisode] = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The episodes.
        # 
        # This parameter is required.
        self.episode = episode
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        if self.episode:
            for k in self.episode:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        result['Episode'] = []
        if self.episode is not None:
            for k in self.episode:
                result['Episode'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        self.episode = []
        if m.get('Episode') is not None:
            for k in m.get('Episode'):
                temp_model = ModifyCasterProgramRequestEpisode()
                self.episode.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyCasterProgramResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio.
        self.caster_id = caster_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCasterProgramResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCasterProgramResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCasterProgramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCasterVideoResourceRequest(TeaModel):
    def __init__(
        self,
        begin_offset: int = None,
        caster_id: str = None,
        end_offset: int = None,
        image_id: str = None,
        image_url: str = None,
        live_stream_url: str = None,
        material_id: str = None,
        owner_id: int = None,
        pts_callback_interval: int = None,
        region_id: str = None,
        repeat_num: int = None,
        resource_id: str = None,
        resource_name: str = None,
        vod_url: str = None,
    ):
        # The offset of the position where the system starts to read the video resource.
        # 
        # This parameter takes effect only when the video resource is a video file. Unit: milliseconds.
        # 
        # >  A value greater than 0 indicates an offset from the first frame.
        self.begin_offset = begin_offset
        # The ID of the production studio.
        # 
        # If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.
        # 
        # If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:
        # 
        # Production Studios > Production Studio Management
        # 
        # >  The CasterId is reflected in the Name column on the Production Studio Management page.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # This parameter takes effect only when the video resource is a video file. Unit: milliseconds.
        # 
        # *   A value greater than **0** indicates an offset from the first frame.
        # *   A value smaller than **0** indicates an offset from the last frame.
        self.end_offset = end_offset
        # ID of the media library image material.
        # > This parameter is only available and must be provided when the video source type is an image.
        self.image_id = image_id
        # Image material URL. 
        # >This parameter is only available when the video source type is an image and the image file has not been imported into the material library. Supports uploading images in jpg, png formats, with a maximum file size of 10MB.
        self.image_url = image_url
        # The URL of the live stream.
        # 
        # This parameter takes effect and is required only when the video resource is a live stream.
        self.live_stream_url = live_stream_url
        # The ID of the material.
        self.material_id = material_id
        self.owner_id = owner_id
        # The interval between presentation timestamp (PTS) callbacks. Unit: milliseconds. This parameter takes effect only when the video resource is a VOD file.
        self.pts_callback_interval = pts_callback_interval
        self.region_id = region_id
        # The number of playback times after the first playback is complete. This parameter takes effect only when the video resource is a file. Valid values:
        # 
        # *   **0**: indicates that the video is played only once. This is the default value.
        # *   **-1**: indicates that the video is played in loop mode.
        self.repeat_num = repeat_num
        # The ID of the video resource. It is reflected in the ResourceId parameter when you call the [AddCasterVideoResource](~~60250#doc-api-live-AddCasterVideoResource~~ "Adds a video resource to a production studio.") operation.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The name of the video resource.
        self.resource_name = resource_name
        # The URL of the video-on-demand (VOD) file. This parameter takes effect only when the video resource is a video file that is not from the media library.
        # 
        # >  The VOD file must be in the MP4, FLV, or TS format.
        self.vod_url = vod_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_offset is not None:
            result['BeginOffset'] = self.begin_offset
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.end_offset is not None:
            result['EndOffset'] = self.end_offset
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_url is not None:
            result['ImageUrl'] = self.image_url
        if self.live_stream_url is not None:
            result['LiveStreamUrl'] = self.live_stream_url
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pts_callback_interval is not None:
            result['PtsCallbackInterval'] = self.pts_callback_interval
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_num is not None:
            result['RepeatNum'] = self.repeat_num
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.vod_url is not None:
            result['VodUrl'] = self.vod_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginOffset') is not None:
            self.begin_offset = m.get('BeginOffset')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('EndOffset') is not None:
            self.end_offset = m.get('EndOffset')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageUrl') is not None:
            self.image_url = m.get('ImageUrl')
        if m.get('LiveStreamUrl') is not None:
            self.live_stream_url = m.get('LiveStreamUrl')
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PtsCallbackInterval') is not None:
            self.pts_callback_interval = m.get('PtsCallbackInterval')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNum') is not None:
            self.repeat_num = m.get('RepeatNum')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('VodUrl') is not None:
            self.vod_url = m.get('VodUrl')
        return self


class ModifyCasterVideoResourceResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
        resource_id: str = None,
    ):
        # The ID of the production studio. This parameter is used in the requests of the following operations: DescribeCasterVideoResources, AddCasterLayout, and DescribeCasterLayouts.
        self.caster_id = caster_id
        # The ID of the request.
        self.request_id = request_id
        # The ID of the resource.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class ModifyCasterVideoResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCasterVideoResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCasterVideoResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveAIStudioRequestMattingLayout(TeaModel):
    def __init__(
        self,
        height_normalized: float = None,
        position_x: float = None,
        position_y: float = None,
    ):
        # The normalized value of the height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_x = position_x
        # The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_y = position_y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_x is not None:
            result['PositionX'] = self.position_x
        if self.position_y is not None:
            result['PositionY'] = self.position_y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionX') is not None:
            self.position_x = m.get('PositionX')
        if m.get('PositionY') is not None:
            self.position_y = m.get('PositionY')
        return self


class ModifyLiveAIStudioRequestMediaLayout(TeaModel):
    def __init__(
        self,
        height_normalized: float = None,
        position_x: float = None,
        position_y: float = None,
    ):
        # The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.
        self.height_normalized = height_normalized
        # The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_x = position_x
        # The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.
        self.position_y = position_y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height_normalized is not None:
            result['HeightNormalized'] = self.height_normalized
        if self.position_x is not None:
            result['PositionX'] = self.position_x
        if self.position_y is not None:
            result['PositionY'] = self.position_y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HeightNormalized') is not None:
            self.height_normalized = m.get('HeightNormalized')
        if m.get('PositionX') is not None:
            self.position_x = m.get('PositionX')
        if m.get('PositionY') is not None:
            self.position_y = m.get('PositionY')
        return self


class ModifyLiveAIStudioRequest(TeaModel):
    def __init__(
        self,
        background_resource_id: str = None,
        background_resource_url: str = None,
        background_type: str = None,
        description: str = None,
        height: int = None,
        matting_layout: ModifyLiveAIStudioRequestMattingLayout = None,
        matting_type: str = None,
        media_layout: ModifyLiveAIStudioRequestMediaLayout = None,
        media_resource_id: str = None,
        media_resource_url: str = None,
        media_type: str = None,
        owner_id: int = None,
        region_id: str = None,
        studio_name: str = None,
        width: int = None,
    ):
        # The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.background_resource_id = background_resource_id
        # The URL of the background material.
        self.background_resource_url = background_resource_url
        # The type of the background material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.background_type = background_type
        # The custom description.
        self.description = description
        # The preview height. Unit: pixels.
        # 
        # The following preview specifications (width  height) are supported:
        # 
        # *   Landscape low definition 360p (640360)
        # *   Portrait low definition 360p (360640)
        # *   Landscape standard definition 480p (854480)
        # *   Portrait standard definition 480p (480854)
        # *   Landscape high definition 720p (1280720)
        # *   Portrait high definition 720p (7201280)
        # *   Landscape ultra-high definition 1080p (19201080)
        # *   Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The layout information of the chroma-keyed material.
        # 
        # This parameter is required.
        self.matting_layout = matting_layout
        # The type of chroma key. Valid values:
        # 
        # *   green: green-screen chroma key
        # *   blue: blue-screen chroma key
        # *   complex: background replacement
        # 
        # This parameter is required.
        self.matting_type = matting_type
        # The layout information of the multimedia material.
        self.media_layout = media_layout
        # The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.media_resource_id = media_resource_id
        # The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.
        self.media_resource_url = media_resource_url
        # The type of the multimedia material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.media_type = media_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the virtual studio template. The name is the same as the value of the StudioName parameter that was specified when you called the CreateLiveAIStudio operation to create the virtual studio template.
        # 
        # This parameter is required.
        self.studio_name = studio_name
        # The preview width. Unit: pixels.
        self.width = width

    def validate(self):
        if self.matting_layout:
            self.matting_layout.validate()
        if self.media_layout:
            self.media_layout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_resource_id is not None:
            result['BackgroundResourceId'] = self.background_resource_id
        if self.background_resource_url is not None:
            result['BackgroundResourceUrl'] = self.background_resource_url
        if self.background_type is not None:
            result['BackgroundType'] = self.background_type
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.matting_layout is not None:
            result['MattingLayout'] = self.matting_layout.to_map()
        if self.matting_type is not None:
            result['MattingType'] = self.matting_type
        if self.media_layout is not None:
            result['MediaLayout'] = self.media_layout.to_map()
        if self.media_resource_id is not None:
            result['MediaResourceId'] = self.media_resource_id
        if self.media_resource_url is not None:
            result['MediaResourceUrl'] = self.media_resource_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundResourceId') is not None:
            self.background_resource_id = m.get('BackgroundResourceId')
        if m.get('BackgroundResourceUrl') is not None:
            self.background_resource_url = m.get('BackgroundResourceUrl')
        if m.get('BackgroundType') is not None:
            self.background_type = m.get('BackgroundType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MattingLayout') is not None:
            temp_model = ModifyLiveAIStudioRequestMattingLayout()
            self.matting_layout = temp_model.from_map(m['MattingLayout'])
        if m.get('MattingType') is not None:
            self.matting_type = m.get('MattingType')
        if m.get('MediaLayout') is not None:
            temp_model = ModifyLiveAIStudioRequestMediaLayout()
            self.media_layout = temp_model.from_map(m['MediaLayout'])
        if m.get('MediaResourceId') is not None:
            self.media_resource_id = m.get('MediaResourceId')
        if m.get('MediaResourceUrl') is not None:
            self.media_resource_url = m.get('MediaResourceUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ModifyLiveAIStudioShrinkRequest(TeaModel):
    def __init__(
        self,
        background_resource_id: str = None,
        background_resource_url: str = None,
        background_type: str = None,
        description: str = None,
        height: int = None,
        matting_layout_shrink: str = None,
        matting_type: str = None,
        media_layout_shrink: str = None,
        media_resource_id: str = None,
        media_resource_url: str = None,
        media_type: str = None,
        owner_id: int = None,
        region_id: str = None,
        studio_name: str = None,
        width: int = None,
    ):
        # The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.background_resource_id = background_resource_id
        # The URL of the background material.
        self.background_resource_url = background_resource_url
        # The type of the background material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.background_type = background_type
        # The custom description.
        self.description = description
        # The preview height. Unit: pixels.
        # 
        # The following preview specifications (width  height) are supported:
        # 
        # *   Landscape low definition 360p (640360)
        # *   Portrait low definition 360p (360640)
        # *   Landscape standard definition 480p (854480)
        # *   Portrait standard definition 480p (480854)
        # *   Landscape high definition 720p (1280720)
        # *   Portrait high definition 720p (7201280)
        # *   Landscape ultra-high definition 1080p (19201080)
        # *   Portrait ultra-high definition 1080p (10801920)
        self.height = height
        # The layout information of the chroma-keyed material.
        # 
        # This parameter is required.
        self.matting_layout_shrink = matting_layout_shrink
        # The type of chroma key. Valid values:
        # 
        # *   green: green-screen chroma key
        # *   blue: blue-screen chroma key
        # *   complex: background replacement
        # 
        # This parameter is required.
        self.matting_type = matting_type
        # The layout information of the multimedia material.
        self.media_layout_shrink = media_layout_shrink
        # The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.
        self.media_resource_id = media_resource_id
        # The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.
        self.media_resource_url = media_resource_url
        # The type of the multimedia material. Valid values:
        # 
        # *   VOD: a video in ApsaraVideo VOD
        # *   PIC: an image
        # *   LIVE: a live stream
        self.media_type = media_type
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the virtual studio template. The name is the same as the value of the StudioName parameter that was specified when you called the CreateLiveAIStudio operation to create the virtual studio template.
        # 
        # This parameter is required.
        self.studio_name = studio_name
        # The preview width. Unit: pixels.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_resource_id is not None:
            result['BackgroundResourceId'] = self.background_resource_id
        if self.background_resource_url is not None:
            result['BackgroundResourceUrl'] = self.background_resource_url
        if self.background_type is not None:
            result['BackgroundType'] = self.background_type
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.matting_layout_shrink is not None:
            result['MattingLayout'] = self.matting_layout_shrink
        if self.matting_type is not None:
            result['MattingType'] = self.matting_type
        if self.media_layout_shrink is not None:
            result['MediaLayout'] = self.media_layout_shrink
        if self.media_resource_id is not None:
            result['MediaResourceId'] = self.media_resource_id
        if self.media_resource_url is not None:
            result['MediaResourceUrl'] = self.media_resource_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundResourceId') is not None:
            self.background_resource_id = m.get('BackgroundResourceId')
        if m.get('BackgroundResourceUrl') is not None:
            self.background_resource_url = m.get('BackgroundResourceUrl')
        if m.get('BackgroundType') is not None:
            self.background_type = m.get('BackgroundType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MattingLayout') is not None:
            self.matting_layout_shrink = m.get('MattingLayout')
        if m.get('MattingType') is not None:
            self.matting_type = m.get('MattingType')
        if m.get('MediaLayout') is not None:
            self.media_layout_shrink = m.get('MediaLayout')
        if m.get('MediaResourceId') is not None:
            self.media_resource_id = m.get('MediaResourceId')
        if m.get('MediaResourceUrl') is not None:
            self.media_resource_url = m.get('MediaResourceUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ModifyLiveAIStudioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveAIStudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveAIStudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveAIStudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveDomainSchdmByPropertyRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        property: str = None,
        region_id: str = None,
    ):
        # The domain name for which you want to modify the acceleration region.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The acceleration region that you want to set. {"coverage":"overseas"} specifies regions outside the Chinese mainland. Valid values of coverage:
        # 
        # *   domestic: regions in the Chinese mainland.
        # *   overseas: regions outside the Chinese mainland.
        # *   global: regions in and outside the Chinese mainland.
        # 
        # This parameter is required.
        self.property = property
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.property is not None:
            result['Property'] = self.property
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Property') is not None:
            self.property = m.get('Property')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyLiveDomainSchdmByPropertyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveDomainSchdmByPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveDomainSchdmByPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveDomainSchdmByPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageAppAuditRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        audit_type: int = None,
        audit_url: str = None,
        data_center: str = None,
    ):
        # The ID of the interactive messaging application whose content moderation settings you want to modify.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The content moderation method. Valid values:
        # 
        # *   0: disables content moderation.
        # *   1: uses built-in content moderation.
        # *   2: uses custom content moderation.
        self.audit_type = audit_type
        # The URL for content moderation. This parameter is required if you set AuditType to 2. The URL must start with http:// or https:// and cannot contain a private IP address or a port number.
        self.audit_url = audit_url
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.audit_type is not None:
            result['AuditType'] = self.audit_type
        if self.audit_url is not None:
            result['AuditUrl'] = self.audit_url
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AuditType') is not None:
            self.audit_type = m.get('AuditType')
        if m.get('AuditUrl') is not None:
            self.audit_url = m.get('AuditUrl')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        return self


class ModifyLiveMessageAppAuditResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_sign: str = None,
        audit_need_authentication: bool = None,
        audit_type: int = None,
        audit_url: str = None,
        request_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The signature of the interactive messaging application. It is required by the interactive messaging SDK.
        self.app_sign = app_sign
        # Indicates whether authentication is enabled. If custom content moderation is used, the value of this parameter is true by default.
        self.audit_need_authentication = audit_need_authentication
        # The content moderation method.
        self.audit_type = audit_type
        # The URL for content moderation. This parameter is returned when the value of AuditType is 2.
        self.audit_url = audit_url
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.audit_need_authentication is not None:
            result['AuditNeedAuthentication'] = self.audit_need_authentication
        if self.audit_type is not None:
            result['AuditType'] = self.audit_type
        if self.audit_url is not None:
            result['AuditUrl'] = self.audit_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('AuditNeedAuthentication') is not None:
            self.audit_need_authentication = m.get('AuditNeedAuthentication')
        if m.get('AuditType') is not None:
            self.audit_type = m.get('AuditType')
        if m.get('AuditUrl') is not None:
            self.audit_url = m.get('AuditUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveMessageAppAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageAppAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageAppAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageAppCallbackRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        event_callback_url: str = None,
    ):
        # The ID of the interactive messaging application whose callback settings you want to modify.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The callback URL for events such as user logon, logoff, joining a group, and leaving a group. If you leave this parameter empty, callbacks are disabled. The callback URL must start with http:// or https:// and cannot contain a private IP address or a port number.
        self.event_callback_url = event_callback_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.event_callback_url is not None:
            result['EventCallbackUrl'] = self.event_callback_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('EventCallbackUrl') is not None:
            self.event_callback_url = m.get('EventCallbackUrl')
        return self


class ModifyLiveMessageAppCallbackResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_sign: str = None,
        event_callback_need_authentication: bool = None,
        event_callback_url: str = None,
        request_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The signature of the interactive messaging application. It is required by the interactive messaging SDK.
        self.app_sign = app_sign
        # Indicates whether authentication is required for event callbacks. Default value: true.
        self.event_callback_need_authentication = event_callback_need_authentication
        # The callback URL for events such as user logon, logoff, joining a group, and leaving a group. This parameter is not returned if it has an empty value.
        self.event_callback_url = event_callback_url
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.event_callback_need_authentication is not None:
            result['EventCallbackNeedAuthentication'] = self.event_callback_need_authentication
        if self.event_callback_url is not None:
            result['EventCallbackUrl'] = self.event_callback_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('EventCallbackNeedAuthentication') is not None:
            self.event_callback_need_authentication = m.get('EventCallbackNeedAuthentication')
        if m.get('EventCallbackUrl') is not None:
            self.event_callback_url = m.get('EventCallbackUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveMessageAppCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageAppCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageAppCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageAppDisableRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        disable: bool = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # Specifies whether to disable the interactive messaging application.
        self.disable = disable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.disable is not None:
            result['Disable'] = self.disable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('Disable') is not None:
            self.disable = m.get('Disable')
        return self


class ModifyLiveMessageAppDisableResponseBody(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_sign: str = None,
        disable: bool = None,
        request_id: str = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The signature of the interactive messaging application. It is required by the interactive messaging SDK.
        self.app_sign = app_sign
        # Indicates whether the interactive messaging application is disabled.
        self.disable = disable
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_sign is not None:
            result['AppSign'] = self.app_sign
        if self.disable is not None:
            result['Disable'] = self.disable
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppSign') is not None:
            self.app_sign = m.get('AppSign')
        if m.get('Disable') is not None:
            self.disable = m.get('Disable')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveMessageAppDisableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageAppDisableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageAppDisableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        admin_list: List[str] = None,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        group_info: str = None,
        modify_admin: bool = None,
        modify_info: bool = None,
    ):
        # The list of administrators after your change.
        self.admin_list = admin_list
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The additional information about the group after the modification. The value can be up to 32 KB in length.
        self.group_info = group_info
        # Specifies whether to change the group administrators.
        self.modify_admin = modify_admin
        # Specifies whether to modify the additional information about the group.
        self.modify_info = modify_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_list is not None:
            result['AdminList'] = self.admin_list
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.modify_admin is not None:
            result['ModifyAdmin'] = self.modify_admin
        if self.modify_info is not None:
            result['ModifyInfo'] = self.modify_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminList') is not None:
            self.admin_list = m.get('AdminList')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('ModifyAdmin') is not None:
            self.modify_admin = m.get('ModifyAdmin')
        if m.get('ModifyInfo') is not None:
            self.modify_info = m.get('ModifyInfo')
        return self


class ModifyLiveMessageGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        admin_list_shrink: str = None,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        group_info: str = None,
        modify_admin: bool = None,
        modify_info: bool = None,
    ):
        # The list of administrators after your change.
        self.admin_list_shrink = admin_list_shrink
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The additional information about the group after the modification. The value can be up to 32 KB in length.
        self.group_info = group_info
        # Specifies whether to change the group administrators.
        self.modify_admin = modify_admin
        # Specifies whether to modify the additional information about the group.
        self.modify_info = modify_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_list_shrink is not None:
            result['AdminList'] = self.admin_list_shrink
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_info is not None:
            result['GroupInfo'] = self.group_info
        if self.modify_admin is not None:
            result['ModifyAdmin'] = self.modify_admin
        if self.modify_info is not None:
            result['ModifyInfo'] = self.modify_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdminList') is not None:
            self.admin_list_shrink = m.get('AdminList')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInfo') is not None:
            self.group_info = m.get('GroupInfo')
        if m.get('ModifyAdmin') is not None:
            self.modify_admin = m.get('ModifyAdmin')
        if m.get('ModifyInfo') is not None:
            self.modify_info = m.get('ModifyInfo')
        return self


class ModifyLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageGroupBandRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        banned_all: bool = None,
        bannned_users: List[str] = None,
        data_center: str = None,
        except_users: List[str] = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to mute all users.
        self.banned_all = banned_all
        # The ID of the user whom you want to mute. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.
        self.bannned_users = bannned_users
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the user whom you do not want to mute when you set the BannedAll parameter to true. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.
        self.except_users = except_users
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.banned_all is not None:
            result['BannedAll'] = self.banned_all
        if self.bannned_users is not None:
            result['BannnedUsers'] = self.bannned_users
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.except_users is not None:
            result['ExceptUsers'] = self.except_users
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BannedAll') is not None:
            self.banned_all = m.get('BannedAll')
        if m.get('BannnedUsers') is not None:
            self.bannned_users = m.get('BannnedUsers')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('ExceptUsers') is not None:
            self.except_users = m.get('ExceptUsers')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class ModifyLiveMessageGroupBandShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        banned_all: bool = None,
        bannned_users_shrink: str = None,
        data_center: str = None,
        except_users_shrink: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # Specifies whether to mute all users.
        self.banned_all = banned_all
        # The ID of the user whom you want to mute. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.
        self.bannned_users_shrink = bannned_users_shrink
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the user whom you do not want to mute when you set the BannedAll parameter to true. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.
        self.except_users_shrink = except_users_shrink
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.banned_all is not None:
            result['BannedAll'] = self.banned_all
        if self.bannned_users_shrink is not None:
            result['BannnedUsers'] = self.bannned_users_shrink
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.except_users_shrink is not None:
            result['ExceptUsers'] = self.except_users_shrink
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BannedAll') is not None:
            self.banned_all = m.get('BannedAll')
        if m.get('BannnedUsers') is not None:
            self.bannned_users_shrink = m.get('BannnedUsers')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('ExceptUsers') is not None:
            self.except_users_shrink = m.get('ExceptUsers')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class ModifyLiveMessageGroupBandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveMessageGroupBandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageGroupBandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageGroupBandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveMessageUserInfoRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        user_id: str = None,
        user_meta_info: str = None,
    ):
        # The ID of the interactive messaging application whose user information you want to modify.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the user whose information you want to modify.
        # 
        # This parameter is required.
        self.user_id = user_id
        # The additional information about the user after the modification. The value can be up to 512 bytes in length.
        self.user_meta_info = user_meta_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_meta_info is not None:
            result['UserMetaInfo'] = self.user_meta_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserMetaInfo') is not None:
            self.user_meta_info = m.get('UserMetaInfo')
        return self


class ModifyLiveMessageUserInfoResponseBodyFailList(TeaModel):
    def __init__(
        self,
        code: int = None,
        group_id: str = None,
        reason: str = None,
        success: bool = None,
    ):
        # The error code.
        self.code = code
        # The ID of the group to which the user belongs. For failed modification, the information of the user is not updated when you query the users in the group. You can try again after you check the failure reason and fix the issue.
        self.group_id = group_id
        # The reason why the information of the user failed to be modified.
        self.reason = reason
        # Indicates whether the group to which the user belongs is modified. In this case, the group is not modified.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyLiveMessageUserInfoResponseBodySuccessList(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        success: bool = None,
    ):
        # The ID of the group to which the user belongs. For successful modification, the information of the user is updated when you query the users in the group.
        self.group_id = group_id
        # Indicates whether the group to which the user belongs is modified. In this case, the group is modified.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyLiveMessageUserInfoResponseBody(TeaModel):
    def __init__(
        self,
        fail_list: List[ModifyLiveMessageUserInfoResponseBodyFailList] = None,
        request_id: str = None,
        success_list: List[ModifyLiveMessageUserInfoResponseBodySuccessList] = None,
    ):
        # The users whose information failed to be modified.
        self.fail_list = fail_list
        # The request ID.
        self.request_id = request_id
        # The users whose information was modified.
        self.success_list = success_list

    def validate(self):
        if self.fail_list:
            for k in self.fail_list:
                if k:
                    k.validate()
        if self.success_list:
            for k in self.success_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FailList'] = []
        if self.fail_list is not None:
            for k in self.fail_list:
                result['FailList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuccessList'] = []
        if self.success_list is not None:
            for k in self.success_list:
                result['SuccessList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fail_list = []
        if m.get('FailList') is not None:
            for k in m.get('FailList'):
                temp_model = ModifyLiveMessageUserInfoResponseBodyFailList()
                self.fail_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.success_list = []
        if m.get('SuccessList') is not None:
            for k in m.get('SuccessList'):
                temp_model = ModifyLiveMessageUserInfoResponseBodySuccessList()
                self.success_list.append(temp_model.from_map(k))
        return self


class ModifyLiveMessageUserInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveMessageUserInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveMessageUserInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLiveRealtimeLogDeliveryRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        logstore: str = None,
        owner_id: int = None,
        project: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The main streaming domain for which you want to modify the configuration of real-time log delivery.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the Logstore to which log entries are delivered.
        # 
        # This parameter is required.
        self.logstore = logstore
        self.owner_id = owner_id
        # The name of the Log Service project that is used for real-time log delivery.
        # 
        # This parameter is required.
        self.project = project
        # The ID of the region where the Log Service project is deployed.
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyLiveRealtimeLogDeliveryResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLiveRealtimeLogDeliveryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyLiveRealtimeLogDeliveryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLiveRealtimeLogDeliveryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyShowListRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        high_priority_show_id: str = None,
        high_priority_show_start_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        repeat_times: int = None,
        show_id: str = None,
        spot: int = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The episode of the highest priority.
        # 
        # >  You can configure this parameter only before the playback of the episode list starts.
        self.high_priority_show_id = high_priority_show_id
        # The time at which the episode of the highest priority is played. Format: yyyy-MM-dd\\"T\\"HH:mm:ss.
        # 
        # >  You can configure this parameter only before the episode list starts playing.\\
        # After you configure this parameter, when the specified point in time is reached, any episode that is playing stops and the episode of the highest priority in the episode list starts to play.
        self.high_priority_show_start_time = high_priority_show_start_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The number of additional times the episode list is played.
        # 
        # > 
        # 
        # *   The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to **0**, the episode list is played **once**. If you set the value to **1**, the episode list is played **twice**.********\
        # 
        # *   If you set the value to -1, the episode list is repeated indefinitely.
        self.repeat_times = repeat_times
        # The ID of the episode for which you want to change the position in the playlist.
        # 
        # >  You can call the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) or [DescribeShowList](https://help.aliyun.com/document_detail/2848054.html) operation and check the value of the response parameter ShowId to obtain the ID.
        self.show_id = show_id
        # The position of the episode in the episode list. If you want to change the position of an episode in a playlist, place the ID of the episode in **Spot**.
        # 
        # >  The value must be greater than or equal to 0 and less than or equal to the total number of episodes in the playlist.
        self.spot = spot

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.high_priority_show_id is not None:
            result['HighPriorityShowId'] = self.high_priority_show_id
        if self.high_priority_show_start_time is not None:
            result['HighPriorityShowStartTime'] = self.high_priority_show_start_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_times is not None:
            result['RepeatTimes'] = self.repeat_times
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.spot is not None:
            result['Spot'] = self.spot
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('HighPriorityShowId') is not None:
            self.high_priority_show_id = m.get('HighPriorityShowId')
        if m.get('HighPriorityShowStartTime') is not None:
            self.high_priority_show_start_time = m.get('HighPriorityShowStartTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatTimes') is not None:
            self.repeat_times = m.get('RepeatTimes')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('Spot') is not None:
            self.spot = m.get('Spot')
        return self


class ModifyShowListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyShowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyShowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyShowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStudioLayoutRequest(TeaModel):
    def __init__(
        self,
        bg_image_config: str = None,
        caster_id: str = None,
        common_config: str = None,
        layer_order_config_list: str = None,
        layout_id: str = None,
        layout_name: str = None,
        media_input_config_list: str = None,
        owner_id: int = None,
        region_id: str = None,
        screen_input_config_list: str = None,
    ):
        # The background material configurations. The value is a JSON string. For more information, see **BgImageConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to studio.
        self.bg_image_config = bg_image_config
        # The ID of the production studio.
        # 
        # >  The production studio must be a virtual studio that you create in advance.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The common layout configurations. The value is a JSON string. For more information, see **CommonConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to common.
        self.common_config = common_config
        # The layer sorting configurations. The value is a JSON string. For more information, see **layerOrderConfig**. You can sort layers of background and multimedia materials. The chroma key layer cannot be sorted. A layer that is in the front of the code is placed behind other layers in the layout.
        self.layer_order_config_list = layer_order_config_list
        # The ID of the layout. If the layout was added by calling the [AddStudioLayout](https://help.aliyun.com/document_detail/2848062.html) operation, check the value of the response parameter LayoutId to obtain the ID.
        # 
        # This parameter is required.
        self.layout_id = layout_id
        # The name of the layout.
        self.layout_name = layout_name
        # The multimedia input configurations. The value is a JSON string. For more information, see **MediaInputConfig**.
        # 
        # >  This parameter is optional and takes effect only if you set LayoutType to studio.
        self.media_input_config_list = media_input_config_list
        self.owner_id = owner_id
        self.region_id = region_id
        # The input configurations for chroma key. The value is a JSON string. For more information, see **ScreenInputConfig**.
        # 
        # >  This parameter is required only if you set LayoutType to studio.
        self.screen_input_config_list = screen_input_config_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_image_config is not None:
            result['BgImageConfig'] = self.bg_image_config
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.common_config is not None:
            result['CommonConfig'] = self.common_config
        if self.layer_order_config_list is not None:
            result['LayerOrderConfigList'] = self.layer_order_config_list
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.layout_name is not None:
            result['LayoutName'] = self.layout_name
        if self.media_input_config_list is not None:
            result['MediaInputConfigList'] = self.media_input_config_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.screen_input_config_list is not None:
            result['ScreenInputConfigList'] = self.screen_input_config_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgImageConfig') is not None:
            self.bg_image_config = m.get('BgImageConfig')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CommonConfig') is not None:
            self.common_config = m.get('CommonConfig')
        if m.get('LayerOrderConfigList') is not None:
            self.layer_order_config_list = m.get('LayerOrderConfigList')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('LayoutName') is not None:
            self.layout_name = m.get('LayoutName')
        if m.get('MediaInputConfigList') is not None:
            self.media_input_config_list = m.get('MediaInputConfigList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScreenInputConfigList') is not None:
            self.screen_input_config_list = m.get('ScreenInputConfigList')
        return self


class ModifyStudioLayoutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStudioLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyStudioLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStudioLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MuteAllGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        group_id: str = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        # 
        # This parameter is required.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class MuteAllGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the mute was successful. Valid values:
        # 
        # *   true: The mute was successful.
        # *   false: The mute failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MuteAllGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: MuteAllGroupUserResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = MuteAllGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class MuteAllGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MuteAllGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MuteAllGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MuteGroupUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        group_id: str = None,
        mute_time: int = None,
        mute_user_list: List[str] = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The duration of the mute. Unit: seconds.
        # 
        # > If you do not specify this parameter or set the value to 0, the default duration of 86,400 seconds is used.
        self.mute_time = mute_time
        # Details about the mute.
        # 
        # This parameter is required.
        self.mute_user_list = mute_user_list
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.mute_time is not None:
            result['MuteTime'] = self.mute_time
        if self.mute_user_list is not None:
            result['MuteUserList'] = self.mute_user_list
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MuteTime') is not None:
            self.mute_time = m.get('MuteTime')
        if m.get('MuteUserList') is not None:
            self.mute_user_list = m.get('MuteUserList')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class MuteGroupUserShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        group_id: str = None,
        mute_time: int = None,
        mute_user_list_shrink: str = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The duration of the mute. Unit: seconds.
        # 
        # > If you do not specify this parameter or set the value to 0, the default duration of 86,400 seconds is used.
        self.mute_time = mute_time
        # Details about the mute.
        # 
        # This parameter is required.
        self.mute_user_list_shrink = mute_user_list_shrink
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.mute_time is not None:
            result['MuteTime'] = self.mute_time
        if self.mute_user_list_shrink is not None:
            result['MuteUserList'] = self.mute_user_list_shrink
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MuteTime') is not None:
            self.mute_time = m.get('MuteTime')
        if m.get('MuteUserList') is not None:
            self.mute_user_list_shrink = m.get('MuteUserList')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class MuteGroupUserResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the mute is successful. Valid values:
        # 
        # *   true: The mute is successful.
        # *   false: The mute failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MuteGroupUserResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: MuteGroupUserResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = MuteGroupUserResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class MuteGroupUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MuteGroupUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MuteGroupUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenLiveShiftRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        duration: int = None,
        ignore_transcode: bool = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
        vision: int = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The length of a TS segment for HTTP Live Streaming (HLS). Unit: seconds.
        self.duration = duration
        # Specifies whether to disable time shifting for the transcoded stream. Valid values:
        # 
        # *   **true**: disables time shifting for the transcoded stream.
        # *   **false**: enables time shifting for the transcoded stream.
        # 
        # Default value: true.
        self.ignore_transcode = ignore_transcode
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name
        # The duration for which data is retained. Default value: 7. Unit: day.
        self.vision = vision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.ignore_transcode is not None:
            result['IgnoreTranscode'] = self.ignore_transcode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.vision is not None:
            result['Vision'] = self.vision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('IgnoreTranscode') is not None:
            self.ignore_transcode = m.get('IgnoreTranscode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Vision') is not None:
            self.vision = m.get('Vision')
        return self


class OpenLiveShiftResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenLiveShiftResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenLiveShiftResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenLiveShiftResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PlayChoosenShowRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        show_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the episode that you want to switch to.
        # 
        # >  You can call the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) or [DescribeShowList](https://help.aliyun.com/document_detail/2848054.html) operation and check the value of the response parameter ShowId to obtain the ID.
        # 
        # This parameter is required.
        self.show_id = show_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        return self


class PlayChoosenShowResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        show_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The ID of the episode.
        self.show_id = show_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        return self


class PlayChoosenShowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PlayChoosenShowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PlayChoosenShowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishLiveStagingConfigToProductionRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        function_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The accelerated domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the feature. For more information about how to obtain the feature name, see [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html).
        # 
        # This parameter is required.
        self.function_name = function_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PublishLiveStagingConfigToProductionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PublishLiveStagingConfigToProductionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishLiveStagingConfigToProductionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishLiveStagingConfigToProductionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutRecordStorageLifeCycleRequest(TeaModel):
    def __init__(
        self,
        stream_ids: List[str] = None,
        tag: str = None,
        unix_timestamp: int = None,
    ):
        # This parameter is required.
        self.stream_ids = stream_ids
        # This parameter is required.
        self.tag = tag
        # This parameter is required.
        self.unix_timestamp = unix_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stream_ids is not None:
            result['StreamIds'] = self.stream_ids
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.unix_timestamp is not None:
            result['UnixTimestamp'] = self.unix_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StreamIds') is not None:
            self.stream_ids = m.get('StreamIds')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('UnixTimestamp') is not None:
            self.unix_timestamp = m.get('UnixTimestamp')
        return self


class PutRecordStorageLifeCycleShrinkRequest(TeaModel):
    def __init__(
        self,
        stream_ids_shrink: str = None,
        tag: str = None,
        unix_timestamp: int = None,
    ):
        # This parameter is required.
        self.stream_ids_shrink = stream_ids_shrink
        # This parameter is required.
        self.tag = tag
        # This parameter is required.
        self.unix_timestamp = unix_timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stream_ids_shrink is not None:
            result['StreamIds'] = self.stream_ids_shrink
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.unix_timestamp is not None:
            result['UnixTimestamp'] = self.unix_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StreamIds') is not None:
            self.stream_ids_shrink = m.get('StreamIds')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('UnixTimestamp') is not None:
            self.unix_timestamp = m.get('UnixTimestamp')
        return self


class PutRecordStorageLifeCycleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        msg: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.msg = msg
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutRecordStorageLifeCycleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutRecordStorageLifeCycleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutRecordStorageLifeCycleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLiveDomainMultiStreamListRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # The end time must be later than the start time. The time range specified by the StartTime and EndTime parameters cannot exceed seven days. If the two parameters are not specified, data of the last 24 hours is queried by default.
        self.end_time = end_time
        self.owner_id = owner_id
        # The page number. Default value: **1**.
        self.page_number = page_number
        # The number of entries per page. Default value: 10.
        # 
        # Valid values: 1 to 100.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        self.start_time = start_time
        # The name of the live stream. This parameter is used for exact match.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs(TeaModel):
    def __init__(
        self,
        change_reason: str = None,
        change_time: str = None,
        master_upstream: str = None,
        upstream_ip: str = None,
        upstream_sequence: str = None,
    ):
        # The reason for the switchover.
        # 
        # *   merge cut manually: You proactively switched the stream.
        # *   master stream no data: No data is available in the active stream.
        # *   master stream low quality: The quality of the active stream deteriorated.
        self.change_reason = change_reason
        # The switchover time.
        self.change_time = change_time
        # The stream used after the switchover.
        self.master_upstream = master_upstream
        # The IP address used after the switchover.
        self.upstream_ip = upstream_ip
        # The identifier of the stream after the switchover.
        self.upstream_sequence = upstream_sequence

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_reason is not None:
            result['ChangeReason'] = self.change_reason
        if self.change_time is not None:
            result['ChangeTime'] = self.change_time
        if self.master_upstream is not None:
            result['MasterUpstream'] = self.master_upstream
        if self.upstream_ip is not None:
            result['UpstreamIp'] = self.upstream_ip
        if self.upstream_sequence is not None:
            result['UpstreamSequence'] = self.upstream_sequence
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeReason') is not None:
            self.change_reason = m.get('ChangeReason')
        if m.get('ChangeTime') is not None:
            self.change_time = m.get('ChangeTime')
        if m.get('MasterUpstream') is not None:
            self.master_upstream = m.get('MasterUpstream')
        if m.get('UpstreamIp') is not None:
            self.upstream_ip = m.get('UpstreamIp')
        if m.get('UpstreamSequence') is not None:
            self.upstream_sequence = m.get('UpstreamSequence')
        return self


class QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList(TeaModel):
    def __init__(
        self,
        master_flag: bool = None,
        upstream_ip: str = None,
        upstream_sequence: str = None,
        upstream_time: str = None,
    ):
        # The active/standby tag.
        # 
        # >  This parameter indicates whether the active or standby stream is being distributed.
        # 
        # Valid values:
        # 
        # *   true
        # *   false
        self.master_flag = master_flag
        # The IP address of the stream ingest client.
        self.upstream_ip = upstream_ip
        # The unique identifier of the stream ingest.
        self.upstream_sequence = upstream_sequence
        # The stream ingest time.
        self.upstream_time = upstream_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.master_flag is not None:
            result['MasterFlag'] = self.master_flag
        if self.upstream_ip is not None:
            result['UpstreamIp'] = self.upstream_ip
        if self.upstream_sequence is not None:
            result['UpstreamSequence'] = self.upstream_sequence
        if self.upstream_time is not None:
            result['UpstreamTime'] = self.upstream_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MasterFlag') is not None:
            self.master_flag = m.get('MasterFlag')
        if m.get('UpstreamIp') is not None:
            self.upstream_ip = m.get('UpstreamIp')
        if m.get('UpstreamSequence') is not None:
            self.upstream_sequence = m.get('UpstreamSequence')
        if m.get('UpstreamTime') is not None:
            self.upstream_time = m.get('UpstreamTime')
        return self


class QueryLiveDomainMultiStreamListResponseBodyOnlineStreams(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        change_logs: List[QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs] = None,
        domain: str = None,
        optimal_mode: str = None,
        stream_name: str = None,
        upstream_list: List[QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList] = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The switchover records.
        self.change_logs = change_logs
        # The main streaming domain.
        self.domain = domain
        # Indicates whether the dual-stream disaster recovery feature is enabled. Valid values:
        # 
        # *   **on**: enabled
        # *   **off**: disabled
        self.optimal_mode = optimal_mode
        # The name of the live stream.
        self.stream_name = stream_name
        # The standby streams.
        self.upstream_list = upstream_list

    def validate(self):
        if self.change_logs:
            for k in self.change_logs:
                if k:
                    k.validate()
        if self.upstream_list:
            for k in self.upstream_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        result['ChangeLogs'] = []
        if self.change_logs is not None:
            for k in self.change_logs:
                result['ChangeLogs'].append(k.to_map() if k else None)
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.optimal_mode is not None:
            result['OptimalMode'] = self.optimal_mode
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        result['UpstreamList'] = []
        if self.upstream_list is not None:
            for k in self.upstream_list:
                result['UpstreamList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        self.change_logs = []
        if m.get('ChangeLogs') is not None:
            for k in m.get('ChangeLogs'):
                temp_model = QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs()
                self.change_logs.append(temp_model.from_map(k))
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OptimalMode') is not None:
            self.optimal_mode = m.get('OptimalMode')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        self.upstream_list = []
        if m.get('UpstreamList') is not None:
            for k in m.get('UpstreamList'):
                temp_model = QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList()
                self.upstream_list.append(temp_model.from_map(k))
        return self


class QueryLiveDomainMultiStreamListResponseBody(TeaModel):
    def __init__(
        self,
        online_streams: List[QueryLiveDomainMultiStreamListResponseBodyOnlineStreams] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        # The online streams returned.
        self.online_streams = online_streams
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.online_streams:
            for k in self.online_streams:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OnlineStreams'] = []
        if self.online_streams is not None:
            for k in self.online_streams:
                result['OnlineStreams'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.online_streams = []
        if m.get('OnlineStreams') is not None:
            for k in m.get('OnlineStreams'):
                temp_model = QueryLiveDomainMultiStreamListResponseBodyOnlineStreams()
                self.online_streams.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryLiveDomainMultiStreamListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLiveDomainMultiStreamListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLiveDomainMultiStreamListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        page_num: int = None,
        page_size: int = None,
        sort_type: int = None,
    ):
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The number of the page to return. Default value: 1. Valid values: 1 to 100000.
        self.page_num = page_num
        # The number of applications to return on each page. Default value: 20. Valid values: 1 to 50.
        self.page_size = page_size
        # The sort order. Valid values:
        # 
        # *   0: ascending order by time
        # *   1: descending order by time
        self.sort_type = sort_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        return self


class QueryMessageAppResponseBodyResultAppList(TeaModel):
    def __init__(
        self,
        app_config: Dict[str, str] = None,
        app_id: str = None,
        app_name: str = None,
        create_time: int = None,
        extension: Dict[str, str] = None,
        status: int = None,
    ):
        # The configurations of the application.
        self.app_config = app_config
        # The ID of the interactive messaging application.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The time when the interactive messaging application was created. The time is displayed in UTC.
        self.create_time = create_time
        # The extended field.
        self.extension = extension
        # The status of the interactive message application. A value of **1** indicates that the application is normal.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        app_list: List[QueryMessageAppResponseBodyResultAppList] = None,
        has_more: bool = None,
        total_count: int = None,
    ):
        # Details about the interactive messaging applications.
        self.app_list = app_list
        # Indicates whether the current page is followed by another page. Valid values:
        # 
        # *   true: The current page is followed by another page.
        # *   false: The current page is not followed by another page.
        self.has_more = has_more
        # The total number of applications returned.
        self.total_count = total_count

    def validate(self):
        if self.app_list:
            for k in self.app_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppList'] = []
        if self.app_list is not None:
            for k in self.app_list:
                result['AppList'].append(k.to_map() if k else None)
        if self.has_more is not None:
            result['HasMore'] = self.has_more
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_list = []
        if m.get('AppList') is not None:
            for k in m.get('AppList'):
                temp_model = QueryMessageAppResponseBodyResultAppList()
                self.app_list.append(temp_model.from_map(k))
        if m.get('HasMore') is not None:
            self.has_more = m.get('HasMore')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: List[QueryMessageAppResponseBodyResult] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMessageAppResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryRtcAsrTasksRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the task that you want to query. If you do not specify this parameter, all running tasks under your UID are queried.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class QueryRtcAsrTasksResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
        tasks: Dict[str, Any] = None,
    ):
        # The result of the request. If success is returned, the request was successful. If an error message is returned, the request failed.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The HTTP status code. HTTP status code 2000 indicates that the request was successful. Other HTTP status codes indicate that the request failed.
        self.ret_code = ret_code
        # The results returned for the tasks.
        self.tasks = tasks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        if self.tasks is not None:
            result['Tasks'] = self.tasks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        if m.get('Tasks') is not None:
            self.tasks = m.get('Tasks')
        return self


class QueryRtcAsrTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryRtcAsrTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryRtcAsrTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySnapshotCallbackAuthRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class QuerySnapshotCallbackAuthResponseBody(TeaModel):
    def __init__(
        self,
        callback_auth_key: str = None,
        callback_req_auth: str = None,
        domain_name: str = None,
        request_id: str = None,
    ):
        # The callback authentication key.
        self.callback_auth_key = callback_auth_key
        # Indicates whether callback authentication is enabled. Valid values:
        # 
        # *   **yes**: Callback authentication is enabled.
        # *   **no**: Callback authentication is disabled.
        self.callback_req_auth = callback_req_auth
        # The main streaming domain.
        self.domain_name = domain_name
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_auth_key is not None:
            result['CallbackAuthKey'] = self.callback_auth_key
        if self.callback_req_auth is not None:
            result['CallbackReqAuth'] = self.callback_req_auth
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackAuthKey') is not None:
            self.callback_auth_key = m.get('CallbackAuthKey')
        if m.get('CallbackReqAuth') is not None:
            self.callback_req_auth = m.get('CallbackReqAuth')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QuerySnapshotCallbackAuthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySnapshotCallbackAuthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySnapshotCallbackAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RealTimeRecordCommandRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        command: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The action to be performed. Valid values:
        # 
        # *   **start**: forcibly starts recording.
        # *   **stop**: forcibly stops recording. If the live stream is interrupted for longer than a specific latency, a recording is generated.
        # *   **cancel_delay**: resets the latency for stream interruption and completely stops recording. If the recording task is stopped when you perform this action, a recording is generated.
        # *   **restart**: forcibly restarts recording. If the live stream is being recorded when you perform this action, a recording is generated.
        # 
        # >  **stop** forcibly stops recording. By default, a recording is generated after 180 seconds. **cancel_delay** resets the latency for stream interruption from 180 seconds to 0 seconds. This means that a recording is generated immediately.
        # 
        # This parameter is required.
        self.command = command
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. Make sure that you specify the correct stream name. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.command is not None:
            result['Command'] = self.command
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class RealTimeRecordCommandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RealTimeRecordCommandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RealTimeRecordCommandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RealTimeRecordCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecoverLiveMessageDeletedGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group that you want to restore.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class RecoverLiveMessageDeletedGroupResponseBody(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        request_id: str = None,
    ):
        # The ID of the group that was restored.
        self.group_id = group_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RecoverLiveMessageDeletedGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecoverLiveMessageDeletedGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecoverLiveMessageDeletedGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveLiveMessageGroupBandRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        unbanned_users: List[str] = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The users whom you want to unmute.
        # 
        # This parameter is required.
        self.unbanned_users = unbanned_users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.unbanned_users is not None:
            result['UnbannedUsers'] = self.unbanned_users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UnbannedUsers') is not None:
            self.unbanned_users = m.get('UnbannedUsers')
        return self


class RemoveLiveMessageGroupBandShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
        unbanned_users_shrink: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The users whom you want to unmute.
        # 
        # This parameter is required.
        self.unbanned_users_shrink = unbanned_users_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.unbanned_users_shrink is not None:
            result['UnbannedUsers'] = self.unbanned_users_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('UnbannedUsers') is not None:
            self.unbanned_users_shrink = m.get('UnbannedUsers')
        return self


class RemoveLiveMessageGroupBandResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveLiveMessageGroupBandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveLiveMessageGroupBandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveLiveMessageGroupBandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveShowFromShowListRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        show_id: str = None,
        is_batch_mode: bool = None,
        show_id_list: List[str] = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the episode.
        # 
        # >  You can obtain the ID by checking the value of the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html) operation.
        self.show_id = show_id
        # Specifies whether to remove multiple episodes at a time. Valid values:
        # 
        # *   true: removes multiple episodes at a time.
        # *   false: removes a single episode.
        # 
        # >  If you do not configure this parameter or this parameter is left empty, a single episode is to be removed.
        self.is_batch_mode = is_batch_mode
        # The IDs of episodes that you want to remove.
        self.show_id_list = show_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.is_batch_mode is not None:
            result['isBatchMode'] = self.is_batch_mode
        if self.show_id_list is not None:
            result['showIdList'] = self.show_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('isBatchMode') is not None:
            self.is_batch_mode = m.get('isBatchMode')
        if m.get('showIdList') is not None:
            self.show_id_list = m.get('showIdList')
        return self


class RemoveShowFromShowListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        show_id: str = None,
        failed_list: str = None,
        successful_show_ids: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The ID of the episode.
        self.show_id = show_id
        # The IDs of episodes that failed to be removed and the relevant failure information.
        self.failed_list = failed_list
        # The IDs of episodes that were removed.
        self.successful_show_ids = successful_show_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.show_id is not None:
            result['ShowId'] = self.show_id
        if self.failed_list is not None:
            result['failedList'] = self.failed_list
        if self.successful_show_ids is not None:
            result['successfulShowIds'] = self.successful_show_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShowId') is not None:
            self.show_id = m.get('ShowId')
        if m.get('failedList') is not None:
            self.failed_list = m.get('failedList')
        if m.get('successfulShowIds') is not None:
            self.successful_show_ids = m.get('successfulShowIds')
        return self


class RemoveShowFromShowListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveShowFromShowListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveShowFromShowListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTerminalsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        terminal_ids: List[str] = None,
    ):
        # The ID of the application. You can specify only one application ID in each request.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The ID of the channel. You can specify only one channel ID in each request.
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The IDs of the users that you want to remove.
        # 
        # This parameter is required.
        self.terminal_ids = terminal_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.terminal_ids is not None:
            result['TerminalIds'] = self.terminal_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TerminalIds') is not None:
            self.terminal_ids = m.get('TerminalIds')
        return self


class RemoveTerminalsResponseBodyTerminals(TeaModel):
    def __init__(
        self,
        code: int = None,
        id: str = None,
        message: str = None,
    ):
        # The returned status code. A value of 0 indicates that the request is successful. If the request fails, an error message is returned.
        self.code = code
        # The ID of the user.
        self.id = id
        # The result of removing the specified users from the channel. Valid values:
        # 
        # *   Success
        # *   Failed
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class RemoveTerminalsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        terminals: List[RemoveTerminalsResponseBodyTerminals] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The information about the users.
        self.terminals = terminals

    def validate(self):
        if self.terminals:
            for k in self.terminals:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Terminals'] = []
        if self.terminals is not None:
            for k in self.terminals:
                result['Terminals'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.terminals = []
        if m.get('Terminals') is not None:
            for k in m.get('Terminals'):
                temp_model = RemoveTerminalsResponseBodyTerminals()
                self.terminals.append(temp_model.from_map(k))
        return self


class RemoveTerminalsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveTerminalsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTerminalsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartCasterRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RestartCasterResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RestartCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        # The region of the live center. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RestartLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The new task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RestartLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartTranscodeTaskRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        push_domain: str = None,
        security_token: str = None,
        stream_name: str = None,
        transcoding_template: str = None,
    ):
        self.app = app
        self.push_domain = push_domain
        self.security_token = security_token
        self.stream_name = stream_name
        self.transcoding_template = transcoding_template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.push_domain is not None:
            result['PushDomain'] = self.push_domain
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transcoding_template is not None:
            result['TranscodingTemplate'] = self.transcoding_template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('PushDomain') is not None:
            self.push_domain = m.get('PushDomain')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TranscodingTemplate') is not None:
            self.transcoding_template = m.get('TranscodingTemplate')
        return self


class RestartTranscodeTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RestartTranscodeTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartTranscodeTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartTranscodeTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeLiveStreamRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        live_stream_type: str = None,
        owner_id: int = None,
        security_token: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether the live stream is ingested by a streamer or played by a client. Set the value to **publisher**, which specifies that the live stream is ingested by a streamer.
        # 
        # This parameter is required.
        self.live_stream_type = live_stream_type
        self.owner_id = owner_id
        self.security_token = security_token
        # The name of the ingested stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_stream_type is not None:
            result['LiveStreamType'] = self.live_stream_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveStreamType') is not None:
            self.live_stream_type = m.get('LiveStreamType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class ResumeLiveStreamResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResumeLiveStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeLiveStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeLiveStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackLiveStagingConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        function_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The accelerated domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the feature. For more information about how to obtain the feature name, see [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html).
        # 
        # This parameter is required.
        self.function_name = function_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RollbackLiveStagingConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackLiveStagingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RollbackLiveStagingConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackLiveStagingConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLikeRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        broad_cast_type: int = None,
        count: str = None,
        group_id: str = None,
        operator_user_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The mode in which system messages are broadcasted. Valid values:
        # 
        # *   0: specifies that system messages are not broadcasted. This is the default value.
        # *   1: specifies that system messages are broadcasted to specified users.
        # *   2: specifies that system messages are broadcasted to the message group.
        self.broad_cast_type = broad_cast_type
        # The number of likes.
        # 
        # This parameter is required.
        self.count = count
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        self.operator_user_id = operator_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.broad_cast_type is not None:
            result['BroadCastType'] = self.broad_cast_type
        if self.count is not None:
            result['Count'] = self.count
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BroadCastType') is not None:
            self.broad_cast_type = m.get('BroadCastType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        return self


class SendLikeResponseBodyResult(TeaModel):
    def __init__(
        self,
        like_count: int = None,
    ):
        # The number of likes.
        self.like_count = like_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.like_count is not None:
            result['LikeCount'] = self.like_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LikeCount') is not None:
            self.like_count = m.get('LikeCount')
        return self


class SendLikeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: SendLikeResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = SendLikeResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class SendLikeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendLikeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLikeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        body: str = None,
        data_center: str = None,
        group_id: str = None,
        msg_tid: str = None,
        msg_type: int = None,
        no_cache: bool = None,
        no_storage: bool = None,
        sender_id: str = None,
        sender_meta_info: str = None,
        statics_increase: int = None,
        weight: int = None,
    ):
        # The ID of the interactive messaging application in which the message is received.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The message body. The body can be up to 15 KB in length.
        self.body = body
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The ID of the group that receives the message.
        # 
        # >  Make sure that the specified group ID exists. Otherwise, a ResourceNotExist error is returned.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.msg_tid = msg_tid
        # The message type.
        self.msg_type = msg_type
        # Specifies whether to disable message caching. Valid values: true and false. Default value: false, which specifies that the message is cached to the recent message list of the group.
        self.no_cache = no_cache
        # Specifies whether to disable message storage. Valid values: true and false. Default value: false, which specifies that the message is stored for a validity period of 30 days. You can find the message in the response of the ListLiveMessageGroupMessages operation. If you do not want to store the message, set this parameter to true.
        self.no_storage = no_storage
        # The ID of the user who sends the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        # 
        # This parameter is required.
        self.sender_id = sender_id
        # The additional information about the user who sends the message. The value can be up to 512 bytes in length.
        self.sender_meta_info = sender_meta_info
        # The contribution of the message to the increase in the number of messages of this type. Default value: 1.
        self.statics_increase = statics_increase
        # The weight of the message. Default value: 1. A greater value indicates a higher priority. For a message of the highest priority, you can set the weight to 1000000.
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.body is not None:
            result['Body'] = self.body
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.msg_tid is not None:
            result['MsgTid'] = self.msg_tid
        if self.msg_type is not None:
            result['MsgType'] = self.msg_type
        if self.no_cache is not None:
            result['NoCache'] = self.no_cache
        if self.no_storage is not None:
            result['NoStorage'] = self.no_storage
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_meta_info is not None:
            result['SenderMetaInfo'] = self.sender_meta_info
        if self.statics_increase is not None:
            result['StaticsIncrease'] = self.statics_increase
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MsgTid') is not None:
            self.msg_tid = m.get('MsgTid')
        if m.get('MsgType') is not None:
            self.msg_type = m.get('MsgType')
        if m.get('NoCache') is not None:
            self.no_cache = m.get('NoCache')
        if m.get('NoStorage') is not None:
            self.no_storage = m.get('NoStorage')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderMetaInfo') is not None:
            self.sender_meta_info = m.get('SenderMetaInfo')
        if m.get('StaticsIncrease') is not None:
            self.statics_increase = m.get('StaticsIncrease')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class SendLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        msg_tid: str = None,
        request_id: str = None,
    ):
        # The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.msg_tid = msg_tid
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.msg_tid is not None:
            result['MsgTid'] = self.msg_tid
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MsgTid') is not None:
            self.msg_tid = m.get('MsgTid')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLiveMessageUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        body: str = None,
        data_center: str = None,
        high_reliability: bool = None,
        msg_tid: str = None,
        msg_type: int = None,
        receiver_id: str = None,
        sender_id: str = None,
        sender_info: str = None,
        storage: bool = None,
    ):
        # The ID of the interactive messaging application in which the message is sent.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The message body. It can be up to 15 KB in length.
        self.body = body
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # Specifies whether to set the message as a highly reliable message. A highly reliable message ensures that success is returned only after the receiver has received the message and responded. If the receiver does not respond within 3 seconds, failure is returned.
        # 
        # *   true: sets the message as a highly reliable message.
        # *   false (default): does not set the message as a highly reliable message.
        # 
        # >  This parameter is supported only by the client SDK V1.5.1 and later. When you send a message to a client with an earlier SDK version, the message can be successfully sent without waiting for an acknowledgement (ACK) response.
        self.high_reliability = high_reliability
        # The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.msg_tid = msg_tid
        # The message type.
        self.msg_type = msg_type
        # The ID of the user who receives the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        # 
        # >  Make sure that the user who receives the message is online. You can call the CheckLiveMessageUsersOnline operation to query whether the user is online.
        # 
        # This parameter is required.
        self.receiver_id = receiver_id
        # The ID of the user who sends the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        # 
        # This parameter is required.
        self.sender_id = sender_id
        # The additional information about the user who sends the message. It can be up to 512 bytes in length.
        self.sender_info = sender_info
        # Specifies whether to store the message.
        # 
        # *   true: stores the message.
        # *   false (default): does not store the message.
        self.storage = storage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.body is not None:
            result['Body'] = self.body
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.high_reliability is not None:
            result['HighReliability'] = self.high_reliability
        if self.msg_tid is not None:
            result['MsgTid'] = self.msg_tid
        if self.msg_type is not None:
            result['MsgType'] = self.msg_type
        if self.receiver_id is not None:
            result['ReceiverId'] = self.receiver_id
        if self.sender_id is not None:
            result['SenderId'] = self.sender_id
        if self.sender_info is not None:
            result['SenderInfo'] = self.sender_info
        if self.storage is not None:
            result['Storage'] = self.storage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('HighReliability') is not None:
            self.high_reliability = m.get('HighReliability')
        if m.get('MsgTid') is not None:
            self.msg_tid = m.get('MsgTid')
        if m.get('MsgType') is not None:
            self.msg_type = m.get('MsgType')
        if m.get('ReceiverId') is not None:
            self.receiver_id = m.get('ReceiverId')
        if m.get('SenderId') is not None:
            self.sender_id = m.get('SenderId')
        if m.get('SenderInfo') is not None:
            self.sender_info = m.get('SenderInfo')
        if m.get('Storage') is not None:
            self.storage = m.get('Storage')
        return self


class SendLiveMessageUserResponseBody(TeaModel):
    def __init__(
        self,
        msg_tid: str = None,
        request_id: str = None,
    ):
        # The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.
        self.msg_tid = msg_tid
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.msg_tid is not None:
            result['MsgTid'] = self.msg_tid
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MsgTid') is not None:
            self.msg_tid = m.get('MsgTid')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendLiveMessageUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendLiveMessageUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLiveMessageUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendMessageToGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data: str = None,
        group_id: str = None,
        operator_user_id: str = None,
        skip_audit: bool = None,
        type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The message body. The value is a JSON string.
        # 
        # This parameter is required.
        self.data = data
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performed the operation.
        # 
        # This parameter is required.
        self.operator_user_id = operator_user_id
        # Specifies whether the message requires Alibaba Cloud content moderation. Valid values:
        # 
        # - **true**: does not require content moderation.
        # - **false**: requires content moderation. This is the default value.
        self.skip_audit = skip_audit
        # The type of the message. A value that is less than or equal to 10000 specifies a system message. A value that is greater than 10000 specifies a custom message.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data is not None:
            result['Data'] = self.data
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        if self.skip_audit is not None:
            result['SkipAudit'] = self.skip_audit
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        if m.get('SkipAudit') is not None:
            self.skip_audit = m.get('SkipAudit')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SendMessageToGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        message_id: str = None,
    ):
        # The ID of the message.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SendMessageToGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: SendMessageToGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The data returned.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = SendMessageToGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class SendMessageToGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendMessageToGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendMessageToGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendMessageToGroupUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data: str = None,
        group_id: str = None,
        operator_user_id: str = None,
        receiver_id_list: List[str] = None,
        skip_audit: bool = None,
        type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The message body. The value is a JSON string.
        # 
        # This parameter is required.
        self.data = data
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        # 
        # This parameter is required.
        self.operator_user_id = operator_user_id
        # The list of users to receive the message.
        self.receiver_id_list = receiver_id_list
        # Specifies whether the message requires Alibaba Cloud content moderation. Valid values:
        # 
        # - **true**: does not require content moderation.
        # - **false**: requires content moderation. This is the default value.
        self.skip_audit = skip_audit
        # The type of the message. A value that is less than or equal to 10000 specifies a system message. A value that is greater than 10000 specifies a custom message.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data is not None:
            result['Data'] = self.data
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        if self.receiver_id_list is not None:
            result['ReceiverIdList'] = self.receiver_id_list
        if self.skip_audit is not None:
            result['SkipAudit'] = self.skip_audit
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        if m.get('ReceiverIdList') is not None:
            self.receiver_id_list = m.get('ReceiverIdList')
        if m.get('SkipAudit') is not None:
            self.skip_audit = m.get('SkipAudit')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SendMessageToGroupUsersShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data: str = None,
        group_id: str = None,
        operator_user_id: str = None,
        receiver_id_list_shrink: str = None,
        skip_audit: bool = None,
        type: int = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The message body. The value is a JSON string.
        # 
        # This parameter is required.
        self.data = data
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The ID of the user who performs the operation.
        # 
        # This parameter is required.
        self.operator_user_id = operator_user_id
        # The list of users to receive the message.
        self.receiver_id_list_shrink = receiver_id_list_shrink
        # Specifies whether the message requires Alibaba Cloud content moderation. Valid values:
        # 
        # - **true**: does not require content moderation.
        # - **false**: requires content moderation. This is the default value.
        self.skip_audit = skip_audit
        # The type of the message. A value that is less than or equal to 10000 specifies a system message. A value that is greater than 10000 specifies a custom message.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data is not None:
            result['Data'] = self.data
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.operator_user_id is not None:
            result['OperatorUserId'] = self.operator_user_id
        if self.receiver_id_list_shrink is not None:
            result['ReceiverIdList'] = self.receiver_id_list_shrink
        if self.skip_audit is not None:
            result['SkipAudit'] = self.skip_audit
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('OperatorUserId') is not None:
            self.operator_user_id = m.get('OperatorUserId')
        if m.get('ReceiverIdList') is not None:
            self.receiver_id_list_shrink = m.get('ReceiverIdList')
        if m.get('SkipAudit') is not None:
            self.skip_audit = m.get('SkipAudit')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SendMessageToGroupUsersResponseBodyResult(TeaModel):
    def __init__(
        self,
        message_id: str = None,
    ):
        # The ID of the message.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SendMessageToGroupUsersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: SendMessageToGroupUsersResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = SendMessageToGroupUsersResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class SendMessageToGroupUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendMessageToGroupUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendMessageToGroupUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetCasterChannelRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        channel_id: str = None,
        face_beauty: str = None,
        owner_id: int = None,
        play_status: int = None,
        region_id: str = None,
        resource_id: str = None,
        seek_offset: int = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the channel.
        # 
        # When channels are enabled, the layout references the channel IDs. You can specify up to one resource for a channel. The number of resources is limited by the number of the channels of the production studio. The value must be in the RV[Number] format, such as RV01 and RV12.
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The face retouching effect. Valid values: 0 (all effects), 1 (skin smoothing), 2 (skin whitening), 3 (dark circles removal), and 4 (nasolabial folds removal).
        self.face_beauty = face_beauty
        self.owner_id = owner_id
        # The playback status. This parameter take effects for video files, but not for live streams. Valid values:
        # 
        # *   **1**: specifies that the video source is playing. This is the default value.
        # *   **0**: specifies that the playback of the video source is paused.
        self.play_status = play_status
        self.region_id = region_id
        # The ID of the video source.
        self.resource_id = resource_id
        # The offset of the position where the production studio starts reading the video source. The value must be greater than or equal to 0, indicating an offset from the first frame. This parameter take effects for video files, but not for live streams. Unit: milliseconds.
        self.seek_offset = seek_offset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.face_beauty is not None:
            result['FaceBeauty'] = self.face_beauty
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_status is not None:
            result['PlayStatus'] = self.play_status
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.seek_offset is not None:
            result['SeekOffset'] = self.seek_offset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('FaceBeauty') is not None:
            self.face_beauty = m.get('FaceBeauty')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayStatus') is not None:
            self.play_status = m.get('PlayStatus')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('SeekOffset') is not None:
            self.seek_offset = m.get('SeekOffset')
        return self


class SetCasterChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetCasterChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetCasterChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetCasterChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetCasterConfigRequest(TeaModel):
    def __init__(
        self,
        auto_switch_urgent_config: str = None,
        auto_switch_urgent_on: bool = None,
        callback_url: str = None,
        caster_id: str = None,
        caster_name: str = None,
        channel_enable: int = None,
        delay: float = None,
        domain_name: str = None,
        owner_id: int = None,
        program_effect: int = None,
        program_name: str = None,
        record_config: str = None,
        region_id: str = None,
        side_output_url: str = None,
        side_output_url_list: str = None,
        sync_groups_config: str = None,
        transcode_config: str = None,
        urgent_image_id: str = None,
        urgent_image_url: str = None,
        urgent_live_stream_url: str = None,
        urgent_material_id: str = None,
    ):
        # The configuration for automatic switchover to the standby resource.
        # 
        # The `eofThres` field specifies the duration after which the production studio automatically switches to the standby resource if a stream interruption occurs. Unit: seconds.
        self.auto_switch_urgent_config = auto_switch_urgent_config
        # Specifies whether the production studio automatically switches to the standby resource in case of a stream interruption.
        # 
        # *   **true**\
        # *   **false**\
        self.auto_switch_urgent_on = auto_switch_urgent_on
        # The callback URL. Enter a valid HTTP address for receiving callback notifications. If you do not specify this parameter, the production studio does not send callback notifications.
        # 
        # >  For more information about production studio callbacks, see [Production studio callbacks](https://help.aliyun.com/document_detail/213633.html).
        self.callback_url = callback_url
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The name of the production studio.
        self.caster_name = caster_name
        # Specifies whether to enable channels. Valid values:
        # 
        # *   **0** (default): disables channels.
        # *   **1**: enables channels.
        # 
        # > You cannot disable channels after you enable them. If you set this parameter to 0, the production studio references video resources in a layout without using channels. If you enable channels for the first time, make sure that the production studio is in the idle state. After you enable channels, a new layout that references video resources by using channels is generated to replace the original one. Therefore, you must specify video resources for channels. You can use the channels to change the playback progress or status. If the video resource, preview, and program modules of the production studio use the same video source, the three modules display the same content.
        self.channel_enable = channel_enable
        # Specifies whether to enable stream delay. Unit: seconds. Valid values:
        # 
        # *   **0** (default): disables stream delay.
        # 
        # *   **A value greater than 0**: enables stream delay.
        # 
        # *   **Empty**: clears the stream delay configuration.
        # 
        #     **\
        # 
        #     **Note **The maximum value can be 300 seconds.
        self.delay = delay
        # The main streaming domain.
        # 
        # Complete the configuration of the domain name before the production studio is started. If you do not specify this parameter, the domain configuration for the production studio is cleared.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # Specifies whether to enable the carousel playback feature. Valid values:
        # 
        # *   **0**: disables carousel playback.
        # *   **1**: enables carousel playback.
        self.program_effect = program_effect
        # The name of the playlist for carousel playback. You can specify this parameter if you enable the carousel playback feature.
        self.program_name = program_name
        # The recording configuration. The value is a JSON string. You can configure the following fields:
        # 
        # *   **endpoint**: the API server address of an Alibaba Cloud service.
        # *   **ossBucket**: the name of the Object Storage Service (OSS) bucket.
        # *   **videoFormat**: the format in which the video file can be exported. Example: `[{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"m3u8\\",\\"CycleDuration\\":21600,\\"SliceOssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{UnixTimestamp}\\"},{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"flv\\",\\"CycleDuration\\":21600}]`.
        # *   **interval**: the interval between recordings. Unit: milliseconds.
        # 
        # > If you do not specify this parameter, the recording feature is disabled and the recording configuration for the production studio is cleared.
        self.record_config = record_config
        self.region_id = region_id
        # The custom stream redirect URL.
        # 
        # If you do not specify this parameter, the production studio uses the redirect URL generated by the system.
        # 
        # > Redirect URLs support only the Real-Time Messaging Protocol (RTMP) protocol.
        self.side_output_url = side_output_url
        # The stream relay URLs. A relay URL can be an Alibaba Cloud URL or a URL from a third-party CDN provider. You can specify up to 20 relay URLs over the RTMP protocol.
        # 
        # > Use the following format to specify multiple relay URLs: "rtmp://domain/app1/stream1","rtmp://domain/app2/stream2".
        self.side_output_url_list = side_output_url_list
        # The multi-view synchronization configuration. You can specify this parameter to synchronize multiple video sources.
        # 
        # There are two modes of multi-view synchronization.
        # 
        # *   A value of 0 for the mode field specifies the streamer mode. In this mode, multiple video sources are synchronized based on the settings by the streamer.
        # *   A value of 1 for the mode field specifies the conference mode. In this mode, all video sources are synchronized.
        # 
        # In the streamer mode, the hostResourceId field specifies the video source on the streamer side.
        # 
        # In the conference mode, the hostResourceId field is not available. You need to provide only resource IDs that are required.
        self.sync_groups_config = sync_groups_config
        # The transcoding configuration.
        # 
        # The value is a JSON string. Use upper camel case for fields of the string. If you do not specify this parameter, the transcoding configuration is cleared. If no transcoding template is available, an error occurs when the production studio is started.
        self.transcode_config = transcode_config
        # The ID of the standby image from the media library.
        self.urgent_image_id = urgent_image_id
        # The URL of the standby image.
        self.urgent_image_url = urgent_image_url
        # The URL of the standby live stream.
        self.urgent_live_stream_url = urgent_live_stream_url
        # The ID of the standby video from the media library. If you do not specify this parameter, the standby video configuration for the production studio is cleared.
        self.urgent_material_id = urgent_material_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_switch_urgent_config is not None:
            result['AutoSwitchUrgentConfig'] = self.auto_switch_urgent_config
        if self.auto_switch_urgent_on is not None:
            result['AutoSwitchUrgentOn'] = self.auto_switch_urgent_on
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.caster_name is not None:
            result['CasterName'] = self.caster_name
        if self.channel_enable is not None:
            result['ChannelEnable'] = self.channel_enable
        if self.delay is not None:
            result['Delay'] = self.delay
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_effect is not None:
            result['ProgramEffect'] = self.program_effect
        if self.program_name is not None:
            result['ProgramName'] = self.program_name
        if self.record_config is not None:
            result['RecordConfig'] = self.record_config
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.side_output_url is not None:
            result['SideOutputUrl'] = self.side_output_url
        if self.side_output_url_list is not None:
            result['SideOutputUrlList'] = self.side_output_url_list
        if self.sync_groups_config is not None:
            result['SyncGroupsConfig'] = self.sync_groups_config
        if self.transcode_config is not None:
            result['TranscodeConfig'] = self.transcode_config
        if self.urgent_image_id is not None:
            result['UrgentImageId'] = self.urgent_image_id
        if self.urgent_image_url is not None:
            result['UrgentImageUrl'] = self.urgent_image_url
        if self.urgent_live_stream_url is not None:
            result['UrgentLiveStreamUrl'] = self.urgent_live_stream_url
        if self.urgent_material_id is not None:
            result['UrgentMaterialId'] = self.urgent_material_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoSwitchUrgentConfig') is not None:
            self.auto_switch_urgent_config = m.get('AutoSwitchUrgentConfig')
        if m.get('AutoSwitchUrgentOn') is not None:
            self.auto_switch_urgent_on = m.get('AutoSwitchUrgentOn')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('CasterName') is not None:
            self.caster_name = m.get('CasterName')
        if m.get('ChannelEnable') is not None:
            self.channel_enable = m.get('ChannelEnable')
        if m.get('Delay') is not None:
            self.delay = m.get('Delay')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramEffect') is not None:
            self.program_effect = m.get('ProgramEffect')
        if m.get('ProgramName') is not None:
            self.program_name = m.get('ProgramName')
        if m.get('RecordConfig') is not None:
            self.record_config = m.get('RecordConfig')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SideOutputUrl') is not None:
            self.side_output_url = m.get('SideOutputUrl')
        if m.get('SideOutputUrlList') is not None:
            self.side_output_url_list = m.get('SideOutputUrlList')
        if m.get('SyncGroupsConfig') is not None:
            self.sync_groups_config = m.get('SyncGroupsConfig')
        if m.get('TranscodeConfig') is not None:
            self.transcode_config = m.get('TranscodeConfig')
        if m.get('UrgentImageId') is not None:
            self.urgent_image_id = m.get('UrgentImageId')
        if m.get('UrgentImageUrl') is not None:
            self.urgent_image_url = m.get('UrgentImageUrl')
        if m.get('UrgentLiveStreamUrl') is not None:
            self.urgent_live_stream_url = m.get('UrgentLiveStreamUrl')
        if m.get('UrgentMaterialId') is not None:
            self.urgent_material_id = m.get('UrgentMaterialId')
        return self


class SetCasterConfigResponseBody(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        request_id: str = None,
    ):
        # The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.
        self.caster_id = caster_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetCasterConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetCasterConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetCasterConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetCasterSceneConfigRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: List[str] = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The IDs of the components. Components in the scene are listed from the bottom to the top in an array.
        # 
        # >  N indicates a sequence number. Examples:\\
        # ComponentId.1 indicates the ID of the first component.\\
        # ComponentId.2 indicates the ID of the second component.
        self.component_id = component_id
        # The ID of the layout. If you call the [DescribeCasterLayouts](https://help.aliyun.com/document_detail/60260.html) operation to query the layouts of the production studio, check the value of the response parameter LayoutId to obtain the ID.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class SetCasterSceneConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetCasterSceneConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetCasterSceneConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetCasterSceneConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveDomainCertificateRequest(TeaModel):
    def __init__(
        self,
        cert_name: str = None,
        cert_type: str = None,
        domain_name: str = None,
        force_set: str = None,
        owner_id: int = None,
        sslpri: str = None,
        sslprotocol: str = None,
        sslpub: str = None,
        security_token: str = None,
    ):
        # The certificate name.
        self.cert_name = cert_name
        # The certificate type. Valid values:
        # 
        # *   **upload**: a custom certificate
        # *   **cas**: a certificate that is purchased from Certificate Management Service
        # *   **free**: a free certificate (for testing)
        self.cert_type = cert_type
        # The domain name that is secured by the certificate. The domain name uses `HTTPS`-based acceleration.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to check the certificate name for duplicates. A value of 1 indicates that the system does not perform the check and overwrites the information about the certificate that has the same name. Set the value to **1**.
        self.force_set = force_set
        self.owner_id = owner_id
        # The private key.
        # 
        # >  This parameter is required only if you set the SSLProtocol parameter to on.
        self.sslpri = sslpri
        # Specifies whether to enable the HTTPS certificate. Valid values:
        # 
        # *   **on**. If you set this parameter to **on**, you must also specify the SSLPub and SSLPri parameters.
        # *   **off**. This is the default value.
        # 
        # This parameter is required.
        self.sslprotocol = sslprotocol
        # The public key.
        # 
        # >  This parameter is required only if you set the SSLProtocol parameter to on.
        self.sslpub = sslpub
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['CertName'] = self.cert_name
        if self.cert_type is not None:
            result['CertType'] = self.cert_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.force_set is not None:
            result['ForceSet'] = self.force_set
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.sslpri is not None:
            result['SSLPri'] = self.sslpri
        if self.sslprotocol is not None:
            result['SSLProtocol'] = self.sslprotocol
        if self.sslpub is not None:
            result['SSLPub'] = self.sslpub
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertName') is not None:
            self.cert_name = m.get('CertName')
        if m.get('CertType') is not None:
            self.cert_type = m.get('CertType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ForceSet') is not None:
            self.force_set = m.get('ForceSet')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SSLPri') is not None:
            self.sslpri = m.get('SSLPri')
        if m.get('SSLProtocol') is not None:
            self.sslprotocol = m.get('SSLProtocol')
        if m.get('SSLPub') is not None:
            self.sslpub = m.get('SSLPub')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class SetLiveDomainCertificateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveDomainCertificateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveDomainCertificateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveDomainCertificateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveDomainMultiStreamConfigRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        owner_id: int = None,
        switch: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        # Specifies whether to enable the dual-stream disaster recovery feature. Valid values:
        # 
        # *   **on**: enables the feature.
        # *   **off**: disables the feature.
        # 
        # This parameter is required.
        self.switch = switch

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.switch is not None:
            result['Switch'] = self.switch
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Switch') is not None:
            self.switch = m.get('Switch')
        return self


class SetLiveDomainMultiStreamConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveDomainMultiStreamConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveDomainMultiStreamConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveDomainMultiStreamConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveDomainMultiStreamMasterRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain: str = None,
        owner_id: int = None,
        stream_name: str = None,
        upstream_sequence: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The unique identifier of the stream ingest.
        # 
        # This parameter is required.
        self.upstream_sequence = upstream_sequence

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.upstream_sequence is not None:
            result['UpstreamSequence'] = self.upstream_sequence
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('UpstreamSequence') is not None:
            self.upstream_sequence = m.get('UpstreamSequence')
        return self


class SetLiveDomainMultiStreamMasterResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveDomainMultiStreamMasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveDomainMultiStreamMasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveDomainMultiStreamMasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveDomainMultiStreamOptimalModeRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain: str = None,
        optimal_mode: str = None,
        owner_id: int = None,
        stream_name: str = None,
    ):
        # The application name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # Specifies whether to enable the auto mode of dual-stream disaster recovery. Valid values:
        # 
        # *   **on**: enables the auto mode.
        # *   **off**: disables the auto mode.
        # 
        # This parameter is required.
        self.optimal_mode = optimal_mode
        self.owner_id = owner_id
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.optimal_mode is not None:
            result['OptimalMode'] = self.optimal_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OptimalMode') is not None:
            self.optimal_mode = m.get('OptimalMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class SetLiveDomainMultiStreamOptimalModeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveDomainMultiStreamOptimalModeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveDomainMultiStreamOptimalModeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveDomainMultiStreamOptimalModeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveDomainStagingConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        functions: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The accelerated domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The list of features. You must specify the ConfigId field when you want to modify the configurations. For more information, see **Features specified by the Functions parameter**.
        # 
        # This parameter is required.
        self.functions = functions
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.functions is not None:
            result['Functions'] = self.functions
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Functions') is not None:
            self.functions = m.get('Functions')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetLiveDomainStagingConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveDomainStagingConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveDomainStagingConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveDomainStagingConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveEdgeTransferRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        http_dns: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
        target_domain_list: str = None,
        transfer_args: str = None,
    ):
        # The name of the application to which the live stream belongs. Regular expressions are supported, with a few limits. For more information, see the **Description about the AppName and StreamName parameters** section. For example, a value of **liveApp\\*\\*\\*\\*[1,2,3]** specifies that stream relay is configured for three applications: liveApp\\*\\*\\*\\*1, liveApp\\*\\*\\*\\*2, and liveApp\\*\\*\\*\\*3.****\
        # 
        # > 
        # 
        # *   This parameter takes effect for only destination domain names that are specified by the TargetDomainList parameter.
        # 
        # *   You cannot use a caret (^) or a dollar sign ($) in a regular expression to configure the `AppName` parameter. Otherwise, stream relay fails.
        self.app_name = app_name
        # The ingest domain. Stream relay is configured based on the ingest domain. Only one stream relay configuration can be set for an ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The HTTPDNS API that is used to obtain the destination URLs. The request must contain the `TargetDomainList` parameter or the `HttpDns` parameter. The two parameters are mutually exclusive.
        # 
        # >  If the `HttpDns` parameter is configured, you cannot configure the `TargetDomainList` parameter, and the `AppName` and `StreamName` parameters do not take effect.
        # 
        # For information about the requirements on the structure of messages that are returned by the HTTPDNS API, see the **Description about the HTTPDNS API** section.
        self.http_dns = http_dns
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the ingested stream. Regular expressions are supported, with a few limits. For more information, see the **Description about the AppName and StreamName parameters** section. For example, a value of **liveStream\\*\\*\\*\\*[1,2,3]** specifies that stream relay is configured for three streams: liveStream\\*\\*\\*\\*1, liveStream\\*\\*\\*\\*2, and liveStream\\*\\*\\*\\*3.****\
        # 
        # > 
        # 
        # *   This parameter takes effect for only destination domain names that are specified by the TargetDomainList parameter.
        # 
        # *   You cannot use a caret (^) or a dollar sign ($) in a regular expression to configure the `StreamName` parameter. Otherwise, stream relay fails.
        self.stream_name = stream_name
        # The destination domain names to which you want to relay the ingested stream. Separate multiple domain names with commas (,). The request must contain the `TargetDomainList` parameter or the `HttpDns` parameter. The two parameters are mutually exclusive.
        # 
        # > 
        # 
        # *   The `AppName` and `StreamName` parameters take effect only when the `TargetDomainList` parameter is configured.
        # 
        # *   If the `TargetDomainList` parameter is configured, you cannot configure the `HttpDns` parameter.
        self.target_domain_list = target_domain_list
        # Specifies whether to pass through stream ingest parameters. Valid values:
        # 
        # *   **yes**: passes through stream ingest parameters.
        # *   **no**: does not pass through stream ingest parameters.
        self.transfer_args = transfer_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.http_dns is not None:
            result['HttpDns'] = self.http_dns
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.target_domain_list is not None:
            result['TargetDomainList'] = self.target_domain_list
        if self.transfer_args is not None:
            result['TransferArgs'] = self.transfer_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('HttpDns') is not None:
            self.http_dns = m.get('HttpDns')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TargetDomainList') is not None:
            self.target_domain_list = m.get('TargetDomainList')
        if m.get('TransferArgs') is not None:
            self.transfer_args = m.get('TransferArgs')
        return self


class SetLiveEdgeTransferResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveEdgeTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveEdgeTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveEdgeTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveLazyPullStreamInfoConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        owner_id: int = None,
        pull_app_name: str = None,
        pull_domain_name: str = None,
        pull_protocol: str = None,
        region_id: str = None,
        transcode_lazy: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # >  If you want to configure triggered stream pulling for all applications, set the value to **ali_all_app**.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The name of the application for back-to-origin stream pulling.
        # 
        # >  If you want to use the application specified in the streaming URL, leave this parameter empty.
        self.pull_app_name = pull_app_name
        # The origin server address of the live stream. Separate multiple addresses with semicolons (;).
        # 
        # This parameter is required.
        self.pull_domain_name = pull_domain_name
        # The protocol for back-to-origin stream pulling. Valid values:
        # 
        # *   **rtmp**\
        # *   **httpflv**\
        # *   **hls**\
        # 
        # This parameter is required.
        self.pull_protocol = pull_protocol
        self.region_id = region_id
        # Specifies whether to trigger stream pulling when the transcoded stream is played. The default value is **no**. Valid values:
        # 
        # *   **yes**\
        # *   **no**\
        self.transcode_lazy = transcode_lazy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pull_app_name is not None:
            result['PullAppName'] = self.pull_app_name
        if self.pull_domain_name is not None:
            result['PullDomainName'] = self.pull_domain_name
        if self.pull_protocol is not None:
            result['PullProtocol'] = self.pull_protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.transcode_lazy is not None:
            result['TranscodeLazy'] = self.transcode_lazy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PullAppName') is not None:
            self.pull_app_name = m.get('PullAppName')
        if m.get('PullDomainName') is not None:
            self.pull_domain_name = m.get('PullDomainName')
        if m.get('PullProtocol') is not None:
            self.pull_protocol = m.get('PullProtocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TranscodeLazy') is not None:
            self.transcode_lazy = m.get('TranscodeLazy')
        return self


class SetLiveLazyPullStreamInfoConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveLazyPullStreamInfoConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveLazyPullStreamInfoConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveLazyPullStreamInfoConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveMpuTaskSeiRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        custom_sei: str = None,
        task_id: str = None,
    ):
        # The application ID.
        # 
        # >  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The custom SEI.
        # 
        # >  The value is a JSON string that can be up to 4,096 characters in length.
        # 
        # This parameter is required.
        self.custom_sei = custom_sei
        # The task ID.
        # 
        # >  The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.custom_sei is not None:
            result['CustomSei'] = self.custom_sei
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CustomSei') is not None:
            self.custom_sei = m.get('CustomSei')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SetLiveMpuTaskSeiResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveMpuTaskSeiResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveMpuTaskSeiResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveMpuTaskSeiResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveStreamBlockRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        block_type: str = None,
        domain_name: str = None,
        location_list: str = None,
        owner_id: int = None,
        region_id: str = None,
        release_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The blocking type. Valid values: blacklist and whitelist.
        # 
        # This parameter is required.
        self.block_type = block_type
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The blocked region. If you specify multiple regions, such as CN and AS, separate them with commas (,).
        # 
        # This parameter is required.
        self.location_list = location_list
        self.owner_id = owner_id
        self.region_id = region_id
        # The time when the blocking ends. The time must be in UTC. If you do not specify this parameter, the blocking is valid for 7 days by default.
        self.release_time = release_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.block_type is not None:
            result['BlockType'] = self.block_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.location_list is not None:
            result['LocationList'] = self.location_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BlockType') is not None:
            self.block_type = m.get('BlockType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LocationList') is not None:
            self.location_list = m.get('LocationList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class SetLiveStreamBlockResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        status: str = None,
    ):
        # The result description.
        # 
        # *   If the request was successful, ok is returned.
        # *   If the request failed, the failure detail is returned.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The status. Valid values:
        # 
        # *   ok: The request was successful.
        # *   fail: The request failed.
        # 
        # >  If any parameter failed to be configured, the request failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetLiveStreamBlockResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveStreamBlockResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveStreamBlockResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveStreamDelayConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        flv_delay: int = None,
        flv_level: str = None,
        hls_delay: int = None,
        hls_level: str = None,
        owner_id: int = None,
        region_id: str = None,
        rtmp_delay: int = None,
        rtmp_level: str = None,
    ):
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The latency of FLV-based playback. Unit: seconds.
        # 
        # >  If this parameter is left empty, the latency is set to a value corresponding to the FlvLevel parameter.
        self.flv_delay = flv_delay
        # The latency level of FLV-based playback. Ignore this parameter if the FlvDelay parameter is configured.
        # 
        # Valid values:
        # 
        # *   **short** (default): The latency is 4 seconds.
        # *   **medium**: The latency is 8 seconds.
        # *   **long**: The latency is 16 seconds.
        # 
        # >  If both the FlvDelay and FlvLevel parameters are left empty, FlvLevel is set to **short** by default.
        self.flv_level = flv_level
        # The latency of HLS-based playback. Unit: seconds.
        # 
        # >  If this parameter is left empty, the latency is set to a value corresponding to the HlsLevel parameter.
        self.hls_delay = hls_delay
        # The latency level of HLS-based playback. Ignore this parameter if the HlsDelay parameter is configured.
        # 
        # Valid values:
        # 
        # *   **short**: The latency is 3 seconds. This is the default value.
        # *   **medium**: The latency is 6 seconds.
        # *   **long**: The latency is 15 seconds.
        # 
        # >  If both the HlsDelay and HlsLevel parameters are left empty, HlsLevel is set to **short** by default.
        self.hls_level = hls_level
        self.owner_id = owner_id
        self.region_id = region_id
        # The latency of RTMP-based playback. Unit: seconds.
        # 
        # >  If this parameter is left empty, the latency is set to a value corresponding to the RtmpLevel parameter.
        self.rtmp_delay = rtmp_delay
        # The latency level of RTMP-based playback. Ignore this parameter if the RtmpDelay parameter is configured.
        # 
        # Valid values:
        # 
        # *   **short** (default): The latency is 4 seconds.
        # *   **medium**: The latency is 8 seconds.
        # *   **long**: The latency is 16 seconds.
        # 
        # >  If both the RtmpDelay and RtmpLevel parameters are left empty, RtmpLevel is set to **short** by default.
        self.rtmp_level = rtmp_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.flv_delay is not None:
            result['FlvDelay'] = self.flv_delay
        if self.flv_level is not None:
            result['FlvLevel'] = self.flv_level
        if self.hls_delay is not None:
            result['HlsDelay'] = self.hls_delay
        if self.hls_level is not None:
            result['HlsLevel'] = self.hls_level
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rtmp_delay is not None:
            result['RtmpDelay'] = self.rtmp_delay
        if self.rtmp_level is not None:
            result['RtmpLevel'] = self.rtmp_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('FlvDelay') is not None:
            self.flv_delay = m.get('FlvDelay')
        if m.get('FlvLevel') is not None:
            self.flv_level = m.get('FlvLevel')
        if m.get('HlsDelay') is not None:
            self.hls_delay = m.get('HlsDelay')
        if m.get('HlsLevel') is not None:
            self.hls_level = m.get('HlsLevel')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RtmpDelay') is not None:
            self.rtmp_delay = m.get('RtmpDelay')
        if m.get('RtmpLevel') is not None:
            self.rtmp_level = m.get('RtmpLevel')
        return self


class SetLiveStreamDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveStreamDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveStreamDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveStreamDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveStreamPreloadTasksRequest(TeaModel):
    def __init__(
        self,
        area: str = None,
        domain_name: str = None,
        owner_id: int = None,
        play_url: str = None,
        preloaded_end_time: str = None,
        preloaded_start_time: str = None,
        region_id: str = None,
    ):
        # The acceleration region where you want to prefetch the live content. Valid values:
        # 
        # *   domestic: regions in the Chinese mainland.
        # *   overseas: regions outside the Chinese mainland.
        # *   global: regions in and outside the Chinese mainland.
        # 
        # If you do not specify this parameter, the acceleration region configured for the domain name is used.
        self.area = area
        # The streaming domain name.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        # The streaming URL. You can specify up to 100 streaming URLs in a request. Separate multiple streaming URLs with commas (,).
        # 
        # This parameter is required.
        self.play_url = play_url
        # The end time of the prefetch task. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-30T19:00:00Z. The interval between the start time and end time cannot exceed 6 hours.
        self.preloaded_end_time = preloaded_end_time
        # The start time of the prefetch task. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-29T19:00:00Z. If you do not specify this parameter, the prefetch task runs for 1 hour by default.
        self.preloaded_start_time = preloaded_start_time
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_url is not None:
            result['PlayUrl'] = self.play_url
        if self.preloaded_end_time is not None:
            result['PreloadedEndTime'] = self.preloaded_end_time
        if self.preloaded_start_time is not None:
            result['PreloadedStartTime'] = self.preloaded_start_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayUrl') is not None:
            self.play_url = m.get('PlayUrl')
        if m.get('PreloadedEndTime') is not None:
            self.preloaded_end_time = m.get('PreloadedEndTime')
        if m.get('PreloadedStartTime') is not None:
            self.preloaded_start_time = m.get('PreloadedStartTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage(TeaModel):
    def __init__(
        self,
        description: str = None,
        play_url: str = None,
        task_id: str = None,
    ):
        # Indicates whether the prefetch task is successful. Valid values:
        # 
        # *   Successfully
        # *   InternalError
        self.description = description
        # The streaming URL.
        self.play_url = play_url
        # The ID of the prefetch task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.play_url is not None:
            result['PlayUrl'] = self.play_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('PlayUrl') is not None:
            self.play_url = m.get('PlayUrl')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages(TeaModel):
    def __init__(
        self,
        preload_tasks_message: List[SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage] = None,
    ):
        self.preload_tasks_message = preload_tasks_message

    def validate(self):
        if self.preload_tasks_message:
            for k in self.preload_tasks_message:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PreloadTasksMessage'] = []
        if self.preload_tasks_message is not None:
            for k in self.preload_tasks_message:
                result['PreloadTasksMessage'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preload_tasks_message = []
        if m.get('PreloadTasksMessage') is not None:
            for k in m.get('PreloadTasksMessage'):
                temp_model = SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage()
                self.preload_tasks_message.append(temp_model.from_map(k))
        return self


class SetLiveStreamPreloadTasksResponseBody(TeaModel):
    def __init__(
        self,
        failed_url: int = None,
        preload_tasks_messages: SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages = None,
        request_id: str = None,
        status: str = None,
        success_url: int = None,
        total_url: int = None,
    ):
        # The number of URLs for which the prefetch task configuration failed.
        self.failed_url = failed_url
        # The details of the prefetch task.
        self.preload_tasks_messages = preload_tasks_messages
        # The ID of the request.
        self.request_id = request_id
        # The status of the prefetch task. Valid values:
        # 
        # *   Success
        # *   Failed
        # 
        # >  Success is returned only if the prefetch task is configured for all specified streaming URLs.
        self.status = status
        # The number of URLs for which the prefetch task is successfully configured.
        self.success_url = success_url
        # The total number of URLs.
        self.total_url = total_url

    def validate(self):
        if self.preload_tasks_messages:
            self.preload_tasks_messages.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_url is not None:
            result['FailedURL'] = self.failed_url
        if self.preload_tasks_messages is not None:
            result['PreloadTasksMessages'] = self.preload_tasks_messages.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.success_url is not None:
            result['SuccessURL'] = self.success_url
        if self.total_url is not None:
            result['TotalURL'] = self.total_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedURL') is not None:
            self.failed_url = m.get('FailedURL')
        if m.get('PreloadTasksMessages') is not None:
            temp_model = SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages()
            self.preload_tasks_messages = temp_model.from_map(m['PreloadTasksMessages'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SuccessURL') is not None:
            self.success_url = m.get('SuccessURL')
        if m.get('TotalURL') is not None:
            self.total_url = m.get('TotalURL')
        return self


class SetLiveStreamPreloadTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveStreamPreloadTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveStreamPreloadTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetLiveStreamsNotifyUrlConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        exception_notify_url: str = None,
        notify_auth_key: str = None,
        notify_req_auth: str = None,
        notify_url: str = None,
        owner_id: int = None,
        switch_notify_url: str = None,
    ):
        # The ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Exception event callback URL.
        self.exception_notify_url = exception_notify_url
        # The authentication key.
        # 
        # >  This parameter is required if you set the NotifyReqAuth parameter to **yes**.
        # 
        # Value requirements:
        # 
        # *   The key must be 16 to 64 characters in length.
        # *   The key can contain letters and digits.
        self.notify_auth_key = notify_auth_key
        # Specifies whether to enable callback authentication. Valid values:
        # 
        # *   **yes**: enables callback authentication. If you set this parameter to **yes**, you must also specify the NotifyAuthKey parameter.
        # *   **no**: disables callback authentication.
        # 
        # >  If you do not specify this parameter, the default value **no** is used.
        # 
        # For information about the authentication logic, see **Authentication for stream ingest callbacks**.
        self.notify_req_auth = notify_req_auth
        # The URL to which the stream ingest callbacks are sent.
        self.notify_url = notify_url
        self.owner_id = owner_id
        self.switch_notify_url = switch_notify_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.exception_notify_url is not None:
            result['ExceptionNotifyUrl'] = self.exception_notify_url
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.switch_notify_url is not None:
            result['SwitchNotifyUrl'] = self.switch_notify_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ExceptionNotifyUrl') is not None:
            self.exception_notify_url = m.get('ExceptionNotifyUrl')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SwitchNotifyUrl') is not None:
            self.switch_notify_url = m.get('SwitchNotifyUrl')
        return self


class SetLiveStreamsNotifyUrlConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetLiveStreamsNotifyUrlConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetLiveStreamsNotifyUrlConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetLiveStreamsNotifyUrlConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetShowListBackgroundRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        material_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        resource_type: str = None,
        resource_url: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the material in ApsaraVideo VOD.
        # 
        # >  Specify either this parameter or the ResourceUrl parameter.
        self.material_id = material_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The resource type. Valid values:
        # 
        # *   LIVE: live stream. You can add a live stream from ApsaraVideo Live or by using a third-party URL.
        # *   VOD: on-demand video. You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL.
        # *   PIC: image. You can add an image from ApsaraVideo VOD or by using a third-party URL.
        # 
        # >  Set this parameter to one of the preceding values, or leave this parameter empty.
        self.resource_type = resource_type
        # The URL of the third-party material.
        self.resource_url = resource_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.material_id is not None:
            result['MaterialId'] = self.material_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.resource_url is not None:
            result['ResourceUrl'] = self.resource_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('MaterialId') is not None:
            self.material_id = m.get('MaterialId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('ResourceUrl') is not None:
            self.resource_url = m.get('ResourceUrl')
        return self


class SetShowListBackgroundResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetShowListBackgroundResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetShowListBackgroundResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetShowListBackgroundResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetSnapshotCallbackAuthRequest(TeaModel):
    def __init__(
        self,
        callback_auth_key: str = None,
        callback_req_auth: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The custom key that is used for callback authentication.
        # 
        # This parameter is required.
        self.callback_auth_key = callback_auth_key
        # Specifies whether to enable callback authentication. Valid values:
        # 
        # *   **yes**: enables callback authentication.
        # *   **no**: disables callback authentication.
        # 
        # This parameter is required.
        self.callback_req_auth = callback_req_auth
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_auth_key is not None:
            result['CallbackAuthKey'] = self.callback_auth_key
        if self.callback_req_auth is not None:
            result['CallbackReqAuth'] = self.callback_req_auth
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackAuthKey') is not None:
            self.callback_auth_key = m.get('CallbackAuthKey')
        if m.get('CallbackReqAuth') is not None:
            self.callback_req_auth = m.get('CallbackReqAuth')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetSnapshotCallbackAuthResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetSnapshotCallbackAuthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetSnapshotCallbackAuthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetSnapshotCallbackAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCasterRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo(TeaModel):
    def __init__(
        self,
        output_stream_url: str = None,
        transcode_config: str = None,
        video_format: str = None,
    ):
        # The URL.
        self.output_stream_url = output_stream_url
        # The transcoding configuration. Valid values:
        # 
        # *   **lsd**: standard definition
        # *   **lld**: low definition
        # *   **lud**: ultra-high definition
        # *   **lhd**: high definition
        self.transcode_config = transcode_config
        # The format. Valid values:
        # 
        # *   **flv**\
        # *   **rtmp**\
        # *   **m3u8**\
        self.video_format = video_format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_stream_url is not None:
            result['OutputStreamUrl'] = self.output_stream_url
        if self.transcode_config is not None:
            result['TranscodeConfig'] = self.transcode_config
        if self.video_format is not None:
            result['VideoFormat'] = self.video_format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OutputStreamUrl') is not None:
            self.output_stream_url = m.get('OutputStreamUrl')
        if m.get('TranscodeConfig') is not None:
            self.transcode_config = m.get('TranscodeConfig')
        if m.get('VideoFormat') is not None:
            self.video_format = m.get('VideoFormat')
        return self


class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos(TeaModel):
    def __init__(
        self,
        stream_info: List[StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo] = None,
    ):
        self.stream_info = stream_info

    def validate(self):
        if self.stream_info:
            for k in self.stream_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfo'] = []
        if self.stream_info is not None:
            for k in self.stream_info:
                result['StreamInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream_info = []
        if m.get('StreamInfo') is not None:
            for k in m.get('StreamInfo'):
                temp_model = StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo()
                self.stream_info.append(temp_model.from_map(k))
        return self


class StartCasterResponseBodyPgmSceneInfosSceneInfo(TeaModel):
    def __init__(
        self,
        scene_id: str = None,
        stream_infos: StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos = None,
        stream_url: str = None,
    ):
        # The ID of the scene.
        self.scene_id = scene_id
        # The stream relay URLs.
        self.stream_infos = stream_infos
        # The streaming URL of the PGM scene in the production studio. The value is not a stream relay URL.
        self.stream_url = stream_url

    def validate(self):
        if self.stream_infos:
            self.stream_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        if self.stream_infos is not None:
            result['StreamInfos'] = self.stream_infos.to_map()
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        if m.get('StreamInfos') is not None:
            temp_model = StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos()
            self.stream_infos = temp_model.from_map(m['StreamInfos'])
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class StartCasterResponseBodyPgmSceneInfos(TeaModel):
    def __init__(
        self,
        scene_info: List[StartCasterResponseBodyPgmSceneInfosSceneInfo] = None,
    ):
        self.scene_info = scene_info

    def validate(self):
        if self.scene_info:
            for k in self.scene_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SceneInfo'] = []
        if self.scene_info is not None:
            for k in self.scene_info:
                result['SceneInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.scene_info = []
        if m.get('SceneInfo') is not None:
            for k in m.get('SceneInfo'):
                temp_model = StartCasterResponseBodyPgmSceneInfosSceneInfo()
                self.scene_info.append(temp_model.from_map(k))
        return self


class StartCasterResponseBodyPvwSceneInfosSceneInfo(TeaModel):
    def __init__(
        self,
        scene_id: str = None,
        stream_url: str = None,
    ):
        # The ID of the scene.
        self.scene_id = scene_id
        # The streaming URL of the PVW scene in the production studio. The value is not a stream relay URL.
        self.stream_url = stream_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class StartCasterResponseBodyPvwSceneInfos(TeaModel):
    def __init__(
        self,
        scene_info: List[StartCasterResponseBodyPvwSceneInfosSceneInfo] = None,
    ):
        self.scene_info = scene_info

    def validate(self):
        if self.scene_info:
            for k in self.scene_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SceneInfo'] = []
        if self.scene_info is not None:
            for k in self.scene_info:
                result['SceneInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.scene_info = []
        if m.get('SceneInfo') is not None:
            for k in m.get('SceneInfo'):
                temp_model = StartCasterResponseBodyPvwSceneInfosSceneInfo()
                self.scene_info.append(temp_model.from_map(k))
        return self


class StartCasterResponseBody(TeaModel):
    def __init__(
        self,
        pgm_scene_infos: StartCasterResponseBodyPgmSceneInfos = None,
        pvw_scene_infos: StartCasterResponseBodyPvwSceneInfos = None,
        request_id: str = None,
    ):
        # The PGM scenes.
        self.pgm_scene_infos = pgm_scene_infos
        # The PVW scenes.
        self.pvw_scene_infos = pvw_scene_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.pgm_scene_infos:
            self.pgm_scene_infos.validate()
        if self.pvw_scene_infos:
            self.pvw_scene_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pgm_scene_infos is not None:
            result['PgmSceneInfos'] = self.pgm_scene_infos.to_map()
        if self.pvw_scene_infos is not None:
            result['PvwSceneInfos'] = self.pvw_scene_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PgmSceneInfos') is not None:
            temp_model = StartCasterResponseBodyPgmSceneInfos()
            self.pgm_scene_infos = temp_model.from_map(m['PgmSceneInfos'])
        if m.get('PvwSceneInfos') is not None:
            temp_model = StartCasterResponseBodyPvwSceneInfos()
            self.pvw_scene_infos = temp_model.from_map(m['PvwSceneInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCasterSceneRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This parameter takes effect only if the scene is a PVW scene.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class StartCasterSceneResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stream_url: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The streaming URL of the scene. It is used for playback, but not for stream relay.
        self.stream_url = stream_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_url is not None:
            result['StreamUrl'] = self.stream_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamUrl') is not None:
            self.stream_url = m.get('StreamUrl')
        return self


class StartCasterSceneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCasterSceneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCasterSceneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        job_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the edge transcoding task.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the edge transcoding task.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartLiveDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The ingest domain or streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class StartLiveDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartLiveDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartLiveDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartLiveDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartLiveMPUTaskRequestMultiStreamURL(TeaModel):
    def __init__(
        self,
        is_ali_cdn: bool = None,
        url: str = None,
    ):
        # Specifies whether to perform stream relay by using Alibaba Cloud CDN. Valid values:
        # 
        # *   false: performs stream relay by using a CDN service that is not Alibaba Cloud CDN.
        # *   true: performs stream relay by using Alibaba Cloud CDN.
        # 
        # >  The default value of this parameter is false.
        self.is_ali_cdn = is_ali_cdn
        # The ingest URL. Only the RTMP format is supported. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_ali_cdn is not None:
            result['IsAliCdn'] = self.is_ali_cdn
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsAliCdn') is not None:
            self.is_ali_cdn = m.get('IsAliCdn')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class StartLiveMPUTaskRequestSeiParamsLayoutVolume(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
    ):
        # Specifies whether to include the SEI in an Instantaneous Decoder Refresh (IDR) frame. Valid values:
        # 
        # *   **0**: does not include the SEI.
        # *   **1**: includes the SEI.
        self.follow_idr = follow_idr
        # The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.
        self.interval = interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        return self


class StartLiveMPUTaskRequestSeiParamsPassThrough(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
        payload_content: str = None,
        payload_content_key: str = None,
    ):
        # Specifies whether to include the SEI in an IDR frame. Valid values:
        # 
        # *   **0**: does not include the SEI.
        # *   **1**: includes the SEI.
        self.follow_idr = follow_idr
        # The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.
        self.interval = interval
        # The payload content of the SEI.
        self.payload_content = payload_content
        # The key of the payload content of the SEI. If you do not specify this parameter, the default value udd is used.
        self.payload_content_key = payload_content_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.payload_content is not None:
            result['PayloadContent'] = self.payload_content
        if self.payload_content_key is not None:
            result['PayloadContentKey'] = self.payload_content_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PayloadContent') is not None:
            self.payload_content = m.get('PayloadContent')
        if m.get('PayloadContentKey') is not None:
            self.payload_content_key = m.get('PayloadContentKey')
        return self


class StartLiveMPUTaskRequestSeiParams(TeaModel):
    def __init__(
        self,
        layout_volume: StartLiveMPUTaskRequestSeiParamsLayoutVolume = None,
        pass_through: StartLiveMPUTaskRequestSeiParamsPassThrough = None,
        payload_type: str = None,
    ):
        # The layout and volume SEI. If you leave this parameter empty, the default layout and volume SEI is used.
        self.layout_volume = layout_volume
        # Specifies whether to pass through the SEI.
        self.pass_through = pass_through
        # The custom payload_type of the SEI. Valid values: 100 to 254. If you do not specify this parameter, the default value 5 is used.
        self.payload_type = payload_type

    def validate(self):
        if self.layout_volume:
            self.layout_volume.validate()
        if self.pass_through:
            self.pass_through.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_volume is not None:
            result['LayoutVolume'] = self.layout_volume.to_map()
        if self.pass_through is not None:
            result['PassThrough'] = self.pass_through.to_map()
        if self.payload_type is not None:
            result['PayloadType'] = self.payload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutVolume') is not None:
            temp_model = StartLiveMPUTaskRequestSeiParamsLayoutVolume()
            self.layout_volume = temp_model.from_map(m['LayoutVolume'])
        if m.get('PassThrough') is not None:
            temp_model = StartLiveMPUTaskRequestSeiParamsPassThrough()
            self.pass_through = temp_model.from_map(m['PassThrough'])
        if m.get('PayloadType') is not None:
            self.payload_type = m.get('PayloadType')
        return self


class StartLiveMPUTaskRequestSingleSubParams(TeaModel):
    def __init__(
        self,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The type of the stream that you want to relay. Valid values:
        # 
        # *   **0** (default): original stream
        # *   **1**: only the audio track
        # *   **2**: only the video track
        self.stream_type = stream_type
        # The user ID. In the single-stream relay mode, you can relay only one stream in a request.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartLiveMPUTaskRequestTranscodeParamsBackground(TeaModel):
    def __init__(
        self,
        render_mode: str = None,
        url: str = None,
    ):
        # The display mode of the global background image. Valid values:
        # 
        # *   **0**: scales the background image proportionally to fit the view, with black bars displayed.
        # *   **1** (default): crops the background image to fit the view.
        self.render_mode = render_mode
        # The URL of the global background image. The URL can be up to 2,048 characters in length.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class StartLiveMPUTaskRequestTranscodeParamsEncodeParams(TeaModel):
    def __init__(
        self,
        audio_bitrate: str = None,
        audio_channels: str = None,
        audio_only: str = None,
        audio_sample_rate: str = None,
        enhanced_param: str = None,
        video_bitrate: str = None,
        video_codec: str = None,
        video_framerate: str = None,
        video_gop: str = None,
        video_height: str = None,
        video_width: str = None,
    ):
        # The bitrate of the audio. Valid values: [8,500]. Unit: Kbit/s.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values: 1 and 2.
        self.audio_channels = audio_channels
        # Specifies whether the output stream is an audio-only stream. Valid values:
        # 
        # *   **true**: The output stream is an audio-only stream. If you set this parameter to true, you need to configure only audio-related parameters under EncodeParams.
        # *   **false** (default): The output stream is not an audio-only stream. If you set this parameter to false, you need to configure all parameters under EncodeParams, except the VideoCodec and EnhancedParam parameters.
        self.audio_only = audio_only
        # The audio sampling rate. Valid values: 8000, 16000, 32000, 44100, and 48000. Unit: Hz.
        self.audio_sample_rate = audio_sample_rate
        # The parameter used for encoding enhancement, which is a JSON string. The parameter includes the optional profile and preset fields.
        # 
        # *   profile: the encoding level. If the video codec is H.264, the valid values of this field are baseline, main, and high. If the video codec is H.265, the valid value of this field is main.
        # *   preset: adjusts the trade-off between encoding speed and video quality. The valid values of this field are ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.
        # 
        # >  A value of superfast for the preset field is suitable for real-time communication scenarios. We recommend that you not set the field if you are not a professional encoding engineer.
        self.enhanced_param = enhanced_param
        # The bitrate of the video. Valid values: [1,10000]. Unit: Kbit/s.
        self.video_bitrate = video_bitrate
        # The video codec. Valid values:
        # 
        # *   H.264 (default)
        # *   H.265
        self.video_codec = video_codec
        # The frame rate of the video. Valid values: [1,60]. Unit: frames per second (FPS).
        self.video_framerate = video_framerate
        # The group of pictures (GOP) size of the video. Valid values: [1,60].
        self.video_gop = video_gop
        # The height of the video. Valid values: [0,1920]. Unit: pixels.
        self.video_height = video_height
        # The width of the video. Valid values: [0,1920]. Unit: pixels.
        self.video_width = video_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channels is not None:
            result['AudioChannels'] = self.audio_channels
        if self.audio_only is not None:
            result['AudioOnly'] = self.audio_only
        if self.audio_sample_rate is not None:
            result['AudioSampleRate'] = self.audio_sample_rate
        if self.enhanced_param is not None:
            result['EnhancedParam'] = self.enhanced_param
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_framerate is not None:
            result['VideoFramerate'] = self.video_framerate
        if self.video_gop is not None:
            result['VideoGop'] = self.video_gop
        if self.video_height is not None:
            result['VideoHeight'] = self.video_height
        if self.video_width is not None:
            result['VideoWidth'] = self.video_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannels') is not None:
            self.audio_channels = m.get('AudioChannels')
        if m.get('AudioOnly') is not None:
            self.audio_only = m.get('AudioOnly')
        if m.get('AudioSampleRate') is not None:
            self.audio_sample_rate = m.get('AudioSampleRate')
        if m.get('EnhancedParam') is not None:
            self.enhanced_param = m.get('EnhancedParam')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoFramerate') is not None:
            self.video_framerate = m.get('VideoFramerate')
        if m.get('VideoGop') is not None:
            self.video_gop = m.get('VideoGop')
        if m.get('VideoHeight') is not None:
            self.video_height = m.get('VideoHeight')
        if m.get('VideoWidth') is not None:
            self.video_width = m.get('VideoWidth')
        return self


class StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.
        self.channel_id = channel_id
        # The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes(TeaModel):
    def __init__(
        self,
        background_image_url: str = None,
        height: str = None,
        render_mode: str = None,
        user_info: StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo = None,
        width: str = None,
        x: str = None,
        y: str = None,
        zorder: str = None,
    ):
        # The URL of the background image of the pane. The URL can be up to 2,048 characters in length. This image is displayed if the user turns off the camera or is not present in the channel.
        self.background_image_url = background_image_url
        # The height of the pane. The value is normalized.
        self.height = height
        # The display mode of the pane. Valid values:
        # 
        # *   **0**: scales the video proportionally to fit the view, with black bars displayed.
        # *   **1 (default)**: crops the video to fit the view.
        self.render_mode = render_mode
        # The information about the user whose stream is played in the pane. If you leave this parameter empty, the system automatically sets this parameter based on the order in which streamers join the channel.
        # 
        # > 
        # 
        # *   If you specify the information about a user by using this parameter, the information about the user must also be specified by using the TranscodeParams.UserInfos parameter.
        # 
        # *   This parameter is valid only when you set StreamType to 0 or 2.
        self.user_info = user_info
        # The width of the pane. The value is normalized.
        self.width = width
        # The x-coordinate of the pane. The value is normalized.
        self.x = x
        # The y-coordinate of the pane. The value is normalized.
        self.y = y
        # The layer in which the pane resides. A value of 0 indicates the bottom layer. Each increment of the value by 1 indicates the next upper layer.
        self.zorder = zorder

    def validate(self):
        if self.user_info:
            self.user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_image_url is not None:
            result['BackgroundImageUrl'] = self.background_image_url
        if self.height is not None:
            result['Height'] = self.height
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.user_info is not None:
            result['UserInfo'] = self.user_info.to_map()
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundImageUrl') is not None:
            self.background_image_url = m.get('BackgroundImageUrl')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('UserInfo') is not None:
            temp_model = StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo()
            self.user_info = temp_model.from_map(m['UserInfo'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartLiveMPUTaskRequestTranscodeParamsLayout(TeaModel):
    def __init__(
        self,
        user_panes: List[StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes] = None,
    ):
        # The information about the panes.
        self.user_panes = user_panes

    def validate(self):
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class StartLiveMPUTaskRequestTranscodeParamsUserInfos(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the subscribed user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.
        self.channel_id = channel_id
        # The type of the video source that is subscribed to. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The type of the relayed stream that is subscribed to. Valid values:
        # 
        # *   **0** (default): original stream
        # *   **1**: only the audio track
        # *   **2**: only the video track
        self.stream_type = stream_type
        # The ID of the subscribed user.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartLiveMPUTaskRequestTranscodeParams(TeaModel):
    def __init__(
        self,
        background: StartLiveMPUTaskRequestTranscodeParamsBackground = None,
        encode_params: StartLiveMPUTaskRequestTranscodeParamsEncodeParams = None,
        layout: StartLiveMPUTaskRequestTranscodeParamsLayout = None,
        user_infos: List[StartLiveMPUTaskRequestTranscodeParamsUserInfos] = None,
    ):
        # The global background image.
        self.background = background
        # The encoding parameters for the output stream.
        self.encode_params = encode_params
        # The video layout information.
        # 
        # >  If video transcoding is required, you must specify the video layout information, including the x-coordinate and y-coordinate, the width and height, and the layer. For audio-only transcoding, leave the video layout information empty.
        self.layout = layout
        # The information about the users whose streams are subscribed to. If you leave this parameter empty, streams from all users are mixed.
        self.user_infos = user_infos

    def validate(self):
        if self.background:
            self.background.validate()
        if self.encode_params:
            self.encode_params.validate()
        if self.layout:
            self.layout.validate()
        if self.user_infos:
            for k in self.user_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background is not None:
            result['Background'] = self.background.to_map()
        if self.encode_params is not None:
            result['EncodeParams'] = self.encode_params.to_map()
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        result['UserInfos'] = []
        if self.user_infos is not None:
            for k in self.user_infos:
                result['UserInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Background') is not None:
            temp_model = StartLiveMPUTaskRequestTranscodeParamsBackground()
            self.background = temp_model.from_map(m['Background'])
        if m.get('EncodeParams') is not None:
            temp_model = StartLiveMPUTaskRequestTranscodeParamsEncodeParams()
            self.encode_params = temp_model.from_map(m['EncodeParams'])
        if m.get('Layout') is not None:
            temp_model = StartLiveMPUTaskRequestTranscodeParamsLayout()
            self.layout = temp_model.from_map(m['Layout'])
        self.user_infos = []
        if m.get('UserInfos') is not None:
            for k in m.get('UserInfos'):
                temp_model = StartLiveMPUTaskRequestTranscodeParamsUserInfos()
                self.user_infos.append(temp_model.from_map(k))
        return self


class StartLiveMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        max_idle_time: str = None,
        mix_mode: str = None,
        multi_stream_url: List[StartLiveMPUTaskRequestMultiStreamURL] = None,
        region: str = None,
        sei_params: StartLiveMPUTaskRequestSeiParams = None,
        single_sub_params: StartLiveMPUTaskRequestSingleSubParams = None,
        stream_url: str = None,
        task_id: str = None,
        transcode_params: StartLiveMPUTaskRequestTranscodeParams = None,
    ):
        # The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The timeout period of an idle connection. Unit: seconds. Valid values: [10,86400].
        # 
        # >  If the task is idle for a period of time longer than the duration specified by the MaxIdleTime parameter, the task is automatically stopped. If the parameter is not specified, the task is stopped after the channel is closed.
        self.max_idle_time = max_idle_time
        # The stream mixing mode. Valid values:
        # 
        # *   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
        # *   **1** (default): the mixed-stream relay mode.
        # 
        # This parameter is required.
        self.mix_mode = mix_mode
        # The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.
        # 
        # >  The StreamURL and MultiStreamURL parameters are mutually exclusive. You must specify one of the two parameters.
        self.multi_stream_url = multi_stream_url
        # The region in which the streams are mixed. Valid values:
        # 
        # *   **CN-Shanghai**\
        # *   **AP-Singapore** (default)
        # *   **EMAA-Saudi**\
        self.region = region
        # The supplemental enhancement information (SEI) parameters.
        self.sei_params = sei_params
        # The single-stream relay parameters. These parameters are required if you set MixMode to 0. Leave these parameters empty in the mixed-stream relay mode.
        self.single_sub_params = single_sub_params
        # The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        # 
        # > 
        # 
        # *   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
        # *   You cannot use the same ingest URL in different tasks.
        # *   You cannot use the same ingest URL within 10 seconds after a task is stopped.
        self.stream_url = stream_url
        # The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.
        # 
        # This parameter is required.
        self.task_id = task_id
        # The mixed-stream relay parameters. These parameters are required if you set MixMode to 1. Leave these parameters empty if you use the single-stream relay mode.
        self.transcode_params = transcode_params

    def validate(self):
        if self.multi_stream_url:
            for k in self.multi_stream_url:
                if k:
                    k.validate()
        if self.sei_params:
            self.sei_params.validate()
        if self.single_sub_params:
            self.single_sub_params.validate()
        if self.transcode_params:
            self.transcode_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        result['MultiStreamURL'] = []
        if self.multi_stream_url is not None:
            for k in self.multi_stream_url:
                result['MultiStreamURL'].append(k.to_map() if k else None)
        if self.region is not None:
            result['Region'] = self.region
        if self.sei_params is not None:
            result['SeiParams'] = self.sei_params.to_map()
        if self.single_sub_params is not None:
            result['SingleSubParams'] = self.single_sub_params.to_map()
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.transcode_params is not None:
            result['TranscodeParams'] = self.transcode_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        self.multi_stream_url = []
        if m.get('MultiStreamURL') is not None:
            for k in m.get('MultiStreamURL'):
                temp_model = StartLiveMPUTaskRequestMultiStreamURL()
                self.multi_stream_url.append(temp_model.from_map(k))
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SeiParams') is not None:
            temp_model = StartLiveMPUTaskRequestSeiParams()
            self.sei_params = temp_model.from_map(m['SeiParams'])
        if m.get('SingleSubParams') is not None:
            temp_model = StartLiveMPUTaskRequestSingleSubParams()
            self.single_sub_params = temp_model.from_map(m['SingleSubParams'])
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TranscodeParams') is not None:
            temp_model = StartLiveMPUTaskRequestTranscodeParams()
            self.transcode_params = temp_model.from_map(m['TranscodeParams'])
        return self


class StartLiveMPUTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        max_idle_time: str = None,
        mix_mode: str = None,
        multi_stream_urlshrink: str = None,
        region: str = None,
        sei_params_shrink: str = None,
        single_sub_params_shrink: str = None,
        stream_url: str = None,
        task_id: str = None,
        transcode_params_shrink: str = None,
    ):
        # The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The timeout period of an idle connection. Unit: seconds. Valid values: [10,86400].
        # 
        # >  If the task is idle for a period of time longer than the duration specified by the MaxIdleTime parameter, the task is automatically stopped. If the parameter is not specified, the task is stopped after the channel is closed.
        self.max_idle_time = max_idle_time
        # The stream mixing mode. Valid values:
        # 
        # *   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
        # *   **1** (default): the mixed-stream relay mode.
        # 
        # This parameter is required.
        self.mix_mode = mix_mode
        # The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.
        # 
        # >  The StreamURL and MultiStreamURL parameters are mutually exclusive. You must specify one of the two parameters.
        self.multi_stream_urlshrink = multi_stream_urlshrink
        # The region in which the streams are mixed. Valid values:
        # 
        # *   **CN-Shanghai**\
        # *   **AP-Singapore** (default)
        # *   **EMAA-Saudi**\
        self.region = region
        # The supplemental enhancement information (SEI) parameters.
        self.sei_params_shrink = sei_params_shrink
        # The single-stream relay parameters. These parameters are required if you set MixMode to 0. Leave these parameters empty in the mixed-stream relay mode.
        self.single_sub_params_shrink = single_sub_params_shrink
        # The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        # 
        # > 
        # 
        # *   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
        # *   You cannot use the same ingest URL in different tasks.
        # *   You cannot use the same ingest URL within 10 seconds after a task is stopped.
        self.stream_url = stream_url
        # The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.
        # 
        # This parameter is required.
        self.task_id = task_id
        # The mixed-stream relay parameters. These parameters are required if you set MixMode to 1. Leave these parameters empty if you use the single-stream relay mode.
        self.transcode_params_shrink = transcode_params_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        if self.multi_stream_urlshrink is not None:
            result['MultiStreamURL'] = self.multi_stream_urlshrink
        if self.region is not None:
            result['Region'] = self.region
        if self.sei_params_shrink is not None:
            result['SeiParams'] = self.sei_params_shrink
        if self.single_sub_params_shrink is not None:
            result['SingleSubParams'] = self.single_sub_params_shrink
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.transcode_params_shrink is not None:
            result['TranscodeParams'] = self.transcode_params_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        if m.get('MultiStreamURL') is not None:
            self.multi_stream_urlshrink = m.get('MultiStreamURL')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SeiParams') is not None:
            self.sei_params_shrink = m.get('SeiParams')
        if m.get('SingleSubParams') is not None:
            self.single_sub_params_shrink = m.get('SingleSubParams')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TranscodeParams') is not None:
            self.transcode_params_shrink = m.get('TranscodeParams')
        return self


class StartLiveMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartLiveMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartLiveMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartLiveMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartLiveStreamMonitorRequest(TeaModel):
    def __init__(
        self,
        monitor_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the monitoring session.
        # 
        # >  You can obtain the monitoring session ID from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        # 
        # This parameter is required.
        self.monitor_id = monitor_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartLiveStreamMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartLiveStreamMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartLiveStreamMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartLiveStreamMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPlaylistRequest(TeaModel):
    def __init__(
        self,
        offset: int = None,
        owner_id: int = None,
        program_id: str = None,
        region_id: str = None,
        resume_mode: str = None,
        start_item_id: str = None,
    ):
        # The offset of the position where the system starts the playback. This parameter takes effect only if the input source is a video file. Unit: milliseconds.
        # 
        # A value greater than 0 indicates an offset from the first frame.
        self.offset = offset
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        self.region_id = region_id
        # The method to resume the playback of the episode list. Valid values:
        # 
        # *   **Restart**: resumes the playback from the beginning.
        # *   **Continue**: resumes the playback from the position where the previous playback stops. The **StartItemId** parameter is required only if you set **ResumeMode** to **Custom**.
        # *   **Custom**: resumes the playback from a custom position.
        self.resume_mode = resume_mode
        # The ID of the first episode to play. This episode is the first to play in carousel playback.
        # 
        # >  This parameter is required only if you set ResumeMode to Custom.
        self.start_item_id = start_item_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resume_mode is not None:
            result['ResumeMode'] = self.resume_mode
        if self.start_item_id is not None:
            result['StartItemId'] = self.start_item_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResumeMode') is not None:
            self.resume_mode = m.get('ResumeMode')
        if m.get('StartItemId') is not None:
            self.start_item_id = m.get('StartItemId')
        return self


class StartPlaylistResponseBodyStreamInfoStreamsStream(TeaModel):
    def __init__(
        self,
        pull_flv_url: str = None,
        pull_m3u8url: str = None,
        pull_rtmp_url: str = None,
        quality: str = None,
    ):
        # The streaming URL in the Flash Video (FLV) format.
        self.pull_flv_url = pull_flv_url
        # The streaming URL in the Real-Time Messaging Protocol (RTMP) format.
        self.pull_m3u8url = pull_m3u8url
        # The streaming URL in the M3U8 format.
        self.pull_rtmp_url = pull_rtmp_url
        # The video quality of the live stream. Valid values: **original**: original quality
        self.quality = quality

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pull_flv_url is not None:
            result['PullFlvUrl'] = self.pull_flv_url
        if self.pull_m3u8url is not None:
            result['PullM3U8Url'] = self.pull_m3u8url
        if self.pull_rtmp_url is not None:
            result['PullRtmpUrl'] = self.pull_rtmp_url
        if self.quality is not None:
            result['Quality'] = self.quality
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PullFlvUrl') is not None:
            self.pull_flv_url = m.get('PullFlvUrl')
        if m.get('PullM3U8Url') is not None:
            self.pull_m3u8url = m.get('PullM3U8Url')
        if m.get('PullRtmpUrl') is not None:
            self.pull_rtmp_url = m.get('PullRtmpUrl')
        if m.get('Quality') is not None:
            self.quality = m.get('Quality')
        return self


class StartPlaylistResponseBodyStreamInfoStreams(TeaModel):
    def __init__(
        self,
        stream: List[StartPlaylistResponseBodyStreamInfoStreamsStream] = None,
    ):
        self.stream = stream

    def validate(self):
        if self.stream:
            for k in self.stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Stream'] = []
        if self.stream is not None:
            for k in self.stream:
                result['Stream'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stream = []
        if m.get('Stream') is not None:
            for k in m.get('Stream'):
                temp_model = StartPlaylistResponseBodyStreamInfoStreamsStream()
                self.stream.append(temp_model.from_map(k))
        return self


class StartPlaylistResponseBodyStreamInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        stream_name: str = None,
        streams: StartPlaylistResponseBodyStreamInfoStreams = None,
    ):
        # The name of the application.
        self.app_name = app_name
        # The main streaming domain.
        self.domain_name = domain_name
        # The name of the live stream.
        self.stream_name = stream_name
        # The streaming URLs.
        self.streams = streams

    def validate(self):
        if self.streams:
            self.streams.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.streams is not None:
            result['Streams'] = self.streams.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('Streams') is not None:
            temp_model = StartPlaylistResponseBodyStreamInfoStreams()
            self.streams = temp_model.from_map(m['Streams'])
        return self


class StartPlaylistResponseBody(TeaModel):
    def __init__(
        self,
        program_id: str = None,
        request_id: str = None,
        stream_info: StartPlaylistResponseBodyStreamInfo = None,
    ):
        # The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to stop playing the episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id
        # The information about the live stream.
        self.stream_info = stream_info

    def validate(self):
        if self.stream_info:
            self.stream_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stream_info is not None:
            result['StreamInfo'] = self.stream_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StreamInfo') is not None:
            temp_model = StartPlaylistResponseBodyStreamInfo()
            self.stream_info = temp_model.from_map(m['StreamInfo'])
        return self


class StartPlaylistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPlaylistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPlaylistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartRtcCloudRecordingRequestMixLayoutParamsMixBackground(TeaModel):
    def __init__(
        self,
        render_mode: int = None,
        url: str = None,
    ):
        self.render_mode = render_mode
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground(TeaModel):
    def __init__(
        self,
        render_mode: int = None,
        url: str = None,
    ):
        self.render_mode = render_mode
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class StartRtcCloudRecordingRequestMixLayoutParamsUserPanes(TeaModel):
    def __init__(
        self,
        height: str = None,
        source_type: int = None,
        sub_background: StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground = None,
        user_id: str = None,
        width: str = None,
        x: str = None,
        y: str = None,
        zorder: int = None,
    ):
        self.height = height
        self.source_type = source_type
        self.sub_background = sub_background
        self.user_id = user_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        if self.sub_background:
            self.sub_background.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.sub_background is not None:
            result['SubBackground'] = self.sub_background.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SubBackground') is not None:
            temp_model = StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground()
            self.sub_background = temp_model.from_map(m['SubBackground'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartRtcCloudRecordingRequestMixLayoutParams(TeaModel):
    def __init__(
        self,
        mix_background: StartRtcCloudRecordingRequestMixLayoutParamsMixBackground = None,
        user_panes: List[StartRtcCloudRecordingRequestMixLayoutParamsUserPanes] = None,
    ):
        self.mix_background = mix_background
        self.user_panes = user_panes

    def validate(self):
        if self.mix_background:
            self.mix_background.validate()
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_background is not None:
            result['MixBackground'] = self.mix_background.to_map()
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixBackground') is not None:
            temp_model = StartRtcCloudRecordingRequestMixLayoutParamsMixBackground()
            self.mix_background = temp_model.from_map(m['MixBackground'])
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = StartRtcCloudRecordingRequestMixLayoutParamsUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class StartRtcCloudRecordingRequestMixTranscodeParams(TeaModel):
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channels: int = None,
        audio_sample_rate: int = None,
        frame_fill_type: int = None,
        video_bitrate: int = None,
        video_codec: str = None,
        video_framerate: int = None,
        video_gop: int = None,
        video_height: int = None,
        video_width: int = None,
    ):
        # This parameter is required.
        self.audio_bitrate = audio_bitrate
        # This parameter is required.
        self.audio_channels = audio_channels
        # This parameter is required.
        self.audio_sample_rate = audio_sample_rate
        self.frame_fill_type = frame_fill_type
        self.video_bitrate = video_bitrate
        self.video_codec = video_codec
        self.video_framerate = video_framerate
        self.video_gop = video_gop
        self.video_height = video_height
        self.video_width = video_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channels is not None:
            result['AudioChannels'] = self.audio_channels
        if self.audio_sample_rate is not None:
            result['AudioSampleRate'] = self.audio_sample_rate
        if self.frame_fill_type is not None:
            result['FrameFillType'] = self.frame_fill_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_framerate is not None:
            result['VideoFramerate'] = self.video_framerate
        if self.video_gop is not None:
            result['VideoGop'] = self.video_gop
        if self.video_height is not None:
            result['VideoHeight'] = self.video_height
        if self.video_width is not None:
            result['VideoWidth'] = self.video_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannels') is not None:
            self.audio_channels = m.get('AudioChannels')
        if m.get('AudioSampleRate') is not None:
            self.audio_sample_rate = m.get('AudioSampleRate')
        if m.get('FrameFillType') is not None:
            self.frame_fill_type = m.get('FrameFillType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoFramerate') is not None:
            self.video_framerate = m.get('VideoFramerate')
        if m.get('VideoGop') is not None:
            self.video_gop = m.get('VideoGop')
        if m.get('VideoHeight') is not None:
            self.video_height = m.get('VideoHeight')
        if m.get('VideoWidth') is not None:
            self.video_width = m.get('VideoWidth')
        return self


class StartRtcCloudRecordingRequestRecordParams(TeaModel):
    def __init__(
        self,
        max_file_duration: int = None,
        record_mode: int = None,
        stream_type: int = None,
    ):
        self.max_file_duration = max_file_duration
        # This parameter is required.
        self.record_mode = record_mode
        self.stream_type = stream_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_file_duration is not None:
            result['MaxFileDuration'] = self.max_file_duration
        if self.record_mode is not None:
            result['RecordMode'] = self.record_mode
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxFileDuration') is not None:
            self.max_file_duration = m.get('MaxFileDuration')
        if m.get('RecordMode') is not None:
            self.record_mode = m.get('RecordMode')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        return self


class StartRtcCloudRecordingRequestStorageParamsFileInfo(TeaModel):
    def __init__(
        self,
        file_name_pattern: str = None,
        file_path_prefix: List[str] = None,
        format: str = None,
        slice_name_pattern: str = None,
    ):
        self.file_name_pattern = file_name_pattern
        self.file_path_prefix = file_path_prefix
        # This parameter is required.
        self.format = format
        self.slice_name_pattern = slice_name_pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name_pattern is not None:
            result['FileNamePattern'] = self.file_name_pattern
        if self.file_path_prefix is not None:
            result['FilePathPrefix'] = self.file_path_prefix
        if self.format is not None:
            result['Format'] = self.format
        if self.slice_name_pattern is not None:
            result['SliceNamePattern'] = self.slice_name_pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileNamePattern') is not None:
            self.file_name_pattern = m.get('FileNamePattern')
        if m.get('FilePathPrefix') is not None:
            self.file_path_prefix = m.get('FilePathPrefix')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('SliceNamePattern') is not None:
            self.slice_name_pattern = m.get('SliceNamePattern')
        return self


class StartRtcCloudRecordingRequestStorageParamsOSSParams(TeaModel):
    def __init__(
        self,
        ossbucket: str = None,
        ossendpoint: str = None,
    ):
        # This parameter is required.
        self.ossbucket = ossbucket
        # This parameter is required.
        self.ossendpoint = ossendpoint

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossendpoint is not None:
            result['OSSEndpoint'] = self.ossendpoint
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSEndpoint') is not None:
            self.ossendpoint = m.get('OSSEndpoint')
        return self


class StartRtcCloudRecordingRequestStorageParamsVodParams(TeaModel):
    def __init__(
        self,
        auto_compose: int = None,
        compose_vod_transcode_group_id: str = None,
        storage_location: str = None,
        vod_transcode_group_id: str = None,
    ):
        self.auto_compose = auto_compose
        self.compose_vod_transcode_group_id = compose_vod_transcode_group_id
        self.storage_location = storage_location
        self.vod_transcode_group_id = vod_transcode_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_compose is not None:
            result['AutoCompose'] = self.auto_compose
        if self.compose_vod_transcode_group_id is not None:
            result['ComposeVodTranscodeGroupId'] = self.compose_vod_transcode_group_id
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.vod_transcode_group_id is not None:
            result['VodTranscodeGroupId'] = self.vod_transcode_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoCompose') is not None:
            self.auto_compose = m.get('AutoCompose')
        if m.get('ComposeVodTranscodeGroupId') is not None:
            self.compose_vod_transcode_group_id = m.get('ComposeVodTranscodeGroupId')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('VodTranscodeGroupId') is not None:
            self.vod_transcode_group_id = m.get('VodTranscodeGroupId')
        return self


class StartRtcCloudRecordingRequestStorageParams(TeaModel):
    def __init__(
        self,
        file_info: List[StartRtcCloudRecordingRequestStorageParamsFileInfo] = None,
        ossparams: StartRtcCloudRecordingRequestStorageParamsOSSParams = None,
        storage_type: int = None,
        vod_params: StartRtcCloudRecordingRequestStorageParamsVodParams = None,
    ):
        self.file_info = file_info
        self.ossparams = ossparams
        # This parameter is required.
        self.storage_type = storage_type
        self.vod_params = vod_params

    def validate(self):
        if self.file_info:
            for k in self.file_info:
                if k:
                    k.validate()
        if self.ossparams:
            self.ossparams.validate()
        if self.vod_params:
            self.vod_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfo'] = []
        if self.file_info is not None:
            for k in self.file_info:
                result['FileInfo'].append(k.to_map() if k else None)
        if self.ossparams is not None:
            result['OSSParams'] = self.ossparams.to_map()
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.vod_params is not None:
            result['VodParams'] = self.vod_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_info = []
        if m.get('FileInfo') is not None:
            for k in m.get('FileInfo'):
                temp_model = StartRtcCloudRecordingRequestStorageParamsFileInfo()
                self.file_info.append(temp_model.from_map(k))
        if m.get('OSSParams') is not None:
            temp_model = StartRtcCloudRecordingRequestStorageParamsOSSParams()
            self.ossparams = temp_model.from_map(m['OSSParams'])
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('VodParams') is not None:
            temp_model = StartRtcCloudRecordingRequestStorageParamsVodParams()
            self.vod_params = temp_model.from_map(m['VodParams'])
        return self


class StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList(TeaModel):
    def __init__(
        self,
        source_type: int = None,
        stream_type: int = None,
        user_id: str = None,
    ):
        self.source_type = source_type
        self.stream_type = stream_type
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartRtcCloudRecordingRequestSubscribeParams(TeaModel):
    def __init__(
        self,
        subscribe_user_id_list: List[StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList] = None,
    ):
        # This parameter is required.
        self.subscribe_user_id_list = subscribe_user_id_list

    def validate(self):
        if self.subscribe_user_id_list:
            for k in self.subscribe_user_id_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubscribeUserIdList'] = []
        if self.subscribe_user_id_list is not None:
            for k in self.subscribe_user_id_list:
                result['SubscribeUserIdList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subscribe_user_id_list = []
        if m.get('SubscribeUserIdList') is not None:
            for k in m.get('SubscribeUserIdList'):
                temp_model = StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList()
                self.subscribe_user_id_list.append(temp_model.from_map(k))
        return self


class StartRtcCloudRecordingRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        max_idle_time: int = None,
        mix_layout_params: StartRtcCloudRecordingRequestMixLayoutParams = None,
        mix_transcode_params: StartRtcCloudRecordingRequestMixTranscodeParams = None,
        notify_auth_key: str = None,
        notify_url: str = None,
        record_params: StartRtcCloudRecordingRequestRecordParams = None,
        storage_params: StartRtcCloudRecordingRequestStorageParams = None,
        subscribe_params: StartRtcCloudRecordingRequestSubscribeParams = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.max_idle_time = max_idle_time
        self.mix_layout_params = mix_layout_params
        self.mix_transcode_params = mix_transcode_params
        self.notify_auth_key = notify_auth_key
        self.notify_url = notify_url
        # This parameter is required.
        self.record_params = record_params
        # This parameter is required.
        self.storage_params = storage_params
        # This parameter is required.
        self.subscribe_params = subscribe_params

    def validate(self):
        if self.mix_layout_params:
            self.mix_layout_params.validate()
        if self.mix_transcode_params:
            self.mix_transcode_params.validate()
        if self.record_params:
            self.record_params.validate()
        if self.storage_params:
            self.storage_params.validate()
        if self.subscribe_params:
            self.subscribe_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.mix_layout_params is not None:
            result['MixLayoutParams'] = self.mix_layout_params.to_map()
        if self.mix_transcode_params is not None:
            result['MixTranscodeParams'] = self.mix_transcode_params.to_map()
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_params is not None:
            result['RecordParams'] = self.record_params.to_map()
        if self.storage_params is not None:
            result['StorageParams'] = self.storage_params.to_map()
        if self.subscribe_params is not None:
            result['SubscribeParams'] = self.subscribe_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('MixLayoutParams') is not None:
            temp_model = StartRtcCloudRecordingRequestMixLayoutParams()
            self.mix_layout_params = temp_model.from_map(m['MixLayoutParams'])
        if m.get('MixTranscodeParams') is not None:
            temp_model = StartRtcCloudRecordingRequestMixTranscodeParams()
            self.mix_transcode_params = temp_model.from_map(m['MixTranscodeParams'])
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordParams') is not None:
            temp_model = StartRtcCloudRecordingRequestRecordParams()
            self.record_params = temp_model.from_map(m['RecordParams'])
        if m.get('StorageParams') is not None:
            temp_model = StartRtcCloudRecordingRequestStorageParams()
            self.storage_params = temp_model.from_map(m['StorageParams'])
        if m.get('SubscribeParams') is not None:
            temp_model = StartRtcCloudRecordingRequestSubscribeParams()
            self.subscribe_params = temp_model.from_map(m['SubscribeParams'])
        return self


class StartRtcCloudRecordingShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        max_idle_time: int = None,
        mix_layout_params_shrink: str = None,
        mix_transcode_params_shrink: str = None,
        notify_auth_key: str = None,
        notify_url: str = None,
        record_params_shrink: str = None,
        storage_params_shrink: str = None,
        subscribe_params_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.max_idle_time = max_idle_time
        self.mix_layout_params_shrink = mix_layout_params_shrink
        self.mix_transcode_params_shrink = mix_transcode_params_shrink
        self.notify_auth_key = notify_auth_key
        self.notify_url = notify_url
        # This parameter is required.
        self.record_params_shrink = record_params_shrink
        # This parameter is required.
        self.storage_params_shrink = storage_params_shrink
        # This parameter is required.
        self.subscribe_params_shrink = subscribe_params_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.max_idle_time is not None:
            result['MaxIdleTime'] = self.max_idle_time
        if self.mix_layout_params_shrink is not None:
            result['MixLayoutParams'] = self.mix_layout_params_shrink
        if self.mix_transcode_params_shrink is not None:
            result['MixTranscodeParams'] = self.mix_transcode_params_shrink
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.record_params_shrink is not None:
            result['RecordParams'] = self.record_params_shrink
        if self.storage_params_shrink is not None:
            result['StorageParams'] = self.storage_params_shrink
        if self.subscribe_params_shrink is not None:
            result['SubscribeParams'] = self.subscribe_params_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MaxIdleTime') is not None:
            self.max_idle_time = m.get('MaxIdleTime')
        if m.get('MixLayoutParams') is not None:
            self.mix_layout_params_shrink = m.get('MixLayoutParams')
        if m.get('MixTranscodeParams') is not None:
            self.mix_transcode_params_shrink = m.get('MixTranscodeParams')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('RecordParams') is not None:
            self.record_params_shrink = m.get('RecordParams')
        if m.get('StorageParams') is not None:
            self.storage_params_shrink = m.get('StorageParams')
        if m.get('SubscribeParams') is not None:
            self.subscribe_params_shrink = m.get('SubscribeParams')
        return self


class StartRtcCloudRecordingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StartRtcCloudRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartRtcCloudRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartRtcCloudRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCasterRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopCasterResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopCasterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCasterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCasterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCasterSceneRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.
        # 
        # If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:
        # 
        # Production Studios > Production Studio Management
        # 
        # >  The CasterId is reflected in the Name column on the Production Studio Management page.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This operation is available only when the scene is a preview scene. For more information about the scene types, see [Query the scenes of production studios](https://help.aliyun.com/document_detail/60262.html).
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class StopCasterSceneResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopCasterSceneResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCasterSceneResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCasterSceneResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        job_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the edge transcoding task.
        # 
        # This parameter is required.
        self.job_id = job_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the edge transcoding task.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopLiveDomainRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The streaming domain or ingest domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class StopLiveDomainResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopLiveDomainResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopLiveDomainResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopLiveDomainResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopLiveMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        task_id: str = None,
    ):
        # The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopLiveMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopLiveMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopLiveMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopLiveMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        # The region of the live center. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The new task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopLiveStreamMonitorRequest(TeaModel):
    def __init__(
        self,
        monitor_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the monitoring session.
        # 
        # >  You can obtain the monitoring session ID**** from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        # 
        # This parameter is required.
        self.monitor_id = monitor_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopLiveStreamMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopLiveStreamMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopLiveStreamMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopLiveStreamMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopPlaylistRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        program_id: str = None,
        region_id: str = None,
    ):
        self.owner_id = owner_id
        # The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.
        # 
        # This parameter is required.
        self.program_id = program_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopPlaylistResponseBody(TeaModel):
    def __init__(
        self,
        program_id: str = None,
        request_id: str = None,
    ):
        # The ID of the episode list.
        self.program_id = program_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.program_id is not None:
            result['ProgramId'] = self.program_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProgramId') is not None:
            self.program_id = m.get('ProgramId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopPlaylistResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopPlaylistResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopPlaylistResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopRtcAsrTaskRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        task_id: str = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the task.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopRtcAsrTaskResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.
        self.description = description
        # The ID of the request.
        self.request_id = request_id
        # The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class StopRtcAsrTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopRtcAsrTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopRtcAsrTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopRtcCloudRecordingRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopRtcCloudRecordingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopRtcCloudRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopRtcCloudRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopRtcCloudRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagLiveResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # This parameter is required.
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagLiveResourcesRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        region_id: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[TagLiveResourcesRequestTag] = None,
    ):
        self.owner_id = owner_id
        self.region_id = region_id
        # The type of the resources. Set the value to **DOMAIN**.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # This parameter is required.
        self.resource_type = resource_type
        # This parameter is required.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagLiveResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagLiveResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagLiveResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagLiveResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagLiveResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnTagLiveResourcesRequest(TeaModel):
    def __init__(
        self,
        all: bool = None,
        owner_id: int = None,
        region_id: str = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag_key: List[str] = None,
    ):
        self.all = all
        self.owner_id = owner_id
        self.region_id = region_id
        # This parameter is required.
        self.resource_id = resource_id
        # This parameter is required.
        self.resource_type = resource_type
        self.tag_key = tag_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class UnTagLiveResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnTagLiveResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnTagLiveResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnTagLiveResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbanLiveMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        data_center: str = None,
        group_id: str = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.
        # 
        # >  Valid values: cn-shanghai and ap-southeast-1 (Singapore).
        self.data_center = data_center
        # The group ID.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.data_center is not None:
            result['DataCenter'] = self.data_center
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DataCenter') is not None:
            self.data_center = m.get('DataCenter')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class UnbanLiveMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnbanLiveMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbanLiveMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbanLiveMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCasterResourceGroupRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        new_resource_group_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The ID of the destination resource group.
        # 
        # This parameter is required.
        self.new_resource_group_id = new_resource_group_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.new_resource_group_id is not None:
            result['NewResourceGroupId'] = self.new_resource_group_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('NewResourceGroupId') is not None:
            self.new_resource_group_id = m.get('NewResourceGroupId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateCasterResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCasterResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCasterResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCasterResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCasterSceneAudioRequestAudioLayer(TeaModel):
    def __init__(
        self,
        filter: str = None,
        fixed_delay_duration: int = None,
        valid_channel: str = None,
        volume_rate: float = None,
    ):
        # Specifies whether to enable the features provided by the audio 3A algorithms. This parameter consists of the following fields:
        # 
        # *   **enableAgc**: specifies whether to enable automatic gain control (AGC). This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that AGC is disabled. **1** specifies that AGC is enabled.
        # *   **enableAns**: specifies whether to enable active noise suppression (ANS). This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that ANS is disabled. **1** specifies that ANS is enabled.
        # *   **ansMode**: specifies the mode for ANS. This field is optional and takes effect only if you set **enableAns** to **1**. Valid values: 0 and 1. **0** is the default value, which specifies the speech noise reduction mode. **1** specifies the music noise reduction mode.
        # 
        # >  To ensure a better noise reduction effect, we recommend that you set ansMode to 1.
        # 
        # *   **enableBeautify**: specifies whether to enable voice change. This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that voice change is disabled. **1** specifies that voice change is enabled.
        # *   **voiceBeautifyMode**: specifies the mode for voice change. This field is optional and takes effect only if you set **enableBeautify** to **1**. Valid values: 0 and 1. **0** is the default value, which specifies the magnetic male voice mode. **1** specifies the fresh female voice mode.
        self.filter = filter
        # The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles.
        # 
        # Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.
        self.fixed_delay_duration = fixed_delay_duration
        # The sound channels that are used for volume input in the audio layer. Valid values:
        # 
        # *   **leftChannel**: the left channel
        # *   **rightChannel**: the right channel
        # *   **all** (default): both the left and right channels
        self.valid_channel = valid_channel
        # The multiple of the original volume at which the audio layer plays audio. Valid values: **0 to 10.0**. Default value: **1.0**.
        # 
        # *   **1.0**: specifies that the audio layer plays audio at the original volume.
        # *   A value smaller than **1**: specifies that the audio layer plays audio at a volume that is less than the original volume.
        # *   A value greater than **1**: specifies that the audio layer plays audio at a volume that is more than the original volume.
        self.volume_rate = volume_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.fixed_delay_duration is not None:
            result['FixedDelayDuration'] = self.fixed_delay_duration
        if self.valid_channel is not None:
            result['ValidChannel'] = self.valid_channel
        if self.volume_rate is not None:
            result['VolumeRate'] = self.volume_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('FixedDelayDuration') is not None:
            self.fixed_delay_duration = m.get('FixedDelayDuration')
        if m.get('ValidChannel') is not None:
            self.valid_channel = m.get('ValidChannel')
        if m.get('VolumeRate') is not None:
            self.volume_rate = m.get('VolumeRate')
        return self


class UpdateCasterSceneAudioRequest(TeaModel):
    def __init__(
        self,
        audio_layer: List[UpdateCasterSceneAudioRequestAudioLayer] = None,
        caster_id: str = None,
        follow_enable: int = None,
        mix_list: List[str] = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The audio configurations.
        self.audio_layer = audio_layer
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The audio mode. By default, the AFV mode is used. If you do not specify this parameter, the scene retains the last configuration. Valid values:
        # 
        # *   **0**: the audio mixing mode.
        # *   **1**: the AFV mode.
        self.follow_enable = follow_enable
        # The location IDs of the audio layers, which are in the same order as the audio layers.
        self.mix_list = mix_list
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene. If you call the [DescribeCasterScenes](https://help.aliyun.com/document_detail/2848039.html) operation to query scenes of the production studio, check the value of the response parameter ComponentId to obtain the ID.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        if self.audio_layer:
            for k in self.audio_layer:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioLayer'] = []
        if self.audio_layer is not None:
            for k in self.audio_layer:
                result['AudioLayer'].append(k.to_map() if k else None)
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.follow_enable is not None:
            result['FollowEnable'] = self.follow_enable
        if self.mix_list is not None:
            result['MixList'] = self.mix_list
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_layer = []
        if m.get('AudioLayer') is not None:
            for k in m.get('AudioLayer'):
                temp_model = UpdateCasterSceneAudioRequestAudioLayer()
                self.audio_layer.append(temp_model.from_map(k))
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('FollowEnable') is not None:
            self.follow_enable = m.get('FollowEnable')
        if m.get('MixList') is not None:
            self.mix_list = m.get('MixList')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class UpdateCasterSceneAudioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCasterSceneAudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCasterSceneAudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCasterSceneAudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCasterSceneConfigRequest(TeaModel):
    def __init__(
        self,
        caster_id: str = None,
        component_id: List[str] = None,
        layout_id: str = None,
        owner_id: int = None,
        region_id: str = None,
        scene_id: str = None,
    ):
        # The ID of the production studio.
        # 
        # *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        # *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        # 
        # >  You can find the ID of the production studio in the Instance ID/Name column.
        # 
        # This parameter is required.
        self.caster_id = caster_id
        # The IDs of the components. Components in the scene are listed from the bottom to the top in an array.
        # 
        # >  N indicates a sequence number. Examples:\\
        # ComponentId.1 indicates the ID of the first component.\\
        # ComponentId.2 indicates the ID of the second component.
        self.component_id = component_id
        # The ID of the layout. If you call the [DescribeCasterLayouts](https://help.aliyun.com/document_detail/2848028.html) operation to query the layouts of the production studio, check the value of the response parameter LayoutId to obtain the ID.
        # 
        # This parameter is required.
        self.layout_id = layout_id
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the scene.
        # 
        # This parameter is required.
        self.scene_id = scene_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.caster_id is not None:
            result['CasterId'] = self.caster_id
        if self.component_id is not None:
            result['ComponentId'] = self.component_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene_id is not None:
            result['SceneId'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CasterId') is not None:
            self.caster_id = m.get('CasterId')
        if m.get('ComponentId') is not None:
            self.component_id = m.get('ComponentId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SceneId') is not None:
            self.scene_id = m.get('SceneId')
        return self


class UpdateCasterSceneConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCasterSceneConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCasterSceneConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCasterSceneConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        audio_bitrate: int = None,
        audio_channel_num: int = None,
        audio_codec: str = None,
        audio_profile: str = None,
        audio_rate: int = None,
        bitrate_with_source: str = None,
        de_interlaced: bool = None,
        domain: str = None,
        encrypt_parameters: str = None,
        ext_with_source: str = None,
        fps: int = None,
        fps_with_source: str = None,
        gop: str = None,
        height: int = None,
        lazy: str = None,
        owner_id: int = None,
        profile: int = None,
        region_id: str = None,
        res_with_source: str = None,
        template: str = None,
        template_type: str = None,
        video_bitrate: int = None,
        width: int = None,
    ):
        # The name of the application to which the stream belongs, and it cannot be modified.
        # 
        # This parameter is required.
        self.app = app
        # Audio transcoding bitrate. Unit: kbps, value range: 1 to 1000.
        self.audio_bitrate = audio_bitrate
        # Number of audio channels. Values: 
        # - 1: Mono. 
        # - 2: Stereo.
        self.audio_channel_num = audio_channel_num
        # Audio encoding format. Values: 
        # - aac 
        # - mp3
        self.audio_codec = audio_codec
        # Audio encoding. Values: 
        # - aac_low
        #  - aac_he
        #  - aac_he_v2 
        # - aac_ld
        self.audio_profile = audio_profile
        # Audio sampling rate. Values: 22050, 32000, 44100, 48000, 96000. Unit: Hz.
        # > If **AudioProfile** is set to **aac_ld**, the sampling rate must not exceed 44100.
        self.audio_rate = audio_rate
        # The source-based bitrate settings. This parameter takes precedence over other bitrate settings. The following fields must be included:
        # 
        # *   **UpLimit**: the maximum bitrate. Set this field to an integer from 128 to 10000. The value must be greater than the minimum bitrate.
        # *   **LowerLimit**: the minimum bitrate. Set this field to an integer from 128 to 10000. The value must be smaller than the maximum bitrate.
        # *   **Factor**: the ratio of the output bitrate to the source bitrate. Valid values: 0.1 to 1. The value is accurate to one decimal place. A value of 1 indicates that the output video has the same bitrate as the source video.
        self.bitrate_with_source = bitrate_with_source
        self.de_interlaced = de_interlaced
        # Streamer domain name, unmodifiable.
        # 
        # This parameter is required.
        self.domain = domain
        # Encryption configuration. JSON format, with the following fields: 
        # -  EncryptType: Type of encryption. Fixed value is aliyun.
        #  -  KmsKeyID: User\\"s KMS master key ID. 
        # -  KmsKeyExpireInterval: Key rotation period. Value range: 60~3600, unit: seconds.
        # > When using DRM encryption, KmsKeyID cannot be modified.
        self.encrypt_parameters = encrypt_parameters
        # Other source-based settings. The following fields are included:
        # 
        # *   **KeyFrameOpen**: Valid values: yes and no.
        # *   **Copyts**: Valid values: yes and no.
        # *   **SeiMode**: Valid values: 0, 1, and 2. 0 specifies that no supplemental enhancement information (SEI) messages are passed through, 1 specifies that part of SEI messages are passed through, and 2 specifies that all SEI messages are passed through.
        self.ext_with_source = ext_with_source
        # Transcode video frame rate. Unit: FPS, value range: 1 to 60.
        self.fps = fps
        # The source-based frame rate settings. This parameter takes precedence over other frame rate settings. The following fields must be included:
        # 
        # *   **UpLimit**: the maximum frame rate. Set this field to an integer from 1 to 60. The value must be greater than the minimum frame rate.
        # *   **LowerLimit**: the minimum frame rate. Set this field to an integer from 1 to 60. The value must be smaller than the maximum frame rate.
        self.fps_with_source = fps_with_source
        # Video GOP (Group of Pictures), supports units in frames or seconds. When the unit is frames, the value should be {number}; when the unit is seconds, the value should be {number}s. 
        # - For frames, the range is 1 to 3000. 
        # - For seconds, the range is 1 to 20s.
        self.gop = gop
        # Video transcoding height. Unit: pixels. The value must meet the following three conditions:
        #  - Height  100: The height of the video must be no less than 100 pixels.
        #  - max(Height, Width)  2560: The larger of the video\\"s width and height cannot exceed 2560.
        #  - min(Height, Width)  1440: The smaller of the video\\"s width and height cannot exceed 1440.
        #  > For 265 narrowband HD templates, the maximum resolution is 1280720.
        self.height = height
        # Specifies whether to enable triggered transcoding. Valid values:
        # 
        # *   **yes**: enables triggered transcoding.
        # *   **no**: disables triggered transcoding.
        self.lazy = lazy
        self.owner_id = owner_id
        # Encoding level. A set of specific encoding features supported by the video, generally, the higher the value, the better the picture quality, but also the higher the resources consumed for encoding and decoding. Values: 
        # - 1: baseline (suitable for mobile devices).
        #  - 2: main (suitable for standard resolution devices). 
        # - 3: high (suitable for high-resolution devices).
        self.profile = profile
        self.region_id = region_id
        # The source-based resolution settings. This parameter takes precedence over other resolution settings. The following fields must be included:
        # 
        # *   **Type**: You can set this field to short, long, or screen. short specifies that the resolution of the output video is adapted to the shorter side, long specifies that the resolution of the output video is adapted to the longer side, and screen specifies that the output video has an adaptive resolution.
        # 
        # *   **Value**:
        # 
        #     *   Set this field to 360, 480, 540, 720, or 1080 if the Type field is set to short.
        #     *   Set this field to 640, 848, 960, 1280, or 1920 if the Type field is set to long.
        #     *   Set this field to 640\\*360, 848\\*480, 960\\*540, 1280\\*720, or 1920\\*1080 if the Type field is set to screen.
        self.res_with_source = res_with_source
        # Custom name of the transcoding template, not modifiable.
        # 
        # This parameter is required.
        self.template = template
        # Custom transcoding template type, unmodifiable.
        # 
        # This parameter is required.
        self.template_type = template_type
        # Video transcoding bitrate. Unit: kbps, value range: 1 to 6000.
        # > The actual bitrate of the transcoded video will try to be as close as possible to the one you set, but it cannot be guaranteed to be exactly the same, especially when the set bitrate is too high or too low.
        self.video_bitrate = video_bitrate
        # Video transcoding width. Unit: pixels. The value must meet the following three conditions: 
        # - Width  100: The video width must be no less than 100 pixels. 
        # - max(Height, Width)  2560: The larger of the video\\"s height and width cannot exceed 2560. 
        # - min(Height, Width)  1440: The smaller of the video\\"s height and width cannot exceed 1440.
        # > For 265 narrowband HD templates, the maximum resolution is 1280720.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channel_num is not None:
            result['AudioChannelNum'] = self.audio_channel_num
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_profile is not None:
            result['AudioProfile'] = self.audio_profile
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.bitrate_with_source is not None:
            result['BitrateWithSource'] = self.bitrate_with_source
        if self.de_interlaced is not None:
            result['DeInterlaced'] = self.de_interlaced
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.encrypt_parameters is not None:
            result['EncryptParameters'] = self.encrypt_parameters
        if self.ext_with_source is not None:
            result['ExtWithSource'] = self.ext_with_source
        if self.fps is not None:
            result['FPS'] = self.fps
        if self.fps_with_source is not None:
            result['FpsWithSource'] = self.fps_with_source
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.res_with_source is not None:
            result['ResWithSource'] = self.res_with_source
        if self.template is not None:
            result['Template'] = self.template
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannelNum') is not None:
            self.audio_channel_num = m.get('AudioChannelNum')
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioProfile') is not None:
            self.audio_profile = m.get('AudioProfile')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('BitrateWithSource') is not None:
            self.bitrate_with_source = m.get('BitrateWithSource')
        if m.get('DeInterlaced') is not None:
            self.de_interlaced = m.get('DeInterlaced')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EncryptParameters') is not None:
            self.encrypt_parameters = m.get('EncryptParameters')
        if m.get('ExtWithSource') is not None:
            self.ext_with_source = m.get('ExtWithSource')
        if m.get('FPS') is not None:
            self.fps = m.get('FPS')
        if m.get('FpsWithSource') is not None:
            self.fps_with_source = m.get('FpsWithSource')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResWithSource') is not None:
            self.res_with_source = m.get('ResWithSource')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateCustomLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCustomLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCustomLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEdgeTranscodeJobRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        job_id: str = None,
        name: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_input: str = None,
        stream_output: str = None,
        template_id: str = None,
    ):
        # The ID of the data center.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the edge transcoding task.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The task name.
        self.name = name
        self.owner_id = owner_id
        self.region_id = region_id
        # The URL of the input stream.
        self.stream_input = stream_input
        # The URL of the output stream.
        self.stream_output = stream_output
        # The template ID.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input
        if self.stream_output is not None:
            result['StreamOutput'] = self.stream_output
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamInput') is not None:
            self.stream_input = m.get('StreamInput')
        if m.get('StreamOutput') is not None:
            self.stream_output = m.get('StreamOutput')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateEdgeTranscodeJobResponseBody(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        request_id: str = None,
    ):
        # The ID of the edge transcoding task.
        self.job_id = job_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEdgeTranscodeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEdgeTranscodeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEdgeTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_id: str = None,
        events: List[str] = None,
        subscribe_id: str = None,
        users: List[str] = None,
    ):
        # The application ID.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The callback URL. For more information about the callback content, see CreateEventSub.
        # 
        # This parameter is required.
        self.callback_url = callback_url
        # The channel ID. You can call the [ListEventSub](https://help.aliyun.com/document_detail/2848210.html) operation to query the channel ID.
        # 
        # > 
        # 
        # *   This parameter is required if you specify the Users.N parameter.
        # 
        # *   If you set this parameter to \\* or do not specify this parameter, all channels are subscribed to.
        # 
        # *   You can create up to 20 subscriptions for each application ID.
        self.channel_id = channel_id
        # The type of the events to which you want to subscribe.
        # 
        # This parameter is required.
        self.events = events
        # The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.
        # 
        # This parameter is required.
        self.subscribe_id = subscribe_id
        # The user whose events you want to subscribe to.
        self.users = users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.events is not None:
            result['Events'] = self.events
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Events') is not None:
            self.events = m.get('Events')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class UpdateEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAIProduceRulesRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        description: str = None,
        domain: str = None,
        is_lazy: bool = None,
        live_template: str = None,
        owner_id: int = None,
        region_id: str = None,
        rules_id: str = None,
        studio_name: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
        suffix: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app = app
        # The description of the subtitle rule. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        # Specifies whether to generate live subtitles when stream pulling starts. Valid values:
        # 
        # *   true: generates live subtitles when stream pulling starts and stops generating live subtitles when no streams are pulled for 5 minutes. When stream pulling restarts, live subtitles are generated again.
        # *   false: generates live subtitles when stream ingest starts.
        self.is_lazy = is_lazy
        # The specification of the output subtitles. Valid values:
        # 
        # *   `lp_ld`: 360p (640  360)
        # *   `lp_ld_v`: 360p (360  640)
        # *   `lp_sd`: 480p (854  480)
        # *   `lp_sd_v`: 480p (480  854)
        # *   `lp_hd`: 720p (1280  720)
        # *   `lp_hd_v`: 720p (720  1280)
        # *   `lp_ud`: 1080p (1920  1080)
        # *   `lp_ud_v`: 1080p (1080  1920)
        self.live_template = live_template
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the subtitle rule.
        self.rules_id = rules_id
        # The name of the virtual background template.
        self.studio_name = studio_name
        # The ID of the subtitle template.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template.
        self.subtitle_name = subtitle_name
        # The suffix to match.
        self.suffix = suffix

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.is_lazy is not None:
            result['IsLazy'] = self.is_lazy
        if self.live_template is not None:
            result['LiveTemplate'] = self.live_template
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rules_id is not None:
            result['RulesId'] = self.rules_id
        if self.studio_name is not None:
            result['StudioName'] = self.studio_name
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.suffix is not None:
            result['Suffix'] = self.suffix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IsLazy') is not None:
            self.is_lazy = m.get('IsLazy')
        if m.get('LiveTemplate') is not None:
            self.live_template = m.get('LiveTemplate')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RulesId') is not None:
            self.rules_id = m.get('RulesId')
        if m.get('StudioName') is not None:
            self.studio_name = m.get('StudioName')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Suffix') is not None:
            self.suffix = m.get('Suffix')
        return self


class UpdateLiveAIProduceRulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAIProduceRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAIProduceRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAIProduceRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAISubtitleRequest(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        bg_width_normalized: float = None,
        border_width_normalized: float = None,
        description: str = None,
        dst_language: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size_normalized: float = None,
        height: str = None,
        max_lines: int = None,
        owner_id: int = None,
        position_normalized: List[float] = None,
        region_id: str = None,
        show_source_lan: bool = None,
        src_language: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
        width: str = None,
        word_per_line: int = None,
    ):
        # The background color of the subtitles. Color format: RGBA.
        self.bg_color = bg_color
        # The size of the background box. Valid values: [0,1].
        self.bg_width_normalized = bg_width_normalized
        # The font weight. Valid values: [0,1].
        self.border_width_normalized = border_width_normalized
        # The description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The target language. Valid values:
        # 
        # *   en-US: English
        # *   zh-CN: Chinese
        # *   es-ES: Spanish
        # *   ru-RU: Russian
        self.dst_language = dst_language
        # The font color. Color format: RGBA.
        self.font_color = font_color
        # The font. Valid values:
        # 
        # *   KaiTi (default)
        # *   AlibabaPuHuiTi-Regular
        # *   AlibabaPuHuiTi-Bold
        # *   AlibabaPuHuiTi-Light
        # *   NotoSansHans-Regular
        # *   NotoSansHans-Bold
        # *   NotoSansHans-Light
        self.font_name = font_name
        # The font size. Valid values: [0,1].
        self.font_size_normalized = font_size_normalized
        # The height of the preview. Unit: pixels.
        # 
        # The following preview specifications (width x height) are supported:
        # 
        # *   360p (640 x 360)
        # *   360p (360 x 640)
        # *   480p (854 x 480)
        # *   480p (480 x 854)
        # *   720p (1280 x 720)
        # *   720p (720 x 1280)
        # *   1080p (1920 x 1080)
        # *   1080p (1080 x 1920)
        self.height = height
        # The number of displayed lines.
        self.max_lines = max_lines
        self.owner_id = owner_id
        # The position of the subtitles relative to the lower-left corner of the screen. The value is a pair of coordinates.
        self.position_normalized = position_normalized
        self.region_id = region_id
        # Specifies whether to display the source language. Valid values: true and false. Default value: false.
        self.show_source_lan = show_source_lan
        # The source language. Valid values:
        # 
        # *   en-US: English
        # *   zh-CN: Chinese
        # *   ru-RU: Russian
        self.src_language = src_language
        # The ID of the subtitle template.
        # 
        # This parameter is required.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template. The name can contain digits, letters, and hyphens (-) but cannot start with a hyphen (-).
        self.subtitle_name = subtitle_name
        # The width of the preview. Unit: pixels.
        self.width = width
        # The number of characters per line. Valid values: 1 to 500.
        self.word_per_line = word_per_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.bg_width_normalized is not None:
            result['BgWidthNormalized'] = self.bg_width_normalized
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.description is not None:
            result['Description'] = self.description
        if self.dst_language is not None:
            result['DstLanguage'] = self.dst_language
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size_normalized is not None:
            result['FontSizeNormalized'] = self.font_size_normalized
        if self.height is not None:
            result['Height'] = self.height
        if self.max_lines is not None:
            result['MaxLines'] = self.max_lines
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.position_normalized is not None:
            result['PositionNormalized'] = self.position_normalized
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.src_language is not None:
            result['SrcLanguage'] = self.src_language
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.width is not None:
            result['Width'] = self.width
        if self.word_per_line is not None:
            result['WordPerLine'] = self.word_per_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BgWidthNormalized') is not None:
            self.bg_width_normalized = m.get('BgWidthNormalized')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DstLanguage') is not None:
            self.dst_language = m.get('DstLanguage')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSizeNormalized') is not None:
            self.font_size_normalized = m.get('FontSizeNormalized')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxLines') is not None:
            self.max_lines = m.get('MaxLines')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PositionNormalized') is not None:
            self.position_normalized = m.get('PositionNormalized')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SrcLanguage') is not None:
            self.src_language = m.get('SrcLanguage')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WordPerLine') is not None:
            self.word_per_line = m.get('WordPerLine')
        return self


class UpdateLiveAISubtitleShrinkRequest(TeaModel):
    def __init__(
        self,
        bg_color: str = None,
        bg_width_normalized: float = None,
        border_width_normalized: float = None,
        description: str = None,
        dst_language: str = None,
        font_color: str = None,
        font_name: str = None,
        font_size_normalized: float = None,
        height: str = None,
        max_lines: int = None,
        owner_id: int = None,
        position_normalized_shrink: str = None,
        region_id: str = None,
        show_source_lan: bool = None,
        src_language: str = None,
        subtitle_id: str = None,
        subtitle_name: str = None,
        width: str = None,
        word_per_line: int = None,
    ):
        # The background color of the subtitles. Color format: RGBA.
        self.bg_color = bg_color
        # The size of the background box. Valid values: [0,1].
        self.bg_width_normalized = bg_width_normalized
        # The font weight. Valid values: [0,1].
        self.border_width_normalized = border_width_normalized
        # The description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.
        self.description = description
        # The target language. Valid values:
        # 
        # *   en-US: English
        # *   zh-CN: Chinese
        # *   es-ES: Spanish
        # *   ru-RU: Russian
        self.dst_language = dst_language
        # The font color. Color format: RGBA.
        self.font_color = font_color
        # The font. Valid values:
        # 
        # *   KaiTi (default)
        # *   AlibabaPuHuiTi-Regular
        # *   AlibabaPuHuiTi-Bold
        # *   AlibabaPuHuiTi-Light
        # *   NotoSansHans-Regular
        # *   NotoSansHans-Bold
        # *   NotoSansHans-Light
        self.font_name = font_name
        # The font size. Valid values: [0,1].
        self.font_size_normalized = font_size_normalized
        # The height of the preview. Unit: pixels.
        # 
        # The following preview specifications (width x height) are supported:
        # 
        # *   360p (640 x 360)
        # *   360p (360 x 640)
        # *   480p (854 x 480)
        # *   480p (480 x 854)
        # *   720p (1280 x 720)
        # *   720p (720 x 1280)
        # *   1080p (1920 x 1080)
        # *   1080p (1080 x 1920)
        self.height = height
        # The number of displayed lines.
        self.max_lines = max_lines
        self.owner_id = owner_id
        # The position of the subtitles relative to the lower-left corner of the screen. The value is a pair of coordinates.
        self.position_normalized_shrink = position_normalized_shrink
        self.region_id = region_id
        # Specifies whether to display the source language. Valid values: true and false. Default value: false.
        self.show_source_lan = show_source_lan
        # The source language. Valid values:
        # 
        # *   en-US: English
        # *   zh-CN: Chinese
        # *   ru-RU: Russian
        self.src_language = src_language
        # The ID of the subtitle template.
        # 
        # This parameter is required.
        self.subtitle_id = subtitle_id
        # The name of the subtitle template. The name can contain digits, letters, and hyphens (-) but cannot start with a hyphen (-).
        self.subtitle_name = subtitle_name
        # The width of the preview. Unit: pixels.
        self.width = width
        # The number of characters per line. Valid values: 1 to 500.
        self.word_per_line = word_per_line

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color
        if self.bg_width_normalized is not None:
            result['BgWidthNormalized'] = self.bg_width_normalized
        if self.border_width_normalized is not None:
            result['BorderWidthNormalized'] = self.border_width_normalized
        if self.description is not None:
            result['Description'] = self.description
        if self.dst_language is not None:
            result['DstLanguage'] = self.dst_language
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size_normalized is not None:
            result['FontSizeNormalized'] = self.font_size_normalized
        if self.height is not None:
            result['Height'] = self.height
        if self.max_lines is not None:
            result['MaxLines'] = self.max_lines
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.position_normalized_shrink is not None:
            result['PositionNormalized'] = self.position_normalized_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_source_lan is not None:
            result['ShowSourceLan'] = self.show_source_lan
        if self.src_language is not None:
            result['SrcLanguage'] = self.src_language
        if self.subtitle_id is not None:
            result['SubtitleId'] = self.subtitle_id
        if self.subtitle_name is not None:
            result['SubtitleName'] = self.subtitle_name
        if self.width is not None:
            result['Width'] = self.width
        if self.word_per_line is not None:
            result['WordPerLine'] = self.word_per_line
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BgColor') is not None:
            self.bg_color = m.get('BgColor')
        if m.get('BgWidthNormalized') is not None:
            self.bg_width_normalized = m.get('BgWidthNormalized')
        if m.get('BorderWidthNormalized') is not None:
            self.border_width_normalized = m.get('BorderWidthNormalized')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DstLanguage') is not None:
            self.dst_language = m.get('DstLanguage')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSizeNormalized') is not None:
            self.font_size_normalized = m.get('FontSizeNormalized')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxLines') is not None:
            self.max_lines = m.get('MaxLines')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PositionNormalized') is not None:
            self.position_normalized_shrink = m.get('PositionNormalized')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowSourceLan') is not None:
            self.show_source_lan = m.get('ShowSourceLan')
        if m.get('SrcLanguage') is not None:
            self.src_language = m.get('SrcLanguage')
        if m.get('SubtitleId') is not None:
            self.subtitle_id = m.get('SubtitleId')
        if m.get('SubtitleName') is not None:
            self.subtitle_name = m.get('SubtitleName')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WordPerLine') is not None:
            self.word_per_line = m.get('WordPerLine')
        return self


class UpdateLiveAISubtitleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAISubtitleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAISubtitleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAISubtitleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAppRecordConfigRequestRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        slice_duration: int = None,
    ):
        # The recording cycle. Unit: seconds If you do not specify this parameter, the default value 6 hours is used.
        # 
        # > 
        # 
        # *   If a live stream is interrupted during a recording cycle but is resumed within the interruption duration threshold, the stream is recorded in the same recording before and after the interruption.
        # 
        # *   If a live stream is interrupted for longer than the interruption duration threshold, a new recording is generated.
        self.cycle_duration = cycle_duration
        # The recording format. Supported formats include M3U8, Flash Video (FLV), MP4, and Common Media Application Format (CMAF). Valid values:
        # 
        # >  You need to specify at lease one of the RecordFormat and TranscodeRecordFormat parameters. If you set this parameter to m3u8 or cmaf, you must also specify the RecordFormat.N.SliceOssObjectPrefix and RecordFormat.N.SliceDuration parameters.
        # 
        # *   m3u8
        # *   flv
        # *   mp4
        # *   cmaf
        self.format = format
        # The duration of a single segment. Unit: seconds
        # 
        # >  This parameter takes effect only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        return self


class UpdateLiveAppRecordConfigRequestTranscodeRecordFormat(TeaModel):
    def __init__(
        self,
        cycle_duration: int = None,
        format: str = None,
        slice_duration: int = None,
    ):
        # The transcoded stream recording cycle. Unit: seconds If you do not specify this parameter, the default value 6 hours is used.
        self.cycle_duration = cycle_duration
        # The format of the transcoded stream recording. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:
        # 
        # >  If you set this parameter to m3u8 or cmaf, you must also specify the TranscodeRecordFormat.N.SliceOssObjectPrefix and TranscodeRecordFormat.N.SliceDuration parameters.
        # 
        # *   m3u8
        # *   flv
        # *   mp4
        # *   cmaf
        self.format = format
        # The duration of a single segment in the transcoded stream recording. Unit: seconds.
        # 
        # >  This parameter takes effect only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.
        # 
        # If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.
        self.slice_duration = slice_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        return self


class UpdateLiveAppRecordConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        delay_time: int = None,
        domain_name: str = None,
        end_time: str = None,
        on_demand: int = None,
        oss_endpoint: str = None,
        owner_id: int = None,
        record_format: List[UpdateLiveAppRecordConfigRequestRecordFormat] = None,
        security_token: str = None,
        start_time: str = None,
        stream_name: str = None,
        transcode_record_format: List[UpdateLiveAppRecordConfigRequestTranscodeRecordFormat] = None,
        transcode_templates: List[str] = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The interruption duration for merge. If the stream interruption duration exceeds the specified duration, a new recording is generated. The value of this parameter ranges from 15 to 21600 seconds.
        self.delay_time = delay_time
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The recording end time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  The time range that is specified by the EndTime and StartTime parameters must be less than or equal to seven days. If the value exceeds seven days, ApsaraVideo Live considers seven days as the time range. This parameter takes effect only for the live stream specified by the StreamName parameter. If the StreamName parameter is not specified, this parameter does not take effect.
        self.end_time = end_time
        # Specifies whether to enable on-demand recording. Valid values:
        # 
        # *   **0**: disables on-demand recording.
        # *   **1**: enables on-demand recording by using the HTTP callback method.
        # *   **2**: enables on-demand recording by parsing the stream ingest parameters.
        # *   **7**: By default, ApsaraVideo Live does not automatically record live streams. You can call the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/2847882.html) operation to manually start or stop recording.
        # 
        # >  If you set the OnDemand parameter to **1**, you need to call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847891.html) operation to configure the OnDemandUrl parameter. Otherwise, ApsaraVideo Live does not perform on-demand recording.
        self.on_demand = on_demand
        # The endpoint of the Object Storage Service (OSS) bucket.
        # 
        # To store live stream recordings in OSS, you need to create an OSS bucket in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        # 
        # This parameter is required.
        self.oss_endpoint = oss_endpoint
        self.owner_id = owner_id
        # The recording details.
        self.record_format = record_format
        self.security_token = security_token
        # The recording start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # >  The start time must be within seven days after the stream ingest starts. This parameter takes effect only for the live stream specified by the StreamName parameter. If the StreamName parameter is not specified, this parameter does not take effect.
        self.start_time = start_time
        # The name of the live stream.
        self.stream_name = stream_name
        # The transcoded stream recording details.
        self.transcode_record_format = transcode_record_format
        # The transcoding template group details.
        self.transcode_templates = transcode_templates

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()
        if self.transcode_record_format:
            for k in self.transcode_record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        result['TranscodeRecordFormat'] = []
        if self.transcode_record_format is not None:
            for k in self.transcode_record_format:
                result['TranscodeRecordFormat'].append(k.to_map() if k else None)
        if self.transcode_templates is not None:
            result['TranscodeTemplates'] = self.transcode_templates
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = UpdateLiveAppRecordConfigRequestRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        self.transcode_record_format = []
        if m.get('TranscodeRecordFormat') is not None:
            for k in m.get('TranscodeRecordFormat'):
                temp_model = UpdateLiveAppRecordConfigRequestTranscodeRecordFormat()
                self.transcode_record_format.append(temp_model.from_map(k))
        if m.get('TranscodeTemplates') is not None:
            self.transcode_templates = m.get('TranscodeTemplates')
        return self


class UpdateLiveAppRecordConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAppRecordConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAppRecordConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAppRecordConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAppSnapshotConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        callback: str = None,
        domain_name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        overwrite_oss_object: str = None,
        owner_id: int = None,
        security_token: str = None,
        sequence_oss_object: str = None,
        time_interval: int = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The callback URL that is used to receive notifications about snapshot capture.
        self.callback = callback
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the OSS bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.
        # 
        # *   The name must be less than 256 bytes in length.
        # *   Only JPG images are supported.
        # *   The name can contain variables such as {AppName} and {StreamName}.
        # *   A value of hyphen (-) indicates that this parameter is deleted.
        self.overwrite_oss_object = overwrite_oss_object
        self.owner_id = owner_id
        self.security_token = security_token
        # The naming format of snapshots that are stored in sequence, which means that a new snapshot does not overwrite the previous snapshot. You can call the [DescribeLiveStreamSnapshotInfo](https://help.aliyun.com/document_detail/2847902.html) operation to query the snapshots that were captured within a specific time period.
        # 
        # *   The name must be less than 256 bytes in length.
        # *   Only JPG images are supported.
        # *   The name can contain variables such as {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence}. The name must contain at least one of the {UnixTimestamp} and {Sequence} variables.
        # *   A value of hyphen (-) indicates that this parameter is deleted.
        self.sequence_oss_object = sequence_oss_object
        # The interval at which snapshots are captured. Valid values: **5 to 3600**. Unit: seconds.
        self.time_interval = time_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.overwrite_oss_object is not None:
            result['OverwriteOssObject'] = self.overwrite_oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.sequence_oss_object is not None:
            result['SequenceOssObject'] = self.sequence_oss_object
        if self.time_interval is not None:
            result['TimeInterval'] = self.time_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OverwriteOssObject') is not None:
            self.overwrite_oss_object = m.get('OverwriteOssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('SequenceOssObject') is not None:
            self.sequence_oss_object = m.get('SequenceOssObject')
        if m.get('TimeInterval') is not None:
            self.time_interval = m.get('TimeInterval')
        return self


class UpdateLiveAppSnapshotConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAppSnapshotConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAppSnapshotConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAppSnapshotConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAudioAuditConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        biz_type: str = None,
        domain_name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The application name is case-sensitive.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The business type. You can specify a model. The default value is the domain name.
        self.biz_type = biz_type
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The name of the Object Storage Service (OSS) bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the OSS bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the recording that is stored in OSS.
        self.oss_object = oss_object
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. The stream name is case-sensitive.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class UpdateLiveAudioAuditConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAudioAuditConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAudioAuditConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAudioAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveAudioAuditNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        callback: str = None,
        callback_template: str = None,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The callback URL. This URL is used to receive callback notifications about violations in audio.
        self.callback = callback
        # The callback template. Configure the following fields:
        # 
        # *   **{DomainName}**: the streaming domain.
        # *   **{AppName}**: the name of the application to which the live stream belongs.
        # *   **{StreamName}**: the name of the live stream.
        # *   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
        # *   **{Result}**: the moderation results.
        self.callback_template = callback_template
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['Callback'] = self.callback
        if self.callback_template is not None:
            result['CallbackTemplate'] = self.callback_template
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Callback') is not None:
            self.callback = m.get('Callback')
        if m.get('CallbackTemplate') is not None:
            self.callback_template = m.get('CallbackTemplate')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateLiveAudioAuditNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveAudioAuditNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveAudioAuditNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveAudioAuditNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveCenterTransferRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        dst_url: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        start_time: str = None,
        stream_name: str = None,
        transfer_args: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The third-party URL to which the live stream is relayed. You can add only one URL.
        # 
        # >  The protocol that the URL uses must be the same as the protocol of the live stream. Only URLs over RTMP and SRT are supported.
        # 
        # This parameter is required.
        self.dst_url = dst_url
        # The end time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # >  The end time must be later than the start time.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The start time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.stream_name = stream_name
        # The validity period of stream relay. Valid values:
        # 
        # *   **always**: The stream can always be relayed.
        # *   **time**: The stream can be relayed in a specified time period.
        # 
        # >  If the value is **time**, **StartTime** and **EndTime** are required.
        # 
        # This parameter is required.
        self.transfer_args = transfer_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.dst_url is not None:
            result['DstUrl'] = self.dst_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.transfer_args is not None:
            result['TransferArgs'] = self.transfer_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DstUrl') is not None:
            self.dst_url = m.get('DstUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TransferArgs') is not None:
            self.transfer_args = m.get('TransferArgs')
        return self


class UpdateLiveCenterTransferResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveCenterTransferResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveCenterTransferResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveCenterTransferResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveDelayConfigRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        delay_time: int = None,
        domain: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
        task_trigger_mode: str = None,
    ):
        # The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.
        # 
        # This parameter is required.
        self.app = app
        # The duration for which the playback of the live stream is delayed. The value must be an integer. Valid values: 16 to 3600. Unit: seconds.
        # 
        # This parameter is required.
        self.delay_time = delay_time
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain = domain
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.
        # 
        # This parameter is required.
        self.stream = stream
        # The trigger mode. Valid values:
        # 
        # *   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
        # *   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
        # *   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.
        self.task_trigger_mode = task_trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.delay_time is not None:
            result['DelayTime'] = self.delay_time
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        if self.task_trigger_mode is not None:
            result['TaskTriggerMode'] = self.task_trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('DelayTime') is not None:
            self.delay_time = m.get('DelayTime')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        if m.get('TaskTriggerMode') is not None:
            self.task_trigger_mode = m.get('TaskTriggerMode')
        return self


class UpdateLiveDelayConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveDelayConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveDelayConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveDelayConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveDetectNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_url: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The callback URL that is used to receive callback notifications about violations, such as pornographic content, detected in live streams.
        # 
        # This parameter is required.
        self.notify_url = notify_url
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class UpdateLiveDetectNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveDetectNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveDetectNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveDetectNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveMPUTaskRequestMultiStreamURL(TeaModel):
    def __init__(
        self,
        is_ali_cdn: bool = None,
        url: str = None,
    ):
        # Specifies whether to perform stream relay by using Alibaba Cloud CDN. Valid values:
        # 
        # *   false: performs stream relay by using a CDN service that is not Alibaba Cloud CDN.
        # *   true: performs stream relay by using Alibaba Cloud CDN.
        # 
        # >  The default value of this parameter is false.
        self.is_ali_cdn = is_ali_cdn
        # The ingest URL. Only the RTMP format is supported. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_ali_cdn is not None:
            result['IsAliCdn'] = self.is_ali_cdn
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsAliCdn') is not None:
            self.is_ali_cdn = m.get('IsAliCdn')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class UpdateLiveMPUTaskRequestSeiParamsLayoutVolume(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
    ):
        # Specifies whether to include the SEI in an Instantaneous Decoder Refresh (IDR) frame. Valid values:
        # 
        # *   **0**: does not include the SEI.
        # *   **1**: includes the SEI.
        self.follow_idr = follow_idr
        # The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.
        self.interval = interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        return self


class UpdateLiveMPUTaskRequestSeiParamsPassThrough(TeaModel):
    def __init__(
        self,
        follow_idr: str = None,
        interval: str = None,
        payload_content: str = None,
        payload_content_key: str = None,
    ):
        # Specifies whether to include the SEI in an IDR frame. Valid values:
        # 
        # *   **0**: does not include the SEI.
        # *   **1**: includes the SEI.
        self.follow_idr = follow_idr
        # The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.
        self.interval = interval
        # The payload content of the SEI.
        self.payload_content = payload_content
        # The key of the payload content of the SEI. If you do not specify this parameter, the default value udd is used.
        self.payload_content_key = payload_content_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.follow_idr is not None:
            result['FollowIdr'] = self.follow_idr
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.payload_content is not None:
            result['PayloadContent'] = self.payload_content
        if self.payload_content_key is not None:
            result['PayloadContentKey'] = self.payload_content_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FollowIdr') is not None:
            self.follow_idr = m.get('FollowIdr')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PayloadContent') is not None:
            self.payload_content = m.get('PayloadContent')
        if m.get('PayloadContentKey') is not None:
            self.payload_content_key = m.get('PayloadContentKey')
        return self


class UpdateLiveMPUTaskRequestSeiParams(TeaModel):
    def __init__(
        self,
        layout_volume: UpdateLiveMPUTaskRequestSeiParamsLayoutVolume = None,
        pass_through: UpdateLiveMPUTaskRequestSeiParamsPassThrough = None,
    ):
        # The layout and volume SEI. If you leave this parameter empty, the default layout and volume SEI is used.
        self.layout_volume = layout_volume
        # Specifies whether to pass through the SEI.
        self.pass_through = pass_through

    def validate(self):
        if self.layout_volume:
            self.layout_volume.validate()
        if self.pass_through:
            self.pass_through.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_volume is not None:
            result['LayoutVolume'] = self.layout_volume.to_map()
        if self.pass_through is not None:
            result['PassThrough'] = self.pass_through.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutVolume') is not None:
            temp_model = UpdateLiveMPUTaskRequestSeiParamsLayoutVolume()
            self.layout_volume = temp_model.from_map(m['LayoutVolume'])
        if m.get('PassThrough') is not None:
            temp_model = UpdateLiveMPUTaskRequestSeiParamsPassThrough()
            self.pass_through = temp_model.from_map(m['PassThrough'])
        return self


class UpdateLiveMPUTaskRequestSingleSubParams(TeaModel):
    def __init__(
        self,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The type of the stream that you want to relay. Valid values:
        # 
        # *   **0** (default): original stream
        # *   **1**: only the audio track
        # *   **2**: only the video track
        self.stream_type = stream_type
        # The user ID. In the single-stream relay mode, you can relay only one stream in a request.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsBackground(TeaModel):
    def __init__(
        self,
        render_mode: str = None,
        url: str = None,
    ):
        # The display mode of the global background image.
        # 
        # *   **0**: scales the background image proportionally to fit the view, with black bars displayed.
        # *   **1** (default): crops the background image to fit the view.
        self.render_mode = render_mode
        # The URL of the global background image.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams(TeaModel):
    def __init__(
        self,
        audio_bitrate: str = None,
        audio_channels: str = None,
        audio_only: str = None,
        audio_sample_rate: str = None,
        enhanced_param: str = None,
        video_bitrate: str = None,
        video_codec: str = None,
        video_framerate: str = None,
        video_gop: str = None,
        video_height: str = None,
        video_width: str = None,
    ):
        # The bitrate of the audio. Valid values: [8,500]. Unit: Kbit/s.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values: 1 and 2.
        self.audio_channels = audio_channels
        # Specifies whether the output stream is an audio-only stream. Valid values:
        # 
        # *   **true**: The output stream is an audio-only stream. If you set this parameter to true, you need to configure only audio-related parameters under EncodeParams.
        # *   **false** (default): The output stream is not an audio-only stream. If you set this parameter to false, you need to configure all parameters under EncodeParams, except the VideoCodec and EnhancedParam parameters.
        self.audio_only = audio_only
        # The audio sampling rate. Valid values: 8000, 16000, 32000, 44100, and 48000. Unit: Hz.
        self.audio_sample_rate = audio_sample_rate
        # The parameter used for encoding enhancement, which is a JSON string. The parameter includes the optional profile and preset fields.
        # 
        # *   profile: the encoding level. If the video codec is H.264, the valid values of this field are baseline, main, and high. If the video codec is H.265, the valid value of this field is main.
        # *   preset: adjusts the trade-off between encoding speed and video quality. The valid values of this field are ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.
        # 
        # >  A value of superfast for the preset field is suitable for real-time communication scenarios. We recommend that you not set the field if you are not a professional encoding engineer.
        self.enhanced_param = enhanced_param
        # The bitrate of the video. Valid values: [1,10000]. Unit: Kbit/s.
        self.video_bitrate = video_bitrate
        # The video codec. Valid values:
        # 
        # *   H.264 (default)
        # *   H.265
        self.video_codec = video_codec
        # The frame rate of the video. Valid values: [1,60]. Unit: frames per second (FPS).
        self.video_framerate = video_framerate
        # The group of pictures (GOP) size of the video. Valid values: [1,60].
        self.video_gop = video_gop
        # The height of the video. Valid values: [0,1920]. Unit: pixels.
        self.video_height = video_height
        # The width of the video. Valid values: [0,1920]. Unit: pixels.
        self.video_width = video_width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channels is not None:
            result['AudioChannels'] = self.audio_channels
        if self.audio_only is not None:
            result['AudioOnly'] = self.audio_only
        if self.audio_sample_rate is not None:
            result['AudioSampleRate'] = self.audio_sample_rate
        if self.enhanced_param is not None:
            result['EnhancedParam'] = self.enhanced_param
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        if self.video_framerate is not None:
            result['VideoFramerate'] = self.video_framerate
        if self.video_gop is not None:
            result['VideoGop'] = self.video_gop
        if self.video_height is not None:
            result['VideoHeight'] = self.video_height
        if self.video_width is not None:
            result['VideoWidth'] = self.video_width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannels') is not None:
            self.audio_channels = m.get('AudioChannels')
        if m.get('AudioOnly') is not None:
            self.audio_only = m.get('AudioOnly')
        if m.get('AudioSampleRate') is not None:
            self.audio_sample_rate = m.get('AudioSampleRate')
        if m.get('EnhancedParam') is not None:
            self.enhanced_param = m.get('EnhancedParam')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        if m.get('VideoFramerate') is not None:
            self.video_framerate = m.get('VideoFramerate')
        if m.get('VideoGop') is not None:
            self.video_gop = m.get('VideoGop')
        if m.get('VideoHeight') is not None:
            self.video_height = m.get('VideoHeight')
        if m.get('VideoWidth') is not None:
            self.video_width = m.get('VideoWidth')
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.
        self.channel_id = channel_id
        # The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes(TeaModel):
    def __init__(
        self,
        background_image_url: str = None,
        height: str = None,
        render_mode: str = None,
        user_info: UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo = None,
        width: str = None,
        x: str = None,
        y: str = None,
        zorder: str = None,
    ):
        # The URL of the background image of the pane. This image is displayed if the user turns off the camera or is not present in the channel.
        self.background_image_url = background_image_url
        # The height of the pane. The value is normalized.
        self.height = height
        # The display mode of the pane. Valid values:
        # 
        # *   **0**: scales the video proportionally to fit the view, with black bars displayed.
        # *   **1 (default)**: crops the video to fit the view.
        self.render_mode = render_mode
        # The information about the user whose stream is played in the pane. If you leave this parameter empty, the system automatically sets this parameter based on the order in which streamers join the channel.
        # 
        # > 
        # 
        # *   If you specify the information about a user by using this parameter, the information about the user must also be specified by using the TranscodeParams.UserInfos parameter.
        # 
        # *   This parameter is valid only when you set StreamType to 0 or 2.
        self.user_info = user_info
        # The width of the pane. The value is normalized.
        self.width = width
        # The x-coordinate of the pane. The value is normalized.
        self.x = x
        # The y-coordinate of the pane. The value is normalized.
        self.y = y
        # The layer in which the pane resides. A value of 0 indicates the bottom layer. Each increment of the value by 1 indicates the next upper layer.
        self.zorder = zorder

    def validate(self):
        if self.user_info:
            self.user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_image_url is not None:
            result['BackgroundImageUrl'] = self.background_image_url
        if self.height is not None:
            result['Height'] = self.height
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.user_info is not None:
            result['UserInfo'] = self.user_info.to_map()
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundImageUrl') is not None:
            self.background_image_url = m.get('BackgroundImageUrl')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('UserInfo') is not None:
            temp_model = UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo()
            self.user_info = temp_model.from_map(m['UserInfo'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsLayout(TeaModel):
    def __init__(
        self,
        user_panes: List[UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes] = None,
    ):
        # The information about the panes.
        self.user_panes = user_panes

    def validate(self):
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class UpdateLiveMPUTaskRequestTranscodeParamsUserInfos(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        source_type: str = None,
        stream_type: str = None,
        user_id: str = None,
    ):
        # The ID of the channel where the subscribed user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.
        self.channel_id = channel_id
        # The type of the video source that is subscribed to. This parameter is valid only when you set StreamType to 2. Valid values:
        # 
        # *   **camera** (default)
        # *   **shareScreen**\
        self.source_type = source_type
        # The type of the relayed stream that is subscribed to. Valid values:
        # 
        # *   **0** (default): original stream
        # *   **1**: only the audio track
        # *   **2**: only the video track
        self.stream_type = stream_type
        # The ID of the subscribed user.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateLiveMPUTaskRequestTranscodeParams(TeaModel):
    def __init__(
        self,
        background: UpdateLiveMPUTaskRequestTranscodeParamsBackground = None,
        encode_params: UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams = None,
        layout: UpdateLiveMPUTaskRequestTranscodeParamsLayout = None,
        user_infos: List[UpdateLiveMPUTaskRequestTranscodeParamsUserInfos] = None,
    ):
        # The global background image.
        self.background = background
        # The encoding parameters for the output stream.
        self.encode_params = encode_params
        # The video layout information.
        # 
        # >  If video transcoding is required, you must specify the video layout information, including the x-coordinate and y-coordinate, the width and height, and the layer. For audio-only transcoding, leave the video layout information empty.
        self.layout = layout
        # The information about the users whose streams are subscribed to. If you leave this parameter empty, streams from all users are mixed.
        self.user_infos = user_infos

    def validate(self):
        if self.background:
            self.background.validate()
        if self.encode_params:
            self.encode_params.validate()
        if self.layout:
            self.layout.validate()
        if self.user_infos:
            for k in self.user_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background is not None:
            result['Background'] = self.background.to_map()
        if self.encode_params is not None:
            result['EncodeParams'] = self.encode_params.to_map()
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        result['UserInfos'] = []
        if self.user_infos is not None:
            for k in self.user_infos:
                result['UserInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Background') is not None:
            temp_model = UpdateLiveMPUTaskRequestTranscodeParamsBackground()
            self.background = temp_model.from_map(m['Background'])
        if m.get('EncodeParams') is not None:
            temp_model = UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams()
            self.encode_params = temp_model.from_map(m['EncodeParams'])
        if m.get('Layout') is not None:
            temp_model = UpdateLiveMPUTaskRequestTranscodeParamsLayout()
            self.layout = temp_model.from_map(m['Layout'])
        self.user_infos = []
        if m.get('UserInfos') is not None:
            for k in m.get('UserInfos'):
                temp_model = UpdateLiveMPUTaskRequestTranscodeParamsUserInfos()
                self.user_infos.append(temp_model.from_map(k))
        return self


class UpdateLiveMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        mix_mode: str = None,
        multi_stream_url: List[UpdateLiveMPUTaskRequestMultiStreamURL] = None,
        sei_params: UpdateLiveMPUTaskRequestSeiParams = None,
        single_sub_params: UpdateLiveMPUTaskRequestSingleSubParams = None,
        stream_url: str = None,
        task_id: str = None,
        transcode_params: UpdateLiveMPUTaskRequestTranscodeParams = None,
    ):
        # The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The stream mixing mode. Valid values:
        # 
        # *   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
        # *   **1** (default): the mixed-stream relay mode.
        self.mix_mode = mix_mode
        # The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.
        self.multi_stream_url = multi_stream_url
        # The supplemental enhancement information (SEI) parameters.
        self.sei_params = sei_params
        # The single-stream relay parameters. These parameters are required if you set MixMode to 0.
        self.single_sub_params = single_sub_params
        # The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        # 
        # > 
        # 
        # *   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
        # *   You cannot use the same ingest URL in different tasks.
        # *   You cannot use the same ingest URL within 10 seconds after a task is stopped.
        self.stream_url = stream_url
        # The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.
        # 
        # This parameter is required.
        self.task_id = task_id
        # The mixed-stream relay parameters. These parameters are required if you set MixMode to 1.
        self.transcode_params = transcode_params

    def validate(self):
        if self.multi_stream_url:
            for k in self.multi_stream_url:
                if k:
                    k.validate()
        if self.sei_params:
            self.sei_params.validate()
        if self.single_sub_params:
            self.single_sub_params.validate()
        if self.transcode_params:
            self.transcode_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        result['MultiStreamURL'] = []
        if self.multi_stream_url is not None:
            for k in self.multi_stream_url:
                result['MultiStreamURL'].append(k.to_map() if k else None)
        if self.sei_params is not None:
            result['SeiParams'] = self.sei_params.to_map()
        if self.single_sub_params is not None:
            result['SingleSubParams'] = self.single_sub_params.to_map()
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.transcode_params is not None:
            result['TranscodeParams'] = self.transcode_params.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        self.multi_stream_url = []
        if m.get('MultiStreamURL') is not None:
            for k in m.get('MultiStreamURL'):
                temp_model = UpdateLiveMPUTaskRequestMultiStreamURL()
                self.multi_stream_url.append(temp_model.from_map(k))
        if m.get('SeiParams') is not None:
            temp_model = UpdateLiveMPUTaskRequestSeiParams()
            self.sei_params = temp_model.from_map(m['SeiParams'])
        if m.get('SingleSubParams') is not None:
            temp_model = UpdateLiveMPUTaskRequestSingleSubParams()
            self.single_sub_params = temp_model.from_map(m['SingleSubParams'])
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TranscodeParams') is not None:
            temp_model = UpdateLiveMPUTaskRequestTranscodeParams()
            self.transcode_params = temp_model.from_map(m['TranscodeParams'])
        return self


class UpdateLiveMPUTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        mix_mode: str = None,
        multi_stream_urlshrink: str = None,
        sei_params_shrink: str = None,
        single_sub_params_shrink: str = None,
        stream_url: str = None,
        task_id: str = None,
        transcode_params_shrink: str = None,
    ):
        # The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.channel_id = channel_id
        # The stream mixing mode. Valid values:
        # 
        # *   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
        # *   **1** (default): the mixed-stream relay mode.
        self.mix_mode = mix_mode
        # The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.
        self.multi_stream_urlshrink = multi_stream_urlshrink
        # The supplemental enhancement information (SEI) parameters.
        self.sei_params_shrink = sei_params_shrink
        # The single-stream relay parameters. These parameters are required if you set MixMode to 0.
        self.single_sub_params_shrink = single_sub_params_shrink
        # The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).
        # 
        # > 
        # 
        # *   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
        # *   You cannot use the same ingest URL in different tasks.
        # *   You cannot use the same ingest URL within 10 seconds after a task is stopped.
        self.stream_url = stream_url
        # The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.
        # 
        # This parameter is required.
        self.task_id = task_id
        # The mixed-stream relay parameters. These parameters are required if you set MixMode to 1.
        self.transcode_params_shrink = transcode_params_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        if self.multi_stream_urlshrink is not None:
            result['MultiStreamURL'] = self.multi_stream_urlshrink
        if self.sei_params_shrink is not None:
            result['SeiParams'] = self.sei_params_shrink
        if self.single_sub_params_shrink is not None:
            result['SingleSubParams'] = self.single_sub_params_shrink
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.transcode_params_shrink is not None:
            result['TranscodeParams'] = self.transcode_params_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        if m.get('MultiStreamURL') is not None:
            self.multi_stream_urlshrink = m.get('MultiStreamURL')
        if m.get('SeiParams') is not None:
            self.sei_params_shrink = m.get('SeiParams')
        if m.get('SingleSubParams') is not None:
            self.single_sub_params_shrink = m.get('SingleSubParams')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TranscodeParams') is not None:
            self.transcode_params_shrink = m.get('TranscodeParams')
        return self


class UpdateLiveMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePackageConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        ignore_transcode: bool = None,
        owner_id: int = None,
        part_duration: int = None,
        protocol: str = None,
        region_id: str = None,
        segment_duration: int = None,
        segment_num: int = None,
        stream_name: str = None,
    ):
        # The application name. The value of this parameter must be the same as the application name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to ignore the transcoded stream. Valid values:
        # 
        # *   **true** (default)
        # *   **false**\
        self.ignore_transcode = ignore_transcode
        self.owner_id = owner_id
        # The part length. Unit: milliseconds.
        # 
        # >  This parameter is required if Protocol is set to LLHLS_TS or LLHLS_CMAF.
        # 
        # *   If the value of SegmentDuration is 1, the valid values of this parameter are 100 to 500.
        # *   If the value of SegmentDuration is 2, the valid values of this parameter are 100 to 1000.
        self.part_duration = part_duration
        # The streaming protocol and encapsulation format. Valid values:
        # 
        # *   **HLS_CMAF**\
        # *   **LLHLS_TS** (low latency)
        # *   **LLHLS_CMAF** (low latency)
        # *   **DASH_CMAF**\
        # *   **HLSDASH_CMAF**\
        # 
        # This parameter is required.
        self.protocol = protocol
        self.region_id = region_id
        # The segment length. Unit: seconds.
        # 
        # *   If Protocol is set to HLS_CMAF, the valid values of this parameter are 1 to 10.
        # *   If Protocol is set to LLHLS_TS or LLHLS_CMAF, the valid values of this parameter are 1 to 2.
        # 
        # This parameter is required.
        self.segment_duration = segment_duration
        # The number of segments. Valid values: 3 to 10.
        # 
        # This parameter is required.
        self.segment_num = segment_num
        # The stream name. The value of this parameter must be the same as the stream name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all streams.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.ignore_transcode is not None:
            result['IgnoreTranscode'] = self.ignore_transcode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.part_duration is not None:
            result['PartDuration'] = self.part_duration
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.segment_duration is not None:
            result['SegmentDuration'] = self.segment_duration
        if self.segment_num is not None:
            result['SegmentNum'] = self.segment_num
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('IgnoreTranscode') is not None:
            self.ignore_transcode = m.get('IgnoreTranscode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PartDuration') is not None:
            self.part_duration = m.get('PartDuration')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SegmentDuration') is not None:
            self.segment_duration = m.get('SegmentDuration')
        if m.get('SegmentNum') is not None:
            self.segment_num = m.get('SegmentNum')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class UpdateLivePackageConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePackageConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePackageConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePackageConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePullStreamInfoConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        end_time: str = None,
        owner_id: int = None,
        region_id: str = None,
        source_url: str = None,
        start_time: str = None,
        stream_name: str = None,
    ):
        # The name of the application to which the live stream belongs.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The domain name used for stream pulling. It is the main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The time when stream pulling ends.
        # 
        # The time range specified by the StartTime and EndTime parameters cannot exceed seven days. The time specified by the EndTime parameter must be later than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.end_time = end_time
        self.owner_id = owner_id
        self.region_id = region_id
        # The complete URL of the origin server of the live stream. You can specify multiple URLs by separating them with semicolons (;).
        # 
        # This parameter is required.
        self.source_url = source_url
        # The time when stream pulling starts.
        # 
        # The time range specified by the StartTime and EndTime parameters cannot exceed seven days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The name of the live stream.
        # 
        # This parameter is required.
        self.stream_name = stream_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.source_url is not None:
            result['SourceUrl'] = self.source_url
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SourceUrl') is not None:
            self.source_url = m.get('SourceUrl')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class UpdateLivePullStreamInfoConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLivePullStreamInfoConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePullStreamInfoConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePullStreamInfoConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLivePullToPushRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        repeat_number: int = None,
        source_urls: List[str] = None,
        start_time: str = None,
        task_id: str = None,
    ):
        # The callback URL. By default, this parameter is left empty.
        # 
        # > 
        # 
        # *   The URL is used to receive callbacks related to the task.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # *   If you do not specify this parameter, no callbacks are returned for events related to the task.
        # 
        # *   The update takes effect for subsequent events that occur.
        self.callback_url = callback_url
        # The end time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   The end time must be later than the start time.
        # 
        # *   The end time must be later than the current time.
        # 
        # *   If the task has ended, the update does not take effect.
        self.end_time = end_time
        # The file index. Default value: 0.
        # 
        # >  You can modify this parameter only if the task is stopped. The update takes effect after you restart the task.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        # 
        # *   The update takes effect only for the first video in a video list.
        # 
        # *   You can modify this parameter only if the task is stopped. The update takes effect immediately.
        self.offset = offset
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # > 
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        # 
        # *   The update can take effect immediately.
        self.repeat_number = repeat_number
        # The source URLs.
        # 
        # > 
        # 
        # *   If SourceType is set to live, you can specify only one streaming URL.
        # 
        # *   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.
        # 
        # *   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.
        # 
        # *   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.
        # 
        # *   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.
        # 
        # *   If the source is a live stream, the update takes effect immediately. If the source is a list of video resources from ApsaraVideo VOD or a third party, the update does not take effect until the playback of the current video ends. After the update takes effect, the video list starts to play from the beginning.
        # 
        # *   You can modify this parameter only if the task is stopped. The update takes effect immediately.
        self.source_urls = source_urls
        # The start time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   If the task has already started, the update does not take effect.
        self.start_time = start_time
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.source_urls is not None:
            result['SourceUrls'] = self.source_urls
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('SourceUrls') is not None:
            self.source_urls = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateLivePullToPushShrinkRequest(TeaModel):
    def __init__(
        self,
        callback_url: str = None,
        end_time: str = None,
        file_index: int = None,
        offset: int = None,
        owner_id: int = None,
        region: str = None,
        region_id: str = None,
        repeat_number: int = None,
        source_urls_shrink: str = None,
        start_time: str = None,
        task_id: str = None,
    ):
        # The callback URL. By default, this parameter is left empty.
        # 
        # > 
        # 
        # *   The URL is used to receive callbacks related to the task.
        # 
        # *   The URL can be up to 2,000 characters in length.
        # 
        # *   If you do not specify this parameter, no callbacks are returned for events related to the task.
        # 
        # *   The update takes effect for subsequent events that occur.
        self.callback_url = callback_url
        # The end time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   The end time must be later than the start time.
        # 
        # *   The end time must be later than the current time.
        # 
        # *   If the task has ended, the update does not take effect.
        self.end_time = end_time
        # The file index. Default value: 0.
        # 
        # >  You can modify this parameter only if the task is stopped. The update takes effect after you restart the task.
        self.file_index = file_index
        # The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.
        # 
        # > 
        # 
        # *   This parameter indicates an offset from the first frame.
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        # 
        # *   The update takes effect only for the first video in a video list.
        # 
        # *   You can modify this parameter only if the task is stopped. The update takes effect immediately.
        self.offset = offset
        self.owner_id = owner_id
        # The region where the task is started. Valid values:
        # 
        # *   ap-southeast-1: Singapore
        # *   ap-southeast-5: Indonesia (Jakarta)
        # *   cn-beijing: China (Beijing)
        # *   cn-shanghai: China (Shanghai)
        # 
        # This parameter is required.
        self.region = region
        self.region_id = region_id
        # The number of playbacks after the first playback is complete. Valid values:
        # 
        # *   0 (default): specifies that the video list is played only once.
        # *   \\-1: specifies that the video list is played in loop mode.
        # *   Positive integer: specifies the number of times the video list repeats after the first playback is complete.
        # 
        # > 
        # 
        # *   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.
        # 
        # *   The update can take effect immediately.
        self.repeat_number = repeat_number
        # The source URLs.
        # 
        # > 
        # 
        # *   If SourceType is set to live, you can specify only one streaming URL.
        # 
        # *   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.
        # 
        # *   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.
        # 
        # *   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.
        # 
        # *   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.
        # 
        # *   If the source is a live stream, the update takes effect immediately. If the source is a list of video resources from ApsaraVideo VOD or a third party, the update does not take effect until the playback of the current video ends. After the update takes effect, the video list starts to play from the beginning.
        # 
        # *   You can modify this parameter only if the task is stopped. The update takes effect immediately.
        self.source_urls_shrink = source_urls_shrink
        # The start time of the task.
        # 
        # > 
        # 
        # *   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
        # 
        # *   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.
        # 
        # *   If the task has already started, the update does not take effect.
        self.start_time = start_time
        # The task ID.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_index is not None:
            result['FileIndex'] = self.file_index
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_number is not None:
            result['RepeatNumber'] = self.repeat_number
        if self.source_urls_shrink is not None:
            result['SourceUrls'] = self.source_urls_shrink
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileIndex') is not None:
            self.file_index = m.get('FileIndex')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatNumber') is not None:
            self.repeat_number = m.get('RepeatNumber')
        if m.get('SourceUrls') is not None:
            self.source_urls_shrink = m.get('SourceUrls')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateLivePullToPushResponseBody(TeaModel):
    def __init__(
        self,
        description: str = None,
        request_id: str = None,
        ret_code: int = None,
    ):
        # The error description.
        self.description = description
        # The request ID.
        self.request_id = request_id
        # The code that is returned for the request.
        # 
        # > 
        # 
        # *   0 is returned if the request is normal.
        # 
        # *   For information about codes that are returned when exceptions occur, see the following Error codes table.
        self.ret_code = ret_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.ret_code is not None:
            result['RetCode'] = self.ret_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetCode') is not None:
            self.ret_code = m.get('RetCode')
        return self


class UpdateLivePullToPushResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLivePullToPushResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLivePullToPushResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveRecordNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        need_status_notify: bool = None,
        notify_auth_key: str = None,
        notify_req_auth: bool = None,
        notify_url: str = None,
        on_demand_url: str = None,
        owner_id: int = None,
        security_token: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to enable callbacks for recording status. Valid values:
        # 
        # *   **true**\
        # *   **false** (default)
        self.need_status_notify = need_status_notify
        self.notify_auth_key = notify_auth_key
        self.notify_req_auth = notify_req_auth
        # The callback URL that is used to receive notifications about recording events and status.
        # 
        # > 
        # 
        # *   The URL must start with `http://` or `https://`.
        # 
        # *   You must use URLEncoder for encoding. This way, the system can identify Chinese characters, spaces, and special characters.
        # 
        # This parameter is required.
        self.notify_url = notify_url
        # The callback URL for on-demand recordings.
        # 
        # > 
        # 
        # *   The URL must start with `http://` or `https://`.
        # 
        # *   You must use URLEncoder for encoding. This way, the system can identify Chinese characters, spaces, and special characters.
        self.on_demand_url = on_demand_url
        self.owner_id = owner_id
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.need_status_notify is not None:
            result['NeedStatusNotify'] = self.need_status_notify
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.on_demand_url is not None:
            result['OnDemandUrl'] = self.on_demand_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NeedStatusNotify') is not None:
            self.need_status_notify = m.get('NeedStatusNotify')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OnDemandUrl') is not None:
            self.on_demand_url = m.get('OnDemandUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class UpdateLiveRecordNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveRecordNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveRecordNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveRecordNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveRecordVodConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        auto_compose: str = None,
        compose_vod_transcode_group_id: str = None,
        cycle_duration: int = None,
        domain_name: str = None,
        on_demand: int = None,
        owner_id: int = None,
        region_id: str = None,
        stream_name: str = None,
        vod_transcode_group_id: str = None,
    ):
        # The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        # 
        # This parameter is required.
        self.app_name = app_name
        # Specifies whether to enable automatic merging. Valid values:
        # 
        # *   **ON**: enables automatic merging. If you set this parameter to ON, you must also specify the ComposeVodTranscodeGroupId parameter.
        # *   **OFF**: disables automatic merging.
        self.auto_compose = auto_compose
        # The ID of the transcoding template group in ApsaraVideo VOD that is used to transcode the video file. The video file is generated by merging the VOD files created from live streams.
        # 
        # >  To query transcoding template groups, call the [ListTranscodeTemplateGroup](https://help.aliyun.com/document_detail/454928.html) operation.
        self.compose_vod_transcode_group_id = compose_vod_transcode_group_id
        # The recording cycle. Unit: seconds. Valid values: **300 to 21600**. Default value: **3600**.
        self.cycle_duration = cycle_duration
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # Specifies whether to enable on-demand recording. Valid values:
        # 
        # *   **0** (default): disables on-demand recording.
        # *   **1**: enables on-demand recording by using the HTTP callback method.
        self.on_demand = on_demand
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.
        self.stream_name = stream_name
        # The ID of the transcoding template group in ApsaraVideo VOD.
        # 
        # This parameter is required.
        self.vod_transcode_group_id = vod_transcode_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.auto_compose is not None:
            result['AutoCompose'] = self.auto_compose
        if self.compose_vod_transcode_group_id is not None:
            result['ComposeVodTranscodeGroupId'] = self.compose_vod_transcode_group_id
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.on_demand is not None:
            result['OnDemand'] = self.on_demand
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.vod_transcode_group_id is not None:
            result['VodTranscodeGroupId'] = self.vod_transcode_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AutoCompose') is not None:
            self.auto_compose = m.get('AutoCompose')
        if m.get('ComposeVodTranscodeGroupId') is not None:
            self.compose_vod_transcode_group_id = m.get('ComposeVodTranscodeGroupId')
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OnDemand') is not None:
            self.on_demand = m.get('OnDemand')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('VodTranscodeGroupId') is not None:
            self.vod_transcode_group_id = m.get('VodTranscodeGroupId')
        return self


class UpdateLiveRecordVodConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveRecordVodConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveRecordVodConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveRecordVodConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveSnapshotDetectPornConfigRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        domain_name: str = None,
        interval: int = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_object: str = None,
        owner_id: int = None,
        scene: List[str] = None,
        security_token: str = None,
    ):
        # The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The interval at which snapshots are captured from the live stream. Valid values: **5 to 3600**. Unit: seconds.
        self.interval = interval
        # The name of the OSS bucket.
        self.oss_bucket = oss_bucket
        # The endpoint of the Object Storage Service (OSS) bucket.
        self.oss_endpoint = oss_endpoint
        # The name of the snapshot that stores violations such as pornographic content and politically sensitive content.
        self.oss_object = oss_object
        self.owner_id = owner_id
        # The moderation scenario array.
        self.scene = scene
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class UpdateLiveSnapshotDetectPornConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveSnapshotDetectPornConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveSnapshotDetectPornConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveSnapshotDetectPornConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveSnapshotNotifyConfigRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        notify_auth_key: str = None,
        notify_req_auth: str = None,
        notify_url: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The callback authentication key. The key can be 16 to 32 characters in length and can contain only letters and digits.
        # 
        # >  This parameter is required if you set the NotifyReqAuth parameter to **yes**.
        self.notify_auth_key = notify_auth_key
        # Specifies whether to enable callback authentication. Valid values:
        # 
        # *   **yes**: enables callback authentication
        # *   **no**: disables callback authentication
        # 
        # >  Default value: **no**. If you set this parameter to **yes**, the NotifyAuthKey parameter is required.
        self.notify_req_auth = notify_req_auth
        # The callback URL. Specify a valid URL that is up to 500 characters in length.
        self.notify_url = notify_url
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.notify_auth_key is not None:
            result['NotifyAuthKey'] = self.notify_auth_key
        if self.notify_req_auth is not None:
            result['NotifyReqAuth'] = self.notify_req_auth
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('NotifyAuthKey') is not None:
            self.notify_auth_key = m.get('NotifyAuthKey')
        if m.get('NotifyReqAuth') is not None:
            self.notify_req_auth = m.get('NotifyReqAuth')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateLiveSnapshotNotifyConfigResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveSnapshotNotifyConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveSnapshotNotifyConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveSnapshotNotifyConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveStreamMonitorRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        callback_url: str = None,
        ding_talk_web_hook_url: str = None,
        domain: str = None,
        input_list: str = None,
        monitor_config: str = None,
        monitor_id: str = None,
        monitor_name: str = None,
        output_template: str = None,
        owner_id: int = None,
        region_id: str = None,
        stream: str = None,
    ):
        # The name of the application to which the output stream of the monitoring session belongs. You can specify a name. If you do not specify a name, the system uses **monitor** as the name of the application.
        self.app = app
        # The callback URL. Supported formats include HTTP and HTTPS.
        self.callback_url = callback_url
        # The URL of the DingTalk chatbot. Specify a DingTalk chatbot that you have configured, and you can receive live monitoring alerts from the chatbot. For more information, see [Configure a custom chatbot](https://open.dingtalk.com/document/robots/custom-robot-access).
        # 
        # >  Specify "Alert" as the custom keyword of the DingTalk chatbot. Otherwise, you cannot receive messages.
        self.ding_talk_web_hook_url = ding_talk_web_hook_url
        # The domain name.
        self.domain = domain
        # The list of input streams to monitor. For more information, see the following **InputConfig** table.
        # 
        # This parameter is required.
        self.input_list = input_list
        # The monitoring alert thresholds. The value is a JSON string. For more information, see the following MonitorConfig table.
        self.monitor_config = monitor_config
        # The ID of the monitoring session.
        # 
        # >  You can obtain the monitoring session ID from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        # 
        # This parameter is required.
        self.monitor_id = monitor_id
        # The name of the monitoring session.
        self.monitor_name = monitor_name
        # The output template of the monitoring session. Valid values:
        # 
        # *   **lp_ld**: low definition
        # *   **lp_sd**: standard definition
        # *   **lp_hd**: high definition
        # *   **lp_ud**: ultra-high definition
        self.output_template = output_template
        self.owner_id = owner_id
        self.region_id = region_id
        # The name of the output stream of the monitoring session.
        self.stream = stream

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.ding_talk_web_hook_url is not None:
            result['DingTalkWebHookUrl'] = self.ding_talk_web_hook_url
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.input_list is not None:
            result['InputList'] = self.input_list
        if self.monitor_config is not None:
            result['MonitorConfig'] = self.monitor_config
        if self.monitor_id is not None:
            result['MonitorId'] = self.monitor_id
        if self.monitor_name is not None:
            result['MonitorName'] = self.monitor_name
        if self.output_template is not None:
            result['OutputTemplate'] = self.output_template
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stream is not None:
            result['Stream'] = self.stream
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('DingTalkWebHookUrl') is not None:
            self.ding_talk_web_hook_url = m.get('DingTalkWebHookUrl')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('InputList') is not None:
            self.input_list = m.get('InputList')
        if m.get('MonitorConfig') is not None:
            self.monitor_config = m.get('MonitorConfig')
        if m.get('MonitorId') is not None:
            self.monitor_id = m.get('MonitorId')
        if m.get('MonitorName') is not None:
            self.monitor_name = m.get('MonitorName')
        if m.get('OutputTemplate') is not None:
            self.output_template = m.get('OutputTemplate')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Stream') is not None:
            self.stream = m.get('Stream')
        return self


class UpdateLiveStreamMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveStreamMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveStreamMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveStreamMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        domain: str = None,
        encrypt_parameters: str = None,
        lazy: str = None,
        owner_id: int = None,
        region_id: str = None,
        template: str = None,
    ):
        # The name of the application to which the stream belongs, and it cannot be modified.
        # 
        # This parameter is required.
        self.app = app
        # Streamer domain name, not modifiable.
        # 
        # This parameter is required.
        self.domain = domain
        # The encryption configuration. The value is a JSON string. The following fields are included in the syntax:
        # 
        # *   EncryptType: the type of the encryption. Set the value to **aliyun**.
        # *   KmsKeyID: the ID of the CMK in KMS.
        # *   KmsKeyExpireInterval: the validity period of the CMK. Valid values: **60 to 3600**. Unit: seconds.
        self.encrypt_parameters = encrypt_parameters
        # Specifies whether to enable triggered transcoding. Valid values:
        # 
        # *   **yes**: enables triggered transcoding.
        # *   **no**: disables triggered transcoding.
        self.lazy = lazy
        self.owner_id = owner_id
        self.region_id = region_id
        # Transcoding template, not modifiable.
        # 
        # This parameter is required.
        self.template = template

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.encrypt_parameters is not None:
            result['EncryptParameters'] = self.encrypt_parameters
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EncryptParameters') is not None:
            self.encrypt_parameters = m.get('EncryptParameters')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        return self


class UpdateLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveStreamWatermarkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        height: int = None,
        name: str = None,
        offset_corner: str = None,
        owner_id: int = None,
        picture_url: str = None,
        ref_height: int = None,
        ref_width: int = None,
        region_id: str = None,
        template_id: str = None,
        transparency: int = None,
        xoffset: float = None,
        yoffset: float = None,
    ):
        # The description of the watermark.
        self.description = description
        # The height of the watermark. Unit: pixel. The height of the watermark is scaled in proportion to the height of the background video.
        self.height = height
        # The name of the watermark.
        self.name = name
        # The position of the watermark. Valid values:
        # 
        # *   TopLeft: the upper-left corner.
        # *   TopRight: the upper-right corner.
        # *   BottomLeft: the lower-left corner.
        # *   BottomRight: the lower-right corner.
        self.offset_corner = offset_corner
        self.owner_id = owner_id
        # The URL of the watermark image.
        self.picture_url = picture_url
        # The height of the background video. Unit: pixel.
        self.ref_height = ref_height
        # The width of the background video. Unit: pixel.
        self.ref_width = ref_width
        self.region_id = region_id
        # The ID of the watermark template.
        # 
        # >  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.
        self.transparency = transparency
        # The offset of the watermark along the x-axis. Unit: pixel.
        # 
        # >  In this case, the value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.
        self.xoffset = xoffset
        # The offset of the watermark along the y-axis. Unit: pixel.
        # 
        # >  In this case, the value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.
        self.yoffset = yoffset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.height is not None:
            result['Height'] = self.height
        if self.name is not None:
            result['Name'] = self.name
        if self.offset_corner is not None:
            result['OffsetCorner'] = self.offset_corner
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.picture_url is not None:
            result['PictureUrl'] = self.picture_url
        if self.ref_height is not None:
            result['RefHeight'] = self.ref_height
        if self.ref_width is not None:
            result['RefWidth'] = self.ref_width
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.transparency is not None:
            result['Transparency'] = self.transparency
        if self.xoffset is not None:
            result['XOffset'] = self.xoffset
        if self.yoffset is not None:
            result['YOffset'] = self.yoffset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OffsetCorner') is not None:
            self.offset_corner = m.get('OffsetCorner')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PictureUrl') is not None:
            self.picture_url = m.get('PictureUrl')
        if m.get('RefHeight') is not None:
            self.ref_height = m.get('RefHeight')
        if m.get('RefWidth') is not None:
            self.ref_width = m.get('RefWidth')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Transparency') is not None:
            self.transparency = m.get('Transparency')
        if m.get('XOffset') is not None:
            self.xoffset = m.get('XOffset')
        if m.get('YOffset') is not None:
            self.yoffset = m.get('YOffset')
        return self


class UpdateLiveStreamWatermarkResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveStreamWatermarkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveStreamWatermarkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveStreamWatermarkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveStreamWatermarkRuleRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        owner_id: int = None,
        region_id: str = None,
        rule_id: str = None,
        template_id: str = None,
    ):
        # The description of the custom rule.
        self.description = description
        # The name of the custom rule.
        self.name = name
        self.owner_id = owner_id
        self.region_id = region_id
        # The ID of the watermark rule.
        # 
        # >  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.
        # 
        # This parameter is required.
        self.rule_id = rule_id
        # The ID of the watermark template.
        # 
        # >  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/2848096.html) operation.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveStreamWatermarkRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveStreamWatermarkRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateLiveStreamWatermarkRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveStreamWatermarkRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMessageAppRequest(TeaModel):
    def __init__(
        self,
        app_config: Dict[str, str] = None,
        app_id: str = None,
        app_name: str = None,
        extension: Dict[str, str] = None,
    ):
        # The configurations of the application.
        self.app_config = app_config
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The extended field.
        self.extension = extension

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config is not None:
            result['AppConfig'] = self.app_config
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.extension is not None:
            result['Extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config = m.get('AppConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        return self


class UpdateMessageAppShrinkRequest(TeaModel):
    def __init__(
        self,
        app_config_shrink: str = None,
        app_id: str = None,
        app_name: str = None,
        extension_shrink: str = None,
    ):
        # The configurations of the application.
        self.app_config_shrink = app_config_shrink
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the interactive messaging application.
        self.app_name = app_name
        # The extended field.
        self.extension_shrink = extension_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_config_shrink is not None:
            result['AppConfig'] = self.app_config_shrink
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.extension_shrink is not None:
            result['Extension'] = self.extension_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppConfig') is not None:
            self.app_config_shrink = m.get('AppConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Extension') is not None:
            self.extension_shrink = m.get('Extension')
        return self


class UpdateMessageAppResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the update is successful. Valid values:
        # 
        # *   true: The update is successful.
        # *   false: The update failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMessageAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: UpdateMessageAppResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = UpdateMessageAppResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class UpdateMessageAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMessageAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMessageAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMessageGroupRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        extension: Dict[str, str] = None,
        group_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The extended field.
        self.extension = extension
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.extension is not None:
            result['Extension'] = self.extension
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Extension') is not None:
            self.extension = m.get('Extension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class UpdateMessageGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        extension_shrink: str = None,
        group_id: str = None,
    ):
        # The ID of the interactive messaging application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The extended field.
        self.extension_shrink = extension_shrink
        # The ID of the message group.
        # 
        # This parameter is required.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.extension_shrink is not None:
            result['Extension'] = self.extension_shrink
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Extension') is not None:
            self.extension_shrink = m.get('Extension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class UpdateMessageGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        # Indicates whether the update was successful. Valid values:
        # 
        # *   true: The update was successful.
        # *   false: The update failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMessageGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: UpdateMessageGroupResponseBodyResult = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = UpdateMessageGroupResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        return self


class UpdateMessageGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMessageGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMessageGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMixStreamRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        input_stream_list: str = None,
        layout_id: str = None,
        mix_stream_id: str = None,
        owner_id: int = None,
        region_id: str = None,
    ):
        # The main streaming domain.
        # 
        # >  Only domain names that reside in the China (Shanghai) and China (Beijing) regions are supported.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        # The input streams, in a JSON array.
        # 
        # For more information, see **InputStreamConfig**.
        # 
        # This parameter is required.
        self.input_stream_list = input_stream_list
        # The ID of the layout. Valid values:
        # 
        # *   **MixStreamLayout-1-1**\
        # *   **MixStreamLayout-2-1**\
        # *   **MixStreamLayout-2-2**\
        # *   **MixStreamLayout-2-3**\
        # *   **MixStreamLayout-3-1**\
        # *   **MixStreamLayout-3-2**\
        # *   **MixStreamLayout-4-1**\
        # *   **USERDEFINED**: If you do not use a preset layout, set this parameter to **USERDEFINED**.
        # 
        # >  For more information, see [Preset layouts for stream mixing](https://help.aliyun.com/document_detail/199361.html).
        self.layout_id = layout_id
        # The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.
        # 
        # This parameter is required.
        self.mix_stream_id = mix_stream_id
        self.owner_id = owner_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.input_stream_list is not None:
            result['InputStreamList'] = self.input_stream_list
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('InputStreamList') is not None:
            self.input_stream_list = m.get('InputStreamList')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateMixStreamResponseBody(TeaModel):
    def __init__(
        self,
        mix_stream_id: str = None,
        request_id: str = None,
    ):
        # The ID of the stream mixing task. You can specify this parameter in a request to delete the stream mixing task or query stream mixing tasks.
        self.mix_stream_id = mix_stream_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_stream_id is not None:
            result['MixStreamId'] = self.mix_stream_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixStreamId') is not None:
            self.mix_stream_id = m.get('MixStreamId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMixStreamResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMixStreamResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMixStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground(TeaModel):
    def __init__(
        self,
        render_mode: int = None,
        url: str = None,
    ):
        self.render_mode = render_mode
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground(TeaModel):
    def __init__(
        self,
        render_mode: int = None,
        url: str = None,
    ):
        self.render_mode = render_mode
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_mode is not None:
            result['RenderMode'] = self.render_mode
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderMode') is not None:
            self.render_mode = m.get('RenderMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes(TeaModel):
    def __init__(
        self,
        height: str = None,
        source_type: int = None,
        sub_background: UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground = None,
        user_id: str = None,
        width: str = None,
        x: str = None,
        y: str = None,
        zorder: int = None,
    ):
        self.height = height
        self.source_type = source_type
        self.sub_background = sub_background
        self.user_id = user_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        if self.sub_background:
            self.sub_background.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.sub_background is not None:
            result['SubBackground'] = self.sub_background.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SubBackground') is not None:
            temp_model = UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground()
            self.sub_background = temp_model.from_map(m['SubBackground'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRtcCloudRecordingRequestMixLayoutParams(TeaModel):
    def __init__(
        self,
        mix_background: UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground = None,
        user_panes: List[UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes] = None,
    ):
        self.mix_background = mix_background
        self.user_panes = user_panes

    def validate(self):
        if self.mix_background:
            self.mix_background.validate()
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_background is not None:
            result['MixBackground'] = self.mix_background.to_map()
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixBackground') is not None:
            temp_model = UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground()
            self.mix_background = temp_model.from_map(m['MixBackground'])
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList(TeaModel):
    def __init__(
        self,
        source_type: int = None,
        stream_type: int = None,
        user_id: str = None,
    ):
        self.source_type = source_type
        self.stream_type = stream_type
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateRtcCloudRecordingRequestSubscribeParams(TeaModel):
    def __init__(
        self,
        subscribe_user_id_list: List[UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList] = None,
    ):
        # This parameter is required.
        self.subscribe_user_id_list = subscribe_user_id_list

    def validate(self):
        if self.subscribe_user_id_list:
            for k in self.subscribe_user_id_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SubscribeUserIdList'] = []
        if self.subscribe_user_id_list is not None:
            for k in self.subscribe_user_id_list:
                result['SubscribeUserIdList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.subscribe_user_id_list = []
        if m.get('SubscribeUserIdList') is not None:
            for k in m.get('SubscribeUserIdList'):
                temp_model = UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList()
                self.subscribe_user_id_list.append(temp_model.from_map(k))
        return self


class UpdateRtcCloudRecordingRequest(TeaModel):
    def __init__(
        self,
        mix_layout_params: UpdateRtcCloudRecordingRequestMixLayoutParams = None,
        subscribe_params: UpdateRtcCloudRecordingRequestSubscribeParams = None,
        task_id: str = None,
    ):
        self.mix_layout_params = mix_layout_params
        # This parameter is required.
        self.subscribe_params = subscribe_params
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        if self.mix_layout_params:
            self.mix_layout_params.validate()
        if self.subscribe_params:
            self.subscribe_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_layout_params is not None:
            result['MixLayoutParams'] = self.mix_layout_params.to_map()
        if self.subscribe_params is not None:
            result['SubscribeParams'] = self.subscribe_params.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixLayoutParams') is not None:
            temp_model = UpdateRtcCloudRecordingRequestMixLayoutParams()
            self.mix_layout_params = temp_model.from_map(m['MixLayoutParams'])
        if m.get('SubscribeParams') is not None:
            temp_model = UpdateRtcCloudRecordingRequestSubscribeParams()
            self.subscribe_params = temp_model.from_map(m['SubscribeParams'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateRtcCloudRecordingShrinkRequest(TeaModel):
    def __init__(
        self,
        mix_layout_params_shrink: str = None,
        subscribe_params_shrink: str = None,
        task_id: str = None,
    ):
        self.mix_layout_params_shrink = mix_layout_params_shrink
        # This parameter is required.
        self.subscribe_params_shrink = subscribe_params_shrink
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mix_layout_params_shrink is not None:
            result['MixLayoutParams'] = self.mix_layout_params_shrink
        if self.subscribe_params_shrink is not None:
            result['SubscribeParams'] = self.subscribe_params_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MixLayoutParams') is not None:
            self.mix_layout_params_shrink = m.get('MixLayoutParams')
        if m.get('SubscribeParams') is not None:
            self.subscribe_params_shrink = m.get('SubscribeParams')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateRtcCloudRecordingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateRtcCloudRecordingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRtcCloudRecordingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRtcCloudRecordingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRtcMPUEventSubRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_ids: str = None,
    ):
        # The ID of the application.
        # 
        # >  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The callback URL.
        # 
        # >  You can use headers such as HTTP and HTTPS in callback URLs. The URL can be up to 2,083 characters and contain letters, digits, and the following special characters: - _ ? % = # . / +\
        self.callback_url = callback_url
        # The ID of the channel to which you want to send mixed-stream relay event callbacks. Separate multiple channel IDs with commas (,).
        # 
        # > 
        # 
        # *   If you leave this parameter empty, you are subscribed to all mixed-stream relay events submitted in the application.
        # 
        # *   You cannot specify duplicate channel IDs. You can specify up to 20 channel IDs in each call.
        # *   The ID can be up to 64 characters in length and contain letters, digits, underscores (_), and hyphens (-).
        self.channel_ids = channel_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        return self


class UpdateRtcMPUEventSubResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRtcMPUEventSubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRtcMPUEventSubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRtcMPUEventSubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRtsLiveStreamTranscodeRequest(TeaModel):
    def __init__(
        self,
        app: str = None,
        audio_bitrate: int = None,
        audio_channel_num: int = None,
        audio_codec: str = None,
        audio_profile: str = None,
        audio_rate: int = None,
        delete_bframes: bool = None,
        domain: str = None,
        fps: int = None,
        gop: str = None,
        height: int = None,
        lazy: str = None,
        opus: bool = None,
        owner_id: int = None,
        profile: int = None,
        region_id: str = None,
        template: str = None,
        template_type: str = None,
        video_bitrate: int = None,
        width: int = None,
    ):
        # The name of the application to which the live stream belongs, which cannot be modified.
        # 
        # This parameter is required.
        self.app = app
        # The bitrate of the output audio. Unit: Kbit/s. Valid values: 1 to 1000.
        # 
        # >  This parameter is required if you set the TemplateType parameter to audio.
        self.audio_bitrate = audio_bitrate
        # The number of sound channels. Valid values:
        # 
        # *   **1**: mono
        # *   **2**: stereo
        self.audio_channel_num = audio_channel_num
        # The audio encoder. Valid values:
        # 
        # *   aac
        # *   mp3
        # 
        # >  To use the Opus encoder, you need only to set the Opus parameter to true.
        self.audio_codec = audio_codec
        # The audio codec profile. Valid values:
        # 
        # *   aac_low
        # *   aac_he
        # *   aac_he_v2
        # *   aac_ld
        self.audio_profile = audio_profile
        # The audio sampling rate. Valid values: 22050, 32000, 44100, 48000, and 96000. 44100 is commonly used. Unit: Hz.
        # 
        # >  If the value of the AudioProfile parameter is aac_ld, the audio sampling rate cannot exceed 44,100.
        self.audio_rate = audio_rate
        # Specifies whether to remove B frames during transcoding. Valid values:
        # 
        # *   true: Remove B frames.
        # *   false (default): Retain B frames.
        # 
        # > 
        # 
        # *   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.
        # 
        # *   If this parameter is not specified, the default value false is used.
        self.delete_bframes = delete_bframes
        # The main streaming domain, which cannot be modified.
        # 
        # This parameter is required.
        self.domain = domain
        # The frame rate of the output video. Unit: frames per second (FPS). Valid values: 1 to 60.
        # 
        # >  This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.
        self.fps = fps
        # The group of pictures (GOP) of the output video. This parameter is used to specify the keyframe interval. Unit: seconds. Valid values: 1 to 3.
        self.gop = gop
        # The height of the output video. Unit: pixel.
        # 
        # The value must comply with the following rules:
        # 
        # *   Height  100: The height of the video is at least 100 pixels.
        # *   max(Height,Width)  2560: The larger of the width and height of the video cannot exceed 2,560 pixels.
        # *   min(Height,Width)  1440: The smaller of the width and height of the video cannot exceed 1,440 pixels. For example, a resolution of 1560  1560 pixels is invalid.
        # 
        # > 
        # 
        # *   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.
        # 
        # *   If the TemplateType parameter is set to h264-origin, the highest resolution supported is 4K.
        self.height = height
        # Specifies whether to enable triggered transcoding. Valid values:
        # 
        # *   **yes**: enables triggered transcoding.
        # *   **no**: disables triggered transcoding.
        self.lazy = lazy
        # Specifies whether to transcode streams to the Opus format to be compatible with native WebRTC. Valid values:
        # 
        # *   true: Transcode streams to the Opus format.
        # *   false: Do not transcode streams to the Opus format.
        # 
        # >  If this parameter is not specified, the default value false is used.
        self.opus = opus
        self.owner_id = owner_id
        # The video encoding profile. The profile defines a set of parameters that are used to encode a video. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values:
        # 
        # *   **1**: baseline. This value is suitable for mobile devices.
        # *   **2**: main. This value is suitable for standard-definition devices.
        # *   **3**: high. This value is suitable for high-definition devices.
        self.profile = profile
        self.region_id = region_id
        # The ID of the custom transcoding template, which cannot be modified.
        # 
        # This parameter is required.
        self.template = template
        # The type of the custom transcoding template, which cannot be modified.
        # 
        # This parameter is required.
        self.template_type = template_type
        # The bitrate of the output video. Unit: Kbit/s. Valid values: 1 to 6000.
        # 
        # > 
        # 
        # *   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.
        # 
        # *   The bitrate of the output video is as close to the value that you specify as possible, but not the same as the value, especially when the value is excessively large or small.
        self.video_bitrate = video_bitrate
        # The width of the output video. Unit: pixel.
        # 
        # The value must comply with the following rules:
        # 
        # *   Width  100: The width of the video is at least 100 pixels.
        # *   max(Height,Width)  2560: The larger of the width and height of the video cannot exceed 2,560 pixels.
        # *   min(Height,Width)  1440: The smaller of the width and height of the video cannot exceed 1,440 pixels. For example, a resolution of 1560  1560 pixels is invalid.
        # 
        # > 
        # 
        # *   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.
        # 
        # *   If the TemplateType parameter is set to h264-origin, the highest resolution supported is 4K.
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['App'] = self.app
        if self.audio_bitrate is not None:
            result['AudioBitrate'] = self.audio_bitrate
        if self.audio_channel_num is not None:
            result['AudioChannelNum'] = self.audio_channel_num
        if self.audio_codec is not None:
            result['AudioCodec'] = self.audio_codec
        if self.audio_profile is not None:
            result['AudioProfile'] = self.audio_profile
        if self.audio_rate is not None:
            result['AudioRate'] = self.audio_rate
        if self.delete_bframes is not None:
            result['DeleteBframes'] = self.delete_bframes
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.fps is not None:
            result['FPS'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.lazy is not None:
            result['Lazy'] = self.lazy
        if self.opus is not None:
            result['Opus'] = self.opus
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template is not None:
            result['Template'] = self.template
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.video_bitrate is not None:
            result['VideoBitrate'] = self.video_bitrate
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('App') is not None:
            self.app = m.get('App')
        if m.get('AudioBitrate') is not None:
            self.audio_bitrate = m.get('AudioBitrate')
        if m.get('AudioChannelNum') is not None:
            self.audio_channel_num = m.get('AudioChannelNum')
        if m.get('AudioCodec') is not None:
            self.audio_codec = m.get('AudioCodec')
        if m.get('AudioProfile') is not None:
            self.audio_profile = m.get('AudioProfile')
        if m.get('AudioRate') is not None:
            self.audio_rate = m.get('AudioRate')
        if m.get('DeleteBframes') is not None:
            self.delete_bframes = m.get('DeleteBframes')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('FPS') is not None:
            self.fps = m.get('FPS')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Lazy') is not None:
            self.lazy = m.get('Lazy')
        if m.get('Opus') is not None:
            self.opus = m.get('Opus')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Template') is not None:
            self.template = m.get('Template')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('VideoBitrate') is not None:
            self.video_bitrate = m.get('VideoBitrate')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateRtsLiveStreamTranscodeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRtsLiveStreamTranscodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRtsLiveStreamTranscodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRtsLiveStreamTranscodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyLiveDomainOwnerRequest(TeaModel):
    def __init__(
        self,
        domain_name: str = None,
        owner_id: int = None,
        region_id: str = None,
        verify_type: str = None,
    ):
        # The domain name for which you want to verify the ownership. You can specify only one domain name in each request.
        # 
        # This parameter is required.
        self.domain_name = domain_name
        self.owner_id = owner_id
        self.region_id = region_id
        # The verification method. Valid values:
        # 
        # *   dnsCheck: DNS record verification
        # *   fileCheck: file verification
        # 
        # This parameter is required.
        self.verify_type = verify_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.verify_type is not None:
            result['VerifyType'] = self.verify_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VerifyType') is not None:
            self.verify_type = m.get('VerifyType')
        return self


class VerifyLiveDomainOwnerResponseBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        request_id: str = None,
    ):
        # The verification information.
        self.content = content
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class VerifyLiveDomainOwnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: VerifyLiveDomainOwnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyLiveDomainOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


