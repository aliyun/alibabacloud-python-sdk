# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_live20161101 import models as live_20161101_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._endpoint_rule = 'regional'
        self._endpoint_map = {
            'cn-qingdao': 'live.aliyuncs.com',
            'cn-beijing': 'live.aliyuncs.com',
            'cn-hangzhou': 'live.aliyuncs.com',
            'cn-shanghai': 'live.aliyuncs.com',
            'cn-shenzhen': 'live.aliyuncs.com',
            'ap-southeast-1': 'live.aliyuncs.com',
            'ap-southeast-5': 'live.aliyuncs.com',
            'ap-northeast-1': 'live.aliyuncs.com',
            'eu-central-1': 'live.aliyuncs.com',
            'ap-south-1': 'live.aliyuncs.com',
            'ap-northeast-2-pop': 'live.aliyuncs.com',
            'ap-southeast-2': 'live.aliyuncs.com',
            'ap-southeast-3': 'live.aliyuncs.com',
            'cn-beijing-finance-1': 'live.aliyuncs.com',
            'cn-beijing-finance-pop': 'live.aliyuncs.com',
            'cn-beijing-gov-1': 'live.aliyuncs.com',
            'cn-beijing-nu16-b01': 'live.aliyuncs.com',
            'cn-chengdu': 'live.aliyuncs.com',
            'cn-edge-1': 'live.aliyuncs.com',
            'cn-fujian': 'live.aliyuncs.com',
            'cn-haidian-cm12-c01': 'live.aliyuncs.com',
            'cn-hangzhou-bj-b01': 'live.aliyuncs.com',
            'cn-hangzhou-finance': 'live.aliyuncs.com',
            'cn-hangzhou-internal-prod-1': 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-1': 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-2': 'live.aliyuncs.com',
            'cn-hangzhou-internal-test-3': 'live.aliyuncs.com',
            'cn-hangzhou-test-306': 'live.aliyuncs.com',
            'cn-hongkong': 'live.aliyuncs.com',
            'cn-hongkong-finance-pop': 'live.aliyuncs.com',
            'cn-huhehaote': 'live.aliyuncs.com',
            'cn-huhehaote-nebula-1': 'live.aliyuncs.com',
            'cn-north-2-gov-1': 'live.aliyuncs.com',
            'cn-qingdao-nebula': 'live.aliyuncs.com',
            'cn-shanghai-et15-b01': 'live.aliyuncs.com',
            'cn-shanghai-et2-b01': 'live.aliyuncs.com',
            'cn-shanghai-finance-1': 'live.aliyuncs.com',
            'cn-shanghai-inner': 'live.aliyuncs.com',
            'cn-shanghai-internal-test-1': 'live.aliyuncs.com',
            'cn-shenzhen-finance-1': 'live.aliyuncs.com',
            'cn-shenzhen-inner': 'live.aliyuncs.com',
            'cn-shenzhen-st4-d01': 'live.aliyuncs.com',
            'cn-shenzhen-su18-b01': 'live.aliyuncs.com',
            'cn-wuhan': 'live.aliyuncs.com',
            'cn-wulanchabu': 'live.aliyuncs.com',
            'cn-yushanfang': 'live.aliyuncs.com',
            'cn-zhangbei': 'live.aliyuncs.com',
            'cn-zhangbei-na61-b01': 'live.aliyuncs.com',
            'cn-zhangjiakou': 'live.aliyuncs.com',
            'cn-zhangjiakou-na62-a01': 'live.aliyuncs.com',
            'cn-zhengzhou-nebula-1': 'live.aliyuncs.com',
            'eu-west-1': 'live.aliyuncs.com',
            'eu-west-1-oxs': 'live.aliyuncs.com',
            'me-east-1': 'live.aliyuncs.com',
            'rus-west-1-pop': 'live.aliyuncs.com',
            'us-east-1': 'live.aliyuncs.com',
            'us-west-1': 'live.aliyuncs.com'
        }
        self.check_config(config)
        self._endpoint = self.get_endpoint('live', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def add_caster_component_with_options(
        self,
        request: live_20161101_models.AddCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterComponentResponse:
        """
        @summary Adds a component to a production studio.
        
        @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caption_layer_content):
            query['CaptionLayerContent'] = request.caption_layer_content
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_layer):
            query['ComponentLayer'] = request.component_layer
        if not UtilClient.is_unset(request.component_name):
            query['ComponentName'] = request.component_name
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.effect):
            query['Effect'] = request.effect
        if not UtilClient.is_unset(request.html_layer_content):
            query['HtmlLayerContent'] = request.html_layer_content
        if not UtilClient.is_unset(request.image_layer_content):
            query['ImageLayerContent'] = request.image_layer_content
        if not UtilClient.is_unset(request.layer_order):
            query['LayerOrder'] = request.layer_order
        if not UtilClient.is_unset(request.location_id):
            query['LocationId'] = request.location_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.text_layer_content):
            query['TextLayerContent'] = request.text_layer_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterComponentResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_component_with_options_async(
        self,
        request: live_20161101_models.AddCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterComponentResponse:
        """
        @summary Adds a component to a production studio.
        
        @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caption_layer_content):
            query['CaptionLayerContent'] = request.caption_layer_content
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_layer):
            query['ComponentLayer'] = request.component_layer
        if not UtilClient.is_unset(request.component_name):
            query['ComponentName'] = request.component_name
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.effect):
            query['Effect'] = request.effect
        if not UtilClient.is_unset(request.html_layer_content):
            query['HtmlLayerContent'] = request.html_layer_content
        if not UtilClient.is_unset(request.image_layer_content):
            query['ImageLayerContent'] = request.image_layer_content
        if not UtilClient.is_unset(request.layer_order):
            query['LayerOrder'] = request.layer_order
        if not UtilClient.is_unset(request.location_id):
            query['LocationId'] = request.location_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.text_layer_content):
            query['TextLayerContent'] = request.text_layer_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterComponentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_component(
        self,
        request: live_20161101_models.AddCasterComponentRequest,
    ) -> live_20161101_models.AddCasterComponentResponse:
        """
        @summary Adds a component to a production studio.
        
        @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterComponentRequest
        @return: AddCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_component_with_options(request, runtime)

    async def add_caster_component_async(
        self,
        request: live_20161101_models.AddCasterComponentRequest,
    ) -> live_20161101_models.AddCasterComponentResponse:
        """
        @summary Adds a component to a production studio.
        
        @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterComponentRequest
        @return: AddCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_component_with_options_async(request, runtime)

    def add_caster_episode_with_options(
        self,
        request: live_20161101_models.AddCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeResponse:
        """
        @summary Adds an episode to a production studio.
        
        @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
        If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        >  You can find the ID of the production studio in the Instance ID/Name column.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_name):
            query['EpisodeName'] = request.episode_name
        if not UtilClient.is_unset(request.episode_type):
            query['EpisodeType'] = request.episode_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.switch_type):
            query['SwitchType'] = request.switch_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_episode_with_options_async(
        self,
        request: live_20161101_models.AddCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeResponse:
        """
        @summary Adds an episode to a production studio.
        
        @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
        If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        >  You can find the ID of the production studio in the Instance ID/Name column.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_name):
            query['EpisodeName'] = request.episode_name
        if not UtilClient.is_unset(request.episode_type):
            query['EpisodeType'] = request.episode_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.switch_type):
            query['SwitchType'] = request.switch_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_episode(
        self,
        request: live_20161101_models.AddCasterEpisodeRequest,
    ) -> live_20161101_models.AddCasterEpisodeResponse:
        """
        @summary Adds an episode to a production studio.
        
        @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
        If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        >  You can find the ID of the production studio in the Instance ID/Name column.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeRequest
        @return: AddCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_episode_with_options(request, runtime)

    async def add_caster_episode_async(
        self,
        request: live_20161101_models.AddCasterEpisodeRequest,
    ) -> live_20161101_models.AddCasterEpisodeResponse:
        """
        @summary Adds an episode to a production studio.
        
        @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
        If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
        If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
        >  You can find the ID of the production studio in the Instance ID/Name column.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeRequest
        @return: AddCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_episode_with_options_async(request, runtime)

    def add_caster_episode_group_with_options(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeGroupResponse:
        """
        @summary Adds an episode list to a production studio.
        
        @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.item):
            query['Item'] = request.item
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.side_output_url):
            query['SideOutputUrl'] = request.side_output_url
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisodeGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_episode_group_with_options_async(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeGroupResponse:
        """
        @summary Adds an episode list to a production studio.
        
        @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.item):
            query['Item'] = request.item
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.side_output_url):
            query['SideOutputUrl'] = request.side_output_url
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisodeGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_episode_group(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupRequest,
    ) -> live_20161101_models.AddCasterEpisodeGroupResponse:
        """
        @summary Adds an episode list to a production studio.
        
        @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupRequest
        @return: AddCasterEpisodeGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_episode_group_with_options(request, runtime)

    async def add_caster_episode_group_async(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupRequest,
    ) -> live_20161101_models.AddCasterEpisodeGroupResponse:
        """
        @summary Adds an episode list to a production studio.
        
        @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupRequest
        @return: AddCasterEpisodeGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_episode_group_with_options_async(request, runtime)

    def add_caster_episode_group_content_with_options(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeGroupContentResponse:
        """
        @summary Adds information about an episode list in a production studio.
        
        @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeGroupContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisodeGroupContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeGroupContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_episode_group_content_with_options_async(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterEpisodeGroupContentResponse:
        """
        @summary Adds information about an episode list in a production studio.
        
        @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterEpisodeGroupContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterEpisodeGroupContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterEpisodeGroupContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_episode_group_content(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupContentRequest,
    ) -> live_20161101_models.AddCasterEpisodeGroupContentResponse:
        """
        @summary Adds information about an episode list in a production studio.
        
        @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupContentRequest
        @return: AddCasterEpisodeGroupContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_episode_group_content_with_options(request, runtime)

    async def add_caster_episode_group_content_async(
        self,
        request: live_20161101_models.AddCasterEpisodeGroupContentRequest,
    ) -> live_20161101_models.AddCasterEpisodeGroupContentResponse:
        """
        @summary Adds information about an episode list in a production studio.
        
        @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterEpisodeGroupContentRequest
        @return: AddCasterEpisodeGroupContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_episode_group_content_with_options_async(request, runtime)

    def add_caster_layout_with_options(
        self,
        request: live_20161101_models.AddCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterLayoutResponse:
        """
        @summary Adds a layout for a production studio.
        
        @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
        ## QPS Limitation
        The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.blend_list):
            query['BlendList'] = request.blend_list
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.video_layer):
            query['VideoLayer'] = request.video_layer
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_layout_with_options_async(
        self,
        request: live_20161101_models.AddCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterLayoutResponse:
        """
        @summary Adds a layout for a production studio.
        
        @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
        ## QPS Limitation
        The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.blend_list):
            query['BlendList'] = request.blend_list
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.video_layer):
            query['VideoLayer'] = request.video_layer
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_layout(
        self,
        request: live_20161101_models.AddCasterLayoutRequest,
    ) -> live_20161101_models.AddCasterLayoutResponse:
        """
        @summary Adds a layout for a production studio.
        
        @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
        ## QPS Limitation
        The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterLayoutRequest
        @return: AddCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_layout_with_options(request, runtime)

    async def add_caster_layout_async(
        self,
        request: live_20161101_models.AddCasterLayoutRequest,
    ) -> live_20161101_models.AddCasterLayoutResponse:
        """
        @summary Adds a layout for a production studio.
        
        @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
        ## QPS Limitation
        The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterLayoutRequest
        @return: AddCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_layout_with_options_async(request, runtime)

    def add_caster_program_with_options(
        self,
        request: live_20161101_models.AddCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterProgramResponse:
        """
        @summary Adds the episode list for carousel playback in a production studio.
        
        @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode):
            query['Episode'] = request.episode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterProgramResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_program_with_options_async(
        self,
        request: live_20161101_models.AddCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterProgramResponse:
        """
        @summary Adds the episode list for carousel playback in a production studio.
        
        @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode):
            query['Episode'] = request.episode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterProgramResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_program(
        self,
        request: live_20161101_models.AddCasterProgramRequest,
    ) -> live_20161101_models.AddCasterProgramResponse:
        """
        @summary Adds the episode list for carousel playback in a production studio.
        
        @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterProgramRequest
        @return: AddCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_program_with_options(request, runtime)

    async def add_caster_program_async(
        self,
        request: live_20161101_models.AddCasterProgramRequest,
    ) -> live_20161101_models.AddCasterProgramResponse:
        """
        @summary Adds the episode list for carousel playback in a production studio.
        
        @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddCasterProgramRequest
        @return: AddCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_program_with_options_async(request, runtime)

    def add_caster_video_resource_with_options(
        self,
        request: live_20161101_models.AddCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterVideoResourceResponse:
        """
        @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
        
        @description ##
        Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_offset):
            query['BeginOffset'] = request.begin_offset
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_offset):
            query['EndOffset'] = request.end_offset
        if not UtilClient.is_unset(request.fixed_delay_duration):
            query['FixedDelayDuration'] = request.fixed_delay_duration
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_url):
            query['ImageUrl'] = request.image_url
        if not UtilClient.is_unset(request.live_stream_url):
            query['LiveStreamUrl'] = request.live_stream_url
        if not UtilClient.is_unset(request.location_id):
            query['LocationId'] = request.location_id
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pts_callback_interval):
            query['PtsCallbackInterval'] = request.pts_callback_interval
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.resource_name):
            query['ResourceName'] = request.resource_name
        if not UtilClient.is_unset(request.vod_url):
            query['VodUrl'] = request.vod_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterVideoResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_caster_video_resource_with_options_async(
        self,
        request: live_20161101_models.AddCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCasterVideoResourceResponse:
        """
        @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
        
        @description ##
        Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_offset):
            query['BeginOffset'] = request.begin_offset
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_offset):
            query['EndOffset'] = request.end_offset
        if not UtilClient.is_unset(request.fixed_delay_duration):
            query['FixedDelayDuration'] = request.fixed_delay_duration
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_url):
            query['ImageUrl'] = request.image_url
        if not UtilClient.is_unset(request.live_stream_url):
            query['LiveStreamUrl'] = request.live_stream_url
        if not UtilClient.is_unset(request.location_id):
            query['LocationId'] = request.location_id
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pts_callback_interval):
            query['PtsCallbackInterval'] = request.pts_callback_interval
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.resource_name):
            query['ResourceName'] = request.resource_name
        if not UtilClient.is_unset(request.vod_url):
            query['VodUrl'] = request.vod_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCasterVideoResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_caster_video_resource(
        self,
        request: live_20161101_models.AddCasterVideoResourceRequest,
    ) -> live_20161101_models.AddCasterVideoResourceResponse:
        """
        @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
        
        @description ##
        Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterVideoResourceRequest
        @return: AddCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_caster_video_resource_with_options(request, runtime)

    async def add_caster_video_resource_async(
        self,
        request: live_20161101_models.AddCasterVideoResourceRequest,
    ) -> live_20161101_models.AddCasterVideoResourceResponse:
        """
        @summary Adds an input source to a production studio. The number of input sources is limited by the number of input channels of the production studio.
        
        @description ##
        Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCasterVideoResourceRequest
        @return: AddCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_caster_video_resource_with_options_async(request, runtime)

    def add_custom_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.AddCustomLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCustomLiveStreamTranscodeResponse:
        """
        @summary Adds a custom transcoding configuration for a streaming domain.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: H.264
        h264-nbhd: H.264 Narrowband HD
        h265: H.265
        h265-nbhd: H.265 Narrowband HD
        audio: audio-only
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCustomLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCustomLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.bitrate_with_source):
            query['BitrateWithSource'] = request.bitrate_with_source
        if not UtilClient.is_unset(request.de_interlaced):
            query['DeInterlaced'] = request.de_interlaced
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.ext_with_source):
            query['ExtWithSource'] = request.ext_with_source
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.fps_with_source):
            query['FpsWithSource'] = request.fps_with_source
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.kms_key_expire_interval):
            query['KmsKeyExpireInterval'] = request.kms_key_expire_interval
        if not UtilClient.is_unset(request.kms_key_id):
            query['KmsKeyID'] = request.kms_key_id
        if not UtilClient.is_unset(request.kms_uid):
            query['KmsUID'] = request.kms_uid
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.res_with_source):
            query['ResWithSource'] = request.res_with_source
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCustomLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCustomLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_custom_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.AddCustomLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddCustomLiveStreamTranscodeResponse:
        """
        @summary Adds a custom transcoding configuration for a streaming domain.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: H.264
        h264-nbhd: H.264 Narrowband HD
        h265: H.265
        h265-nbhd: H.265 Narrowband HD
        audio: audio-only
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCustomLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCustomLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.bitrate_with_source):
            query['BitrateWithSource'] = request.bitrate_with_source
        if not UtilClient.is_unset(request.de_interlaced):
            query['DeInterlaced'] = request.de_interlaced
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.ext_with_source):
            query['ExtWithSource'] = request.ext_with_source
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.fps_with_source):
            query['FpsWithSource'] = request.fps_with_source
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.kms_key_expire_interval):
            query['KmsKeyExpireInterval'] = request.kms_key_expire_interval
        if not UtilClient.is_unset(request.kms_key_id):
            query['KmsKeyID'] = request.kms_key_id
        if not UtilClient.is_unset(request.kms_uid):
            query['KmsUID'] = request.kms_uid
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.res_with_source):
            query['ResWithSource'] = request.res_with_source
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCustomLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddCustomLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_custom_live_stream_transcode(
        self,
        request: live_20161101_models.AddCustomLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddCustomLiveStreamTranscodeResponse:
        """
        @summary Adds a custom transcoding configuration for a streaming domain.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: H.264
        h264-nbhd: H.264 Narrowband HD
        h265: H.265
        h265-nbhd: H.265 Narrowband HD
        audio: audio-only
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCustomLiveStreamTranscodeRequest
        @return: AddCustomLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_custom_live_stream_transcode_with_options(request, runtime)

    async def add_custom_live_stream_transcode_async(
        self,
        request: live_20161101_models.AddCustomLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddCustomLiveStreamTranscodeResponse:
        """
        @summary Adds a custom transcoding configuration for a streaming domain.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: H.264
        h264-nbhd: H.264 Narrowband HD
        h265: H.265
        h265-nbhd: H.265 Narrowband HD
        audio: audio-only
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddCustomLiveStreamTranscodeRequest
        @return: AddCustomLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_custom_live_stream_transcode_with_options_async(request, runtime)

    def add_live_aiproduce_rules_with_options(
        self,
        request: live_20161101_models.AddLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAIProduceRulesResponse:
        """
        @summary Adds a subtitle rule.
        
        @description    After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
        You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
        RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
        FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
        M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.is_lazy):
            query['IsLazy'] = request.is_lazy
        if not UtilClient.is_unset(request.live_template):
            query['LiveTemplate'] = request.live_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.suffix):
            query['Suffix'] = request.suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAIProduceRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_aiproduce_rules_with_options_async(
        self,
        request: live_20161101_models.AddLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAIProduceRulesResponse:
        """
        @summary Adds a subtitle rule.
        
        @description    After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
        You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
        RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
        FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
        M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.is_lazy):
            query['IsLazy'] = request.is_lazy
        if not UtilClient.is_unset(request.live_template):
            query['LiveTemplate'] = request.live_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.suffix):
            query['Suffix'] = request.suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAIProduceRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_aiproduce_rules(
        self,
        request: live_20161101_models.AddLiveAIProduceRulesRequest,
    ) -> live_20161101_models.AddLiveAIProduceRulesResponse:
        """
        @summary Adds a subtitle rule.
        
        @description    After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
        You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
        RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
        FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
        M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAIProduceRulesRequest
        @return: AddLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_aiproduce_rules_with_options(request, runtime)

    async def add_live_aiproduce_rules_async(
        self,
        request: live_20161101_models.AddLiveAIProduceRulesRequest,
    ) -> live_20161101_models.AddLiveAIProduceRulesResponse:
        """
        @summary Adds a subtitle rule.
        
        @description    After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
        You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
        RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
        FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
        M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAIProduceRulesRequest
        @return: AddLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_aiproduce_rules_with_options_async(request, runtime)

    def add_live_aisubtitle_with_options(
        self,
        tmp_req: live_20161101_models.AddLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAISubtitleResponse:
        """
        @summary Adds a subtitle template.
        
        @description ## Instructions
        - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
        - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
        - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
        >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: AddLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAISubtitleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.AddLiveAISubtitleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.position_normalized):
            request.position_normalized_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.position_normalized, 'PositionNormalized', 'json')
        query = {}
        if not UtilClient.is_unset(request.bg_color):
            query['BgColor'] = request.bg_color
        if not UtilClient.is_unset(request.bg_width_normalized):
            query['BgWidthNormalized'] = request.bg_width_normalized
        if not UtilClient.is_unset(request.border_width_normalized):
            query['BorderWidthNormalized'] = request.border_width_normalized
        if not UtilClient.is_unset(request.copy_from):
            query['CopyFrom'] = request.copy_from
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dst_language):
            query['DstLanguage'] = request.dst_language
        if not UtilClient.is_unset(request.font_color):
            query['FontColor'] = request.font_color
        if not UtilClient.is_unset(request.font_name):
            query['FontName'] = request.font_name
        if not UtilClient.is_unset(request.font_size_normalized):
            query['FontSizeNormalized'] = request.font_size_normalized
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.max_lines):
            query['MaxLines'] = request.max_lines
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position_normalized_shrink):
            query['PositionNormalized'] = request.position_normalized_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_source_lan):
            query['ShowSourceLan'] = request.show_source_lan
        if not UtilClient.is_unset(request.src_language):
            query['SrcLanguage'] = request.src_language
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        if not UtilClient.is_unset(request.word_per_line):
            query['WordPerLine'] = request.word_per_line
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAISubtitleResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_aisubtitle_with_options_async(
        self,
        tmp_req: live_20161101_models.AddLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAISubtitleResponse:
        """
        @summary Adds a subtitle template.
        
        @description ## Instructions
        - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
        - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
        - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
        >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: AddLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAISubtitleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.AddLiveAISubtitleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.position_normalized):
            request.position_normalized_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.position_normalized, 'PositionNormalized', 'json')
        query = {}
        if not UtilClient.is_unset(request.bg_color):
            query['BgColor'] = request.bg_color
        if not UtilClient.is_unset(request.bg_width_normalized):
            query['BgWidthNormalized'] = request.bg_width_normalized
        if not UtilClient.is_unset(request.border_width_normalized):
            query['BorderWidthNormalized'] = request.border_width_normalized
        if not UtilClient.is_unset(request.copy_from):
            query['CopyFrom'] = request.copy_from
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dst_language):
            query['DstLanguage'] = request.dst_language
        if not UtilClient.is_unset(request.font_color):
            query['FontColor'] = request.font_color
        if not UtilClient.is_unset(request.font_name):
            query['FontName'] = request.font_name
        if not UtilClient.is_unset(request.font_size_normalized):
            query['FontSizeNormalized'] = request.font_size_normalized
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.max_lines):
            query['MaxLines'] = request.max_lines
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position_normalized_shrink):
            query['PositionNormalized'] = request.position_normalized_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_source_lan):
            query['ShowSourceLan'] = request.show_source_lan
        if not UtilClient.is_unset(request.src_language):
            query['SrcLanguage'] = request.src_language
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        if not UtilClient.is_unset(request.word_per_line):
            query['WordPerLine'] = request.word_per_line
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAISubtitleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_aisubtitle(
        self,
        request: live_20161101_models.AddLiveAISubtitleRequest,
    ) -> live_20161101_models.AddLiveAISubtitleResponse:
        """
        @summary Adds a subtitle template.
        
        @description ## Instructions
        - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
        - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
        - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
        >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveAISubtitleRequest
        @return: AddLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_aisubtitle_with_options(request, runtime)

    async def add_live_aisubtitle_async(
        self,
        request: live_20161101_models.AddLiveAISubtitleRequest,
    ) -> live_20161101_models.AddLiveAISubtitleResponse:
        """
        @summary Adds a subtitle template.
        
        @description ## Instructions
        - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more.
        - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast.
        - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
        >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveAISubtitleRequest
        @return: AddLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_aisubtitle_with_options_async(request, runtime)

    def add_live_app_record_config_with_options(
        self,
        request: live_20161101_models.AddLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAppRecordConfigResponse:
        """
        @summary Configure APP recording, with output saved to OSS.
        
        @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_format):
            query['RecordFormat'] = request.record_format
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcode_record_format):
            query['TranscodeRecordFormat'] = request.transcode_record_format
        if not UtilClient.is_unset(request.transcode_templates):
            query['TranscodeTemplates'] = request.transcode_templates
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAppRecordConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_app_record_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAppRecordConfigResponse:
        """
        @summary Configure APP recording, with output saved to OSS.
        
        @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_format):
            query['RecordFormat'] = request.record_format
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcode_record_format):
            query['TranscodeRecordFormat'] = request.transcode_record_format
        if not UtilClient.is_unset(request.transcode_templates):
            query['TranscodeTemplates'] = request.transcode_templates
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAppRecordConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_app_record_config(
        self,
        request: live_20161101_models.AddLiveAppRecordConfigRequest,
    ) -> live_20161101_models.AddLiveAppRecordConfigResponse:
        """
        @summary Configure APP recording, with output saved to OSS.
        
        @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppRecordConfigRequest
        @return: AddLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_app_record_config_with_options(request, runtime)

    async def add_live_app_record_config_async(
        self,
        request: live_20161101_models.AddLiveAppRecordConfigRequest,
    ) -> live_20161101_models.AddLiveAppRecordConfigResponse:
        """
        @summary Configure APP recording, with output saved to OSS.
        
        @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppRecordConfigRequest
        @return: AddLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_app_record_config_with_options_async(request, runtime)

    def add_live_app_snapshot_config_with_options(
        self,
        request: live_20161101_models.AddLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAppSnapshotConfigResponse:
        """
        @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
        Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
        The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.overwrite_oss_object):
            query['OverwriteOssObject'] = request.overwrite_oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sequence_oss_object):
            query['SequenceOssObject'] = request.sequence_oss_object
        if not UtilClient.is_unset(request.time_interval):
            query['TimeInterval'] = request.time_interval
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAppSnapshotConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_app_snapshot_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAppSnapshotConfigResponse:
        """
        @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
        Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
        The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.overwrite_oss_object):
            query['OverwriteOssObject'] = request.overwrite_oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sequence_oss_object):
            query['SequenceOssObject'] = request.sequence_oss_object
        if not UtilClient.is_unset(request.time_interval):
            query['TimeInterval'] = request.time_interval
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAppSnapshotConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_app_snapshot_config(
        self,
        request: live_20161101_models.AddLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.AddLiveAppSnapshotConfigResponse:
        """
        @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
        Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
        The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppSnapshotConfigRequest
        @return: AddLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_app_snapshot_config_with_options(request, runtime)

    async def add_live_app_snapshot_config_async(
        self,
        request: live_20161101_models.AddLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.AddLiveAppSnapshotConfigResponse:
        """
        @summary Configures the snapshot feature for a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The configuration takes effect after you restart stream ingest.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
        Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
        If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
        The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAppSnapshotConfigRequest
        @return: AddLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_app_snapshot_config_with_options_async(request, runtime)

    def add_live_audio_audit_config_with_options(
        self,
        request: live_20161101_models.AddLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAudioAuditConfigResponse:
        """
        @summary Adds an audio moderation configuration.
        
        @description    The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAudioAuditConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_audio_audit_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAudioAuditConfigResponse:
        """
        @summary Adds an audio moderation configuration.
        
        @description    The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAudioAuditConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_audio_audit_config(
        self,
        request: live_20161101_models.AddLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.AddLiveAudioAuditConfigResponse:
        """
        @summary Adds an audio moderation configuration.
        
        @description    The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditConfigRequest
        @return: AddLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_audio_audit_config_with_options(request, runtime)

    async def add_live_audio_audit_config_async(
        self,
        request: live_20161101_models.AddLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.AddLiveAudioAuditConfigResponse:
        """
        @summary Adds an audio moderation configuration.
        
        @description    The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditConfigRequest
        @return: AddLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_audio_audit_config_with_options_async(request, runtime)

    def add_live_audio_audit_notify_config_with_options(
        self,
        request: live_20161101_models.AddLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAudioAuditNotifyConfigResponse:
        """
        @summary Configures callbacks for audio moderation results.
        
        @description    The content moderation feature returns the audio moderation results based on the configured callback template.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.callback_template):
            query['CallbackTemplate'] = request.callback_template
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAudioAuditNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_audio_audit_notify_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveAudioAuditNotifyConfigResponse:
        """
        @summary Configures callbacks for audio moderation results.
        
        @description    The content moderation feature returns the audio moderation results based on the configured callback template.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.callback_template):
            query['CallbackTemplate'] = request.callback_template
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveAudioAuditNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_audio_audit_notify_config(
        self,
        request: live_20161101_models.AddLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveAudioAuditNotifyConfigResponse:
        """
        @summary Configures callbacks for audio moderation results.
        
        @description    The content moderation feature returns the audio moderation results based on the configured callback template.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditNotifyConfigRequest
        @return: AddLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_audio_audit_notify_config_with_options(request, runtime)

    async def add_live_audio_audit_notify_config_async(
        self,
        request: live_20161101_models.AddLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveAudioAuditNotifyConfigResponse:
        """
        @summary Configures callbacks for audio moderation results.
        
        @description    The content moderation feature returns the audio moderation results based on the configured callback template.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveAudioAuditNotifyConfigRequest
        @return: AddLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_audio_audit_notify_config_with_options_async(request, runtime)

    def add_live_center_transfer_with_options(
        self,
        request: live_20161101_models.AddLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveCenterTransferResponse:
        """
        @summary Adds a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveCenterTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_center_transfer_with_options_async(
        self,
        request: live_20161101_models.AddLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveCenterTransferResponse:
        """
        @summary Adds a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveCenterTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_center_transfer(
        self,
        request: live_20161101_models.AddLiveCenterTransferRequest,
    ) -> live_20161101_models.AddLiveCenterTransferResponse:
        """
        @summary Adds a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveCenterTransferRequest
        @return: AddLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_center_transfer_with_options(request, runtime)

    async def add_live_center_transfer_async(
        self,
        request: live_20161101_models.AddLiveCenterTransferRequest,
    ) -> live_20161101_models.AddLiveCenterTransferResponse:
        """
        @summary Adds a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveCenterTransferRequest
        @return: AddLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_center_transfer_with_options_async(request, runtime)

    def add_live_detect_notify_config_with_options(
        self,
        request: live_20161101_models.AddLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDetectNotifyConfigResponse:
        """
        @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
        
        @description    The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDetectNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_detect_notify_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDetectNotifyConfigResponse:
        """
        @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
        
        @description    The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDetectNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_detect_notify_config(
        self,
        request: live_20161101_models.AddLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveDetectNotifyConfigResponse:
        """
        @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
        
        @description    The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveDetectNotifyConfigRequest
        @return: AddLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_detect_notify_config_with_options(request, runtime)

    async def add_live_detect_notify_config_async(
        self,
        request: live_20161101_models.AddLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveDetectNotifyConfigResponse:
        """
        @summary Configures callbacks for video moderation results. As a result, a callback URL that is used to receive the callback notifications is added.
        
        @description    The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveDetectNotifyConfigRequest
        @return: AddLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_detect_notify_config_with_options_async(request, runtime)

    def add_live_domain_with_options(
        self,
        request: live_20161101_models.AddLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainResponse:
        """
        @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
        
        @description    You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
        ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
        To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
        After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
        After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
        >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.check_url):
            query['CheckUrl'] = request.check_url
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_domain_type):
            query['LiveDomainType'] = request.live_domain_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_domain_with_options_async(
        self,
        request: live_20161101_models.AddLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainResponse:
        """
        @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
        
        @description    You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
        ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
        To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
        After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
        After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
        >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.check_url):
            query['CheckUrl'] = request.check_url
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_domain_type):
            query['LiveDomainType'] = request.live_domain_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_domain(
        self,
        request: live_20161101_models.AddLiveDomainRequest,
    ) -> live_20161101_models.AddLiveDomainResponse:
        """
        @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
        
        @description    You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
        ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
        To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
        After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
        After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
        >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainRequest
        @return: AddLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_domain_with_options(request, runtime)

    async def add_live_domain_async(
        self,
        request: live_20161101_models.AddLiveDomainRequest,
    ) -> live_20161101_models.AddLiveDomainResponse:
        """
        @summary Adds a domain name to ApsaraVideo Live. This operation allows you to add only one domain name at a time.
        
        @description    You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
        ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
        To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
        After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
        After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
        >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainRequest
        @return: AddLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_domain_with_options_async(request, runtime)

    def add_live_domain_mapping_with_options(
        self,
        request: live_20161101_models.AddLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainMappingResponse:
        """
        @summary Creates the mapping between a streaming domain and an ingest domain.
        
        @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainMappingResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_domain_mapping_with_options_async(
        self,
        request: live_20161101_models.AddLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainMappingResponse:
        """
        @summary Creates the mapping between a streaming domain and an ingest domain.
        
        @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainMappingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_domain_mapping(
        self,
        request: live_20161101_models.AddLiveDomainMappingRequest,
    ) -> live_20161101_models.AddLiveDomainMappingResponse:
        """
        @summary Creates the mapping between a streaming domain and an ingest domain.
        
        @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveDomainMappingRequest
        @return: AddLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_domain_mapping_with_options(request, runtime)

    async def add_live_domain_mapping_async(
        self,
        request: live_20161101_models.AddLiveDomainMappingRequest,
    ) -> live_20161101_models.AddLiveDomainMappingResponse:
        """
        @summary Creates the mapping between a streaming domain and an ingest domain.
        
        @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveDomainMappingRequest
        @return: AddLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_domain_mapping_with_options_async(request, runtime)

    def add_live_domain_play_mapping_with_options(
        self,
        request: live_20161101_models.AddLiveDomainPlayMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainPlayMappingResponse:
        """
        @summary Maps a sub-streaming domain to a main streaming domain.
        
        @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainPlayMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainPlayMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_domain):
            query['PlayDomain'] = request.play_domain
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomainPlayMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainPlayMappingResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_domain_play_mapping_with_options_async(
        self,
        request: live_20161101_models.AddLiveDomainPlayMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveDomainPlayMappingResponse:
        """
        @summary Maps a sub-streaming domain to a main streaming domain.
        
        @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainPlayMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveDomainPlayMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_domain):
            query['PlayDomain'] = request.play_domain
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveDomainPlayMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveDomainPlayMappingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_domain_play_mapping(
        self,
        request: live_20161101_models.AddLiveDomainPlayMappingRequest,
    ) -> live_20161101_models.AddLiveDomainPlayMappingResponse:
        """
        @summary Maps a sub-streaming domain to a main streaming domain.
        
        @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainPlayMappingRequest
        @return: AddLiveDomainPlayMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_domain_play_mapping_with_options(request, runtime)

    async def add_live_domain_play_mapping_async(
        self,
        request: live_20161101_models.AddLiveDomainPlayMappingRequest,
    ) -> live_20161101_models.AddLiveDomainPlayMappingResponse:
        """
        @summary Maps a sub-streaming domain to a main streaming domain.
        
        @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveDomainPlayMappingRequest
        @return: AddLiveDomainPlayMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_domain_play_mapping_with_options_async(request, runtime)

    def add_live_message_group_band_with_options(
        self,
        tmp_req: live_20161101_models.AddLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveMessageGroupBandResponse:
        """
        @summary Mutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: AddLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.AddLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.banned_users):
            request.banned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.banned_users, 'BannedUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.banned_users_shrink):
            query['BannedUsers'] = request.banned_users_shrink
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveMessageGroupBandResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_message_group_band_with_options_async(
        self,
        tmp_req: live_20161101_models.AddLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveMessageGroupBandResponse:
        """
        @summary Mutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: AddLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.AddLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.banned_users):
            request.banned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.banned_users, 'BannedUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.banned_users_shrink):
            query['BannedUsers'] = request.banned_users_shrink
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveMessageGroupBandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_message_group_band(
        self,
        request: live_20161101_models.AddLiveMessageGroupBandRequest,
    ) -> live_20161101_models.AddLiveMessageGroupBandResponse:
        """
        @summary Mutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveMessageGroupBandRequest
        @return: AddLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_message_group_band_with_options(request, runtime)

    async def add_live_message_group_band_async(
        self,
        request: live_20161101_models.AddLiveMessageGroupBandRequest,
    ) -> live_20161101_models.AddLiveMessageGroupBandResponse:
        """
        @summary Mutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveMessageGroupBandRequest
        @return: AddLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_message_group_band_with_options_async(request, runtime)

    def add_live_package_config_with_options(
        self,
        request: live_20161101_models.AddLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLivePackageConfigResponse:
        """
        @summary Adds a live stream encapsulation configuration.
        
        @description    The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
        If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
        You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_duration):
            query['PartDuration'] = request.part_duration
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.segment_duration):
            query['SegmentDuration'] = request.segment_duration
        if not UtilClient.is_unset(request.segment_num):
            query['SegmentNum'] = request.segment_num
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLivePackageConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_package_config_with_options_async(
        self,
        request: live_20161101_models.AddLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLivePackageConfigResponse:
        """
        @summary Adds a live stream encapsulation configuration.
        
        @description    The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
        If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
        You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_duration):
            query['PartDuration'] = request.part_duration
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.segment_duration):
            query['SegmentDuration'] = request.segment_duration
        if not UtilClient.is_unset(request.segment_num):
            query['SegmentNum'] = request.segment_num
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLivePackageConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_package_config(
        self,
        request: live_20161101_models.AddLivePackageConfigRequest,
    ) -> live_20161101_models.AddLivePackageConfigResponse:
        """
        @summary Adds a live stream encapsulation configuration.
        
        @description    The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
        If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
        You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePackageConfigRequest
        @return: AddLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_package_config_with_options(request, runtime)

    async def add_live_package_config_async(
        self,
        request: live_20161101_models.AddLivePackageConfigRequest,
    ) -> live_20161101_models.AddLivePackageConfigResponse:
        """
        @summary Adds a live stream encapsulation configuration.
        
        @description    The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
        If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
        You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePackageConfigRequest
        @return: AddLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_package_config_with_options_async(request, runtime)

    def add_live_pull_stream_info_config_with_options(
        self,
        request: live_20161101_models.AddLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLivePullStreamInfoConfigResponse:
        """
        @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
        Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
        You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
        Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
        You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.source_url):
            query['SourceUrl'] = request.source_url
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLivePullStreamInfoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_pull_stream_info_config_with_options_async(
        self,
        request: live_20161101_models.AddLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLivePullStreamInfoConfigResponse:
        """
        @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
        Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
        You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
        Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
        You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.source_url):
            query['SourceUrl'] = request.source_url
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLivePullStreamInfoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_pull_stream_info_config(
        self,
        request: live_20161101_models.AddLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.AddLivePullStreamInfoConfigResponse:
        """
        @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
        Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
        You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
        Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
        You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePullStreamInfoConfigRequest
        @return: AddLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_pull_stream_info_config_with_options(request, runtime)

    async def add_live_pull_stream_info_config_async(
        self,
        request: live_20161101_models.AddLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.AddLivePullStreamInfoConfigResponse:
        """
        @summary Creates a stream pulling configuration for a live stream, which includes parameters such as the origin URL, start time, and end time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
        Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
        You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
        Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
        You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
        A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLivePullStreamInfoConfigRequest
        @return: AddLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_pull_stream_info_config_with_options_async(request, runtime)

    def add_live_record_notify_config_with_options(
        self,
        request: live_20161101_models.AddLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveRecordNotifyConfigResponse:
        """
        @summary Configures recording callbacks for a domain name.
        
        @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.need_status_notify):
            query['NeedStatusNotify'] = request.need_status_notify
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.on_demand_url):
            query['OnDemandUrl'] = request.on_demand_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveRecordNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_record_notify_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveRecordNotifyConfigResponse:
        """
        @summary Configures recording callbacks for a domain name.
        
        @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.need_status_notify):
            query['NeedStatusNotify'] = request.need_status_notify
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.on_demand_url):
            query['OnDemandUrl'] = request.on_demand_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveRecordNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_record_notify_config(
        self,
        request: live_20161101_models.AddLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveRecordNotifyConfigResponse:
        """
        @summary Configures recording callbacks for a domain name.
        
        @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordNotifyConfigRequest
        @return: AddLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_record_notify_config_with_options(request, runtime)

    async def add_live_record_notify_config_async(
        self,
        request: live_20161101_models.AddLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveRecordNotifyConfigResponse:
        """
        @summary Configures recording callbacks for a domain name.
        
        @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordNotifyConfigRequest
        @return: AddLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_record_notify_config_with_options_async(request, runtime)

    def add_live_record_vod_config_with_options(
        self,
        request: live_20161101_models.AddLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveRecordVodConfigResponse:
        """
        @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
        
        @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
        >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.auto_compose):
            query['AutoCompose'] = request.auto_compose
        if not UtilClient.is_unset(request.compose_vod_transcode_group_id):
            query['ComposeVodTranscodeGroupId'] = request.compose_vod_transcode_group_id
        if not UtilClient.is_unset(request.cycle_duration):
            query['CycleDuration'] = request.cycle_duration
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vod_transcode_group_id):
            query['VodTranscodeGroupId'] = request.vod_transcode_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveRecordVodConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_record_vod_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveRecordVodConfigResponse:
        """
        @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
        
        @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
        >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.auto_compose):
            query['AutoCompose'] = request.auto_compose
        if not UtilClient.is_unset(request.compose_vod_transcode_group_id):
            query['ComposeVodTranscodeGroupId'] = request.compose_vod_transcode_group_id
        if not UtilClient.is_unset(request.cycle_duration):
            query['CycleDuration'] = request.cycle_duration
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vod_transcode_group_id):
            query['VodTranscodeGroupId'] = request.vod_transcode_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveRecordVodConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_record_vod_config(
        self,
        request: live_20161101_models.AddLiveRecordVodConfigRequest,
    ) -> live_20161101_models.AddLiveRecordVodConfigResponse:
        """
        @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
        
        @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
        >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordVodConfigRequest
        @return: AddLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_record_vod_config_with_options(request, runtime)

    async def add_live_record_vod_config_async(
        self,
        request: live_20161101_models.AddLiveRecordVodConfigRequest,
    ) -> live_20161101_models.AddLiveRecordVodConfigResponse:
        """
        @summary Adds a Live-to-VOD configuration to store recordings in the media library of ApsaraVideo VOD.
        
        @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
        >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveRecordVodConfigRequest
        @return: AddLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_record_vod_config_with_options_async(request, runtime)

    def add_live_snapshot_detect_porn_config_with_options(
        self,
        request: live_20161101_models.AddLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveSnapshotDetectPornConfigResponse:
        """
        @summary Adds a video moderation configuration for live streams in an application under a domain name.
        
        @description - The live streaming audit function identifies and reviewssensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
        - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS Limitation
        The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveSnapshotDetectPornConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_snapshot_detect_porn_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveSnapshotDetectPornConfigResponse:
        """
        @summary Adds a video moderation configuration for live streams in an application under a domain name.
        
        @description - The live streaming audit function identifies and reviewssensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
        - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS Limitation
        The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveSnapshotDetectPornConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_snapshot_detect_porn_config(
        self,
        request: live_20161101_models.AddLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.AddLiveSnapshotDetectPornConfigResponse:
        """
        @summary Adds a video moderation configuration for live streams in an application under a domain name.
        
        @description - The live streaming audit function identifies and reviewssensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
        - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS Limitation
        The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotDetectPornConfigRequest
        @return: AddLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_snapshot_detect_porn_config_with_options(request, runtime)

    async def add_live_snapshot_detect_porn_config_async(
        self,
        request: live_20161101_models.AddLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.AddLiveSnapshotDetectPornConfigResponse:
        """
        @summary Adds a video moderation configuration for live streams in an application under a domain name.
        
        @description - The live streaming audit function identifies and reviewssensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
        - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS Limitation
        The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotDetectPornConfigRequest
        @return: AddLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_snapshot_detect_porn_config_with_options_async(request, runtime)

    def add_live_snapshot_notify_config_with_options(
        self,
        request: live_20161101_models.AddLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveSnapshotNotifyConfigResponse:
        """
        @summary Configures snapshot callbacks.
        
        @description ### QPS Limit
        The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveSnapshotNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_snapshot_notify_config_with_options_async(
        self,
        request: live_20161101_models.AddLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveSnapshotNotifyConfigResponse:
        """
        @summary Configures snapshot callbacks.
        
        @description ### QPS Limit
        The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveSnapshotNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_snapshot_notify_config(
        self,
        request: live_20161101_models.AddLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveSnapshotNotifyConfigResponse:
        """
        @summary Configures snapshot callbacks.
        
        @description ### QPS Limit
        The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotNotifyConfigRequest
        @return: AddLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_snapshot_notify_config_with_options(request, runtime)

    async def add_live_snapshot_notify_config_async(
        self,
        request: live_20161101_models.AddLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.AddLiveSnapshotNotifyConfigResponse:
        """
        @summary Configures snapshot callbacks.
        
        @description ### QPS Limit
        The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveSnapshotNotifyConfigRequest
        @return: AddLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_snapshot_notify_config_with_options_async(request, runtime)

    def add_live_stream_merge_with_options(
        self,
        request: live_20161101_models.AddLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamMergeResponse:
        """
        @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.in_app_name_1):
            query['InAppName1'] = request.in_app_name_1
        if not UtilClient.is_unset(request.in_app_name_2):
            query['InAppName2'] = request.in_app_name_2
        if not UtilClient.is_unset(request.in_stream_name_1):
            query['InStreamName1'] = request.in_stream_name_1
        if not UtilClient.is_unset(request.in_stream_name_2):
            query['InStreamName2'] = request.in_stream_name_2
        if not UtilClient.is_unset(request.live_merger):
            query['LiveMerger'] = request.live_merger
        if not UtilClient.is_unset(request.merge_parameters):
            query['MergeParameters'] = request.merge_parameters
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamMergeResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_stream_merge_with_options_async(
        self,
        request: live_20161101_models.AddLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamMergeResponse:
        """
        @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.in_app_name_1):
            query['InAppName1'] = request.in_app_name_1
        if not UtilClient.is_unset(request.in_app_name_2):
            query['InAppName2'] = request.in_app_name_2
        if not UtilClient.is_unset(request.in_stream_name_1):
            query['InStreamName1'] = request.in_stream_name_1
        if not UtilClient.is_unset(request.in_stream_name_2):
            query['InStreamName2'] = request.in_stream_name_2
        if not UtilClient.is_unset(request.live_merger):
            query['LiveMerger'] = request.live_merger
        if not UtilClient.is_unset(request.merge_parameters):
            query['MergeParameters'] = request.merge_parameters
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamMergeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_stream_merge(
        self,
        request: live_20161101_models.AddLiveStreamMergeRequest,
    ) -> live_20161101_models.AddLiveStreamMergeResponse:
        """
        @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamMergeRequest
        @return: AddLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_stream_merge_with_options(request, runtime)

    async def add_live_stream_merge_async(
        self,
        request: live_20161101_models.AddLiveStreamMergeRequest,
    ) -> live_20161101_models.AddLiveStreamMergeResponse:
        """
        @summary Invoke AddLiveStreamMerge to add primary and backup stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamMergeRequest
        @return: AddLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_stream_merge_with_options_async(request, runtime)

    def add_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.AddLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamTranscodeResponse:
        """
        @summary Adds transcoding configurations for a streaming domain.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.AddLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamTranscodeResponse:
        """
        @summary Adds transcoding configurations for a streaming domain.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_stream_transcode(
        self,
        request: live_20161101_models.AddLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddLiveStreamTranscodeResponse:
        """
        @summary Adds transcoding configurations for a streaming domain.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveStreamTranscodeRequest
        @return: AddLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_stream_transcode_with_options(request, runtime)

    async def add_live_stream_transcode_async(
        self,
        request: live_20161101_models.AddLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddLiveStreamTranscodeResponse:
        """
        @summary Adds transcoding configurations for a streaming domain.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: AddLiveStreamTranscodeRequest
        @return: AddLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_stream_transcode_with_options_async(request, runtime)

    def add_live_stream_watermark_with_options(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamWatermarkResponse:
        """
        @summary Creates a watermark template.
        
        @description    You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
        After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.offset_corner):
            query['OffsetCorner'] = request.offset_corner
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.picture_url):
            query['PictureUrl'] = request.picture_url
        if not UtilClient.is_unset(request.ref_height):
            query['RefHeight'] = request.ref_height
        if not UtilClient.is_unset(request.ref_width):
            query['RefWidth'] = request.ref_width
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.transparency):
            query['Transparency'] = request.transparency
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.xoffset):
            query['XOffset'] = request.xoffset
        if not UtilClient.is_unset(request.yoffset):
            query['YOffset'] = request.yoffset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_stream_watermark_with_options_async(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamWatermarkResponse:
        """
        @summary Creates a watermark template.
        
        @description    You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
        After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.offset_corner):
            query['OffsetCorner'] = request.offset_corner
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.picture_url):
            query['PictureUrl'] = request.picture_url
        if not UtilClient.is_unset(request.ref_height):
            query['RefHeight'] = request.ref_height
        if not UtilClient.is_unset(request.ref_width):
            query['RefWidth'] = request.ref_width
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.transparency):
            query['Transparency'] = request.transparency
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.xoffset):
            query['XOffset'] = request.xoffset
        if not UtilClient.is_unset(request.yoffset):
            query['YOffset'] = request.yoffset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_stream_watermark(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRequest,
    ) -> live_20161101_models.AddLiveStreamWatermarkResponse:
        """
        @summary Creates a watermark template.
        
        @description    You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
        After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamWatermarkRequest
        @return: AddLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_stream_watermark_with_options(request, runtime)

    async def add_live_stream_watermark_async(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRequest,
    ) -> live_20161101_models.AddLiveStreamWatermarkResponse:
        """
        @summary Creates a watermark template.
        
        @description    You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
        After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddLiveStreamWatermarkRequest
        @return: AddLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_stream_watermark_with_options_async(request, runtime)

    def add_live_stream_watermark_rule_with_options(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamWatermarkRuleResponse:
        """
        @summary Adds a watermark rule.
        
        @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamWatermarkRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_live_stream_watermark_rule_with_options_async(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddLiveStreamWatermarkRuleResponse:
        """
        @summary Adds a watermark rule.
        
        @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddLiveStreamWatermarkRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_live_stream_watermark_rule(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.AddLiveStreamWatermarkRuleResponse:
        """
        @summary Adds a watermark rule.
        
        @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveStreamWatermarkRuleRequest
        @return: AddLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_live_stream_watermark_rule_with_options(request, runtime)

    async def add_live_stream_watermark_rule_async(
        self,
        request: live_20161101_models.AddLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.AddLiveStreamWatermarkRuleResponse:
        """
        @summary Adds a watermark rule.
        
        @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddLiveStreamWatermarkRuleRequest
        @return: AddLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_live_stream_watermark_rule_with_options_async(request, runtime)

    def add_playlist_items_with_options(
        self,
        request: live_20161101_models.AddPlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddPlaylistItemsResponse:
        """
        @summary Adds episodes to an episode list.
        
        @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddPlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddPlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_config):
            query['ProgramConfig'] = request.program_config
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_items):
            query['ProgramItems'] = request.program_items
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddPlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddPlaylistItemsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_playlist_items_with_options_async(
        self,
        request: live_20161101_models.AddPlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddPlaylistItemsResponse:
        """
        @summary Adds episodes to an episode list.
        
        @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddPlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddPlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_config):
            query['ProgramConfig'] = request.program_config
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_items):
            query['ProgramItems'] = request.program_items
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddPlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddPlaylistItemsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_playlist_items(
        self,
        request: live_20161101_models.AddPlaylistItemsRequest,
    ) -> live_20161101_models.AddPlaylistItemsResponse:
        """
        @summary Adds episodes to an episode list.
        
        @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddPlaylistItemsRequest
        @return: AddPlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_playlist_items_with_options(request, runtime)

    async def add_playlist_items_async(
        self,
        request: live_20161101_models.AddPlaylistItemsRequest,
    ) -> live_20161101_models.AddPlaylistItemsResponse:
        """
        @summary Adds episodes to an episode list.
        
        @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddPlaylistItemsRequest
        @return: AddPlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_playlist_items_with_options_async(request, runtime)

    def add_rts_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.AddRtsLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddRtsLiveStreamTranscodeResponse:
        """
        @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
        
        @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddRtsLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddRtsLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.delete_bframes):
            query['DeleteBframes'] = request.delete_bframes
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.opus):
            query['Opus'] = request.opus
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddRtsLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddRtsLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_rts_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.AddRtsLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddRtsLiveStreamTranscodeResponse:
        """
        @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
        
        @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddRtsLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddRtsLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.delete_bframes):
            query['DeleteBframes'] = request.delete_bframes
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.opus):
            query['Opus'] = request.opus
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddRtsLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddRtsLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_rts_live_stream_transcode(
        self,
        request: live_20161101_models.AddRtsLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddRtsLiveStreamTranscodeResponse:
        """
        @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
        
        @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddRtsLiveStreamTranscodeRequest
        @return: AddRtsLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_rts_live_stream_transcode_with_options(request, runtime)

    async def add_rts_live_stream_transcode_async(
        self,
        request: live_20161101_models.AddRtsLiveStreamTranscodeRequest,
    ) -> live_20161101_models.AddRtsLiveStreamTranscodeResponse:
        """
        @summary Creates a Real-Time Streaming (RTS) transcoding configuration for a streaming domain.
        
        @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: AddRtsLiveStreamTranscodeRequest
        @return: AddRtsLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_rts_live_stream_transcode_with_options_async(request, runtime)

    def add_show_into_show_list_with_options(
        self,
        request: live_20161101_models.AddShowIntoShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddShowIntoShowListResponse:
        """
        @summary Adds an episode to an episode list.
        
        @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can add up to 1,000 episodes to an episode list.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddShowIntoShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddShowIntoShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.live_input_type):
            query['LiveInputType'] = request.live_input_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_times):
            query['RepeatTimes'] = request.repeat_times
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.resource_url):
            query['ResourceUrl'] = request.resource_url
        if not UtilClient.is_unset(request.show_name):
            query['ShowName'] = request.show_name
        if not UtilClient.is_unset(request.spot):
            query['Spot'] = request.spot
        if not UtilClient.is_unset(request.is_batch_mode):
            query['isBatchMode'] = request.is_batch_mode
        if not UtilClient.is_unset(request.show_list):
            query['showList'] = request.show_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddShowIntoShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddShowIntoShowListResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_show_into_show_list_with_options_async(
        self,
        request: live_20161101_models.AddShowIntoShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddShowIntoShowListResponse:
        """
        @summary Adds an episode to an episode list.
        
        @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can add up to 1,000 episodes to an episode list.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddShowIntoShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddShowIntoShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.live_input_type):
            query['LiveInputType'] = request.live_input_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_times):
            query['RepeatTimes'] = request.repeat_times
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.resource_url):
            query['ResourceUrl'] = request.resource_url
        if not UtilClient.is_unset(request.show_name):
            query['ShowName'] = request.show_name
        if not UtilClient.is_unset(request.spot):
            query['Spot'] = request.spot
        if not UtilClient.is_unset(request.is_batch_mode):
            query['isBatchMode'] = request.is_batch_mode
        if not UtilClient.is_unset(request.show_list):
            query['showList'] = request.show_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddShowIntoShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddShowIntoShowListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_show_into_show_list(
        self,
        request: live_20161101_models.AddShowIntoShowListRequest,
    ) -> live_20161101_models.AddShowIntoShowListResponse:
        """
        @summary Adds an episode to an episode list.
        
        @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can add up to 1,000 episodes to an episode list.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddShowIntoShowListRequest
        @return: AddShowIntoShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_show_into_show_list_with_options(request, runtime)

    async def add_show_into_show_list_async(
        self,
        request: live_20161101_models.AddShowIntoShowListRequest,
    ) -> live_20161101_models.AddShowIntoShowListResponse:
        """
        @summary Adds an episode to an episode list.
        
        @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can add up to 1,000 episodes to an episode list.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddShowIntoShowListRequest
        @return: AddShowIntoShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_show_into_show_list_with_options_async(request, runtime)

    def add_studio_layout_with_options(
        self,
        request: live_20161101_models.AddStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddStudioLayoutResponse:
        """
        @summary Configures a layout for a virtual studio.
        
        @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bg_image_config):
            query['BgImageConfig'] = request.bg_image_config
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.common_config):
            query['CommonConfig'] = request.common_config
        if not UtilClient.is_unset(request.layer_order_config_list):
            query['LayerOrderConfigList'] = request.layer_order_config_list
        if not UtilClient.is_unset(request.layout_name):
            query['LayoutName'] = request.layout_name
        if not UtilClient.is_unset(request.layout_type):
            query['LayoutType'] = request.layout_type
        if not UtilClient.is_unset(request.media_input_config_list):
            query['MediaInputConfigList'] = request.media_input_config_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.screen_input_config_list):
            query['ScreenInputConfigList'] = request.screen_input_config_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddStudioLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_studio_layout_with_options_async(
        self,
        request: live_20161101_models.AddStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddStudioLayoutResponse:
        """
        @summary Configures a layout for a virtual studio.
        
        @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bg_image_config):
            query['BgImageConfig'] = request.bg_image_config
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.common_config):
            query['CommonConfig'] = request.common_config
        if not UtilClient.is_unset(request.layer_order_config_list):
            query['LayerOrderConfigList'] = request.layer_order_config_list
        if not UtilClient.is_unset(request.layout_name):
            query['LayoutName'] = request.layout_name
        if not UtilClient.is_unset(request.layout_type):
            query['LayoutType'] = request.layout_type
        if not UtilClient.is_unset(request.media_input_config_list):
            query['MediaInputConfigList'] = request.media_input_config_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.screen_input_config_list):
            query['ScreenInputConfigList'] = request.screen_input_config_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddStudioLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_studio_layout(
        self,
        request: live_20161101_models.AddStudioLayoutRequest,
    ) -> live_20161101_models.AddStudioLayoutResponse:
        """
        @summary Configures a layout for a virtual studio.
        
        @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddStudioLayoutRequest
        @return: AddStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_studio_layout_with_options(request, runtime)

    async def add_studio_layout_async(
        self,
        request: live_20161101_models.AddStudioLayoutRequest,
    ) -> live_20161101_models.AddStudioLayoutResponse:
        """
        @summary Configures a layout for a virtual studio.
        
        @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddStudioLayoutRequest
        @return: AddStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_studio_layout_with_options_async(request, runtime)

    def add_trancode_seiwith_options(
        self,
        request: live_20161101_models.AddTrancodeSEIRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddTrancodeSEIResponse:
        """
        @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
        
        @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddTrancodeSEIRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTrancodeSEIResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay):
            query['Delay'] = request.delay
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pattern):
            query['Pattern'] = request.pattern
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat):
            query['Repeat'] = request.repeat
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.text):
            query['Text'] = request.text
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTrancodeSEI',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddTrancodeSEIResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_trancode_seiwith_options_async(
        self,
        request: live_20161101_models.AddTrancodeSEIRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.AddTrancodeSEIResponse:
        """
        @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
        
        @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddTrancodeSEIRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTrancodeSEIResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay):
            query['Delay'] = request.delay
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pattern):
            query['Pattern'] = request.pattern
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat):
            query['Repeat'] = request.repeat
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.text):
            query['Text'] = request.text
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTrancodeSEI',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.AddTrancodeSEIResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_trancode_sei(
        self,
        request: live_20161101_models.AddTrancodeSEIRequest,
    ) -> live_20161101_models.AddTrancodeSEIResponse:
        """
        @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
        
        @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddTrancodeSEIRequest
        @return: AddTrancodeSEIResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_trancode_seiwith_options(request, runtime)

    async def add_trancode_sei_async(
        self,
        request: live_20161101_models.AddTrancodeSEIRequest,
    ) -> live_20161101_models.AddTrancodeSEIResponse:
        """
        @summary Inserts supplemental enhancement information (SEI) to transcoded streams.
        
        @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: AddTrancodeSEIRequest
        @return: AddTrancodeSEIResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_trancode_seiwith_options_async(request, runtime)

    def ban_live_message_group_with_options(
        self,
        tmp_req: live_20161101_models.BanLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BanLiveMessageGroupResponse:
        """
        @summary Mutes a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: BanLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BanLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.BanLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.except_users):
            request.except_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.except_users, 'ExceptUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.except_users_shrink):
            query['ExceptUsers'] = request.except_users_shrink
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BanLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BanLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def ban_live_message_group_with_options_async(
        self,
        tmp_req: live_20161101_models.BanLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BanLiveMessageGroupResponse:
        """
        @summary Mutes a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: BanLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BanLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.BanLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.except_users):
            request.except_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.except_users, 'ExceptUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.except_users_shrink):
            query['ExceptUsers'] = request.except_users_shrink
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BanLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BanLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def ban_live_message_group(
        self,
        request: live_20161101_models.BanLiveMessageGroupRequest,
    ) -> live_20161101_models.BanLiveMessageGroupResponse:
        """
        @summary Mutes a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BanLiveMessageGroupRequest
        @return: BanLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.ban_live_message_group_with_options(request, runtime)

    async def ban_live_message_group_async(
        self,
        request: live_20161101_models.BanLiveMessageGroupRequest,
    ) -> live_20161101_models.BanLiveMessageGroupResponse:
        """
        @summary Mutes a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BanLiveMessageGroupRequest
        @return: BanLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.ban_live_message_group_with_options_async(request, runtime)

    def batch_delete_live_domain_configs_with_options(
        self,
        request: live_20161101_models.BatchDeleteLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchDeleteLiveDomainConfigsResponse:
        """
        @summary Deletes the configurations of multiple domain names at a time.
        
        @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchDeleteLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchDeleteLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchDeleteLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchDeleteLiveDomainConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_delete_live_domain_configs_with_options_async(
        self,
        request: live_20161101_models.BatchDeleteLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchDeleteLiveDomainConfigsResponse:
        """
        @summary Deletes the configurations of multiple domain names at a time.
        
        @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchDeleteLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchDeleteLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchDeleteLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchDeleteLiveDomainConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_delete_live_domain_configs(
        self,
        request: live_20161101_models.BatchDeleteLiveDomainConfigsRequest,
    ) -> live_20161101_models.BatchDeleteLiveDomainConfigsResponse:
        """
        @summary Deletes the configurations of multiple domain names at a time.
        
        @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchDeleteLiveDomainConfigsRequest
        @return: BatchDeleteLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_delete_live_domain_configs_with_options(request, runtime)

    async def batch_delete_live_domain_configs_async(
        self,
        request: live_20161101_models.BatchDeleteLiveDomainConfigsRequest,
    ) -> live_20161101_models.BatchDeleteLiveDomainConfigsResponse:
        """
        @summary Deletes the configurations of multiple domain names at a time.
        
        @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchDeleteLiveDomainConfigsRequest
        @return: BatchDeleteLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_delete_live_domain_configs_with_options_async(request, runtime)

    def batch_get_online_users_with_options(
        self,
        request: live_20161101_models.BatchGetOnlineUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchGetOnlineUsersResponse:
        """
        @summary uid
        
        @description ## Usage notes
        You can query whether up to 20 users are online at a time.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: BatchGetOnlineUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchGetOnlineUsersResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_ids):
            body['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchGetOnlineUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchGetOnlineUsersResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_get_online_users_with_options_async(
        self,
        request: live_20161101_models.BatchGetOnlineUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchGetOnlineUsersResponse:
        """
        @summary uid
        
        @description ## Usage notes
        You can query whether up to 20 users are online at a time.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: BatchGetOnlineUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchGetOnlineUsersResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_ids):
            body['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchGetOnlineUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchGetOnlineUsersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_get_online_users(
        self,
        request: live_20161101_models.BatchGetOnlineUsersRequest,
    ) -> live_20161101_models.BatchGetOnlineUsersResponse:
        """
        @summary uid
        
        @description ## Usage notes
        You can query whether up to 20 users are online at a time.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: BatchGetOnlineUsersRequest
        @return: BatchGetOnlineUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_get_online_users_with_options(request, runtime)

    async def batch_get_online_users_async(
        self,
        request: live_20161101_models.BatchGetOnlineUsersRequest,
    ) -> live_20161101_models.BatchGetOnlineUsersResponse:
        """
        @summary uid
        
        @description ## Usage notes
        You can query whether up to 20 users are online at a time.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: BatchGetOnlineUsersRequest
        @return: BatchGetOnlineUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_get_online_users_with_options_async(request, runtime)

    def batch_set_live_domain_configs_with_options(
        self,
        request: live_20161101_models.BatchSetLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchSetLiveDomainConfigsResponse:
        """
        @summary Configures multiple domain names at a time.
        
        @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchSetLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchSetLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchSetLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchSetLiveDomainConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_set_live_domain_configs_with_options_async(
        self,
        request: live_20161101_models.BatchSetLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.BatchSetLiveDomainConfigsResponse:
        """
        @summary Configures multiple domain names at a time.
        
        @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchSetLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchSetLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchSetLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.BatchSetLiveDomainConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_set_live_domain_configs(
        self,
        request: live_20161101_models.BatchSetLiveDomainConfigsRequest,
    ) -> live_20161101_models.BatchSetLiveDomainConfigsResponse:
        """
        @summary Configures multiple domain names at a time.
        
        @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchSetLiveDomainConfigsRequest
        @return: BatchSetLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_set_live_domain_configs_with_options(request, runtime)

    async def batch_set_live_domain_configs_async(
        self,
        request: live_20161101_models.BatchSetLiveDomainConfigsRequest,
    ) -> live_20161101_models.BatchSetLiveDomainConfigsResponse:
        """
        @summary Configures multiple domain names at a time.
        
        @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: BatchSetLiveDomainConfigsRequest
        @return: BatchSetLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_set_live_domain_configs_with_options_async(request, runtime)

    def cancel_mute_all_group_user_with_options(
        self,
        request: live_20161101_models.CancelMuteAllGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CancelMuteAllGroupUserResponse:
        """
        @summary Unmutes a message group.
        
        @description ## QPS
        QPS100/API[QPS](https://help.aliyun.com/document_detail/343507.html)
        
        @param request: CancelMuteAllGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMuteAllGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CancelMuteAllGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CancelMuteAllGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_mute_all_group_user_with_options_async(
        self,
        request: live_20161101_models.CancelMuteAllGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CancelMuteAllGroupUserResponse:
        """
        @summary Unmutes a message group.
        
        @description ## QPS
        QPS100/API[QPS](https://help.aliyun.com/document_detail/343507.html)
        
        @param request: CancelMuteAllGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMuteAllGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CancelMuteAllGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CancelMuteAllGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_mute_all_group_user(
        self,
        request: live_20161101_models.CancelMuteAllGroupUserRequest,
    ) -> live_20161101_models.CancelMuteAllGroupUserResponse:
        """
        @summary Unmutes a message group.
        
        @description ## QPS
        QPS100/API[QPS](https://help.aliyun.com/document_detail/343507.html)
        
        @param request: CancelMuteAllGroupUserRequest
        @return: CancelMuteAllGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_mute_all_group_user_with_options(request, runtime)

    async def cancel_mute_all_group_user_async(
        self,
        request: live_20161101_models.CancelMuteAllGroupUserRequest,
    ) -> live_20161101_models.CancelMuteAllGroupUserResponse:
        """
        @summary Unmutes a message group.
        
        @description ## QPS
        QPS100/API[QPS](https://help.aliyun.com/document_detail/343507.html)
        
        @param request: CancelMuteAllGroupUserRequest
        @return: CancelMuteAllGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_mute_all_group_user_with_options_async(request, runtime)

    def cancel_mute_group_user_with_options(
        self,
        tmp_req: live_20161101_models.CancelMuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CancelMuteGroupUserResponse:
        """
        @summary Unmutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CancelMuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMuteGroupUserResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CancelMuteGroupUserShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cancel_mute_user_list):
            request.cancel_mute_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cancel_mute_user_list, 'CancelMuteUserList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.cancel_mute_user_list_shrink):
            body['CancelMuteUserList'] = request.cancel_mute_user_list_shrink
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CancelMuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CancelMuteGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_mute_group_user_with_options_async(
        self,
        tmp_req: live_20161101_models.CancelMuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CancelMuteGroupUserResponse:
        """
        @summary Unmutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CancelMuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMuteGroupUserResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CancelMuteGroupUserShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cancel_mute_user_list):
            request.cancel_mute_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cancel_mute_user_list, 'CancelMuteUserList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.cancel_mute_user_list_shrink):
            body['CancelMuteUserList'] = request.cancel_mute_user_list_shrink
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CancelMuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CancelMuteGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_mute_group_user(
        self,
        request: live_20161101_models.CancelMuteGroupUserRequest,
    ) -> live_20161101_models.CancelMuteGroupUserResponse:
        """
        @summary Unmutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CancelMuteGroupUserRequest
        @return: CancelMuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_mute_group_user_with_options(request, runtime)

    async def cancel_mute_group_user_async(
        self,
        request: live_20161101_models.CancelMuteGroupUserRequest,
    ) -> live_20161101_models.CancelMuteGroupUserResponse:
        """
        @summary Unmutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CancelMuteGroupUserRequest
        @return: CancelMuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_mute_group_user_with_options_async(request, runtime)

    def change_live_domain_resource_group_with_options(
        self,
        request: live_20161101_models.ChangeLiveDomainResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ChangeLiveDomainResourceGroupResponse:
        """
        @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ChangeLiveDomainResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeLiveDomainResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeLiveDomainResourceGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ChangeLiveDomainResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_live_domain_resource_group_with_options_async(
        self,
        request: live_20161101_models.ChangeLiveDomainResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ChangeLiveDomainResourceGroupResponse:
        """
        @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ChangeLiveDomainResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeLiveDomainResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeLiveDomainResourceGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ChangeLiveDomainResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_live_domain_resource_group(
        self,
        request: live_20161101_models.ChangeLiveDomainResourceGroupRequest,
    ) -> live_20161101_models.ChangeLiveDomainResourceGroupResponse:
        """
        @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ChangeLiveDomainResourceGroupRequest
        @return: ChangeLiveDomainResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_live_domain_resource_group_with_options(request, runtime)

    async def change_live_domain_resource_group_async(
        self,
        request: live_20161101_models.ChangeLiveDomainResourceGroupRequest,
    ) -> live_20161101_models.ChangeLiveDomainResourceGroupResponse:
        """
        @summary Changes the resource group to which a domain name belongs. In this case, you move the domain name from the original resource group to another resource group.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ChangeLiveDomainResourceGroupRequest
        @return: ChangeLiveDomainResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_live_domain_resource_group_with_options_async(request, runtime)

    def check_live_message_users_in_group_with_options(
        self,
        tmp_req: live_20161101_models.CheckLiveMessageUsersInGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CheckLiveMessageUsersInGroupResponse:
        """
        @summary Queries whether a user is in an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CheckLiveMessageUsersInGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLiveMessageUsersInGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CheckLiveMessageUsersInGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_ids):
            request.user_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_ids, 'UserIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_ids_shrink):
            query['UserIds'] = request.user_ids_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLiveMessageUsersInGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CheckLiveMessageUsersInGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_live_message_users_in_group_with_options_async(
        self,
        tmp_req: live_20161101_models.CheckLiveMessageUsersInGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CheckLiveMessageUsersInGroupResponse:
        """
        @summary Queries whether a user is in an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CheckLiveMessageUsersInGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLiveMessageUsersInGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CheckLiveMessageUsersInGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_ids):
            request.user_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_ids, 'UserIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_ids_shrink):
            query['UserIds'] = request.user_ids_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLiveMessageUsersInGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CheckLiveMessageUsersInGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_live_message_users_in_group(
        self,
        request: live_20161101_models.CheckLiveMessageUsersInGroupRequest,
    ) -> live_20161101_models.CheckLiveMessageUsersInGroupResponse:
        """
        @summary Queries whether a user is in an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CheckLiveMessageUsersInGroupRequest
        @return: CheckLiveMessageUsersInGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_live_message_users_in_group_with_options(request, runtime)

    async def check_live_message_users_in_group_async(
        self,
        request: live_20161101_models.CheckLiveMessageUsersInGroupRequest,
    ) -> live_20161101_models.CheckLiveMessageUsersInGroupResponse:
        """
        @summary Queries whether a user is in an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CheckLiveMessageUsersInGroupRequest
        @return: CheckLiveMessageUsersInGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_live_message_users_in_group_with_options_async(request, runtime)

    def check_live_message_users_online_with_options(
        self,
        tmp_req: live_20161101_models.CheckLiveMessageUsersOnlineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CheckLiveMessageUsersOnlineResponse:
        """
        @summary Queries whether one or more specified users are online.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CheckLiveMessageUsersOnlineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLiveMessageUsersOnlineResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CheckLiveMessageUsersOnlineShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_ids):
            request.user_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_ids, 'UserIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.user_ids_shrink):
            query['UserIds'] = request.user_ids_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLiveMessageUsersOnline',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CheckLiveMessageUsersOnlineResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_live_message_users_online_with_options_async(
        self,
        tmp_req: live_20161101_models.CheckLiveMessageUsersOnlineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CheckLiveMessageUsersOnlineResponse:
        """
        @summary Queries whether one or more specified users are online.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CheckLiveMessageUsersOnlineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLiveMessageUsersOnlineResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CheckLiveMessageUsersOnlineShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_ids):
            request.user_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_ids, 'UserIds', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.user_ids_shrink):
            query['UserIds'] = request.user_ids_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLiveMessageUsersOnline',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CheckLiveMessageUsersOnlineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_live_message_users_online(
        self,
        request: live_20161101_models.CheckLiveMessageUsersOnlineRequest,
    ) -> live_20161101_models.CheckLiveMessageUsersOnlineResponse:
        """
        @summary Queries whether one or more specified users are online.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CheckLiveMessageUsersOnlineRequest
        @return: CheckLiveMessageUsersOnlineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_live_message_users_online_with_options(request, runtime)

    async def check_live_message_users_online_async(
        self,
        request: live_20161101_models.CheckLiveMessageUsersOnlineRequest,
    ) -> live_20161101_models.CheckLiveMessageUsersOnlineResponse:
        """
        @summary Queries whether one or more specified users are online.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CheckLiveMessageUsersOnlineRequest
        @return: CheckLiveMessageUsersOnlineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_live_message_users_online_with_options_async(request, runtime)

    def close_live_shift_with_options(
        self,
        request: live_20161101_models.CloseLiveShiftRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CloseLiveShiftResponse:
        """
        @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CloseLiveShiftRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CloseLiveShiftResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CloseLiveShift',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CloseLiveShiftResponse(),
            self.call_api(params, req, runtime)
        )

    async def close_live_shift_with_options_async(
        self,
        request: live_20161101_models.CloseLiveShiftRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CloseLiveShiftResponse:
        """
        @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CloseLiveShiftRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CloseLiveShiftResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CloseLiveShift',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CloseLiveShiftResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def close_live_shift(
        self,
        request: live_20161101_models.CloseLiveShiftRequest,
    ) -> live_20161101_models.CloseLiveShiftResponse:
        """
        @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CloseLiveShiftRequest
        @return: CloseLiveShiftResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.close_live_shift_with_options(request, runtime)

    async def close_live_shift_async(
        self,
        request: live_20161101_models.CloseLiveShiftRequest,
    ) -> live_20161101_models.CloseLiveShiftResponse:
        """
        @summary Disables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CloseLiveShiftRequest
        @return: CloseLiveShiftResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.close_live_shift_with_options_async(request, runtime)

    def copy_caster_with_options(
        self,
        request: live_20161101_models.CopyCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CopyCasterResponse:
        """
        @summary Duplicates a production studio.
        
        @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.src_caster_id):
            query['SrcCasterId'] = request.src_caster_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CopyCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def copy_caster_with_options_async(
        self,
        request: live_20161101_models.CopyCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CopyCasterResponse:
        """
        @summary Duplicates a production studio.
        
        @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.src_caster_id):
            query['SrcCasterId'] = request.src_caster_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CopyCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def copy_caster(
        self,
        request: live_20161101_models.CopyCasterRequest,
    ) -> live_20161101_models.CopyCasterResponse:
        """
        @summary Duplicates a production studio.
        
        @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterRequest
        @return: CopyCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.copy_caster_with_options(request, runtime)

    async def copy_caster_async(
        self,
        request: live_20161101_models.CopyCasterRequest,
    ) -> live_20161101_models.CopyCasterResponse:
        """
        @summary Duplicates a production studio.
        
        @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterRequest
        @return: CopyCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.copy_caster_with_options_async(request, runtime)

    def copy_caster_scene_config_with_options(
        self,
        request: live_20161101_models.CopyCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CopyCasterSceneConfigResponse:
        """
        @summary Applies the configuration of a PVW scene to a PGM scene.
        
        @description    Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
        The PVW scene and PGM scene must be in the same production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.from_scene_id):
            query['FromSceneId'] = request.from_scene_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.to_scene_id):
            query['ToSceneId'] = request.to_scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CopyCasterSceneConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def copy_caster_scene_config_with_options_async(
        self,
        request: live_20161101_models.CopyCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CopyCasterSceneConfigResponse:
        """
        @summary Applies the configuration of a PVW scene to a PGM scene.
        
        @description    Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
        The PVW scene and PGM scene must be in the same production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CopyCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.from_scene_id):
            query['FromSceneId'] = request.from_scene_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.to_scene_id):
            query['ToSceneId'] = request.to_scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CopyCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CopyCasterSceneConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def copy_caster_scene_config(
        self,
        request: live_20161101_models.CopyCasterSceneConfigRequest,
    ) -> live_20161101_models.CopyCasterSceneConfigResponse:
        """
        @summary Applies the configuration of a PVW scene to a PGM scene.
        
        @description    Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
        The PVW scene and PGM scene must be in the same production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterSceneConfigRequest
        @return: CopyCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.copy_caster_scene_config_with_options(request, runtime)

    async def copy_caster_scene_config_async(
        self,
        request: live_20161101_models.CopyCasterSceneConfigRequest,
    ) -> live_20161101_models.CopyCasterSceneConfigResponse:
        """
        @summary Applies the configuration of a PVW scene to a PGM scene.
        
        @description    Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
        The PVW scene and PGM scene must be in the same production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CopyCasterSceneConfigRequest
        @return: CopyCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.copy_caster_scene_config_with_options_async(request, runtime)

    def create_caster_with_options(
        self,
        request: live_20161101_models.CreateCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateCasterResponse:
        """
        @summary Creates a production studio.
        
        @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
        You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.caster_template):
            query['CasterTemplate'] = request.caster_template
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.expire_time):
            query['ExpireTime'] = request.expire_time
        if not UtilClient.is_unset(request.norm_type):
            query['NormType'] = request.norm_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.purchase_time):
            query['PurchaseTime'] = request.purchase_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_caster_with_options_async(
        self,
        request: live_20161101_models.CreateCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateCasterResponse:
        """
        @summary Creates a production studio.
        
        @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
        You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.caster_template):
            query['CasterTemplate'] = request.caster_template
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.expire_time):
            query['ExpireTime'] = request.expire_time
        if not UtilClient.is_unset(request.norm_type):
            query['NormType'] = request.norm_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.purchase_time):
            query['PurchaseTime'] = request.purchase_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_caster(
        self,
        request: live_20161101_models.CreateCasterRequest,
    ) -> live_20161101_models.CreateCasterResponse:
        """
        @summary Creates a production studio.
        
        @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
        You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCasterRequest
        @return: CreateCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_caster_with_options(request, runtime)

    async def create_caster_async(
        self,
        request: live_20161101_models.CreateCasterRequest,
    ) -> live_20161101_models.CreateCasterResponse:
        """
        @summary Creates a production studio.
        
        @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
        You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCasterRequest
        @return: CreateCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_caster_with_options_async(request, runtime)

    def create_custom_template_with_options(
        self,
        request: live_20161101_models.CreateCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateCustomTemplateResponse:
        """
        @summary Creates a custom stream mixing template.
        
        @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.custom_template):
            query['CustomTemplate'] = request.custom_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateCustomTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_custom_template_with_options_async(
        self,
        request: live_20161101_models.CreateCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateCustomTemplateResponse:
        """
        @summary Creates a custom stream mixing template.
        
        @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.custom_template):
            query['CustomTemplate'] = request.custom_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateCustomTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_custom_template(
        self,
        request: live_20161101_models.CreateCustomTemplateRequest,
    ) -> live_20161101_models.CreateCustomTemplateResponse:
        """
        @summary Creates a custom stream mixing template.
        
        @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCustomTemplateRequest
        @return: CreateCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_custom_template_with_options(request, runtime)

    async def create_custom_template_async(
        self,
        request: live_20161101_models.CreateCustomTemplateRequest,
    ) -> live_20161101_models.CreateCustomTemplateResponse:
        """
        @summary Creates a custom stream mixing template.
        
        @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateCustomTemplateRequest
        @return: CreateCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_custom_template_with_options_async(request, runtime)

    def create_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.CreateEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateEdgeTranscodeJobResponse:
        """
        @summary Creates an edge transcoding task.
        
        @description    You can call this operation to create an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_input):
            query['StreamInput'] = request.stream_input
        if not UtilClient.is_unset(request.stream_output):
            query['StreamOutput'] = request.stream_output
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.CreateEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateEdgeTranscodeJobResponse:
        """
        @summary Creates an edge transcoding task.
        
        @description    You can call this operation to create an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_input):
            query['StreamInput'] = request.stream_input
        if not UtilClient.is_unset(request.stream_output):
            query['StreamOutput'] = request.stream_output
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_edge_transcode_job(
        self,
        request: live_20161101_models.CreateEdgeTranscodeJobRequest,
    ) -> live_20161101_models.CreateEdgeTranscodeJobResponse:
        """
        @summary Creates an edge transcoding task.
        
        @description    You can call this operation to create an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEdgeTranscodeJobRequest
        @return: CreateEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_edge_transcode_job_with_options(request, runtime)

    async def create_edge_transcode_job_async(
        self,
        request: live_20161101_models.CreateEdgeTranscodeJobRequest,
    ) -> live_20161101_models.CreateEdgeTranscodeJobResponse:
        """
        @summary Creates an edge transcoding task.
        
        @description    You can call this operation to create an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEdgeTranscodeJobRequest
        @return: CreateEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_edge_transcode_job_with_options_async(request, runtime)

    def create_event_sub_with_options(
        self,
        request: live_20161101_models.CreateEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateEventSubResponse:
        """
        @summary Creates a callback to subscribe to channel or user events.
        
        @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.events):
            query['Events'] = request.events
        if not UtilClient.is_unset(request.users):
            query['Users'] = request.users
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_event_sub_with_options_async(
        self,
        request: live_20161101_models.CreateEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateEventSubResponse:
        """
        @summary Creates a callback to subscribe to channel or user events.
        
        @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.events):
            query['Events'] = request.events
        if not UtilClient.is_unset(request.users):
            query['Users'] = request.users
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_event_sub(
        self,
        request: live_20161101_models.CreateEventSubRequest,
    ) -> live_20161101_models.CreateEventSubResponse:
        """
        @summary Creates a callback to subscribe to channel or user events.
        
        @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEventSubRequest
        @return: CreateEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_event_sub_with_options(request, runtime)

    async def create_event_sub_async(
        self,
        request: live_20161101_models.CreateEventSubRequest,
    ) -> live_20161101_models.CreateEventSubResponse:
        """
        @summary Creates a callback to subscribe to channel or user events.
        
        @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateEventSubRequest
        @return: CreateEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_event_sub_with_options_async(request, runtime)

    def create_live_aistudio_with_options(
        self,
        tmp_req: live_20161101_models.CreateLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveAIStudioResponse:
        """
        @summary Creates a lightweight virtual studio template.
        
        @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param tmp_req: CreateLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveAIStudioResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLiveAIStudioShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.matting_layout):
            request.matting_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.matting_layout, 'MattingLayout', 'json')
        if not UtilClient.is_unset(tmp_req.media_layout):
            request.media_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.media_layout, 'MediaLayout', 'json')
        query = {}
        if not UtilClient.is_unset(request.background_resource_id):
            query['BackgroundResourceId'] = request.background_resource_id
        if not UtilClient.is_unset(request.background_resource_url):
            query['BackgroundResourceUrl'] = request.background_resource_url
        if not UtilClient.is_unset(request.background_type):
            query['BackgroundType'] = request.background_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.matting_layout_shrink):
            query['MattingLayout'] = request.matting_layout_shrink
        if not UtilClient.is_unset(request.matting_type):
            query['MattingType'] = request.matting_type
        if not UtilClient.is_unset(request.media_layout_shrink):
            query['MediaLayout'] = request.media_layout_shrink
        if not UtilClient.is_unset(request.media_resource_id):
            query['MediaResourceId'] = request.media_resource_id
        if not UtilClient.is_unset(request.media_resource_url):
            query['MediaResourceUrl'] = request.media_resource_url
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveAIStudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_aistudio_with_options_async(
        self,
        tmp_req: live_20161101_models.CreateLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveAIStudioResponse:
        """
        @summary Creates a lightweight virtual studio template.
        
        @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param tmp_req: CreateLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveAIStudioResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLiveAIStudioShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.matting_layout):
            request.matting_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.matting_layout, 'MattingLayout', 'json')
        if not UtilClient.is_unset(tmp_req.media_layout):
            request.media_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.media_layout, 'MediaLayout', 'json')
        query = {}
        if not UtilClient.is_unset(request.background_resource_id):
            query['BackgroundResourceId'] = request.background_resource_id
        if not UtilClient.is_unset(request.background_resource_url):
            query['BackgroundResourceUrl'] = request.background_resource_url
        if not UtilClient.is_unset(request.background_type):
            query['BackgroundType'] = request.background_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.matting_layout_shrink):
            query['MattingLayout'] = request.matting_layout_shrink
        if not UtilClient.is_unset(request.matting_type):
            query['MattingType'] = request.matting_type
        if not UtilClient.is_unset(request.media_layout_shrink):
            query['MediaLayout'] = request.media_layout_shrink
        if not UtilClient.is_unset(request.media_resource_id):
            query['MediaResourceId'] = request.media_resource_id
        if not UtilClient.is_unset(request.media_resource_url):
            query['MediaResourceUrl'] = request.media_resource_url
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveAIStudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_aistudio(
        self,
        request: live_20161101_models.CreateLiveAIStudioRequest,
    ) -> live_20161101_models.CreateLiveAIStudioResponse:
        """
        @summary Creates a lightweight virtual studio template.
        
        @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: CreateLiveAIStudioRequest
        @return: CreateLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_aistudio_with_options(request, runtime)

    async def create_live_aistudio_async(
        self,
        request: live_20161101_models.CreateLiveAIStudioRequest,
    ) -> live_20161101_models.CreateLiveAIStudioResponse:
        """
        @summary Creates a lightweight virtual studio template.
        
        @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: CreateLiveAIStudioRequest
        @return: CreateLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_aistudio_with_options_async(request, runtime)

    def create_live_delay_config_with_options(
        self,
        request: live_20161101_models.CreateLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveDelayConfigResponse:
        """
        @summary Adds a stream delay configuration.
        
        @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.task_trigger_mode):
            query['TaskTriggerMode'] = request.task_trigger_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_delay_config_with_options_async(
        self,
        request: live_20161101_models.CreateLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveDelayConfigResponse:
        """
        @summary Adds a stream delay configuration.
        
        @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.task_trigger_mode):
            query['TaskTriggerMode'] = request.task_trigger_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_delay_config(
        self,
        request: live_20161101_models.CreateLiveDelayConfigRequest,
    ) -> live_20161101_models.CreateLiveDelayConfigResponse:
        """
        @summary Adds a stream delay configuration.
        
        @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveDelayConfigRequest
        @return: CreateLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_delay_config_with_options(request, runtime)

    async def create_live_delay_config_async(
        self,
        request: live_20161101_models.CreateLiveDelayConfigRequest,
    ) -> live_20161101_models.CreateLiveDelayConfigResponse:
        """
        @summary Adds a stream delay configuration.
        
        @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveDelayConfigRequest
        @return: CreateLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_delay_config_with_options_async(request, runtime)

    def create_live_message_app_with_options(
        self,
        request: live_20161101_models.CreateLiveMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description    When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
        You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveMessageAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.audit_type):
            query['AuditType'] = request.audit_type
        if not UtilClient.is_unset(request.audit_url):
            query['AuditUrl'] = request.audit_url
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.event_callback_url):
            query['EventCallbackUrl'] = request.event_callback_url
        if not UtilClient.is_unset(request.msg_life_cycle):
            query['MsgLifeCycle'] = request.msg_life_cycle
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_message_app_with_options_async(
        self,
        request: live_20161101_models.CreateLiveMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description    When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
        You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveMessageAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.audit_type):
            query['AuditType'] = request.audit_type
        if not UtilClient.is_unset(request.audit_url):
            query['AuditUrl'] = request.audit_url
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.event_callback_url):
            query['EventCallbackUrl'] = request.event_callback_url
        if not UtilClient.is_unset(request.msg_life_cycle):
            query['MsgLifeCycle'] = request.msg_life_cycle
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_message_app(
        self,
        request: live_20161101_models.CreateLiveMessageAppRequest,
    ) -> live_20161101_models.CreateLiveMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description    When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
        You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageAppRequest
        @return: CreateLiveMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_message_app_with_options(request, runtime)

    async def create_live_message_app_async(
        self,
        request: live_20161101_models.CreateLiveMessageAppRequest,
    ) -> live_20161101_models.CreateLiveMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description    When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
        You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageAppRequest
        @return: CreateLiveMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_message_app_with_options_async(request, runtime)

    def create_live_message_group_with_options(
        self,
        tmp_req: live_20161101_models.CreateLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveMessageGroupResponse:
        """
        @summary Creates an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
        You can create up to 5,000 interactive messaging groups in an interactive messaging application.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CreateLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.administrators):
            request.administrators_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.administrators, 'Administrators', 'simple')
        query = {}
        if not UtilClient.is_unset(request.administrators_shrink):
            query['Administrators'] = request.administrators_shrink
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.creator_id):
            query['CreatorId'] = request.creator_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_info):
            query['GroupInfo'] = request.group_info
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_message_group_with_options_async(
        self,
        tmp_req: live_20161101_models.CreateLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveMessageGroupResponse:
        """
        @summary Creates an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
        You can create up to 5,000 interactive messaging groups in an interactive messaging application.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CreateLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.administrators):
            request.administrators_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.administrators, 'Administrators', 'simple')
        query = {}
        if not UtilClient.is_unset(request.administrators_shrink):
            query['Administrators'] = request.administrators_shrink
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.creator_id):
            query['CreatorId'] = request.creator_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_info):
            query['GroupInfo'] = request.group_info
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_message_group(
        self,
        request: live_20161101_models.CreateLiveMessageGroupRequest,
    ) -> live_20161101_models.CreateLiveMessageGroupResponse:
        """
        @summary Creates an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
        You can create up to 5,000 interactive messaging groups in an interactive messaging application.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageGroupRequest
        @return: CreateLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_message_group_with_options(request, runtime)

    async def create_live_message_group_async(
        self,
        request: live_20161101_models.CreateLiveMessageGroupRequest,
    ) -> live_20161101_models.CreateLiveMessageGroupResponse:
        """
        @summary Creates an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
        You can create up to 5,000 interactive messaging groups in an interactive messaging application.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveMessageGroupRequest
        @return: CreateLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_message_group_with_options_async(request, runtime)

    def create_live_private_line_with_options(
        self,
        request: live_20161101_models.CreateLivePrivateLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLivePrivateLineResponse:
        """
        @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
        
        @description    You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
        The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePrivateLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLivePrivateLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_area):
            query['AccelerationArea'] = request.acceleration_area
        if not UtilClient.is_unset(request.acceleration_type):
            query['AccelerationType'] = request.acceleration_type
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_bandwidth):
            query['MaxBandwidth'] = request.max_bandwidth
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reuse):
            query['Reuse'] = request.reuse
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_center):
            query['VideoCenter'] = request.video_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLivePrivateLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLivePrivateLineResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_private_line_with_options_async(
        self,
        request: live_20161101_models.CreateLivePrivateLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLivePrivateLineResponse:
        """
        @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
        
        @description    You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
        The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePrivateLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLivePrivateLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_area):
            query['AccelerationArea'] = request.acceleration_area
        if not UtilClient.is_unset(request.acceleration_type):
            query['AccelerationType'] = request.acceleration_type
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.max_bandwidth):
            query['MaxBandwidth'] = request.max_bandwidth
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.reuse):
            query['Reuse'] = request.reuse
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_center):
            query['VideoCenter'] = request.video_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLivePrivateLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLivePrivateLineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_private_line(
        self,
        request: live_20161101_models.CreateLivePrivateLineRequest,
    ) -> live_20161101_models.CreateLivePrivateLineResponse:
        """
        @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
        
        @description    You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
        The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePrivateLineRequest
        @return: CreateLivePrivateLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_private_line_with_options(request, runtime)

    async def create_live_private_line_async(
        self,
        request: live_20161101_models.CreateLivePrivateLineRequest,
    ) -> live_20161101_models.CreateLivePrivateLineResponse:
        """
        @summary Creates a Global Accelerator (GA) instance and binds it to an acceleration circuit.
        
        @description    You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
        The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePrivateLineRequest
        @return: CreateLivePrivateLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_private_line_with_options_async(request, runtime)

    def create_live_pull_to_push_with_options(
        self,
        tmp_req: live_20161101_models.CreateLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLivePullToPushResponse:
        """
        @summary Creates a pulled-stream relay task.
        
        @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
        You can call this operation to create a pulled-stream relay task.
        The pulled source can be a live stream or video-on-demand (VOD) resources.
        After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
        Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
        The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CreateLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLivePullToPushResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLivePullToPushShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.source_urls):
            request.source_urls_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.source_urls, 'SourceUrls', 'json')
        query = {}
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.file_index):
            query['FileIndex'] = request.file_index
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_number):
            query['RepeatNumber'] = request.repeat_number
        if not UtilClient.is_unset(request.retry_count):
            query['RetryCount'] = request.retry_count
        if not UtilClient.is_unset(request.retry_interval):
            query['RetryInterval'] = request.retry_interval
        if not UtilClient.is_unset(request.source_protocol):
            query['SourceProtocol'] = request.source_protocol
        if not UtilClient.is_unset(request.source_type):
            query['SourceType'] = request.source_type
        if not UtilClient.is_unset(request.source_urls_shrink):
            query['SourceUrls'] = request.source_urls_shrink
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_name):
            query['TaskName'] = request.task_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_pull_to_push_with_options_async(
        self,
        tmp_req: live_20161101_models.CreateLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLivePullToPushResponse:
        """
        @summary Creates a pulled-stream relay task.
        
        @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
        You can call this operation to create a pulled-stream relay task.
        The pulled source can be a live stream or video-on-demand (VOD) resources.
        After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
        Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
        The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: CreateLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLivePullToPushResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateLivePullToPushShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.source_urls):
            request.source_urls_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.source_urls, 'SourceUrls', 'json')
        query = {}
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.file_index):
            query['FileIndex'] = request.file_index
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_number):
            query['RepeatNumber'] = request.repeat_number
        if not UtilClient.is_unset(request.retry_count):
            query['RetryCount'] = request.retry_count
        if not UtilClient.is_unset(request.retry_interval):
            query['RetryInterval'] = request.retry_interval
        if not UtilClient.is_unset(request.source_protocol):
            query['SourceProtocol'] = request.source_protocol
        if not UtilClient.is_unset(request.source_type):
            query['SourceType'] = request.source_type
        if not UtilClient.is_unset(request.source_urls_shrink):
            query['SourceUrls'] = request.source_urls_shrink
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_name):
            query['TaskName'] = request.task_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_pull_to_push(
        self,
        request: live_20161101_models.CreateLivePullToPushRequest,
    ) -> live_20161101_models.CreateLivePullToPushResponse:
        """
        @summary Creates a pulled-stream relay task.
        
        @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
        You can call this operation to create a pulled-stream relay task.
        The pulled source can be a live stream or video-on-demand (VOD) resources.
        After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
        Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
        The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePullToPushRequest
        @return: CreateLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_pull_to_push_with_options(request, runtime)

    async def create_live_pull_to_push_async(
        self,
        request: live_20161101_models.CreateLivePullToPushRequest,
    ) -> live_20161101_models.CreateLivePullToPushResponse:
        """
        @summary Creates a pulled-stream relay task.
        
        @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
        You can call this operation to create a pulled-stream relay task.
        The pulled source can be a live stream or video-on-demand (VOD) resources.
        After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
        Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
        The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLivePullToPushRequest
        @return: CreateLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_pull_to_push_with_options_async(request, runtime)

    def create_live_real_time_log_delivery_with_options(
        self,
        request: live_20161101_models.CreateLiveRealTimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveRealTimeLogDeliveryResponse:
        """
        @summary Configures real-time log delivery for a domain name.
        
        @description ##
        Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateLiveRealTimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveRealTimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveRealTimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveRealTimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_real_time_log_delivery_with_options_async(
        self,
        request: live_20161101_models.CreateLiveRealTimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveRealTimeLogDeliveryResponse:
        """
        @summary Configures real-time log delivery for a domain name.
        
        @description ##
        Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateLiveRealTimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveRealTimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveRealTimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveRealTimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_real_time_log_delivery(
        self,
        request: live_20161101_models.CreateLiveRealTimeLogDeliveryRequest,
    ) -> live_20161101_models.CreateLiveRealTimeLogDeliveryResponse:
        """
        @summary Configures real-time log delivery for a domain name.
        
        @description ##
        Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateLiveRealTimeLogDeliveryRequest
        @return: CreateLiveRealTimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_real_time_log_delivery_with_options(request, runtime)

    async def create_live_real_time_log_delivery_async(
        self,
        request: live_20161101_models.CreateLiveRealTimeLogDeliveryRequest,
    ) -> live_20161101_models.CreateLiveRealTimeLogDeliveryResponse:
        """
        @summary Configures real-time log delivery for a domain name.
        
        @description ##
        Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateLiveRealTimeLogDeliveryRequest
        @return: CreateLiveRealTimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_real_time_log_delivery_with_options_async(request, runtime)

    def create_live_stream_monitor_with_options(
        self,
        request: live_20161101_models.CreateLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveStreamMonitorResponse:
        """
        @summary Creates a monitoring session.
        
        @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.ding_talk_web_hook_url):
            query['DingTalkWebHookUrl'] = request.ding_talk_web_hook_url
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.input_list):
            query['InputList'] = request.input_list
        if not UtilClient.is_unset(request.monitor_config):
            query['MonitorConfig'] = request.monitor_config
        if not UtilClient.is_unset(request.monitor_name):
            query['MonitorName'] = request.monitor_name
        if not UtilClient.is_unset(request.output_template):
            query['OutputTemplate'] = request.output_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveStreamMonitorResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_stream_monitor_with_options_async(
        self,
        request: live_20161101_models.CreateLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveStreamMonitorResponse:
        """
        @summary Creates a monitoring session.
        
        @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.ding_talk_web_hook_url):
            query['DingTalkWebHookUrl'] = request.ding_talk_web_hook_url
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.input_list):
            query['InputList'] = request.input_list
        if not UtilClient.is_unset(request.monitor_config):
            query['MonitorConfig'] = request.monitor_config
        if not UtilClient.is_unset(request.monitor_name):
            query['MonitorName'] = request.monitor_name
        if not UtilClient.is_unset(request.output_template):
            query['OutputTemplate'] = request.output_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveStreamMonitorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_stream_monitor(
        self,
        request: live_20161101_models.CreateLiveStreamMonitorRequest,
    ) -> live_20161101_models.CreateLiveStreamMonitorResponse:
        """
        @summary Creates a monitoring session.
        
        @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamMonitorRequest
        @return: CreateLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_stream_monitor_with_options(request, runtime)

    async def create_live_stream_monitor_async(
        self,
        request: live_20161101_models.CreateLiveStreamMonitorRequest,
    ) -> live_20161101_models.CreateLiveStreamMonitorResponse:
        """
        @summary Creates a monitoring session.
        
        @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamMonitorRequest
        @return: CreateLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_stream_monitor_with_options_async(request, runtime)

    def create_live_stream_record_index_files_with_options(
        self,
        request: live_20161101_models.CreateLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveStreamRecordIndexFilesResponse:
        """
        @summary Creates an M3U8 index file for a recording in a specified time period.
        
        @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
        >
        You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
        The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
        ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
        OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
        ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_included):
            query['EndTimeIncluded'] = request.end_time_included
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveStreamRecordIndexFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_live_stream_record_index_files_with_options_async(
        self,
        request: live_20161101_models.CreateLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateLiveStreamRecordIndexFilesResponse:
        """
        @summary Creates an M3U8 index file for a recording in a specified time period.
        
        @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
        >
        You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
        The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
        ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
        OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
        ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_included):
            query['EndTimeIncluded'] = request.end_time_included
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateLiveStreamRecordIndexFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_live_stream_record_index_files(
        self,
        request: live_20161101_models.CreateLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.CreateLiveStreamRecordIndexFilesResponse:
        """
        @summary Creates an M3U8 index file for a recording in a specified time period.
        
        @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
        >
        You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
        The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
        ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
        OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
        ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamRecordIndexFilesRequest
        @return: CreateLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_live_stream_record_index_files_with_options(request, runtime)

    async def create_live_stream_record_index_files_async(
        self,
        request: live_20161101_models.CreateLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.CreateLiveStreamRecordIndexFilesResponse:
        """
        @summary Creates an M3U8 index file for a recording in a specified time period.
        
        @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
        >
        You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
        The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
        ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
        OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
        ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateLiveStreamRecordIndexFilesRequest
        @return: CreateLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_live_stream_record_index_files_with_options_async(request, runtime)

    def create_message_app_with_options(
        self,
        tmp_req: live_20161101_models.CreateMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CreateMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMessageAppResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateMessageAppShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.app_config):
            request.app_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.app_config, 'AppConfig', 'json')
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_config_shrink):
            body['AppConfig'] = request.app_config_shrink
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_message_app_with_options_async(
        self,
        tmp_req: live_20161101_models.CreateMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CreateMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMessageAppResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateMessageAppShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.app_config):
            request.app_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.app_config, 'AppConfig', 'json')
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_config_shrink):
            body['AppConfig'] = request.app_config_shrink
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_message_app(
        self,
        request: live_20161101_models.CreateMessageAppRequest,
    ) -> live_20161101_models.CreateMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateMessageAppRequest
        @return: CreateMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_message_app_with_options(request, runtime)

    async def create_message_app_async(
        self,
        request: live_20161101_models.CreateMessageAppRequest,
    ) -> live_20161101_models.CreateMessageAppResponse:
        """
        @summary Creates an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateMessageAppRequest
        @return: CreateMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_message_app_with_options_async(request, runtime)

    def create_message_group_with_options(
        self,
        tmp_req: live_20161101_models.CreateMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMessageGroupResponse:
        """
        @summary Creates a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CreateMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.creator_id):
            body['CreatorId'] = request.creator_id
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_message_group_with_options_async(
        self,
        tmp_req: live_20161101_models.CreateMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMessageGroupResponse:
        """
        @summary Creates a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: CreateMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.CreateMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.creator_id):
            body['CreatorId'] = request.creator_id
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_message_group(
        self,
        request: live_20161101_models.CreateMessageGroupRequest,
    ) -> live_20161101_models.CreateMessageGroupResponse:
        """
        @summary Creates a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateMessageGroupRequest
        @return: CreateMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_message_group_with_options(request, runtime)

    async def create_message_group_async(
        self,
        request: live_20161101_models.CreateMessageGroupRequest,
    ) -> live_20161101_models.CreateMessageGroupResponse:
        """
        @summary Creates a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateMessageGroupRequest
        @return: CreateMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_message_group_with_options_async(request, runtime)

    def create_mix_stream_with_options(
        self,
        request: live_20161101_models.CreateMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMixStreamResponse:
        """
        @summary Creates a stream mixing task.
        
        @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
        If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.input_stream_list):
            query['InputStreamList'] = request.input_stream_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.output_config):
            query['OutputConfig'] = request.output_config
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMixStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_mix_stream_with_options_async(
        self,
        request: live_20161101_models.CreateMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateMixStreamResponse:
        """
        @summary Creates a stream mixing task.
        
        @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
        If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.input_stream_list):
            query['InputStreamList'] = request.input_stream_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.output_config):
            query['OutputConfig'] = request.output_config
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateMixStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_mix_stream(
        self,
        request: live_20161101_models.CreateMixStreamRequest,
    ) -> live_20161101_models.CreateMixStreamResponse:
        """
        @summary Creates a stream mixing task.
        
        @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
        If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateMixStreamRequest
        @return: CreateMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_mix_stream_with_options(request, runtime)

    async def create_mix_stream_async(
        self,
        request: live_20161101_models.CreateMixStreamRequest,
    ) -> live_20161101_models.CreateMixStreamResponse:
        """
        @summary Creates a stream mixing task.
        
        @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
        If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateMixStreamRequest
        @return: CreateMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_mix_stream_with_options_async(request, runtime)

    def create_rtcwhip_stream_address_with_options(
        self,
        request: live_20161101_models.CreateRTCWhipStreamAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRTCWhipStreamAddressResponse:
        """
        @summary whip
        
        @param request: CreateRTCWhipStreamAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRTCWhipStreamAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.display_name):
            query['DisplayName'] = request.display_name
        if not UtilClient.is_unset(request.expire_time):
            query['ExpireTime'] = request.expire_time
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRTCWhipStreamAddress',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRTCWhipStreamAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_rtcwhip_stream_address_with_options_async(
        self,
        request: live_20161101_models.CreateRTCWhipStreamAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRTCWhipStreamAddressResponse:
        """
        @summary whip
        
        @param request: CreateRTCWhipStreamAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRTCWhipStreamAddressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.display_name):
            query['DisplayName'] = request.display_name
        if not UtilClient.is_unset(request.expire_time):
            query['ExpireTime'] = request.expire_time
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRTCWhipStreamAddress',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRTCWhipStreamAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_rtcwhip_stream_address(
        self,
        request: live_20161101_models.CreateRTCWhipStreamAddressRequest,
    ) -> live_20161101_models.CreateRTCWhipStreamAddressResponse:
        """
        @summary whip
        
        @param request: CreateRTCWhipStreamAddressRequest
        @return: CreateRTCWhipStreamAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_rtcwhip_stream_address_with_options(request, runtime)

    async def create_rtcwhip_stream_address_async(
        self,
        request: live_20161101_models.CreateRTCWhipStreamAddressRequest,
    ) -> live_20161101_models.CreateRTCWhipStreamAddressResponse:
        """
        @summary whip
        
        @param request: CreateRTCWhipStreamAddressRequest
        @return: CreateRTCWhipStreamAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_rtcwhip_stream_address_with_options_async(request, runtime)

    def create_room_real_time_stream_address_with_options(
        self,
        request: live_20161101_models.CreateRoomRealTimeStreamAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRoomRealTimeStreamAddressResponse:
        """
        @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
        
        @description ### [](#)Usage notes
        To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
        ## [](#)Procedure
        1.  Call this operation to generate an ingest URL in the RTMP format.
        2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
        3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
        >
        You can repeat Steps 2 and 3 within the validity period of the ingest URL.
        We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateRoomRealTimeStreamAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRoomRealTimeStreamAddressResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRoomRealTimeStreamAddress',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRoomRealTimeStreamAddressResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_room_real_time_stream_address_with_options_async(
        self,
        request: live_20161101_models.CreateRoomRealTimeStreamAddressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRoomRealTimeStreamAddressResponse:
        """
        @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
        
        @description ### [](#)Usage notes
        To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
        ## [](#)Procedure
        1.  Call this operation to generate an ingest URL in the RTMP format.
        2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
        3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
        >
        You can repeat Steps 2 and 3 within the validity period of the ingest URL.
        We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateRoomRealTimeStreamAddressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRoomRealTimeStreamAddressResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRoomRealTimeStreamAddress',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRoomRealTimeStreamAddressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_room_real_time_stream_address(
        self,
        request: live_20161101_models.CreateRoomRealTimeStreamAddressRequest,
    ) -> live_20161101_models.CreateRoomRealTimeStreamAddressResponse:
        """
        @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
        
        @description ### [](#)Usage notes
        To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
        ## [](#)Procedure
        1.  Call this operation to generate an ingest URL in the RTMP format.
        2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
        3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
        >
        You can repeat Steps 2 and 3 within the validity period of the ingest URL.
        We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateRoomRealTimeStreamAddressRequest
        @return: CreateRoomRealTimeStreamAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_room_real_time_stream_address_with_options(request, runtime)

    async def create_room_real_time_stream_address_async(
        self,
        request: live_20161101_models.CreateRoomRealTimeStreamAddressRequest,
    ) -> live_20161101_models.CreateRoomRealTimeStreamAddressResponse:
        """
        @summary Creates a Real-Time Messaging Protocol (RTMP) ingest URL for a channel.
        
        @description ### [](#)Usage notes
        To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
        ## [](#)Procedure
        1.  Call this operation to generate an ingest URL in the RTMP format.
        2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
        3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
        >
        You can repeat Steps 2 and 3 within the validity period of the ingest URL.
        We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: CreateRoomRealTimeStreamAddressRequest
        @return: CreateRoomRealTimeStreamAddressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_room_real_time_stream_address_with_options_async(request, runtime)

    def create_rtc_asr_task_with_options(
        self,
        request: live_20161101_models.CreateRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRtcAsrTaskResponse:
        """
        @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
        
        @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.auto_terminate_delay):
            query['AutoTerminateDelay'] = request.auto_terminate_delay
        if not UtilClient.is_unset(request.auto_terminate_enabled):
            query['AutoTerminateEnabled'] = request.auto_terminate_enabled
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackURL'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelID'] = request.channel_id
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_interval):
            query['ReportInterval'] = request.report_interval
        if not UtilClient.is_unset(request.rtc_user_id):
            query['RtcUserId'] = request.rtc_user_id
        if not UtilClient.is_unset(request.sdkapp_id):
            query['SDKAppID'] = request.sdkapp_id
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.target_languages):
            query['TargetLanguages'] = request.target_languages
        if not UtilClient.is_unset(request.translate_enabled):
            query['TranslateEnabled'] = request.translate_enabled
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRtcAsrTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_rtc_asr_task_with_options_async(
        self,
        request: live_20161101_models.CreateRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRtcAsrTaskResponse:
        """
        @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
        
        @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.auto_terminate_delay):
            query['AutoTerminateDelay'] = request.auto_terminate_delay
        if not UtilClient.is_unset(request.auto_terminate_enabled):
            query['AutoTerminateEnabled'] = request.auto_terminate_enabled
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackURL'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelID'] = request.channel_id
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.report_interval):
            query['ReportInterval'] = request.report_interval
        if not UtilClient.is_unset(request.rtc_user_id):
            query['RtcUserId'] = request.rtc_user_id
        if not UtilClient.is_unset(request.sdkapp_id):
            query['SDKAppID'] = request.sdkapp_id
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.target_languages):
            query['TargetLanguages'] = request.target_languages
        if not UtilClient.is_unset(request.translate_enabled):
            query['TranslateEnabled'] = request.translate_enabled
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRtcAsrTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_rtc_asr_task(
        self,
        request: live_20161101_models.CreateRtcAsrTaskRequest,
    ) -> live_20161101_models.CreateRtcAsrTaskResponse:
        """
        @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
        
        @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcAsrTaskRequest
        @return: CreateRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_rtc_asr_task_with_options(request, runtime)

    async def create_rtc_asr_task_async(
        self,
        request: live_20161101_models.CreateRtcAsrTaskRequest,
    ) -> live_20161101_models.CreateRtcAsrTaskResponse:
        """
        @summary Creates a live subtitle task to transcribe an audio stream to text in real time.
        
        @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcAsrTaskRequest
        @return: CreateRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_rtc_asr_task_with_options_async(request, runtime)

    def create_rtc_mpuevent_sub_with_options(
        self,
        request: live_20161101_models.CreateRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRtcMPUEventSubResponse:
        """
        @summary Creates a subscription to mixed-stream relay events.
        
        @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_ids):
            query['ChannelIds'] = request.channel_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRtcMPUEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_rtc_mpuevent_sub_with_options_async(
        self,
        request: live_20161101_models.CreateRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.CreateRtcMPUEventSubResponse:
        """
        @summary Creates a subscription to mixed-stream relay events.
        
        @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_ids):
            query['ChannelIds'] = request.channel_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.CreateRtcMPUEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_rtc_mpuevent_sub(
        self,
        request: live_20161101_models.CreateRtcMPUEventSubRequest,
    ) -> live_20161101_models.CreateRtcMPUEventSubResponse:
        """
        @summary Creates a subscription to mixed-stream relay events.
        
        @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcMPUEventSubRequest
        @return: CreateRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_rtc_mpuevent_sub_with_options(request, runtime)

    async def create_rtc_mpuevent_sub_async(
        self,
        request: live_20161101_models.CreateRtcMPUEventSubRequest,
    ) -> live_20161101_models.CreateRtcMPUEventSubResponse:
        """
        @summary Creates a subscription to mixed-stream relay events.
        
        @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: CreateRtcMPUEventSubRequest
        @return: CreateRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_rtc_mpuevent_sub_with_options_async(request, runtime)

    def delete_caster_with_options(
        self,
        request: live_20161101_models.DeleteCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterResponse:
        """
        @summary Deletes a production studio.
        
        @description    You can delete only production studios that are closed.
        When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
        You cannot recover a deleted production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterResponse:
        """
        @summary Deletes a production studio.
        
        @description    You can delete only production studios that are closed.
        When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
        You cannot recover a deleted production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster(
        self,
        request: live_20161101_models.DeleteCasterRequest,
    ) -> live_20161101_models.DeleteCasterResponse:
        """
        @summary Deletes a production studio.
        
        @description    You can delete only production studios that are closed.
        When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
        You cannot recover a deleted production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterRequest
        @return: DeleteCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_with_options(request, runtime)

    async def delete_caster_async(
        self,
        request: live_20161101_models.DeleteCasterRequest,
    ) -> live_20161101_models.DeleteCasterResponse:
        """
        @summary Deletes a production studio.
        
        @description    You can delete only production studios that are closed.
        When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
        You cannot recover a deleted production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterRequest
        @return: DeleteCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_with_options_async(request, runtime)

    def delete_caster_component_with_options(
        self,
        request: live_20161101_models.DeleteCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterComponentResponse:
        """
        @summary Deletes a component in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterComponentResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_component_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterComponentResponse:
        """
        @summary Deletes a component in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterComponentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_component(
        self,
        request: live_20161101_models.DeleteCasterComponentRequest,
    ) -> live_20161101_models.DeleteCasterComponentResponse:
        """
        @summary Deletes a component in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterComponentRequest
        @return: DeleteCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_component_with_options(request, runtime)

    async def delete_caster_component_async(
        self,
        request: live_20161101_models.DeleteCasterComponentRequest,
    ) -> live_20161101_models.DeleteCasterComponentResponse:
        """
        @summary Deletes a component in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterComponentRequest
        @return: DeleteCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_component_with_options_async(request, runtime)

    def delete_caster_episode_with_options(
        self,
        request: live_20161101_models.DeleteCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterEpisodeResponse:
        """
        @summary Deletes an episode in a production studio.
        
        @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterEpisodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_episode_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterEpisodeResponse:
        """
        @summary Deletes an episode in a production studio.
        
        @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterEpisodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_episode(
        self,
        request: live_20161101_models.DeleteCasterEpisodeRequest,
    ) -> live_20161101_models.DeleteCasterEpisodeResponse:
        """
        @summary Deletes an episode in a production studio.
        
        @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeRequest
        @return: DeleteCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_episode_with_options(request, runtime)

    async def delete_caster_episode_async(
        self,
        request: live_20161101_models.DeleteCasterEpisodeRequest,
    ) -> live_20161101_models.DeleteCasterEpisodeResponse:
        """
        @summary Deletes an episode in a production studio.
        
        @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeRequest
        @return: DeleteCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_episode_with_options_async(request, runtime)

    def delete_caster_episode_group_with_options(
        self,
        request: live_20161101_models.DeleteCasterEpisodeGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterEpisodeGroupResponse:
        """
        @summary Deletes an episode list in a production studio.
        
        @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterEpisodeGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterEpisodeGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterEpisodeGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_episode_group_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterEpisodeGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterEpisodeGroupResponse:
        """
        @summary Deletes an episode list in a production studio.
        
        @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterEpisodeGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterEpisodeGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterEpisodeGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_episode_group(
        self,
        request: live_20161101_models.DeleteCasterEpisodeGroupRequest,
    ) -> live_20161101_models.DeleteCasterEpisodeGroupResponse:
        """
        @summary Deletes an episode list in a production studio.
        
        @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeGroupRequest
        @return: DeleteCasterEpisodeGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_episode_group_with_options(request, runtime)

    async def delete_caster_episode_group_async(
        self,
        request: live_20161101_models.DeleteCasterEpisodeGroupRequest,
    ) -> live_20161101_models.DeleteCasterEpisodeGroupResponse:
        """
        @summary Deletes an episode list in a production studio.
        
        @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterEpisodeGroupRequest
        @return: DeleteCasterEpisodeGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_episode_group_with_options_async(request, runtime)

    def delete_caster_layout_with_options(
        self,
        request: live_20161101_models.DeleteCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterLayoutResponse:
        """
        @summary Deletes a layout in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_layout_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterLayoutResponse:
        """
        @summary Deletes a layout in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_layout(
        self,
        request: live_20161101_models.DeleteCasterLayoutRequest,
    ) -> live_20161101_models.DeleteCasterLayoutResponse:
        """
        @summary Deletes a layout in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterLayoutRequest
        @return: DeleteCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_layout_with_options(request, runtime)

    async def delete_caster_layout_async(
        self,
        request: live_20161101_models.DeleteCasterLayoutRequest,
    ) -> live_20161101_models.DeleteCasterLayoutResponse:
        """
        @summary Deletes a layout in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterLayoutRequest
        @return: DeleteCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_layout_with_options_async(request, runtime)

    def delete_caster_program_with_options(
        self,
        request: live_20161101_models.DeleteCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterProgramResponse:
        """
        @summary Deletes the episode list for carousel playback in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterProgramResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_program_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterProgramResponse:
        """
        @summary Deletes the episode list for carousel playback in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterProgramResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_program(
        self,
        request: live_20161101_models.DeleteCasterProgramRequest,
    ) -> live_20161101_models.DeleteCasterProgramResponse:
        """
        @summary Deletes the episode list for carousel playback in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterProgramRequest
        @return: DeleteCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_program_with_options(request, runtime)

    async def delete_caster_program_async(
        self,
        request: live_20161101_models.DeleteCasterProgramRequest,
    ) -> live_20161101_models.DeleteCasterProgramResponse:
        """
        @summary Deletes the episode list for carousel playback in a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCasterProgramRequest
        @return: DeleteCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_program_with_options_async(request, runtime)

    def delete_caster_scene_config_with_options(
        self,
        request: live_20161101_models.DeleteCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterSceneConfigResponse:
        """
        @summary Deletes the settings of a scene.
        
        @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterSceneConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_scene_config_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterSceneConfigResponse:
        """
        @summary Deletes the settings of a scene.
        
        @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterSceneConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_scene_config(
        self,
        request: live_20161101_models.DeleteCasterSceneConfigRequest,
    ) -> live_20161101_models.DeleteCasterSceneConfigResponse:
        """
        @summary Deletes the settings of a scene.
        
        @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterSceneConfigRequest
        @return: DeleteCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_scene_config_with_options(request, runtime)

    async def delete_caster_scene_config_async(
        self,
        request: live_20161101_models.DeleteCasterSceneConfigRequest,
    ) -> live_20161101_models.DeleteCasterSceneConfigResponse:
        """
        @summary Deletes the settings of a scene.
        
        @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterSceneConfigRequest
        @return: DeleteCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_scene_config_with_options_async(request, runtime)

    def delete_caster_video_resource_with_options(
        self,
        request: live_20161101_models.DeleteCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterVideoResourceResponse:
        """
        @summary Removes an input source from a production studio.
        
        @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterVideoResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_caster_video_resource_with_options_async(
        self,
        request: live_20161101_models.DeleteCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCasterVideoResourceResponse:
        """
        @summary Removes an input source from a production studio.
        
        @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCasterVideoResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_caster_video_resource(
        self,
        request: live_20161101_models.DeleteCasterVideoResourceRequest,
    ) -> live_20161101_models.DeleteCasterVideoResourceResponse:
        """
        @summary Removes an input source from a production studio.
        
        @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterVideoResourceRequest
        @return: DeleteCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_caster_video_resource_with_options(request, runtime)

    async def delete_caster_video_resource_async(
        self,
        request: live_20161101_models.DeleteCasterVideoResourceRequest,
    ) -> live_20161101_models.DeleteCasterVideoResourceResponse:
        """
        @summary Removes an input source from a production studio.
        
        @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteCasterVideoResourceRequest
        @return: DeleteCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_caster_video_resource_with_options_async(request, runtime)

    def delete_channel_with_options(
        self,
        request: live_20161101_models.DeleteChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteChannelResponse:
        """
        @summary Deletes a channel.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteChannel',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteChannelResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_channel_with_options_async(
        self,
        request: live_20161101_models.DeleteChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteChannelResponse:
        """
        @summary Deletes a channel.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteChannel',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteChannelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_channel(
        self,
        request: live_20161101_models.DeleteChannelRequest,
    ) -> live_20161101_models.DeleteChannelResponse:
        """
        @summary Deletes a channel.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteChannelRequest
        @return: DeleteChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_channel_with_options(request, runtime)

    async def delete_channel_async(
        self,
        request: live_20161101_models.DeleteChannelRequest,
    ) -> live_20161101_models.DeleteChannelResponse:
        """
        @summary Deletes a channel.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteChannelRequest
        @return: DeleteChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_channel_with_options_async(request, runtime)

    def delete_custom_template_with_options(
        self,
        request: live_20161101_models.DeleteCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCustomTemplateResponse:
        """
        @summary Deletes a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCustomTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_custom_template_with_options_async(
        self,
        request: live_20161101_models.DeleteCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteCustomTemplateResponse:
        """
        @summary Deletes a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteCustomTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_custom_template(
        self,
        request: live_20161101_models.DeleteCustomTemplateRequest,
    ) -> live_20161101_models.DeleteCustomTemplateResponse:
        """
        @summary Deletes a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCustomTemplateRequest
        @return: DeleteCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_custom_template_with_options(request, runtime)

    async def delete_custom_template_async(
        self,
        request: live_20161101_models.DeleteCustomTemplateRequest,
    ) -> live_20161101_models.DeleteCustomTemplateResponse:
        """
        @summary Deletes a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteCustomTemplateRequest
        @return: DeleteCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_custom_template_with_options_async(request, runtime)

    def delete_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.DeleteEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteEdgeTranscodeJobResponse:
        """
        @summary Deletes an edge transcoding task.
        
        @description    You can call this operation to delete an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.DeleteEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteEdgeTranscodeJobResponse:
        """
        @summary Deletes an edge transcoding task.
        
        @description    You can call this operation to delete an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_edge_transcode_job(
        self,
        request: live_20161101_models.DeleteEdgeTranscodeJobRequest,
    ) -> live_20161101_models.DeleteEdgeTranscodeJobResponse:
        """
        @summary Deletes an edge transcoding task.
        
        @description    You can call this operation to delete an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEdgeTranscodeJobRequest
        @return: DeleteEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_edge_transcode_job_with_options(request, runtime)

    async def delete_edge_transcode_job_async(
        self,
        request: live_20161101_models.DeleteEdgeTranscodeJobRequest,
    ) -> live_20161101_models.DeleteEdgeTranscodeJobResponse:
        """
        @summary Deletes an edge transcoding task.
        
        @description    You can call this operation to delete an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEdgeTranscodeJobRequest
        @return: DeleteEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_edge_transcode_job_with_options_async(request, runtime)

    def delete_event_sub_with_options(
        self,
        request: live_20161101_models.DeleteEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteEventSubResponse:
        """
        @summary Deletes a callback that is used to subscribe to channel or user events.
        
        @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.subscribe_id):
            query['SubscribeId'] = request.subscribe_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_event_sub_with_options_async(
        self,
        request: live_20161101_models.DeleteEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteEventSubResponse:
        """
        @summary Deletes a callback that is used to subscribe to channel or user events.
        
        @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.subscribe_id):
            query['SubscribeId'] = request.subscribe_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_event_sub(
        self,
        request: live_20161101_models.DeleteEventSubRequest,
    ) -> live_20161101_models.DeleteEventSubResponse:
        """
        @summary Deletes a callback that is used to subscribe to channel or user events.
        
        @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEventSubRequest
        @return: DeleteEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_event_sub_with_options(request, runtime)

    async def delete_event_sub_async(
        self,
        request: live_20161101_models.DeleteEventSubRequest,
    ) -> live_20161101_models.DeleteEventSubResponse:
        """
        @summary Deletes a callback that is used to subscribe to channel or user events.
        
        @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteEventSubRequest
        @return: DeleteEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_event_sub_with_options_async(request, runtime)

    def delete_live_aiproduce_rules_with_options(
        self,
        request: live_20161101_models.DeleteLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAIProduceRulesResponse:
        """
        @summary Deletes a subtitle rule.
        
        @description You can call this operation to delete a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.suffix_name):
            query['SuffixName'] = request.suffix_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAIProduceRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_aiproduce_rules_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAIProduceRulesResponse:
        """
        @summary Deletes a subtitle rule.
        
        @description You can call this operation to delete a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.suffix_name):
            query['SuffixName'] = request.suffix_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAIProduceRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_aiproduce_rules(
        self,
        request: live_20161101_models.DeleteLiveAIProduceRulesRequest,
    ) -> live_20161101_models.DeleteLiveAIProduceRulesResponse:
        """
        @summary Deletes a subtitle rule.
        
        @description You can call this operation to delete a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAIProduceRulesRequest
        @return: DeleteLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_aiproduce_rules_with_options(request, runtime)

    async def delete_live_aiproduce_rules_async(
        self,
        request: live_20161101_models.DeleteLiveAIProduceRulesRequest,
    ) -> live_20161101_models.DeleteLiveAIProduceRulesResponse:
        """
        @summary Deletes a subtitle rule.
        
        @description You can call this operation to delete a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAIProduceRulesRequest
        @return: DeleteLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_aiproduce_rules_with_options_async(request, runtime)

    def delete_live_aistudio_with_options(
        self,
        request: live_20161101_models.DeleteLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAIStudioResponse:
        """
        @summary Deletes a virtual studio template.
        
        @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
        >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: DeleteLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAIStudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_id):
            query['StudioId'] = request.studio_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAIStudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_aistudio_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAIStudioResponse:
        """
        @summary Deletes a virtual studio template.
        
        @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
        >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: DeleteLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAIStudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_id):
            query['StudioId'] = request.studio_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAIStudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_aistudio(
        self,
        request: live_20161101_models.DeleteLiveAIStudioRequest,
    ) -> live_20161101_models.DeleteLiveAIStudioResponse:
        """
        @summary Deletes a virtual studio template.
        
        @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
        >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: DeleteLiveAIStudioRequest
        @return: DeleteLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_aistudio_with_options(request, runtime)

    async def delete_live_aistudio_async(
        self,
        request: live_20161101_models.DeleteLiveAIStudioRequest,
    ) -> live_20161101_models.DeleteLiveAIStudioResponse:
        """
        @summary Deletes a virtual studio template.
        
        @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
        >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
        
        @param request: DeleteLiveAIStudioRequest
        @return: DeleteLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_aistudio_with_options_async(request, runtime)

    def delete_live_aisubtitle_with_options(
        self,
        request: live_20161101_models.DeleteLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAISubtitleResponse:
        """
        @summary Deletes a specified subtitle template.
        
        @description You can call this operation to delete a specified subtitle template for live streaming.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAISubtitleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAISubtitleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_aisubtitle_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAISubtitleResponse:
        """
        @summary Deletes a specified subtitle template.
        
        @description You can call this operation to delete a specified subtitle template for live streaming.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAISubtitleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAISubtitleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_aisubtitle(
        self,
        request: live_20161101_models.DeleteLiveAISubtitleRequest,
    ) -> live_20161101_models.DeleteLiveAISubtitleResponse:
        """
        @summary Deletes a specified subtitle template.
        
        @description You can call this operation to delete a specified subtitle template for live streaming.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAISubtitleRequest
        @return: DeleteLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_aisubtitle_with_options(request, runtime)

    async def delete_live_aisubtitle_async(
        self,
        request: live_20161101_models.DeleteLiveAISubtitleRequest,
    ) -> live_20161101_models.DeleteLiveAISubtitleResponse:
        """
        @summary Deletes a specified subtitle template.
        
        @description You can call this operation to delete a specified subtitle template for live streaming.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAISubtitleRequest
        @return: DeleteLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_aisubtitle_with_options_async(request, runtime)

    def delete_live_app_record_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAppRecordConfigResponse:
        """
        @summary Deletes a recording configuration at the application level.
        
        @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAppRecordConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_app_record_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAppRecordConfigResponse:
        """
        @summary Deletes a recording configuration at the application level.
        
        @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAppRecordConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_app_record_config(
        self,
        request: live_20161101_models.DeleteLiveAppRecordConfigRequest,
    ) -> live_20161101_models.DeleteLiveAppRecordConfigResponse:
        """
        @summary Deletes a recording configuration at the application level.
        
        @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppRecordConfigRequest
        @return: DeleteLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_app_record_config_with_options(request, runtime)

    async def delete_live_app_record_config_async(
        self,
        request: live_20161101_models.DeleteLiveAppRecordConfigRequest,
    ) -> live_20161101_models.DeleteLiveAppRecordConfigResponse:
        """
        @summary Deletes a recording configuration at the application level.
        
        @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppRecordConfigRequest
        @return: DeleteLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_app_record_config_with_options_async(request, runtime)

    def delete_live_app_snapshot_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAppSnapshotConfigResponse:
        """
        @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        
        @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAppSnapshotConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_app_snapshot_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAppSnapshotConfigResponse:
        """
        @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        
        @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAppSnapshotConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_app_snapshot_config(
        self,
        request: live_20161101_models.DeleteLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.DeleteLiveAppSnapshotConfigResponse:
        """
        @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        
        @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppSnapshotConfigRequest
        @return: DeleteLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_app_snapshot_config_with_options(request, runtime)

    async def delete_live_app_snapshot_config_async(
        self,
        request: live_20161101_models.DeleteLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.DeleteLiveAppSnapshotConfigResponse:
        """
        @summary Deletes the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        
        @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAppSnapshotConfigRequest
        @return: DeleteLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_app_snapshot_config_with_options_async(request, runtime)

    def delete_live_audio_audit_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAudioAuditConfigResponse:
        """
        @summary Deletes an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAudioAuditConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_audio_audit_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAudioAuditConfigResponse:
        """
        @summary Deletes an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAudioAuditConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_audio_audit_config(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.DeleteLiveAudioAuditConfigResponse:
        """
        @summary Deletes an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAudioAuditConfigRequest
        @return: DeleteLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_audio_audit_config_with_options(request, runtime)

    async def delete_live_audio_audit_config_async(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.DeleteLiveAudioAuditConfigResponse:
        """
        @summary Deletes an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveAudioAuditConfigRequest
        @return: DeleteLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_audio_audit_config_with_options_async(request, runtime)

    def delete_live_audio_audit_notify_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_audio_audit_notify_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_audio_audit_notify_config(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAudioAuditNotifyConfigRequest
        @return: DeleteLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_audio_audit_notify_config_with_options(request, runtime)

    async def delete_live_audio_audit_notify_config_async(
        self,
        request: live_20161101_models.DeleteLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveAudioAuditNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveAudioAuditNotifyConfigRequest
        @return: DeleteLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_audio_audit_notify_config_with_options_async(request, runtime)

    def delete_live_center_transfer_with_options(
        self,
        request: live_20161101_models.DeleteLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveCenterTransferResponse:
        """
        @summary Deletes a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveCenterTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_center_transfer_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveCenterTransferResponse:
        """
        @summary Deletes a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveCenterTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_center_transfer(
        self,
        request: live_20161101_models.DeleteLiveCenterTransferRequest,
    ) -> live_20161101_models.DeleteLiveCenterTransferResponse:
        """
        @summary Deletes a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveCenterTransferRequest
        @return: DeleteLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_center_transfer_with_options(request, runtime)

    async def delete_live_center_transfer_async(
        self,
        request: live_20161101_models.DeleteLiveCenterTransferRequest,
    ) -> live_20161101_models.DeleteLiveCenterTransferResponse:
        """
        @summary Deletes a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveCenterTransferRequest
        @return: DeleteLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_center_transfer_with_options_async(request, runtime)

    def delete_live_delay_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDelayConfigResponse:
        """
        @summary Deletes a stream delay configuration.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_delay_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDelayConfigResponse:
        """
        @summary Deletes a stream delay configuration.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_delay_config(
        self,
        request: live_20161101_models.DeleteLiveDelayConfigRequest,
    ) -> live_20161101_models.DeleteLiveDelayConfigResponse:
        """
        @summary Deletes a stream delay configuration.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDelayConfigRequest
        @return: DeleteLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_delay_config_with_options(request, runtime)

    async def delete_live_delay_config_async(
        self,
        request: live_20161101_models.DeleteLiveDelayConfigRequest,
    ) -> live_20161101_models.DeleteLiveDelayConfigResponse:
        """
        @summary Deletes a stream delay configuration.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDelayConfigRequest
        @return: DeleteLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_delay_config_with_options_async(request, runtime)

    def delete_live_detect_notify_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDetectNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for video moderation results.
        
        @description ## [](#)Usage notes
        Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDetectNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_detect_notify_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDetectNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for video moderation results.
        
        @description ## [](#)Usage notes
        Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDetectNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_detect_notify_config(
        self,
        request: live_20161101_models.DeleteLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveDetectNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for video moderation results.
        
        @description ## [](#)Usage notes
        Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDetectNotifyConfigRequest
        @return: DeleteLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_detect_notify_config_with_options(request, runtime)

    async def delete_live_detect_notify_config_async(
        self,
        request: live_20161101_models.DeleteLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveDetectNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for video moderation results.
        
        @description ## [](#)Usage notes
        Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDetectNotifyConfigRequest
        @return: DeleteLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_detect_notify_config_with_options_async(request, runtime)

    def delete_live_domain_with_options(
        self,
        request: live_20161101_models.DeleteLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainResponse:
        """
        @summary Removes a domain name from ApsaraVideo Live.
        
        @description    After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
        We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
        If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_domain_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainResponse:
        """
        @summary Removes a domain name from ApsaraVideo Live.
        
        @description    After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
        We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
        If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_domain(
        self,
        request: live_20161101_models.DeleteLiveDomainRequest,
    ) -> live_20161101_models.DeleteLiveDomainResponse:
        """
        @summary Removes a domain name from ApsaraVideo Live.
        
        @description    After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
        We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
        If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainRequest
        @return: DeleteLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_domain_with_options(request, runtime)

    async def delete_live_domain_async(
        self,
        request: live_20161101_models.DeleteLiveDomainRequest,
    ) -> live_20161101_models.DeleteLiveDomainResponse:
        """
        @summary Removes a domain name from ApsaraVideo Live.
        
        @description    After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
        We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
        If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainRequest
        @return: DeleteLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_domain_with_options_async(request, runtime)

    def delete_live_domain_mapping_with_options(
        self,
        request: live_20161101_models.DeleteLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainMappingResponse:
        """
        @summary Deletes the mapping between a streaming domain and an ingest domain.
        
        @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainMappingResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_domain_mapping_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainMappingResponse:
        """
        @summary Deletes the mapping between a streaming domain and an ingest domain.
        
        @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainMappingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_domain_mapping(
        self,
        request: live_20161101_models.DeleteLiveDomainMappingRequest,
    ) -> live_20161101_models.DeleteLiveDomainMappingResponse:
        """
        @summary Deletes the mapping between a streaming domain and an ingest domain.
        
        @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainMappingRequest
        @return: DeleteLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_domain_mapping_with_options(request, runtime)

    async def delete_live_domain_mapping_async(
        self,
        request: live_20161101_models.DeleteLiveDomainMappingRequest,
    ) -> live_20161101_models.DeleteLiveDomainMappingResponse:
        """
        @summary Deletes the mapping between a streaming domain and an ingest domain.
        
        @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveDomainMappingRequest
        @return: DeleteLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_domain_mapping_with_options_async(request, runtime)

    def delete_live_domain_play_mapping_with_options(
        self,
        request: live_20161101_models.DeleteLiveDomainPlayMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainPlayMappingResponse:
        """
        @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
        
        @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDomainPlayMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainPlayMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_domain):
            query['PlayDomain'] = request.play_domain
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomainPlayMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainPlayMappingResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_domain_play_mapping_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveDomainPlayMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveDomainPlayMappingResponse:
        """
        @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
        
        @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDomainPlayMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveDomainPlayMappingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_domain):
            query['PlayDomain'] = request.play_domain
        if not UtilClient.is_unset(request.pull_domain):
            query['PullDomain'] = request.pull_domain
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveDomainPlayMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveDomainPlayMappingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_domain_play_mapping(
        self,
        request: live_20161101_models.DeleteLiveDomainPlayMappingRequest,
    ) -> live_20161101_models.DeleteLiveDomainPlayMappingResponse:
        """
        @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
        
        @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDomainPlayMappingRequest
        @return: DeleteLiveDomainPlayMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_domain_play_mapping_with_options(request, runtime)

    async def delete_live_domain_play_mapping_async(
        self,
        request: live_20161101_models.DeleteLiveDomainPlayMappingRequest,
    ) -> live_20161101_models.DeleteLiveDomainPlayMappingResponse:
        """
        @summary Deletes the mapping between a main streaming domain and a sub-streaming domain.
        
        @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveDomainPlayMappingRequest
        @return: DeleteLiveDomainPlayMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_domain_play_mapping_with_options_async(request, runtime)

    def delete_live_edge_transfer_with_options(
        self,
        request: live_20161101_models.DeleteLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveEdgeTransferResponse:
        """
        @summary Deletes the configuration of edge stream relay.
        
        @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
        |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
        |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveEdgeTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_edge_transfer_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveEdgeTransferResponse:
        """
        @summary Deletes the configuration of edge stream relay.
        
        @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
        |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
        |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveEdgeTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_edge_transfer(
        self,
        request: live_20161101_models.DeleteLiveEdgeTransferRequest,
    ) -> live_20161101_models.DeleteLiveEdgeTransferResponse:
        """
        @summary Deletes the configuration of edge stream relay.
        
        @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
        |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
        |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveEdgeTransferRequest
        @return: DeleteLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_edge_transfer_with_options(request, runtime)

    async def delete_live_edge_transfer_async(
        self,
        request: live_20161101_models.DeleteLiveEdgeTransferRequest,
    ) -> live_20161101_models.DeleteLiveEdgeTransferResponse:
        """
        @summary Deletes the configuration of edge stream relay.
        
        @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
        |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
        |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveEdgeTransferRequest
        @return: DeleteLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_edge_transfer_with_options_async(request, runtime)

    def delete_live_lazy_pull_stream_info_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveLazyPullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Deletes a configuration of triggered stream pulling.
        
        @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveLazyPullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveLazyPullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveLazyPullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_lazy_pull_stream_info_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveLazyPullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Deletes a configuration of triggered stream pulling.
        
        @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveLazyPullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveLazyPullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveLazyPullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_lazy_pull_stream_info_config(
        self,
        request: live_20161101_models.DeleteLiveLazyPullStreamInfoConfigRequest,
    ) -> live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Deletes a configuration of triggered stream pulling.
        
        @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveLazyPullStreamInfoConfigRequest
        @return: DeleteLiveLazyPullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_lazy_pull_stream_info_config_with_options(request, runtime)

    async def delete_live_lazy_pull_stream_info_config_async(
        self,
        request: live_20161101_models.DeleteLiveLazyPullStreamInfoConfigRequest,
    ) -> live_20161101_models.DeleteLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Deletes a configuration of triggered stream pulling.
        
        @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveLazyPullStreamInfoConfigRequest
        @return: DeleteLiveLazyPullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_lazy_pull_stream_info_config_with_options_async(request, runtime)

    def delete_live_message_group_with_options(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageGroupResponse:
        """
        @summary Deletes an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
        After you delete an interactive messaging group, messages in the group are retained for 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_id):
            query['OperatorId'] = request.operator_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_message_group_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageGroupResponse:
        """
        @summary Deletes an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
        After you delete an interactive messaging group, messages in the group are retained for 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_id):
            query['OperatorId'] = request.operator_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_message_group(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupRequest,
    ) -> live_20161101_models.DeleteLiveMessageGroupResponse:
        """
        @summary Deletes an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
        After you delete an interactive messaging group, messages in the group are retained for 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupRequest
        @return: DeleteLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_message_group_with_options(request, runtime)

    async def delete_live_message_group_async(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupRequest,
    ) -> live_20161101_models.DeleteLiveMessageGroupResponse:
        """
        @summary Deletes an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
        After you delete an interactive messaging group, messages in the group are retained for 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupRequest
        @return: DeleteLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_message_group_with_options_async(request, runtime)

    def delete_live_message_group_message_with_options(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageGroupMessageResponse:
        """
        @summary Deletes a message that was sent to an interactive messaging group.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageGroupMessageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.deleter_id):
            query['DeleterId'] = request.deleter_id
        if not UtilClient.is_unset(request.deleter_info):
            query['DeleterInfo'] = request.deleter_info
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.message_id):
            query['MessageId'] = request.message_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageGroupMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageGroupMessageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_message_group_message_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageGroupMessageResponse:
        """
        @summary Deletes a message that was sent to an interactive messaging group.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageGroupMessageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.deleter_id):
            query['DeleterId'] = request.deleter_id
        if not UtilClient.is_unset(request.deleter_info):
            query['DeleterInfo'] = request.deleter_info
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.message_id):
            query['MessageId'] = request.message_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageGroupMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageGroupMessageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_message_group_message(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupMessageRequest,
    ) -> live_20161101_models.DeleteLiveMessageGroupMessageResponse:
        """
        @summary Deletes a message that was sent to an interactive messaging group.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupMessageRequest
        @return: DeleteLiveMessageGroupMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_message_group_message_with_options(request, runtime)

    async def delete_live_message_group_message_async(
        self,
        request: live_20161101_models.DeleteLiveMessageGroupMessageRequest,
    ) -> live_20161101_models.DeleteLiveMessageGroupMessageResponse:
        """
        @summary Deletes a message that was sent to an interactive messaging group.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveMessageGroupMessageRequest
        @return: DeleteLiveMessageGroupMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_message_group_message_with_options_async(request, runtime)

    def delete_live_message_user_message_with_options(
        self,
        request: live_20161101_models.DeleteLiveMessageUserMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageUserMessageResponse:
        """
        @summary Deletes a message that is sent to a user.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveMessageUserMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageUserMessageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.deleter_id):
            query['DeleterId'] = request.deleter_id
        if not UtilClient.is_unset(request.deleter_info):
            query['DeleterInfo'] = request.deleter_info
        if not UtilClient.is_unset(request.message_id):
            query['MessageId'] = request.message_id
        if not UtilClient.is_unset(request.receiver_id):
            query['ReceiverId'] = request.receiver_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageUserMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageUserMessageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_message_user_message_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveMessageUserMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveMessageUserMessageResponse:
        """
        @summary Deletes a message that is sent to a user.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveMessageUserMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveMessageUserMessageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.deleter_id):
            query['DeleterId'] = request.deleter_id
        if not UtilClient.is_unset(request.deleter_info):
            query['DeleterInfo'] = request.deleter_info
        if not UtilClient.is_unset(request.message_id):
            query['MessageId'] = request.message_id
        if not UtilClient.is_unset(request.receiver_id):
            query['ReceiverId'] = request.receiver_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveMessageUserMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveMessageUserMessageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_message_user_message(
        self,
        request: live_20161101_models.DeleteLiveMessageUserMessageRequest,
    ) -> live_20161101_models.DeleteLiveMessageUserMessageResponse:
        """
        @summary Deletes a message that is sent to a user.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveMessageUserMessageRequest
        @return: DeleteLiveMessageUserMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_message_user_message_with_options(request, runtime)

    async def delete_live_message_user_message_async(
        self,
        request: live_20161101_models.DeleteLiveMessageUserMessageRequest,
    ) -> live_20161101_models.DeleteLiveMessageUserMessageResponse:
        """
        @summary Deletes a message that is sent to a user.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveMessageUserMessageRequest
        @return: DeleteLiveMessageUserMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_message_user_message_with_options_async(request, runtime)

    def delete_live_package_config_with_options(
        self,
        request: live_20161101_models.DeleteLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePackageConfigResponse:
        """
        @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePackageConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_package_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePackageConfigResponse:
        """
        @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePackageConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_package_config(
        self,
        request: live_20161101_models.DeleteLivePackageConfigRequest,
    ) -> live_20161101_models.DeleteLivePackageConfigResponse:
        """
        @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePackageConfigRequest
        @return: DeleteLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_package_config_with_options(request, runtime)

    async def delete_live_package_config_async(
        self,
        request: live_20161101_models.DeleteLivePackageConfigRequest,
    ) -> live_20161101_models.DeleteLivePackageConfigResponse:
        """
        @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePackageConfigRequest
        @return: DeleteLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_package_config_with_options_async(request, runtime)

    def delete_live_private_line_with_options(
        self,
        request: live_20161101_models.DeleteLivePrivateLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePrivateLineResponse:
        """
        @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
        
        @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePrivateLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePrivateLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_type):
            query['AccelerationType'] = request.acceleration_type
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePrivateLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePrivateLineResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_private_line_with_options_async(
        self,
        request: live_20161101_models.DeleteLivePrivateLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePrivateLineResponse:
        """
        @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
        
        @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePrivateLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePrivateLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_type):
            query['AccelerationType'] = request.acceleration_type
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePrivateLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePrivateLineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_private_line(
        self,
        request: live_20161101_models.DeleteLivePrivateLineRequest,
    ) -> live_20161101_models.DeleteLivePrivateLineResponse:
        """
        @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
        
        @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePrivateLineRequest
        @return: DeleteLivePrivateLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_private_line_with_options(request, runtime)

    async def delete_live_private_line_async(
        self,
        request: live_20161101_models.DeleteLivePrivateLineRequest,
    ) -> live_20161101_models.DeleteLivePrivateLineResponse:
        """
        @summary Unbinds a Global Accelerator (GA) instance from an acceleration circuit.
        
        @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePrivateLineRequest
        @return: DeleteLivePrivateLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_private_line_with_options_async(request, runtime)

    def delete_live_pull_stream_info_config_with_options(
        self,
        request: live_20161101_models.DeleteLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePullStreamInfoConfigResponse:
        """
        @summary Deletes a stream pulling configuration.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePullStreamInfoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_pull_stream_info_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePullStreamInfoConfigResponse:
        """
        @summary Deletes a stream pulling configuration.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePullStreamInfoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_pull_stream_info_config(
        self,
        request: live_20161101_models.DeleteLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.DeleteLivePullStreamInfoConfigResponse:
        """
        @summary Deletes a stream pulling configuration.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullStreamInfoConfigRequest
        @return: DeleteLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_pull_stream_info_config_with_options(request, runtime)

    async def delete_live_pull_stream_info_config_async(
        self,
        request: live_20161101_models.DeleteLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.DeleteLivePullStreamInfoConfigResponse:
        """
        @summary Deletes a stream pulling configuration.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullStreamInfoConfigRequest
        @return: DeleteLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_pull_stream_info_config_with_options_async(request, runtime)

    def delete_live_pull_to_push_with_options(
        self,
        request: live_20161101_models.DeleteLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePullToPushResponse:
        """
        @summary Deletes a pulled-stream relay task.
        
        @description    You can call this operation to delete a pulled-stream relay task.
        If you delete a running task, the task is immediately stopped and cannot be restarted.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_pull_to_push_with_options_async(
        self,
        request: live_20161101_models.DeleteLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLivePullToPushResponse:
        """
        @summary Deletes a pulled-stream relay task.
        
        @description    You can call this operation to delete a pulled-stream relay task.
        If you delete a running task, the task is immediately stopped and cannot be restarted.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_pull_to_push(
        self,
        request: live_20161101_models.DeleteLivePullToPushRequest,
    ) -> live_20161101_models.DeleteLivePullToPushResponse:
        """
        @summary Deletes a pulled-stream relay task.
        
        @description    You can call this operation to delete a pulled-stream relay task.
        If you delete a running task, the task is immediately stopped and cannot be restarted.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullToPushRequest
        @return: DeleteLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_pull_to_push_with_options(request, runtime)

    async def delete_live_pull_to_push_async(
        self,
        request: live_20161101_models.DeleteLivePullToPushRequest,
    ) -> live_20161101_models.DeleteLivePullToPushResponse:
        """
        @summary Deletes a pulled-stream relay task.
        
        @description    You can call this operation to delete a pulled-stream relay task.
        If you delete a running task, the task is immediately stopped and cannot be restarted.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLivePullToPushRequest
        @return: DeleteLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_pull_to_push_with_options_async(request, runtime)

    def delete_live_real_time_log_logstore_with_options(
        self,
        request: live_20161101_models.DeleteLiveRealTimeLogLogstoreRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse:
        """
        @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
        
        @description    You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealTimeLogLogstoreRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRealTimeLogLogstoreResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRealTimeLogLogstore',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_real_time_log_logstore_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveRealTimeLogLogstoreRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse:
        """
        @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
        
        @description    You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealTimeLogLogstoreRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRealTimeLogLogstoreResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRealTimeLogLogstore',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_real_time_log_logstore(
        self,
        request: live_20161101_models.DeleteLiveRealTimeLogLogstoreRequest,
    ) -> live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse:
        """
        @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
        
        @description    You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealTimeLogLogstoreRequest
        @return: DeleteLiveRealTimeLogLogstoreResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_real_time_log_logstore_with_options(request, runtime)

    async def delete_live_real_time_log_logstore_async(
        self,
        request: live_20161101_models.DeleteLiveRealTimeLogLogstoreRequest,
    ) -> live_20161101_models.DeleteLiveRealTimeLogLogstoreResponse:
        """
        @summary Deletes the Logstore that is specified by a configuration of real-time log delivery.
        
        @description    You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealTimeLogLogstoreRequest
        @return: DeleteLiveRealTimeLogLogstoreResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_real_time_log_logstore_with_options_async(request, runtime)

    def delete_live_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.DeleteLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse:
        """
        @summary Deletes the configurations of real-time log delivery for one or more domain names.
        
        @description
        This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse:
        """
        @summary Deletes the configurations of real-time log delivery for one or more domain names.
        
        @description
        This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_realtime_log_delivery(
        self,
        request: live_20161101_models.DeleteLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse:
        """
        @summary Deletes the configurations of real-time log delivery for one or more domain names.
        
        @description
        This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealtimeLogDeliveryRequest
        @return: DeleteLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_realtime_log_delivery_with_options(request, runtime)

    async def delete_live_realtime_log_delivery_async(
        self,
        request: live_20161101_models.DeleteLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DeleteLiveRealtimeLogDeliveryResponse:
        """
        @summary Deletes the configurations of real-time log delivery for one or more domain names.
        
        @description
        This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRealtimeLogDeliveryRequest
        @return: DeleteLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_realtime_log_delivery_with_options_async(request, runtime)

    def delete_live_record_notify_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRecordNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRecordNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_record_notify_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRecordNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRecordNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_record_notify_config(
        self,
        request: live_20161101_models.DeleteLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveRecordNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordNotifyConfigRequest
        @return: DeleteLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_record_notify_config_with_options(request, runtime)

    async def delete_live_record_notify_config_async(
        self,
        request: live_20161101_models.DeleteLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveRecordNotifyConfigResponse:
        """
        @summary Deletes the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordNotifyConfigRequest
        @return: DeleteLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_record_notify_config_with_options_async(request, runtime)

    def delete_live_record_vod_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRecordVodConfigResponse:
        """
        @summary Deletes a Live-to-VOD configuration.
        
        @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRecordVodConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_record_vod_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveRecordVodConfigResponse:
        """
        @summary Deletes a Live-to-VOD configuration.
        
        @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveRecordVodConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_record_vod_config(
        self,
        request: live_20161101_models.DeleteLiveRecordVodConfigRequest,
    ) -> live_20161101_models.DeleteLiveRecordVodConfigResponse:
        """
        @summary Deletes a Live-to-VOD configuration.
        
        @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordVodConfigRequest
        @return: DeleteLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_record_vod_config_with_options(request, runtime)

    async def delete_live_record_vod_config_async(
        self,
        request: live_20161101_models.DeleteLiveRecordVodConfigRequest,
    ) -> live_20161101_models.DeleteLiveRecordVodConfigResponse:
        """
        @summary Deletes a Live-to-VOD configuration.
        
        @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveRecordVodConfigRequest
        @return: DeleteLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_record_vod_config_with_options_async(request, runtime)

    def delete_live_snapshot_detect_porn_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse:
        """
        @summary Deletes a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_snapshot_detect_porn_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse:
        """
        @summary Deletes a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_snapshot_detect_porn_config(
        self,
        request: live_20161101_models.DeleteLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse:
        """
        @summary Deletes a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotDetectPornConfigRequest
        @return: DeleteLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_snapshot_detect_porn_config_with_options(request, runtime)

    async def delete_live_snapshot_detect_porn_config_async(
        self,
        request: live_20161101_models.DeleteLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.DeleteLiveSnapshotDetectPornConfigResponse:
        """
        @summary Deletes a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotDetectPornConfigRequest
        @return: DeleteLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_snapshot_detect_porn_config_with_options_async(request, runtime)

    def delete_live_snapshot_notify_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse:
        """
        @summary Deletes the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_snapshot_notify_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse:
        """
        @summary Deletes the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_snapshot_notify_config(
        self,
        request: live_20161101_models.DeleteLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse:
        """
        @summary Deletes the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotNotifyConfigRequest
        @return: DeleteLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_snapshot_notify_config_with_options(request, runtime)

    async def delete_live_snapshot_notify_config_async(
        self,
        request: live_20161101_models.DeleteLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.DeleteLiveSnapshotNotifyConfigResponse:
        """
        @summary Deletes the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveSnapshotNotifyConfigRequest
        @return: DeleteLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_snapshot_notify_config_with_options_async(request, runtime)

    def delete_live_specific_staging_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveSpecificStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSpecificStagingConfigResponse:
        """
        @summary Deletes domain configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveSpecificStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSpecificStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config_id):
            query['ConfigId'] = request.config_id
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSpecificStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSpecificStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_specific_staging_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveSpecificStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveSpecificStagingConfigResponse:
        """
        @summary Deletes domain configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveSpecificStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveSpecificStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config_id):
            query['ConfigId'] = request.config_id
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveSpecificStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveSpecificStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_specific_staging_config(
        self,
        request: live_20161101_models.DeleteLiveSpecificStagingConfigRequest,
    ) -> live_20161101_models.DeleteLiveSpecificStagingConfigResponse:
        """
        @summary Deletes domain configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveSpecificStagingConfigRequest
        @return: DeleteLiveSpecificStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_specific_staging_config_with_options(request, runtime)

    async def delete_live_specific_staging_config_async(
        self,
        request: live_20161101_models.DeleteLiveSpecificStagingConfigRequest,
    ) -> live_20161101_models.DeleteLiveSpecificStagingConfigResponse:
        """
        @summary Deletes domain configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveSpecificStagingConfigRequest
        @return: DeleteLiveSpecificStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_specific_staging_config_with_options_async(request, runtime)

    def delete_live_stream_block_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamBlockResponse:
        """
        @summary Deletes a configuration of stream-level region blocking.
        
        @description You can call this operation to delete a configuration of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_block_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamBlockResponse:
        """
        @summary Deletes a configuration of stream-level region blocking.
        
        @description You can call this operation to delete a configuration of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_block(
        self,
        request: live_20161101_models.DeleteLiveStreamBlockRequest,
    ) -> live_20161101_models.DeleteLiveStreamBlockResponse:
        """
        @summary Deletes a configuration of stream-level region blocking.
        
        @description You can call this operation to delete a configuration of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamBlockRequest
        @return: DeleteLiveStreamBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_block_with_options(request, runtime)

    async def delete_live_stream_block_async(
        self,
        request: live_20161101_models.DeleteLiveStreamBlockRequest,
    ) -> live_20161101_models.DeleteLiveStreamBlockResponse:
        """
        @summary Deletes a configuration of stream-level region blocking.
        
        @description You can call this operation to delete a configuration of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamBlockRequest
        @return: DeleteLiveStreamBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_block_with_options_async(request, runtime)

    def delete_live_stream_merge_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamMergeResponse:
        """
        @summary Deletes an active mixed stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamMergeResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_merge_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamMergeResponse:
        """
        @summary Deletes an active mixed stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamMergeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_merge(
        self,
        request: live_20161101_models.DeleteLiveStreamMergeRequest,
    ) -> live_20161101_models.DeleteLiveStreamMergeResponse:
        """
        @summary Deletes an active mixed stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMergeRequest
        @return: DeleteLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_merge_with_options(request, runtime)

    async def delete_live_stream_merge_async(
        self,
        request: live_20161101_models.DeleteLiveStreamMergeRequest,
    ) -> live_20161101_models.DeleteLiveStreamMergeResponse:
        """
        @summary Deletes an active mixed stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMergeRequest
        @return: DeleteLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_merge_with_options_async(request, runtime)

    def delete_live_stream_monitor_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamMonitorResponse:
        """
        @summary Deletes a monitoring session.
        
        @description Before you call this operation, obtain the monitoring session ID from the response parameter *MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamMonitorResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_monitor_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamMonitorResponse:
        """
        @summary Deletes a monitoring session.
        
        @description Before you call this operation, obtain the monitoring session ID from the response parameter *MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamMonitorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_monitor(
        self,
        request: live_20161101_models.DeleteLiveStreamMonitorRequest,
    ) -> live_20161101_models.DeleteLiveStreamMonitorResponse:
        """
        @summary Deletes a monitoring session.
        
        @description Before you call this operation, obtain the monitoring session ID from the response parameter *MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMonitorRequest
        @return: DeleteLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_monitor_with_options(request, runtime)

    async def delete_live_stream_monitor_async(
        self,
        request: live_20161101_models.DeleteLiveStreamMonitorRequest,
    ) -> live_20161101_models.DeleteLiveStreamMonitorResponse:
        """
        @summary Deletes a monitoring session.
        
        @description Before you call this operation, obtain the monitoring session ID from the response parameter *MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
        >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamMonitorRequest
        @return: DeleteLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_monitor_with_options_async(request, runtime)

    def delete_live_stream_record_index_files_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse:
        """
        @summary Deletes live stream recordings.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_id):
            query['RecordId'] = request.record_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_file):
            query['RemoveFile'] = request.remove_file
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_record_index_files_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse:
        """
        @summary Deletes live stream recordings.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_id):
            query['RecordId'] = request.record_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_file):
            query['RemoveFile'] = request.remove_file
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_record_index_files(
        self,
        request: live_20161101_models.DeleteLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse:
        """
        @summary Deletes live stream recordings.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamRecordIndexFilesRequest
        @return: DeleteLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_record_index_files_with_options(request, runtime)

    async def delete_live_stream_record_index_files_async(
        self,
        request: live_20161101_models.DeleteLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.DeleteLiveStreamRecordIndexFilesResponse:
        """
        @summary Deletes live stream recordings.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamRecordIndexFilesRequest
        @return: DeleteLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_record_index_files_with_options_async(request, runtime)

    def delete_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamTranscodeResponse:
        """
        @summary Deletes a transcoding configuration.
        
        @description Standard transcoding templates, Narrowband HD transcoding templates, and custom transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamTranscodeResponse:
        """
        @summary Deletes a transcoding configuration.
        
        @description Standard transcoding templates, Narrowband HD transcoding templates, and custom transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_transcode(
        self,
        request: live_20161101_models.DeleteLiveStreamTranscodeRequest,
    ) -> live_20161101_models.DeleteLiveStreamTranscodeResponse:
        """
        @summary Deletes a transcoding configuration.
        
        @description Standard transcoding templates, Narrowband HD transcoding templates, and custom transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamTranscodeRequest
        @return: DeleteLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_transcode_with_options(request, runtime)

    async def delete_live_stream_transcode_async(
        self,
        request: live_20161101_models.DeleteLiveStreamTranscodeRequest,
    ) -> live_20161101_models.DeleteLiveStreamTranscodeResponse:
        """
        @summary Deletes a transcoding configuration.
        
        @description Standard transcoding templates, Narrowband HD transcoding templates, and custom transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamTranscodeRequest
        @return: DeleteLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_transcode_with_options_async(request, runtime)

    def delete_live_stream_watermark_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkResponse:
        """
        @summary Deletes a specified watermark template.
        
        @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
        ## QPS Limitation
        The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_watermark_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkResponse:
        """
        @summary Deletes a specified watermark template.
        
        @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
        ## QPS Limitation
        The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_watermark(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRequest,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkResponse:
        """
        @summary Deletes a specified watermark template.
        
        @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
        ## QPS Limitation
        The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveStreamWatermarkRequest
        @return: DeleteLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_watermark_with_options(request, runtime)

    async def delete_live_stream_watermark_async(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRequest,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkResponse:
        """
        @summary Deletes a specified watermark template.
        
        @description This interface supports deleting the watermark template with the specified TemplateId for live streaming.
        ## QPS Limitation
        The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteLiveStreamWatermarkRequest
        @return: DeleteLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_watermark_with_options_async(request, runtime)

    def delete_live_stream_watermark_rule_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkRuleResponse:
        """
        @summary Deletes a watermark rule.
        
        @description You can call this operation to delete a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamWatermarkRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_stream_watermark_rule_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkRuleResponse:
        """
        @summary Deletes a watermark rule.
        
        @description You can call this operation to delete a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamWatermarkRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_stream_watermark_rule(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkRuleResponse:
        """
        @summary Deletes a watermark rule.
        
        @description You can call this operation to delete a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamWatermarkRuleRequest
        @return: DeleteLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_stream_watermark_rule_with_options(request, runtime)

    async def delete_live_stream_watermark_rule_async(
        self,
        request: live_20161101_models.DeleteLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.DeleteLiveStreamWatermarkRuleResponse:
        """
        @summary Deletes a watermark rule.
        
        @description You can call this operation to delete a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamWatermarkRuleRequest
        @return: DeleteLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_stream_watermark_rule_with_options_async(request, runtime)

    def delete_live_streams_notify_url_config_with_options(
        self,
        request: live_20161101_models.DeleteLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Deletes the callback configuration for stream ingest under an ingest domain.
        
        @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_live_streams_notify_url_config_with_options_async(
        self,
        request: live_20161101_models.DeleteLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Deletes the callback configuration for stream ingest under an ingest domain.
        
        @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_live_streams_notify_url_config(
        self,
        request: live_20161101_models.DeleteLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Deletes the callback configuration for stream ingest under an ingest domain.
        
        @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamsNotifyUrlConfigRequest
        @return: DeleteLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_live_streams_notify_url_config_with_options(request, runtime)

    async def delete_live_streams_notify_url_config_async(
        self,
        request: live_20161101_models.DeleteLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.DeleteLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Deletes the callback configuration for stream ingest under an ingest domain.
        
        @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteLiveStreamsNotifyUrlConfigRequest
        @return: DeleteLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_live_streams_notify_url_config_with_options_async(request, runtime)

    def delete_message_app_with_options(
        self,
        request: live_20161101_models.DeleteMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteMessageAppResponse:
        """
        @summary Deletes an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DeleteMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_message_app_with_options_async(
        self,
        request: live_20161101_models.DeleteMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteMessageAppResponse:
        """
        @summary Deletes an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DeleteMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_message_app(
        self,
        request: live_20161101_models.DeleteMessageAppRequest,
    ) -> live_20161101_models.DeleteMessageAppResponse:
        """
        @summary Deletes an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteMessageAppRequest
        @return: DeleteMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_message_app_with_options(request, runtime)

    async def delete_message_app_async(
        self,
        request: live_20161101_models.DeleteMessageAppRequest,
    ) -> live_20161101_models.DeleteMessageAppResponse:
        """
        @summary Deletes an interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteMessageAppRequest
        @return: DeleteMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_message_app_with_options_async(request, runtime)

    def delete_mix_stream_with_options(
        self,
        request: live_20161101_models.DeleteMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteMixStreamResponse:
        """
        @summary Deletes a stream mixing task.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteMixStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_mix_stream_with_options_async(
        self,
        request: live_20161101_models.DeleteMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteMixStreamResponse:
        """
        @summary Deletes a stream mixing task.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteMixStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_mix_stream(
        self,
        request: live_20161101_models.DeleteMixStreamRequest,
    ) -> live_20161101_models.DeleteMixStreamResponse:
        """
        @summary Deletes a stream mixing task.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteMixStreamRequest
        @return: DeleteMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_mix_stream_with_options(request, runtime)

    async def delete_mix_stream_async(
        self,
        request: live_20161101_models.DeleteMixStreamRequest,
    ) -> live_20161101_models.DeleteMixStreamResponse:
        """
        @summary Deletes a stream mixing task.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteMixStreamRequest
        @return: DeleteMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_mix_stream_with_options_async(request, runtime)

    def delete_playlist_with_options(
        self,
        request: live_20161101_models.DeletePlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeletePlaylistResponse:
        """
        @summary Deletes an episode list.
        
        @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeletePlaylistResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_playlist_with_options_async(
        self,
        request: live_20161101_models.DeletePlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeletePlaylistResponse:
        """
        @summary Deletes an episode list.
        
        @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeletePlaylistResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_playlist(
        self,
        request: live_20161101_models.DeletePlaylistRequest,
    ) -> live_20161101_models.DeletePlaylistResponse:
        """
        @summary Deletes an episode list.
        
        @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistRequest
        @return: DeletePlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_playlist_with_options(request, runtime)

    async def delete_playlist_async(
        self,
        request: live_20161101_models.DeletePlaylistRequest,
    ) -> live_20161101_models.DeletePlaylistResponse:
        """
        @summary Deletes an episode list.
        
        @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistRequest
        @return: DeletePlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_playlist_with_options_async(request, runtime)

    def delete_playlist_items_with_options(
        self,
        request: live_20161101_models.DeletePlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeletePlaylistItemsResponse:
        """
        @summary Removes episodes from an episode list.
        
        @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_item_ids):
            query['ProgramItemIds'] = request.program_item_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeletePlaylistItemsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_playlist_items_with_options_async(
        self,
        request: live_20161101_models.DeletePlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeletePlaylistItemsResponse:
        """
        @summary Removes episodes from an episode list.
        
        @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_item_ids):
            query['ProgramItemIds'] = request.program_item_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeletePlaylistItemsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_playlist_items(
        self,
        request: live_20161101_models.DeletePlaylistItemsRequest,
    ) -> live_20161101_models.DeletePlaylistItemsResponse:
        """
        @summary Removes episodes from an episode list.
        
        @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistItemsRequest
        @return: DeletePlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_playlist_items_with_options(request, runtime)

    async def delete_playlist_items_async(
        self,
        request: live_20161101_models.DeletePlaylistItemsRequest,
    ) -> live_20161101_models.DeletePlaylistItemsResponse:
        """
        @summary Removes episodes from an episode list.
        
        @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeletePlaylistItemsRequest
        @return: DeletePlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_playlist_items_with_options_async(request, runtime)

    def delete_rtc_asr_task_with_options(
        self,
        request: live_20161101_models.DeleteRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteRtcAsrTaskResponse:
        """
        @summary Deletes a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteRtcAsrTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_rtc_asr_task_with_options_async(
        self,
        request: live_20161101_models.DeleteRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteRtcAsrTaskResponse:
        """
        @summary Deletes a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteRtcAsrTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_rtc_asr_task(
        self,
        request: live_20161101_models.DeleteRtcAsrTaskRequest,
    ) -> live_20161101_models.DeleteRtcAsrTaskResponse:
        """
        @summary Deletes a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteRtcAsrTaskRequest
        @return: DeleteRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_rtc_asr_task_with_options(request, runtime)

    async def delete_rtc_asr_task_async(
        self,
        request: live_20161101_models.DeleteRtcAsrTaskRequest,
    ) -> live_20161101_models.DeleteRtcAsrTaskResponse:
        """
        @summary Deletes a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteRtcAsrTaskRequest
        @return: DeleteRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_rtc_asr_task_with_options_async(request, runtime)

    def delete_rtc_mpuevent_sub_with_options(
        self,
        request: live_20161101_models.DeleteRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteRtcMPUEventSubResponse:
        """
        @summary Deletes a subscription to mixed-stream relay events.
        
        @description    You can call this operation to delete a subscription to mixed-stream relay events.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteRtcMPUEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_rtc_mpuevent_sub_with_options_async(
        self,
        request: live_20161101_models.DeleteRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteRtcMPUEventSubResponse:
        """
        @summary Deletes a subscription to mixed-stream relay events.
        
        @description    You can call this operation to delete a subscription to mixed-stream relay events.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteRtcMPUEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_rtc_mpuevent_sub(
        self,
        request: live_20161101_models.DeleteRtcMPUEventSubRequest,
    ) -> live_20161101_models.DeleteRtcMPUEventSubResponse:
        """
        @summary Deletes a subscription to mixed-stream relay events.
        
        @description    You can call this operation to delete a subscription to mixed-stream relay events.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteRtcMPUEventSubRequest
        @return: DeleteRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_rtc_mpuevent_sub_with_options(request, runtime)

    async def delete_rtc_mpuevent_sub_async(
        self,
        request: live_20161101_models.DeleteRtcMPUEventSubRequest,
    ) -> live_20161101_models.DeleteRtcMPUEventSubResponse:
        """
        @summary Deletes a subscription to mixed-stream relay events.
        
        @description    You can call this operation to delete a subscription to mixed-stream relay events.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DeleteRtcMPUEventSubRequest
        @return: DeleteRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_rtc_mpuevent_sub_with_options_async(request, runtime)

    def delete_snapshot_callback_auth_with_options(
        self,
        request: live_20161101_models.DeleteSnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteSnapshotCallbackAuthResponse:
        """
        @summary Deletes the configuration of authentication for snapshot callbacks.
        
        @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteSnapshotCallbackAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_snapshot_callback_auth_with_options_async(
        self,
        request: live_20161101_models.DeleteSnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteSnapshotCallbackAuthResponse:
        """
        @summary Deletes the configuration of authentication for snapshot callbacks.
        
        @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteSnapshotCallbackAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_snapshot_callback_auth(
        self,
        request: live_20161101_models.DeleteSnapshotCallbackAuthRequest,
    ) -> live_20161101_models.DeleteSnapshotCallbackAuthResponse:
        """
        @summary Deletes the configuration of authentication for snapshot callbacks.
        
        @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotCallbackAuthRequest
        @return: DeleteSnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_snapshot_callback_auth_with_options(request, runtime)

    async def delete_snapshot_callback_auth_async(
        self,
        request: live_20161101_models.DeleteSnapshotCallbackAuthRequest,
    ) -> live_20161101_models.DeleteSnapshotCallbackAuthResponse:
        """
        @summary Deletes the configuration of authentication for snapshot callbacks.
        
        @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotCallbackAuthRequest
        @return: DeleteSnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_snapshot_callback_auth_with_options_async(request, runtime)

    def delete_snapshot_files_with_options(
        self,
        request: live_20161101_models.DeleteSnapshotFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteSnapshotFilesResponse:
        """
        @summary Deletes snapshots.
        
        @description You can delete only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.create_timestamp_list):
            query['CreateTimestampList'] = request.create_timestamp_list
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_file):
            query['RemoveFile'] = request.remove_file
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteSnapshotFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_snapshot_files_with_options_async(
        self,
        request: live_20161101_models.DeleteSnapshotFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteSnapshotFilesResponse:
        """
        @summary Deletes snapshots.
        
        @description You can delete only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSnapshotFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.create_timestamp_list):
            query['CreateTimestampList'] = request.create_timestamp_list
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.remove_file):
            query['RemoveFile'] = request.remove_file
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSnapshotFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteSnapshotFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_snapshot_files(
        self,
        request: live_20161101_models.DeleteSnapshotFilesRequest,
    ) -> live_20161101_models.DeleteSnapshotFilesResponse:
        """
        @summary Deletes snapshots.
        
        @description You can delete only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotFilesRequest
        @return: DeleteSnapshotFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_snapshot_files_with_options(request, runtime)

    async def delete_snapshot_files_async(
        self,
        request: live_20161101_models.DeleteSnapshotFilesRequest,
    ) -> live_20161101_models.DeleteSnapshotFilesResponse:
        """
        @summary Deletes snapshots.
        
        @description You can delete only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteSnapshotFilesRequest
        @return: DeleteSnapshotFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_snapshot_files_with_options_async(request, runtime)

    def delete_studio_layout_with_options(
        self,
        request: live_20161101_models.DeleteStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteStudioLayoutResponse:
        """
        @summary Deletes a layout in a virtual studio.
        
        @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteStudioLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_studio_layout_with_options_async(
        self,
        request: live_20161101_models.DeleteStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DeleteStudioLayoutResponse:
        """
        @summary Deletes a layout in a virtual studio.
        
        @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DeleteStudioLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_studio_layout(
        self,
        request: live_20161101_models.DeleteStudioLayoutRequest,
    ) -> live_20161101_models.DeleteStudioLayoutResponse:
        """
        @summary Deletes a layout in a virtual studio.
        
        @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteStudioLayoutRequest
        @return: DeleteStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_studio_layout_with_options(request, runtime)

    async def delete_studio_layout_async(
        self,
        request: live_20161101_models.DeleteStudioLayoutRequest,
    ) -> live_20161101_models.DeleteStudioLayoutResponse:
        """
        @summary Deletes a layout in a virtual studio.
        
        @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DeleteStudioLayoutRequest
        @return: DeleteStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_studio_layout_with_options_async(request, runtime)

    def describe_auto_show_list_tasks_with_options(
        self,
        request: live_20161101_models.DescribeAutoShowListTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeAutoShowListTasksResponse:
        """
        @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
        
        @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeAutoShowListTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoShowListTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoShowListTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeAutoShowListTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_auto_show_list_tasks_with_options_async(
        self,
        request: live_20161101_models.DescribeAutoShowListTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeAutoShowListTasksResponse:
        """
        @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
        
        @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeAutoShowListTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAutoShowListTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAutoShowListTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeAutoShowListTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_auto_show_list_tasks(
        self,
        request: live_20161101_models.DescribeAutoShowListTasksRequest,
    ) -> live_20161101_models.DescribeAutoShowListTasksResponse:
        """
        @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
        
        @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeAutoShowListTasksRequest
        @return: DescribeAutoShowListTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_auto_show_list_tasks_with_options(request, runtime)

    async def describe_auto_show_list_tasks_async(
        self,
        request: live_20161101_models.DescribeAutoShowListTasksRequest,
    ) -> live_20161101_models.DescribeAutoShowListTasksResponse:
        """
        @summary Queries scheduled tasks that are used to start and stop playing an episode list at specified points in time.
        
        @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeAutoShowListTasksRequest
        @return: DescribeAutoShowListTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_auto_show_list_tasks_with_options_async(request, runtime)

    def describe_caster_channels_with_options(
        self,
        request: live_20161101_models.DescribeCasterChannelsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterChannelsResponse:
        """
        @summary Queries the channels of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterChannelsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterChannelsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterChannels',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterChannelsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_channels_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterChannelsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterChannelsResponse:
        """
        @summary Queries the channels of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterChannelsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterChannelsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterChannels',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterChannelsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_channels(
        self,
        request: live_20161101_models.DescribeCasterChannelsRequest,
    ) -> live_20161101_models.DescribeCasterChannelsResponse:
        """
        @summary Queries the channels of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterChannelsRequest
        @return: DescribeCasterChannelsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_channels_with_options(request, runtime)

    async def describe_caster_channels_async(
        self,
        request: live_20161101_models.DescribeCasterChannelsRequest,
    ) -> live_20161101_models.DescribeCasterChannelsResponse:
        """
        @summary Queries the channels of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterChannelsRequest
        @return: DescribeCasterChannelsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_channels_with_options_async(request, runtime)

    def describe_caster_components_with_options(
        self,
        request: live_20161101_models.DescribeCasterComponentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterComponentsResponse:
        """
        @summary Queries the components of a production studio.
        
        @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterComponentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterComponentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterComponents',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterComponentsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_components_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterComponentsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterComponentsResponse:
        """
        @summary Queries the components of a production studio.
        
        @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterComponentsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterComponentsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterComponents',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterComponentsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_components(
        self,
        request: live_20161101_models.DescribeCasterComponentsRequest,
    ) -> live_20161101_models.DescribeCasterComponentsResponse:
        """
        @summary Queries the components of a production studio.
        
        @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterComponentsRequest
        @return: DescribeCasterComponentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_components_with_options(request, runtime)

    async def describe_caster_components_async(
        self,
        request: live_20161101_models.DescribeCasterComponentsRequest,
    ) -> live_20161101_models.DescribeCasterComponentsResponse:
        """
        @summary Queries the components of a production studio.
        
        @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterComponentsRequest
        @return: DescribeCasterComponentsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_components_with_options_async(request, runtime)

    def describe_caster_config_with_options(
        self,
        request: live_20161101_models.DescribeCasterConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterConfigResponse:
        """
        @summary Queries the configurations of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_config_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterConfigResponse:
        """
        @summary Queries the configurations of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_config(
        self,
        request: live_20161101_models.DescribeCasterConfigRequest,
    ) -> live_20161101_models.DescribeCasterConfigResponse:
        """
        @summary Queries the configurations of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterConfigRequest
        @return: DescribeCasterConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_config_with_options(request, runtime)

    async def describe_caster_config_async(
        self,
        request: live_20161101_models.DescribeCasterConfigRequest,
    ) -> live_20161101_models.DescribeCasterConfigResponse:
        """
        @summary Queries the configurations of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterConfigRequest
        @return: DescribeCasterConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_config_with_options_async(request, runtime)

    def describe_caster_layouts_with_options(
        self,
        request: live_20161101_models.DescribeCasterLayoutsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterLayoutsResponse:
        """
        @summary Queries a specified layout or all layouts of a production studio.
        
        @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterLayoutsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterLayoutsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterLayouts',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterLayoutsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_layouts_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterLayoutsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterLayoutsResponse:
        """
        @summary Queries a specified layout or all layouts of a production studio.
        
        @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterLayoutsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterLayoutsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterLayouts',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterLayoutsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_layouts(
        self,
        request: live_20161101_models.DescribeCasterLayoutsRequest,
    ) -> live_20161101_models.DescribeCasterLayoutsResponse:
        """
        @summary Queries a specified layout or all layouts of a production studio.
        
        @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterLayoutsRequest
        @return: DescribeCasterLayoutsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_layouts_with_options(request, runtime)

    async def describe_caster_layouts_async(
        self,
        request: live_20161101_models.DescribeCasterLayoutsRequest,
    ) -> live_20161101_models.DescribeCasterLayoutsResponse:
        """
        @summary Queries a specified layout or all layouts of a production studio.
        
        @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterLayoutsRequest
        @return: DescribeCasterLayoutsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_layouts_with_options_async(request, runtime)

    def describe_caster_program_with_options(
        self,
        request: live_20161101_models.DescribeCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterProgramResponse:
        """
        @summary Queries the information about the episode list for carousel playback in a production studio.
        
        @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.episode_type):
            query['EpisodeType'] = request.episode_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterProgramResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_program_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterProgramResponse:
        """
        @summary Queries the information about the episode list for carousel playback in a production studio.
        
        @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.episode_type):
            query['EpisodeType'] = request.episode_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterProgramResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_program(
        self,
        request: live_20161101_models.DescribeCasterProgramRequest,
    ) -> live_20161101_models.DescribeCasterProgramResponse:
        """
        @summary Queries the information about the episode list for carousel playback in a production studio.
        
        @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterProgramRequest
        @return: DescribeCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_program_with_options(request, runtime)

    async def describe_caster_program_async(
        self,
        request: live_20161101_models.DescribeCasterProgramRequest,
    ) -> live_20161101_models.DescribeCasterProgramResponse:
        """
        @summary Queries the information about the episode list for carousel playback in a production studio.
        
        @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterProgramRequest
        @return: DescribeCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_program_with_options_async(request, runtime)

    def describe_caster_scene_audio_with_options(
        self,
        request: live_20161101_models.DescribeCasterSceneAudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterSceneAudioResponse:
        """
        @summary Queries the audio configurations of a scene.
        
        @description ## [](#)Usage notes
        You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterSceneAudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterSceneAudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterSceneAudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterSceneAudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_scene_audio_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterSceneAudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterSceneAudioResponse:
        """
        @summary Queries the audio configurations of a scene.
        
        @description ## [](#)Usage notes
        You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterSceneAudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterSceneAudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterSceneAudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterSceneAudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_scene_audio(
        self,
        request: live_20161101_models.DescribeCasterSceneAudioRequest,
    ) -> live_20161101_models.DescribeCasterSceneAudioResponse:
        """
        @summary Queries the audio configurations of a scene.
        
        @description ## [](#)Usage notes
        You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterSceneAudioRequest
        @return: DescribeCasterSceneAudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_scene_audio_with_options(request, runtime)

    async def describe_caster_scene_audio_async(
        self,
        request: live_20161101_models.DescribeCasterSceneAudioRequest,
    ) -> live_20161101_models.DescribeCasterSceneAudioResponse:
        """
        @summary Queries the audio configurations of a scene.
        
        @description ## [](#)Usage notes
        You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterSceneAudioRequest
        @return: DescribeCasterSceneAudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_scene_audio_with_options_async(request, runtime)

    def describe_caster_scenes_with_options(
        self,
        request: live_20161101_models.DescribeCasterScenesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterScenesResponse:
        """
        @summary Queries the scenes of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterScenesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterScenesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterScenes',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterScenesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_scenes_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterScenesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterScenesResponse:
        """
        @summary Queries the scenes of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterScenesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterScenesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterScenes',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterScenesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_scenes(
        self,
        request: live_20161101_models.DescribeCasterScenesRequest,
    ) -> live_20161101_models.DescribeCasterScenesResponse:
        """
        @summary Queries the scenes of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterScenesRequest
        @return: DescribeCasterScenesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_scenes_with_options(request, runtime)

    async def describe_caster_scenes_async(
        self,
        request: live_20161101_models.DescribeCasterScenesRequest,
    ) -> live_20161101_models.DescribeCasterScenesResponse:
        """
        @summary Queries the scenes of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeCasterScenesRequest
        @return: DescribeCasterScenesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_scenes_with_options_async(request, runtime)

    def describe_caster_stream_url_with_options(
        self,
        request: live_20161101_models.DescribeCasterStreamUrlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterStreamUrlResponse:
        """
        @summary Queries the streaming URLs of a production studio.
        
        @description You must create a production studio before calling this operation to query the information.
        ## QPS limit
        A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeCasterStreamUrlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterStreamUrlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterStreamUrl',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterStreamUrlResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_stream_url_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterStreamUrlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterStreamUrlResponse:
        """
        @summary Queries the streaming URLs of a production studio.
        
        @description You must create a production studio before calling this operation to query the information.
        ## QPS limit
        A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeCasterStreamUrlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterStreamUrlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterStreamUrl',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterStreamUrlResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_stream_url(
        self,
        request: live_20161101_models.DescribeCasterStreamUrlRequest,
    ) -> live_20161101_models.DescribeCasterStreamUrlResponse:
        """
        @summary Queries the streaming URLs of a production studio.
        
        @description You must create a production studio before calling this operation to query the information.
        ## QPS limit
        A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeCasterStreamUrlRequest
        @return: DescribeCasterStreamUrlResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_stream_url_with_options(request, runtime)

    async def describe_caster_stream_url_async(
        self,
        request: live_20161101_models.DescribeCasterStreamUrlRequest,
    ) -> live_20161101_models.DescribeCasterStreamUrlResponse:
        """
        @summary Queries the streaming URLs of a production studio.
        
        @description You must create a production studio before calling this operation to query the information.
        ## QPS limit
        A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeCasterStreamUrlRequest
        @return: DescribeCasterStreamUrlResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_stream_url_with_options_async(request, runtime)

    def describe_caster_video_resources_with_options(
        self,
        request: live_20161101_models.DescribeCasterVideoResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterVideoResourcesResponse:
        """
        @summary Queries the input sources of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterVideoResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterVideoResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterVideoResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterVideoResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_caster_video_resources_with_options_async(
        self,
        request: live_20161101_models.DescribeCasterVideoResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCasterVideoResourcesResponse:
        """
        @summary Queries the input sources of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterVideoResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCasterVideoResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasterVideoResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCasterVideoResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_caster_video_resources(
        self,
        request: live_20161101_models.DescribeCasterVideoResourcesRequest,
    ) -> live_20161101_models.DescribeCasterVideoResourcesResponse:
        """
        @summary Queries the input sources of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterVideoResourcesRequest
        @return: DescribeCasterVideoResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_caster_video_resources_with_options(request, runtime)

    async def describe_caster_video_resources_async(
        self,
        request: live_20161101_models.DescribeCasterVideoResourcesRequest,
    ) -> live_20161101_models.DescribeCasterVideoResourcesResponse:
        """
        @summary Queries the input sources of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCasterVideoResourcesRequest
        @return: DescribeCasterVideoResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_caster_video_resources_with_options_async(request, runtime)

    def describe_casters_with_options(
        self,
        request: live_20161101_models.DescribeCastersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCastersResponse:
        """
        @summary Queries the list of production studios.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCastersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCastersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.norm_type):
            query['NormType'] = request.norm_type
        if not UtilClient.is_unset(request.order_by_modify_asc):
            query['OrderByModifyAsc'] = request.order_by_modify_asc
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasters',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCastersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_casters_with_options_async(
        self,
        request: live_20161101_models.DescribeCastersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeCastersResponse:
        """
        @summary Queries the list of production studios.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCastersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCastersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.charge_type):
            query['ChargeType'] = request.charge_type
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.norm_type):
            query['NormType'] = request.norm_type
        if not UtilClient.is_unset(request.order_by_modify_asc):
            query['OrderByModifyAsc'] = request.order_by_modify_asc
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCasters',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeCastersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_casters(
        self,
        request: live_20161101_models.DescribeCastersRequest,
    ) -> live_20161101_models.DescribeCastersResponse:
        """
        @summary Queries the list of production studios.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCastersRequest
        @return: DescribeCastersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_casters_with_options(request, runtime)

    async def describe_casters_async(
        self,
        request: live_20161101_models.DescribeCastersRequest,
    ) -> live_20161101_models.DescribeCastersResponse:
        """
        @summary Queries the list of production studios.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeCastersRequest
        @return: DescribeCastersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_casters_with_options_async(request, runtime)

    def describe_channel_participants_with_options(
        self,
        request: live_20161101_models.DescribeChannelParticipantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeChannelParticipantsResponse:
        """
        @summary Queries online users in a channel.
        
        @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelParticipantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeChannelParticipantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeChannelParticipants',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeChannelParticipantsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_channel_participants_with_options_async(
        self,
        request: live_20161101_models.DescribeChannelParticipantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeChannelParticipantsResponse:
        """
        @summary Queries online users in a channel.
        
        @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelParticipantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeChannelParticipantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeChannelParticipants',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeChannelParticipantsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_channel_participants(
        self,
        request: live_20161101_models.DescribeChannelParticipantsRequest,
    ) -> live_20161101_models.DescribeChannelParticipantsResponse:
        """
        @summary Queries online users in a channel.
        
        @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelParticipantsRequest
        @return: DescribeChannelParticipantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_channel_participants_with_options(request, runtime)

    async def describe_channel_participants_async(
        self,
        request: live_20161101_models.DescribeChannelParticipantsRequest,
    ) -> live_20161101_models.DescribeChannelParticipantsResponse:
        """
        @summary Queries online users in a channel.
        
        @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelParticipantsRequest
        @return: DescribeChannelParticipantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_channel_participants_with_options_async(request, runtime)

    def describe_channel_users_with_options(
        self,
        request: live_20161101_models.DescribeChannelUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeChannelUsersResponse:
        """
        @summary Queries the details of online users in a channel.
        
        @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeChannelUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeChannelUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeChannelUsersResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_channel_users_with_options_async(
        self,
        request: live_20161101_models.DescribeChannelUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeChannelUsersResponse:
        """
        @summary Queries the details of online users in a channel.
        
        @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeChannelUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeChannelUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeChannelUsersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_channel_users(
        self,
        request: live_20161101_models.DescribeChannelUsersRequest,
    ) -> live_20161101_models.DescribeChannelUsersResponse:
        """
        @summary Queries the details of online users in a channel.
        
        @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelUsersRequest
        @return: DescribeChannelUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_channel_users_with_options(request, runtime)

    async def describe_channel_users_async(
        self,
        request: live_20161101_models.DescribeChannelUsersRequest,
    ) -> live_20161101_models.DescribeChannelUsersResponse:
        """
        @summary Queries the details of online users in a channel.
        
        @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeChannelUsersRequest
        @return: DescribeChannelUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_channel_users_with_options_async(request, runtime)

    def describe_domain_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeDomainUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeDomainUsageDataResponse:
        """
        @summary Queries the resource usage data of specific domain names in a specified billable region.
        
        @description  You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
        The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
        If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
        The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|4 hours|
        |1 day|90 days|366 days|04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeDomainUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.data_protocol):
            query['DataProtocol'] = request.data_protocol
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.field):
            query['Field'] = request.field
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeDomainUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_domain_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeDomainUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeDomainUsageDataResponse:
        """
        @summary Queries the resource usage data of specific domain names in a specified billable region.
        
        @description  You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
        The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
        If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
        The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|4 hours|
        |1 day|90 days|366 days|04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeDomainUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.data_protocol):
            query['DataProtocol'] = request.data_protocol
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.field):
            query['Field'] = request.field
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeDomainUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_domain_usage_data(
        self,
        request: live_20161101_models.DescribeDomainUsageDataRequest,
    ) -> live_20161101_models.DescribeDomainUsageDataResponse:
        """
        @summary Queries the resource usage data of specific domain names in a specified billable region.
        
        @description  You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
        The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
        If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
        The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|4 hours|
        |1 day|90 days|366 days|04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeDomainUsageDataRequest
        @return: DescribeDomainUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_domain_usage_data_with_options(request, runtime)

    async def describe_domain_usage_data_async(
        self,
        request: live_20161101_models.DescribeDomainUsageDataRequest,
    ) -> live_20161101_models.DescribeDomainUsageDataResponse:
        """
        @summary Queries the resource usage data of specific domain names in a specified billable region.
        
        @description  You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
        The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
        If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
        The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|4 hours|
        |1 day|90 days|366 days|04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeDomainUsageDataRequest
        @return: DescribeDomainUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_domain_usage_data_with_options_async(request, runtime)

    def describe_domain_with_integrity_with_options(
        self,
        request: live_20161101_models.DescribeDomainWithIntegrityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeDomainWithIntegrityResponse:
        """
        @summary Obtains domain integrity.
        
        @description You can call this operation to obtain domain integrity.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeDomainWithIntegrityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainWithIntegrityResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainWithIntegrity',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeDomainWithIntegrityResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_domain_with_integrity_with_options_async(
        self,
        request: live_20161101_models.DescribeDomainWithIntegrityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeDomainWithIntegrityResponse:
        """
        @summary Obtains domain integrity.
        
        @description You can call this operation to obtain domain integrity.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeDomainWithIntegrityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainWithIntegrityResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainWithIntegrity',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeDomainWithIntegrityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_domain_with_integrity(
        self,
        request: live_20161101_models.DescribeDomainWithIntegrityRequest,
    ) -> live_20161101_models.DescribeDomainWithIntegrityResponse:
        """
        @summary Obtains domain integrity.
        
        @description You can call this operation to obtain domain integrity.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeDomainWithIntegrityRequest
        @return: DescribeDomainWithIntegrityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_domain_with_integrity_with_options(request, runtime)

    async def describe_domain_with_integrity_async(
        self,
        request: live_20161101_models.DescribeDomainWithIntegrityRequest,
    ) -> live_20161101_models.DescribeDomainWithIntegrityResponse:
        """
        @summary Obtains domain integrity.
        
        @description You can call this operation to obtain domain integrity.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeDomainWithIntegrityRequest
        @return: DescribeDomainWithIntegrityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_domain_with_integrity_with_options_async(request, runtime)

    def describe_hls_live_stream_real_time_bps_data_with_options(
        self,
        request: live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse:
        """
        @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        
        @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
        You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
        
        @param request: DescribeHlsLiveStreamRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHlsLiveStreamRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHlsLiveStreamRealTimeBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_hls_live_stream_real_time_bps_data_with_options_async(
        self,
        request: live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse:
        """
        @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        
        @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
        You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
        
        @param request: DescribeHlsLiveStreamRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeHlsLiveStreamRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeHlsLiveStreamRealTimeBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_hls_live_stream_real_time_bps_data(
        self,
        request: live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataRequest,
    ) -> live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse:
        """
        @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        
        @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
        You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
        
        @param request: DescribeHlsLiveStreamRealTimeBpsDataRequest
        @return: DescribeHlsLiveStreamRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_hls_live_stream_real_time_bps_data_with_options(request, runtime)

    async def describe_hls_live_stream_real_time_bps_data_async(
        self,
        request: live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataRequest,
    ) -> live_20161101_models.DescribeHlsLiveStreamRealTimeBpsDataResponse:
        """
        @summary Queries the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        
        @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
        The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
        You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
        
        @param request: DescribeHlsLiveStreamRealTimeBpsDataRequest
        @return: DescribeHlsLiveStreamRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_hls_live_stream_real_time_bps_data_with_options_async(request, runtime)

    def describe_live_aiproduce_rules_with_options(
        self,
        request: live_20161101_models.DescribeLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAIProduceRulesResponse:
        """
        @summary Queries subtitle rules.
        
        @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.suffix_name):
            query['SuffixName'] = request.suffix_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAIProduceRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_aiproduce_rules_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAIProduceRulesResponse:
        """
        @summary Queries subtitle rules.
        
        @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.suffix_name):
            query['SuffixName'] = request.suffix_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAIProduceRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_aiproduce_rules(
        self,
        request: live_20161101_models.DescribeLiveAIProduceRulesRequest,
    ) -> live_20161101_models.DescribeLiveAIProduceRulesResponse:
        """
        @summary Queries subtitle rules.
        
        @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAIProduceRulesRequest
        @return: DescribeLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_aiproduce_rules_with_options(request, runtime)

    async def describe_live_aiproduce_rules_async(
        self,
        request: live_20161101_models.DescribeLiveAIProduceRulesRequest,
    ) -> live_20161101_models.DescribeLiveAIProduceRulesResponse:
        """
        @summary Queries subtitle rules.
        
        @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAIProduceRulesRequest
        @return: DescribeLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_aiproduce_rules_with_options_async(request, runtime)

    def describe_live_aistudio_with_options(
        self,
        request: live_20161101_models.DescribeLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAIStudioResponse:
        """
        @summary Queries the virtual studio templates within your Alibaba Cloud account.
        
        @param request: DescribeLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAIStudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_id):
            query['StudioId'] = request.studio_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAIStudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_aistudio_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAIStudioResponse:
        """
        @summary Queries the virtual studio templates within your Alibaba Cloud account.
        
        @param request: DescribeLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAIStudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_id):
            query['StudioId'] = request.studio_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAIStudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_aistudio(
        self,
        request: live_20161101_models.DescribeLiveAIStudioRequest,
    ) -> live_20161101_models.DescribeLiveAIStudioResponse:
        """
        @summary Queries the virtual studio templates within your Alibaba Cloud account.
        
        @param request: DescribeLiveAIStudioRequest
        @return: DescribeLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_aistudio_with_options(request, runtime)

    async def describe_live_aistudio_async(
        self,
        request: live_20161101_models.DescribeLiveAIStudioRequest,
    ) -> live_20161101_models.DescribeLiveAIStudioResponse:
        """
        @summary Queries the virtual studio templates within your Alibaba Cloud account.
        
        @param request: DescribeLiveAIStudioRequest
        @return: DescribeLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_aistudio_with_options_async(request, runtime)

    def describe_live_aisubtitle_with_options(
        self,
        request: live_20161101_models.DescribeLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAISubtitleResponse:
        """
        @summary Queries subtitle templates.
        
        @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
        >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAISubtitleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAISubtitleResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_aisubtitle_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAISubtitleResponse:
        """
        @summary Queries subtitle templates.
        
        @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
        >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAISubtitleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAISubtitleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_aisubtitle(
        self,
        request: live_20161101_models.DescribeLiveAISubtitleRequest,
    ) -> live_20161101_models.DescribeLiveAISubtitleResponse:
        """
        @summary Queries subtitle templates.
        
        @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
        >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveAISubtitleRequest
        @return: DescribeLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_aisubtitle_with_options(request, runtime)

    async def describe_live_aisubtitle_async(
        self,
        request: live_20161101_models.DescribeLiveAISubtitleRequest,
    ) -> live_20161101_models.DescribeLiveAISubtitleResponse:
        """
        @summary Queries subtitle templates.
        
        @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
        >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates.
        ## QPS Limit
        The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveAISubtitleRequest
        @return: DescribeLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_aisubtitle_with_options_async(request, runtime)

    def describe_live_audio_audit_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAudioAuditConfigResponse:
        """
        @summary Queries audio moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAudioAuditConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_audio_audit_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAudioAuditConfigResponse:
        """
        @summary Queries audio moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAudioAuditConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_audio_audit_config(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.DescribeLiveAudioAuditConfigResponse:
        """
        @summary Queries audio moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditConfigRequest
        @return: DescribeLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_audio_audit_config_with_options(request, runtime)

    async def describe_live_audio_audit_config_async(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.DescribeLiveAudioAuditConfigResponse:
        """
        @summary Queries audio moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditConfigRequest
        @return: DescribeLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_audio_audit_config_with_options_async(request, runtime)

    def describe_live_audio_audit_notify_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_audio_audit_notify_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_audio_audit_notify_config(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditNotifyConfigRequest
        @return: DescribeLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_audio_audit_notify_config_with_options(request, runtime)

    async def describe_live_audio_audit_notify_config_async(
        self,
        request: live_20161101_models.DescribeLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveAudioAuditNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for audio moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveAudioAuditNotifyConfigRequest
        @return: DescribeLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_audio_audit_notify_config_with_options_async(request, runtime)

    def describe_live_cdn_diagnose_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveCdnDiagnoseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse:
        """
        @param request: DescribeLiveCdnDiagnoseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCdnDiagnoseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.interval_type):
            query['intervalType'] = request.interval_type
        if not UtilClient.is_unset(request.phase):
            query['phase'] = request.phase
        if not UtilClient.is_unset(request.request_type):
            query['requestType'] = request.request_type
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['streamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_suffix):
            query['streamSuffix'] = request.stream_suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCdnDiagnoseInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_cdn_diagnose_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveCdnDiagnoseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse:
        """
        @param request: DescribeLiveCdnDiagnoseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCdnDiagnoseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.interval_type):
            query['intervalType'] = request.interval_type
        if not UtilClient.is_unset(request.phase):
            query['phase'] = request.phase
        if not UtilClient.is_unset(request.request_type):
            query['requestType'] = request.request_type
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['streamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_suffix):
            query['streamSuffix'] = request.stream_suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCdnDiagnoseInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_cdn_diagnose_info(
        self,
        request: live_20161101_models.DescribeLiveCdnDiagnoseInfoRequest,
    ) -> live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse:
        """
        @param request: DescribeLiveCdnDiagnoseInfoRequest
        @return: DescribeLiveCdnDiagnoseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_cdn_diagnose_info_with_options(request, runtime)

    async def describe_live_cdn_diagnose_info_async(
        self,
        request: live_20161101_models.DescribeLiveCdnDiagnoseInfoRequest,
    ) -> live_20161101_models.DescribeLiveCdnDiagnoseInfoResponse:
        """
        @param request: DescribeLiveCdnDiagnoseInfoRequest
        @return: DescribeLiveCdnDiagnoseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_cdn_diagnose_info_with_options_async(request, runtime)

    def describe_live_center_stream_rate_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveCenterStreamRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCenterStreamRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
        
        @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterStreamRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCenterStreamRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCenterStreamRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCenterStreamRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_center_stream_rate_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveCenterStreamRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCenterStreamRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
        
        @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterStreamRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCenterStreamRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCenterStreamRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCenterStreamRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_center_stream_rate_data(
        self,
        request: live_20161101_models.DescribeLiveCenterStreamRateDataRequest,
    ) -> live_20161101_models.DescribeLiveCenterStreamRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
        
        @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterStreamRateDataRequest
        @return: DescribeLiveCenterStreamRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_center_stream_rate_data_with_options(request, runtime)

    async def describe_live_center_stream_rate_data_async(
        self,
        request: live_20161101_models.DescribeLiveCenterStreamRateDataRequest,
    ) -> live_20161101_models.DescribeLiveCenterStreamRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a stream in a live center.
        
        @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterStreamRateDataRequest
        @return: DescribeLiveCenterStreamRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_center_stream_rate_data_with_options_async(request, runtime)

    def describe_live_center_transfer_with_options(
        self,
        request: live_20161101_models.DescribeLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCenterTransferResponse:
        """
        @summary Queries the information about a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCenterTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_center_transfer_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCenterTransferResponse:
        """
        @summary Queries the information about a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCenterTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_center_transfer(
        self,
        request: live_20161101_models.DescribeLiveCenterTransferRequest,
    ) -> live_20161101_models.DescribeLiveCenterTransferResponse:
        """
        @summary Queries the information about a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterTransferRequest
        @return: DescribeLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_center_transfer_with_options(request, runtime)

    async def describe_live_center_transfer_async(
        self,
        request: live_20161101_models.DescribeLiveCenterTransferRequest,
    ) -> live_20161101_models.DescribeLiveCenterTransferResponse:
        """
        @summary Queries the information about a configuration of live center stream relay.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCenterTransferRequest
        @return: DescribeLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_center_transfer_with_options_async(request, runtime)

    def describe_live_certificate_detail_with_options(
        self,
        request: live_20161101_models.DescribeLiveCertificateDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCertificateDetailResponse:
        """
        @summary Queries the details of a certificate.
        
        @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveCertificateDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCertificateDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCertificateDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCertificateDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_certificate_detail_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveCertificateDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCertificateDetailResponse:
        """
        @summary Queries the details of a certificate.
        
        @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveCertificateDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCertificateDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCertificateDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCertificateDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_certificate_detail(
        self,
        request: live_20161101_models.DescribeLiveCertificateDetailRequest,
    ) -> live_20161101_models.DescribeLiveCertificateDetailResponse:
        """
        @summary Queries the details of a certificate.
        
        @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveCertificateDetailRequest
        @return: DescribeLiveCertificateDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_certificate_detail_with_options(request, runtime)

    async def describe_live_certificate_detail_async(
        self,
        request: live_20161101_models.DescribeLiveCertificateDetailRequest,
    ) -> live_20161101_models.DescribeLiveCertificateDetailResponse:
        """
        @summary Queries the details of a certificate.
        
        @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveCertificateDetailRequest
        @return: DescribeLiveCertificateDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_certificate_detail_with_options_async(request, runtime)

    def describe_live_certificate_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCertificateListResponse:
        """
        @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
        
        @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCertificateList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCertificateListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_certificate_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveCertificateListResponse:
        """
        @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
        
        @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveCertificateList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveCertificateListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_certificate_list(
        self,
        request: live_20161101_models.DescribeLiveCertificateListRequest,
    ) -> live_20161101_models.DescribeLiveCertificateListResponse:
        """
        @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
        
        @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCertificateListRequest
        @return: DescribeLiveCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_certificate_list_with_options(request, runtime)

    async def describe_live_certificate_list_async(
        self,
        request: live_20161101_models.DescribeLiveCertificateListRequest,
    ) -> live_20161101_models.DescribeLiveCertificateListResponse:
        """
        @summary Queries the certificates of one or more specified domain names or all certificates within your Alibaba Cloud account.
        
        @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveCertificateListRequest
        @return: DescribeLiveCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_certificate_list_with_options_async(request, runtime)

    def describe_live_delay_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDelayConfigResponse:
        """
        @summary Queries the information about a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_delay_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDelayConfigResponse:
        """
        @summary Queries the information about a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_delay_config(
        self,
        request: live_20161101_models.DescribeLiveDelayConfigRequest,
    ) -> live_20161101_models.DescribeLiveDelayConfigResponse:
        """
        @summary Queries the information about a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDelayConfigRequest
        @return: DescribeLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_delay_config_with_options(request, runtime)

    async def describe_live_delay_config_async(
        self,
        request: live_20161101_models.DescribeLiveDelayConfigRequest,
    ) -> live_20161101_models.DescribeLiveDelayConfigResponse:
        """
        @summary Queries the information about a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDelayConfigRequest
        @return: DescribeLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_delay_config_with_options_async(request, runtime)

    def describe_live_delayed_streaming_usage_with_options(
        self,
        request: live_20161101_models.DescribeLiveDelayedStreamingUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDelayedStreamingUsageResponse:
        """
        @summary Queries the stream delay usage data.
        
        @description    You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 hour.
        You can query the data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDelayedStreamingUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDelayedStreamingUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDelayedStreamingUsage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDelayedStreamingUsageResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_delayed_streaming_usage_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDelayedStreamingUsageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDelayedStreamingUsageResponse:
        """
        @summary Queries the stream delay usage data.
        
        @description    You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 hour.
        You can query the data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDelayedStreamingUsageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDelayedStreamingUsageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDelayedStreamingUsage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDelayedStreamingUsageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_delayed_streaming_usage(
        self,
        request: live_20161101_models.DescribeLiveDelayedStreamingUsageRequest,
    ) -> live_20161101_models.DescribeLiveDelayedStreamingUsageResponse:
        """
        @summary Queries the stream delay usage data.
        
        @description    You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 hour.
        You can query the data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDelayedStreamingUsageRequest
        @return: DescribeLiveDelayedStreamingUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_delayed_streaming_usage_with_options(request, runtime)

    async def describe_live_delayed_streaming_usage_async(
        self,
        request: live_20161101_models.DescribeLiveDelayedStreamingUsageRequest,
    ) -> live_20161101_models.DescribeLiveDelayedStreamingUsageResponse:
        """
        @summary Queries the stream delay usage data.
        
        @description    You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 hour.
        You can query the data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDelayedStreamingUsageRequest
        @return: DescribeLiveDelayedStreamingUsageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_delayed_streaming_usage_with_options_async(request, runtime)

    def describe_live_detect_notify_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDetectNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for video moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDetectNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_detect_notify_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDetectNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for video moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDetectNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_detect_notify_config(
        self,
        request: live_20161101_models.DescribeLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveDetectNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for video moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveDetectNotifyConfigRequest
        @return: DescribeLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_detect_notify_config_with_options(request, runtime)

    async def describe_live_detect_notify_config_async(
        self,
        request: live_20161101_models.DescribeLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveDetectNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for video moderation results.
        
        @description    Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
        Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveDetectNotifyConfigRequest
        @return: DescribeLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_detect_notify_config_with_options_async(request, runtime)

    def describe_live_detect_porn_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDetectPornDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDetectPornDataResponse:
        """
        @summary Queries the usage data of content moderation.
        
        @description    The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
        You can query data in the last 90 days.
        You can call this operation to query the bandwidth at each interval.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDetectPornDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDetectPornDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.fee):
            query['Fee'] = request.fee
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDetectPornData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDetectPornDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_detect_porn_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDetectPornDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDetectPornDataResponse:
        """
        @summary Queries the usage data of content moderation.
        
        @description    The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
        You can query data in the last 90 days.
        You can call this operation to query the bandwidth at each interval.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDetectPornDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDetectPornDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.fee):
            query['Fee'] = request.fee
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDetectPornData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDetectPornDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_detect_porn_data(
        self,
        request: live_20161101_models.DescribeLiveDetectPornDataRequest,
    ) -> live_20161101_models.DescribeLiveDetectPornDataResponse:
        """
        @summary Queries the usage data of content moderation.
        
        @description    The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
        You can query data in the last 90 days.
        You can call this operation to query the bandwidth at each interval.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDetectPornDataRequest
        @return: DescribeLiveDetectPornDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_detect_porn_data_with_options(request, runtime)

    async def describe_live_detect_porn_data_async(
        self,
        request: live_20161101_models.DescribeLiveDetectPornDataRequest,
    ) -> live_20161101_models.DescribeLiveDetectPornDataResponse:
        """
        @summary Queries the usage data of content moderation.
        
        @description    The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
        You can query data in the last 90 days.
        You can call this operation to query the bandwidth at each interval.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDetectPornDataRequest
        @return: DescribeLiveDetectPornDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_detect_porn_data_with_options_async(request, runtime)

    def describe_live_domain_bps_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more streaming domains.
        
        @description    You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
        If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
        If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
        You can query the data in the last 90 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_bps_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more streaming domains.
        
        @description    You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
        If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
        If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
        You can query the data in the last 90 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_bps_data(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more streaming domains.
        
        @description    You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
        If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
        If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
        You can query the data in the last 90 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataRequest
        @return: DescribeLiveDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_bps_data_with_options(request, runtime)

    async def describe_live_domain_bps_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more streaming domains.
        
        @description    You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
        If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
        If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
        You can query the data in the last 90 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataRequest
        @return: DescribeLiveDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_bps_data_with_options_async(request, runtime)

    def describe_live_domain_bps_data_by_layer_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataByLayerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
        
        @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the *StartTime** and **EndTime** parameters:
        If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
        If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
        If the time range is larger than 31 days, the time granularity is 1 day.
        >  If neither the *StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataByLayerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainBpsDataByLayerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.layer):
            query['Layer'] = request.layer
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainBpsDataByLayer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_bps_data_by_layer_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataByLayerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
        
        @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the *StartTime** and **EndTime** parameters:
        If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
        If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
        If the time range is larger than 31 days, the time granularity is 1 day.
        >  If neither the *StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataByLayerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainBpsDataByLayerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.layer):
            query['Layer'] = request.layer
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainBpsDataByLayer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_bps_data_by_layer(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataByLayerRequest,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
        
        @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the *StartTime** and **EndTime** parameters:
        If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
        If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
        If the time range is larger than 31 days, the time granularity is 1 day.
        >  If neither the *StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataByLayerRequest
        @return: DescribeLiveDomainBpsDataByLayerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_bps_data_by_layer_with_options(request, runtime)

    async def describe_live_domain_bps_data_by_layer_async(
        self,
        request: live_20161101_models.DescribeLiveDomainBpsDataByLayerRequest,
    ) -> live_20161101_models.DescribeLiveDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth and traffic data by protocol for one or more domain names.
        
        @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the *StartTime** and **EndTime** parameters:
        If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
        If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
        If the time range is larger than 31 days, the time granularity is 1 day.
        >  If neither the *StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainBpsDataByLayerRequest
        @return: DescribeLiveDomainBpsDataByLayerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_bps_data_by_layer_with_options_async(request, runtime)

    def describe_live_domain_by_certificate_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainByCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainByCertificateResponse:
        """
        @summary Queries the accelerated domain names that match a certificate.
        
        @description You can call this operation to query the accelerated domain names that match a certificate.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainByCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainByCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.sslstatus):
            query['SSLStatus'] = request.sslstatus
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainByCertificate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainByCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_by_certificate_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainByCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainByCertificateResponse:
        """
        @summary Queries the accelerated domain names that match a certificate.
        
        @description You can call this operation to query the accelerated domain names that match a certificate.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainByCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainByCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.sslstatus):
            query['SSLStatus'] = request.sslstatus
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainByCertificate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainByCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_by_certificate(
        self,
        request: live_20161101_models.DescribeLiveDomainByCertificateRequest,
    ) -> live_20161101_models.DescribeLiveDomainByCertificateResponse:
        """
        @summary Queries the accelerated domain names that match a certificate.
        
        @description You can call this operation to query the accelerated domain names that match a certificate.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainByCertificateRequest
        @return: DescribeLiveDomainByCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_by_certificate_with_options(request, runtime)

    async def describe_live_domain_by_certificate_async(
        self,
        request: live_20161101_models.DescribeLiveDomainByCertificateRequest,
    ) -> live_20161101_models.DescribeLiveDomainByCertificateResponse:
        """
        @summary Queries the accelerated domain names that match a certificate.
        
        @description You can call this operation to query the accelerated domain names that match a certificate.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainByCertificateRequest
        @return: DescribeLiveDomainByCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_by_certificate_with_options_async(request, runtime)

    def describe_live_domain_certificate_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainCertificateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainCertificateInfoResponse:
        """
        @summary Queries certificate information about a domain name.
        
        @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainCertificateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainCertificateInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainCertificateInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainCertificateInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_certificate_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainCertificateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainCertificateInfoResponse:
        """
        @summary Queries certificate information about a domain name.
        
        @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainCertificateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainCertificateInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainCertificateInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainCertificateInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_certificate_info(
        self,
        request: live_20161101_models.DescribeLiveDomainCertificateInfoRequest,
    ) -> live_20161101_models.DescribeLiveDomainCertificateInfoResponse:
        """
        @summary Queries certificate information about a domain name.
        
        @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainCertificateInfoRequest
        @return: DescribeLiveDomainCertificateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_certificate_info_with_options(request, runtime)

    async def describe_live_domain_certificate_info_async(
        self,
        request: live_20161101_models.DescribeLiveDomainCertificateInfoRequest,
    ) -> live_20161101_models.DescribeLiveDomainCertificateInfoResponse:
        """
        @summary Queries certificate information about a domain name.
        
        @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainCertificateInfoRequest
        @return: DescribeLiveDomainCertificateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_certificate_info_with_options_async(request, runtime)

    def describe_live_domain_configs_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainConfigsResponse:
        """
        @summary Queries one or more configurations of a domain name.
        
        @description You can call this operation to query multiple configurations at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_configs_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainConfigsResponse:
        """
        @summary Queries one or more configurations of a domain name.
        
        @description You can call this operation to query multiple configurations at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_configs(
        self,
        request: live_20161101_models.DescribeLiveDomainConfigsRequest,
    ) -> live_20161101_models.DescribeLiveDomainConfigsResponse:
        """
        @summary Queries one or more configurations of a domain name.
        
        @description You can call this operation to query multiple configurations at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainConfigsRequest
        @return: DescribeLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_configs_with_options(request, runtime)

    async def describe_live_domain_configs_async(
        self,
        request: live_20161101_models.DescribeLiveDomainConfigsRequest,
    ) -> live_20161101_models.DescribeLiveDomainConfigsResponse:
        """
        @summary Queries one or more configurations of a domain name.
        
        @description You can call this operation to query multiple configurations at a time.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainConfigsRequest
        @return: DescribeLiveDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_configs_with_options_async(request, runtime)

    def describe_live_domain_detail_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainDetailResponse:
        """
        @summary Queries the basic information about a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_detail_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainDetailResponse:
        """
        @summary Queries the basic information about a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_detail(
        self,
        request: live_20161101_models.DescribeLiveDomainDetailRequest,
    ) -> live_20161101_models.DescribeLiveDomainDetailResponse:
        """
        @summary Queries the basic information about a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainDetailRequest
        @return: DescribeLiveDomainDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_detail_with_options(request, runtime)

    async def describe_live_domain_detail_async(
        self,
        request: live_20161101_models.DescribeLiveDomainDetailRequest,
    ) -> live_20161101_models.DescribeLiveDomainDetailResponse:
        """
        @summary Queries the basic information about a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainDetailRequest
        @return: DescribeLiveDomainDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_detail_with_options_async(request, runtime)

    def describe_live_domain_edge_log_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainEdgeLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainEdgeLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveDomainEdgeLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainEdgeLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainEdgeLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainEdgeLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_edge_log_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainEdgeLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainEdgeLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveDomainEdgeLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainEdgeLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainEdgeLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainEdgeLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_edge_log(
        self,
        request: live_20161101_models.DescribeLiveDomainEdgeLogRequest,
    ) -> live_20161101_models.DescribeLiveDomainEdgeLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveDomainEdgeLogRequest
        @return: DescribeLiveDomainEdgeLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_edge_log_with_options(request, runtime)

    async def describe_live_domain_edge_log_async(
        self,
        request: live_20161101_models.DescribeLiveDomainEdgeLogRequest,
    ) -> live_20161101_models.DescribeLiveDomainEdgeLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveDomainEdgeLogRequest
        @return: DescribeLiveDomainEdgeLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_edge_log_with_options_async(request, runtime)

    def describe_live_domain_frame_rate_and_bit_rate_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
        
        @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainFrameRateAndBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainFrameRateAndBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.query_time):
            query['QueryTime'] = request.query_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainFrameRateAndBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_frame_rate_and_bit_rate_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
        
        @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainFrameRateAndBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainFrameRateAndBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.query_time):
            query['QueryTime'] = request.query_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainFrameRateAndBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_frame_rate_and_bit_rate_data(
        self,
        request: live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
        
        @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainFrameRateAndBitRateDataRequest
        @return: DescribeLiveDomainFrameRateAndBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_frame_rate_and_bit_rate_data_with_options(request, runtime)

    async def describe_live_domain_frame_rate_and_bit_rate_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainFrameRateAndBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of all live streams under an ingest domain.
        
        @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainFrameRateAndBitRateDataRequest
        @return: DescribeLiveDomainFrameRateAndBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_frame_rate_and_bit_rate_data_with_options_async(request, runtime)

    def describe_live_domain_limit_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainLimitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLimitResponse:
        """
        @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
        
        @description This operation applies only to main streaming domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLimitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLimitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLimit',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLimitResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_limit_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLimitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLimitResponse:
        """
        @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
        
        @description This operation applies only to main streaming domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLimitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLimitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLimit',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLimitResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_limit(
        self,
        request: live_20161101_models.DescribeLiveDomainLimitRequest,
    ) -> live_20161101_models.DescribeLiveDomainLimitResponse:
        """
        @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
        
        @description This operation applies only to main streaming domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLimitRequest
        @return: DescribeLiveDomainLimitResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_limit_with_options(request, runtime)

    async def describe_live_domain_limit_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLimitRequest,
    ) -> live_20161101_models.DescribeLiveDomainLimitResponse:
        """
        @summary Queries the maximum numbers of ingested and transcoded streams for a streaming domain.
        
        @description This operation applies only to main streaming domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLimitRequest
        @return: DescribeLiveDomainLimitResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_limit_with_options_async(request, runtime)

    def describe_live_domain_log_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLogResponse:
        """
        @summary Queries the address from which you can download the raw access logs of a domain name.
        
        @description    You can call this operation to query the offline logs of a single domain name.
        The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
        If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_log_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLogResponse:
        """
        @summary Queries the address from which you can download the raw access logs of a domain name.
        
        @description    You can call this operation to query the offline logs of a single domain name.
        The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
        If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_log(
        self,
        request: live_20161101_models.DescribeLiveDomainLogRequest,
    ) -> live_20161101_models.DescribeLiveDomainLogResponse:
        """
        @summary Queries the address from which you can download the raw access logs of a domain name.
        
        @description    You can call this operation to query the offline logs of a single domain name.
        The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
        If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLogRequest
        @return: DescribeLiveDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_log_with_options(request, runtime)

    async def describe_live_domain_log_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLogRequest,
    ) -> live_20161101_models.DescribeLiveDomainLogResponse:
        """
        @summary Queries the address from which you can download the raw access logs of a domain name.
        
        @description    You can call this operation to query the offline logs of a single domain name.
        The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
        If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainLogRequest
        @return: DescribeLiveDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_log_with_options_async(request, runtime)

    def describe_live_domain_log_ex_ttl_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainLogExTtlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLogExTtlResponse:
        """
        @summary ()
        
        @param request: DescribeLiveDomainLogExTtlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLogExTtlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLogExTtl',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLogExTtlResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_log_ex_ttl_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLogExTtlRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainLogExTtlResponse:
        """
        @summary ()
        
        @param request: DescribeLiveDomainLogExTtlRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainLogExTtlResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainLogExTtl',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainLogExTtlResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_log_ex_ttl(
        self,
        request: live_20161101_models.DescribeLiveDomainLogExTtlRequest,
    ) -> live_20161101_models.DescribeLiveDomainLogExTtlResponse:
        """
        @summary ()
        
        @param request: DescribeLiveDomainLogExTtlRequest
        @return: DescribeLiveDomainLogExTtlResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_log_ex_ttl_with_options(request, runtime)

    async def describe_live_domain_log_ex_ttl_async(
        self,
        request: live_20161101_models.DescribeLiveDomainLogExTtlRequest,
    ) -> live_20161101_models.DescribeLiveDomainLogExTtlResponse:
        """
        @summary ()
        
        @param request: DescribeLiveDomainLogExTtlRequest
        @return: DescribeLiveDomainLogExTtlResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_log_ex_ttl_with_options_async(request, runtime)

    def describe_live_domain_mapping_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMappingResponse:
        """
        @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
        
        @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMappingResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_mapping_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMappingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMappingResponse:
        """
        @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
        
        @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainMappingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMappingResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMapping',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMappingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_mapping(
        self,
        request: live_20161101_models.DescribeLiveDomainMappingRequest,
    ) -> live_20161101_models.DescribeLiveDomainMappingResponse:
        """
        @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
        
        @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainMappingRequest
        @return: DescribeLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_mapping_with_options(request, runtime)

    async def describe_live_domain_mapping_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMappingRequest,
    ) -> live_20161101_models.DescribeLiveDomainMappingResponse:
        """
        @summary Queries the mappings of an ingest domain, a main streaming domain, or a sub-streaming domain.
        
        @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainMappingRequest
        @return: DescribeLiveDomainMappingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_mapping_with_options_async(request, runtime)

    def describe_live_domain_monitoring_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainMonitoringUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse:
        """
        @summary Queries the live monitoring usage data for one or more domain names.
        
        @description    You can specify one or more domain names. Separate multiple domain names with commas (,).
        You can query data in the last 90 days.
        The data is queried by hour or day.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainMonitoringUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMonitoringUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMonitoringUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_monitoring_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMonitoringUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse:
        """
        @summary Queries the live monitoring usage data for one or more domain names.
        
        @description    You can specify one or more domain names. Separate multiple domain names with commas (,).
        You can query data in the last 90 days.
        The data is queried by hour or day.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainMonitoringUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMonitoringUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMonitoringUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_monitoring_usage_data(
        self,
        request: live_20161101_models.DescribeLiveDomainMonitoringUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse:
        """
        @summary Queries the live monitoring usage data for one or more domain names.
        
        @description    You can specify one or more domain names. Separate multiple domain names with commas (,).
        You can query data in the last 90 days.
        The data is queried by hour or day.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainMonitoringUsageDataRequest
        @return: DescribeLiveDomainMonitoringUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_monitoring_usage_data_with_options(request, runtime)

    async def describe_live_domain_monitoring_usage_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMonitoringUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainMonitoringUsageDataResponse:
        """
        @summary Queries the live monitoring usage data for one or more domain names.
        
        @description    You can specify one or more domain names. Separate multiple domain names with commas (,).
        You can query data in the last 90 days.
        The data is queried by hour or day.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainMonitoringUsageDataRequest
        @return: DescribeLiveDomainMonitoringUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_monitoring_usage_data_with_options_async(request, runtime)

    def describe_live_domain_multi_stream_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainMultiStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse:
        """
        @summary Queries the configuration status of dual-stream disaster recovery.
        
        @param request: DescribeLiveDomainMultiStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMultiStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMultiStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_multi_stream_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMultiStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse:
        """
        @summary Queries the configuration status of dual-stream disaster recovery.
        
        @param request: DescribeLiveDomainMultiStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainMultiStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainMultiStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_multi_stream_config(
        self,
        request: live_20161101_models.DescribeLiveDomainMultiStreamConfigRequest,
    ) -> live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse:
        """
        @summary Queries the configuration status of dual-stream disaster recovery.
        
        @param request: DescribeLiveDomainMultiStreamConfigRequest
        @return: DescribeLiveDomainMultiStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_multi_stream_config_with_options(request, runtime)

    async def describe_live_domain_multi_stream_config_async(
        self,
        request: live_20161101_models.DescribeLiveDomainMultiStreamConfigRequest,
    ) -> live_20161101_models.DescribeLiveDomainMultiStreamConfigResponse:
        """
        @summary Queries the configuration status of dual-stream disaster recovery.
        
        @param request: DescribeLiveDomainMultiStreamConfigRequest
        @return: DescribeLiveDomainMultiStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_multi_stream_config_with_options_async(request, runtime)

    def describe_live_domain_online_user_num_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainOnlineUserNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainOnlineUserNumResponse:
        """
        @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
        
        @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainOnlineUserNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainOnlineUserNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.query_time):
            query['QueryTime'] = request.query_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainOnlineUserNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainOnlineUserNumResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_online_user_num_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainOnlineUserNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainOnlineUserNumResponse:
        """
        @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
        
        @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainOnlineUserNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainOnlineUserNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.query_time):
            query['QueryTime'] = request.query_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainOnlineUserNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainOnlineUserNumResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_online_user_num(
        self,
        request: live_20161101_models.DescribeLiveDomainOnlineUserNumRequest,
    ) -> live_20161101_models.DescribeLiveDomainOnlineUserNumResponse:
        """
        @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
        
        @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainOnlineUserNumRequest
        @return: DescribeLiveDomainOnlineUserNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_online_user_num_with_options(request, runtime)

    async def describe_live_domain_online_user_num_async(
        self,
        request: live_20161101_models.DescribeLiveDomainOnlineUserNumRequest,
    ) -> live_20161101_models.DescribeLiveDomainOnlineUserNumResponse:
        """
        @summary Queries the number of online users at a specified point in time for all live streams under a specified domain name.
        
        @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
        >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainOnlineUserNumRequest
        @return: DescribeLiveDomainOnlineUserNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_online_user_num_with_options_async(request, runtime)

    def describe_live_domain_publish_error_code_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainPublishErrorCodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse:
        """
        @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
        
        @description    This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
        You can query data within the previous 90 days.
        The data is delayed for 3 to 5 minutes.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPublishErrorCodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPublishErrorCodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPublishErrorCode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_publish_error_code_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPublishErrorCodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse:
        """
        @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
        
        @description    This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
        You can query data within the previous 90 days.
        The data is delayed for 3 to 5 minutes.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPublishErrorCodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPublishErrorCodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPublishErrorCode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_publish_error_code(
        self,
        request: live_20161101_models.DescribeLiveDomainPublishErrorCodeRequest,
    ) -> live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse:
        """
        @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
        
        @description    This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
        You can query data within the previous 90 days.
        The data is delayed for 3 to 5 minutes.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPublishErrorCodeRequest
        @return: DescribeLiveDomainPublishErrorCodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_publish_error_code_with_options(request, runtime)

    async def describe_live_domain_publish_error_code_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPublishErrorCodeRequest,
    ) -> live_20161101_models.DescribeLiveDomainPublishErrorCodeResponse:
        """
        @summary Queries the HTTP status codes that are returned within a specified period of time under an ingest domain.
        
        @description    This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
        You can query data within the previous 90 days.
        The data is delayed for 3 to 5 minutes.
        ## [](#qps-)QPS limits
        You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPublishErrorCodeRequest
        @return: DescribeLiveDomainPublishErrorCodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_publish_error_code_with_options_async(request, runtime)

    def describe_live_domain_push_bps_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainPushBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPushBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more ingest domains.
        
        @description    The bandwidth unit is bit/s.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPushBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPushBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPushBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_push_bps_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPushBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPushBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more ingest domains.
        
        @description    The bandwidth unit is bit/s.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPushBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPushBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPushBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_push_bps_data(
        self,
        request: live_20161101_models.DescribeLiveDomainPushBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPushBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more ingest domains.
        
        @description    The bandwidth unit is bit/s.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushBpsDataRequest
        @return: DescribeLiveDomainPushBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_push_bps_data_with_options(request, runtime)

    async def describe_live_domain_push_bps_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPushBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPushBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more ingest domains.
        
        @description    The bandwidth unit is bit/s.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushBpsDataRequest
        @return: DescribeLiveDomainPushBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_push_bps_data_with_options_async(request, runtime)

    def describe_live_domain_push_traffic_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainPushTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPushTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more ingest domains.
        
        @description    The traffic unit is bytes.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPushTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPushTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPushTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_push_traffic_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPushTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPushTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more ingest domains.
        
        @description    The traffic unit is bytes.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPushTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPushTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPushTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_push_traffic_data(
        self,
        request: live_20161101_models.DescribeLiveDomainPushTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPushTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more ingest domains.
        
        @description    The traffic unit is bytes.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushTrafficDataRequest
        @return: DescribeLiveDomainPushTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_push_traffic_data_with_options(request, runtime)

    async def describe_live_domain_push_traffic_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPushTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPushTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more ingest domains.
        
        @description    The traffic unit is bytes.
        You can specify multiple domain names by separating them with commas (,).
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPushTrafficDataRequest
        @return: DescribeLiveDomainPushTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_push_traffic_data_with_options_async(request, runtime)

    def describe_live_domain_pv_uv_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainPvUvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPvUvDataResponse:
        """
        @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
        
        @description    You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can specify only one streaming domain in each request.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPvUvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPvUvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPvUvData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPvUvDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_pv_uv_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPvUvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainPvUvDataResponse:
        """
        @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
        
        @description    You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can specify only one streaming domain in each request.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPvUvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainPvUvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainPvUvData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainPvUvDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_pv_uv_data(
        self,
        request: live_20161101_models.DescribeLiveDomainPvUvDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPvUvDataResponse:
        """
        @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
        
        @description    You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can specify only one streaming domain in each request.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPvUvDataRequest
        @return: DescribeLiveDomainPvUvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_pv_uv_data_with_options(request, runtime)

    async def describe_live_domain_pv_uv_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainPvUvDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainPvUvDataResponse:
        """
        @summary Queries the data of page views (PVs) and unique visitors (UVs) of a streaming domain.
        
        @description    You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        You can specify only one streaming domain in each request.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainPvUvDataRequest
        @return: DescribeLiveDomainPvUvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_pv_uv_data_with_options_async(request, runtime)

    def describe_live_domain_real_time_bps_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data that is collected every minute for one or more domain names.
        
        @description    You can call this operation to query the bandwidth usage of one or more specified domain names.
        You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
        If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_real_time_bps_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data that is collected every minute for one or more domain names.
        
        @description    You can call this operation to query the bandwidth usage of one or more specified domain names.
        You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
        If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeBpsData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_real_time_bps_data(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data that is collected every minute for one or more domain names.
        
        @description    You can call this operation to query the bandwidth usage of one or more specified domain names.
        You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
        If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeBpsDataRequest
        @return: DescribeLiveDomainRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_real_time_bps_data_with_options(request, runtime)

    async def describe_live_domain_real_time_bps_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeBpsDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data that is collected every minute for one or more domain names.
        
        @description    You can call this operation to query the bandwidth usage of one or more specified domain names.
        You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
        If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeBpsDataRequest
        @return: DescribeLiveDomainRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_real_time_bps_data_with_options_async(request, runtime)

    def describe_live_domain_real_time_http_code_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
        
        @description The following table describes the time granularities supported by this operation.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|1 hour|7 days|5 minutes|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|Usually 4 hours|
        |1 day|Unlimited|366 days|After 04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeHttpCodeData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_real_time_http_code_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
        
        @description The following table describes the time granularities supported by this operation.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|1 hour|7 days|5 minutes|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|Usually 4 hours|
        |1 day|Unlimited|366 days|After 04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeHttpCodeData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_real_time_http_code_data(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
        
        @description The following table describes the time granularities supported by this operation.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|1 hour|7 days|5 minutes|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|Usually 4 hours|
        |1 day|Unlimited|366 days|After 04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeHttpCodeDataRequest
        @return: DescribeLiveDomainRealTimeHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_real_time_http_code_data_with_options(request, runtime)

    async def describe_live_domain_real_time_http_code_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the proportions of HTTP status codes returned for one or more domain names. Data is collected every minute.
        
        @description The following table describes the time granularities supported by this operation.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|1 hour|7 days|5 minutes|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|Usually 4 hours|
        |1 day|Unlimited|366 days|After 04:00 on the next day|
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRealTimeHttpCodeDataRequest
        @return: DescribeLiveDomainRealTimeHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_real_time_http_code_data_with_options_async(request, runtime)

    def describe_live_domain_real_time_traffic_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the network traffic data that is collected in real time for one or more domain names.
        
        @description    You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
        If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainRealTimeTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_real_time_traffic_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the network traffic data that is collected in real time for one or more domain names.
        
        @description    You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
        If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainRealTimeTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealTimeTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealTimeTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_real_time_traffic_data(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the network traffic data that is collected in real time for one or more domain names.
        
        @description    You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
        If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainRealTimeTrafficDataRequest
        @return: DescribeLiveDomainRealTimeTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_real_time_traffic_data_with_options(request, runtime)

    async def describe_live_domain_real_time_traffic_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealTimeTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the network traffic data that is collected in real time for one or more domain names.
        
        @description    You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
        If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainRealTimeTrafficDataRequest
        @return: DescribeLiveDomainRealTimeTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_real_time_traffic_data_with_options_async(request, runtime)

    def describe_live_domain_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse:
        """
        @summary Queries the information about real-time log delivery for a domain name.
        
        @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse:
        """
        @summary Queries the information about real-time log delivery for a domain name.
        
        @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_realtime_log_delivery(
        self,
        request: live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse:
        """
        @summary Queries the information about real-time log delivery for a domain name.
        
        @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainRealtimeLogDeliveryRequest
        @return: DescribeLiveDomainRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_realtime_log_delivery_with_options(request, runtime)

    async def describe_live_domain_realtime_log_delivery_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DescribeLiveDomainRealtimeLogDeliveryResponse:
        """
        @summary Queries the information about real-time log delivery for a domain name.
        
        @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainRealtimeLogDeliveryRequest
        @return: DescribeLiveDomainRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_realtime_log_delivery_with_options_async(request, runtime)

    def describe_live_domain_record_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainRecordUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRecordUsageDataResponse:
        """
        @summary Queries the numbers of live recording channels and container format conversions.
        
        @description    You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
        The number of time shifting channels is not included in the number of recording channels.
        You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
        If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
        If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
        If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRecordUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRecordUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRecordUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRecordUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_record_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRecordUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainRecordUsageDataResponse:
        """
        @summary Queries the numbers of live recording channels and container format conversions.
        
        @description    You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
        The number of time shifting channels is not included in the number of recording channels.
        You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
        If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
        If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
        If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRecordUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainRecordUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainRecordUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainRecordUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_record_usage_data(
        self,
        request: live_20161101_models.DescribeLiveDomainRecordUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRecordUsageDataResponse:
        """
        @summary Queries the numbers of live recording channels and container format conversions.
        
        @description    You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
        The number of time shifting channels is not included in the number of recording channels.
        You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
        If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
        If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
        If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRecordUsageDataRequest
        @return: DescribeLiveDomainRecordUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_record_usage_data_with_options(request, runtime)

    async def describe_live_domain_record_usage_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainRecordUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainRecordUsageDataResponse:
        """
        @summary Queries the numbers of live recording channels and container format conversions.
        
        @description    You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
        The number of time shifting channels is not included in the number of recording channels.
        You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
        If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
        If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
        If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainRecordUsageDataRequest
        @return: DescribeLiveDomainRecordUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_record_usage_data_with_options_async(request, runtime)

    def describe_live_domain_snapshot_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainSnapshotDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainSnapshotDataResponse:
        """
        @summary Queries the number of snapshots for one or more streaming domains.
        
        @description    You can call this operation to collect statistics on the total number of snapshots on a day.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainSnapshotDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainSnapshotDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainSnapshotData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainSnapshotDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_snapshot_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainSnapshotDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainSnapshotDataResponse:
        """
        @summary Queries the number of snapshots for one or more streaming domains.
        
        @description    You can call this operation to collect statistics on the total number of snapshots on a day.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainSnapshotDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainSnapshotDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainSnapshotData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainSnapshotDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_snapshot_data(
        self,
        request: live_20161101_models.DescribeLiveDomainSnapshotDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainSnapshotDataResponse:
        """
        @summary Queries the number of snapshots for one or more streaming domains.
        
        @description    You can call this operation to collect statistics on the total number of snapshots on a day.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainSnapshotDataRequest
        @return: DescribeLiveDomainSnapshotDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_snapshot_data_with_options(request, runtime)

    async def describe_live_domain_snapshot_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainSnapshotDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainSnapshotDataResponse:
        """
        @summary Queries the number of snapshots for one or more streaming domains.
        
        @description    You can call this operation to collect statistics on the total number of snapshots on a day.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
        
        @param request: DescribeLiveDomainSnapshotDataRequest
        @return: DescribeLiveDomainSnapshotDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_snapshot_data_with_options_async(request, runtime)

    def describe_live_domain_staging_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainStagingConfigResponse:
        """
        @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
        
        @description ## [](#)Usage notes
        You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_staging_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainStagingConfigResponse:
        """
        @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
        
        @description ## [](#)Usage notes
        You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_staging_config(
        self,
        request: live_20161101_models.DescribeLiveDomainStagingConfigRequest,
    ) -> live_20161101_models.DescribeLiveDomainStagingConfigResponse:
        """
        @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
        
        @description ## [](#)Usage notes
        You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainStagingConfigRequest
        @return: DescribeLiveDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_staging_config_with_options(request, runtime)

    async def describe_live_domain_staging_config_async(
        self,
        request: live_20161101_models.DescribeLiveDomainStagingConfigRequest,
    ) -> live_20161101_models.DescribeLiveDomainStagingConfigResponse:
        """
        @summary Queries the feature configurations of an accelerated domain name in the canary release environment.
        
        @description ## [](#)Usage notes
        You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDomainStagingConfigRequest
        @return: DescribeLiveDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_staging_config_with_options_async(request, runtime)

    def describe_live_domain_stream_transcode_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainStreamTranscodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse:
        """
        @summary Queries the transcoding length for one or more domain names.
        
        @description    You can call this operation to collect the transcoding usage data at each time interval.
        You can specify multiple domain names by separating them with commas (,).
        You can query data in the last 90 days.
        The time granularity of data is 1 hour or 1 day.
        For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainStreamTranscodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainStreamTranscodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.precision):
            query['Precision'] = request.precision
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split):
            query['Split'] = request.split
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainStreamTranscodeData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_stream_transcode_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainStreamTranscodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse:
        """
        @summary Queries the transcoding length for one or more domain names.
        
        @description    You can call this operation to collect the transcoding usage data at each time interval.
        You can specify multiple domain names by separating them with commas (,).
        You can query data in the last 90 days.
        The time granularity of data is 1 hour or 1 day.
        For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainStreamTranscodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainStreamTranscodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.precision):
            query['Precision'] = request.precision
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split):
            query['Split'] = request.split
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainStreamTranscodeData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_stream_transcode_data(
        self,
        request: live_20161101_models.DescribeLiveDomainStreamTranscodeDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse:
        """
        @summary Queries the transcoding length for one or more domain names.
        
        @description    You can call this operation to collect the transcoding usage data at each time interval.
        You can specify multiple domain names by separating them with commas (,).
        You can query data in the last 90 days.
        The time granularity of data is 1 hour or 1 day.
        For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainStreamTranscodeDataRequest
        @return: DescribeLiveDomainStreamTranscodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_stream_transcode_data_with_options(request, runtime)

    async def describe_live_domain_stream_transcode_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainStreamTranscodeDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainStreamTranscodeDataResponse:
        """
        @summary Queries the transcoding length for one or more domain names.
        
        @description    You can call this operation to collect the transcoding usage data at each time interval.
        You can specify multiple domain names by separating them with commas (,).
        You can query data in the last 90 days.
        The time granularity of data is 1 hour or 1 day.
        For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainStreamTranscodeDataRequest
        @return: DescribeLiveDomainStreamTranscodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_stream_transcode_data_with_options_async(request, runtime)

    def describe_live_domain_time_shift_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainTimeShiftDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTimeShiftDataResponse:
        """
        @summary Queries the resource usage data of time shifting for one or more domain names.
        
        @description    You can call this operation to query the time shifting usage data at each time interval.
        You can query data in the last 90 days.
        The time interval is 1 hour.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTimeShiftDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTimeShiftDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTimeShiftData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTimeShiftDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_time_shift_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTimeShiftDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTimeShiftDataResponse:
        """
        @summary Queries the resource usage data of time shifting for one or more domain names.
        
        @description    You can call this operation to query the time shifting usage data at each time interval.
        You can query data in the last 90 days.
        The time interval is 1 hour.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTimeShiftDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTimeShiftDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTimeShiftData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTimeShiftDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_time_shift_data(
        self,
        request: live_20161101_models.DescribeLiveDomainTimeShiftDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainTimeShiftDataResponse:
        """
        @summary Queries the resource usage data of time shifting for one or more domain names.
        
        @description    You can call this operation to query the time shifting usage data at each time interval.
        You can query data in the last 90 days.
        The time interval is 1 hour.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTimeShiftDataRequest
        @return: DescribeLiveDomainTimeShiftDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_time_shift_data_with_options(request, runtime)

    async def describe_live_domain_time_shift_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTimeShiftDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainTimeShiftDataResponse:
        """
        @summary Queries the resource usage data of time shifting for one or more domain names.
        
        @description    You can call this operation to query the time shifting usage data at each time interval.
        You can query data in the last 90 days.
        The time interval is 1 hour.
        The maximum time range for a query is 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTimeShiftDataRequest
        @return: DescribeLiveDomainTimeShiftDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_time_shift_data_with_options_async(request, runtime)

    def describe_live_domain_traffic_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more domain names.
        
        @description    If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_traffic_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more domain names.
        
        @description    If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTrafficData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_traffic_data(
        self,
        request: live_20161101_models.DescribeLiveDomainTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more domain names.
        
        @description    If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTrafficDataRequest
        @return: DescribeLiveDomainTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_traffic_data_with_options(request, runtime)

    async def describe_live_domain_traffic_data_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTrafficDataRequest,
    ) -> live_20161101_models.DescribeLiveDomainTrafficDataResponse:
        """
        @summary Queries the network traffic data for one or more domain names.
        
        @description    If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveDomainTrafficDataRequest
        @return: DescribeLiveDomainTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_traffic_data_with_options_async(request, runtime)

    def describe_live_domain_transcode_params_with_options(
        self,
        request: live_20161101_models.DescribeLiveDomainTranscodeParamsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTranscodeParamsResponse:
        """
        @param request: DescribeLiveDomainTranscodeParamsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTranscodeParamsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        if not UtilClient.is_unset(request.pushdomain):
            query['pushdomain'] = request.pushdomain
        if not UtilClient.is_unset(request.template_name):
            query['template_name'] = request.template_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTranscodeParams',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTranscodeParamsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_domain_transcode_params_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTranscodeParamsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDomainTranscodeParamsResponse:
        """
        @param request: DescribeLiveDomainTranscodeParamsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDomainTranscodeParamsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        if not UtilClient.is_unset(request.pushdomain):
            query['pushdomain'] = request.pushdomain
        if not UtilClient.is_unset(request.template_name):
            query['template_name'] = request.template_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDomainTranscodeParams',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDomainTranscodeParamsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_domain_transcode_params(
        self,
        request: live_20161101_models.DescribeLiveDomainTranscodeParamsRequest,
    ) -> live_20161101_models.DescribeLiveDomainTranscodeParamsResponse:
        """
        @param request: DescribeLiveDomainTranscodeParamsRequest
        @return: DescribeLiveDomainTranscodeParamsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_domain_transcode_params_with_options(request, runtime)

    async def describe_live_domain_transcode_params_async(
        self,
        request: live_20161101_models.DescribeLiveDomainTranscodeParamsRequest,
    ) -> live_20161101_models.DescribeLiveDomainTranscodeParamsResponse:
        """
        @param request: DescribeLiveDomainTranscodeParamsRequest
        @return: DescribeLiveDomainTranscodeParamsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_domain_transcode_params_with_options_async(request, runtime)

    def describe_live_drm_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveDrmUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDrmUsageDataResponse:
        """
        @description ### [](#)Usage notes
        You can query data in the previous 90 days.
        The maximum time range to query is 31 days.
        ### [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDrmUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDrmUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDrmUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDrmUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_drm_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveDrmUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveDrmUsageDataResponse:
        """
        @description ### [](#)Usage notes
        You can query data in the previous 90 days.
        The maximum time range to query is 31 days.
        ### [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDrmUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveDrmUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveDrmUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveDrmUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_drm_usage_data(
        self,
        request: live_20161101_models.DescribeLiveDrmUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDrmUsageDataResponse:
        """
        @description ### [](#)Usage notes
        You can query data in the previous 90 days.
        The maximum time range to query is 31 days.
        ### [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDrmUsageDataRequest
        @return: DescribeLiveDrmUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_drm_usage_data_with_options(request, runtime)

    async def describe_live_drm_usage_data_async(
        self,
        request: live_20161101_models.DescribeLiveDrmUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveDrmUsageDataResponse:
        """
        @description ### [](#)Usage notes
        You can query data in the previous 90 days.
        The maximum time range to query is 31 days.
        ### [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveDrmUsageDataRequest
        @return: DescribeLiveDrmUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_drm_usage_data_with_options_async(request, runtime)

    def describe_live_edge_transfer_with_options(
        self,
        request: live_20161101_models.DescribeLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveEdgeTransferResponse:
        """
        @summary Queries the configuration of edge stream relay.
        
        @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveEdgeTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_edge_transfer_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveEdgeTransferResponse:
        """
        @summary Queries the configuration of edge stream relay.
        
        @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveEdgeTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_edge_transfer(
        self,
        request: live_20161101_models.DescribeLiveEdgeTransferRequest,
    ) -> live_20161101_models.DescribeLiveEdgeTransferResponse:
        """
        @summary Queries the configuration of edge stream relay.
        
        @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveEdgeTransferRequest
        @return: DescribeLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_edge_transfer_with_options(request, runtime)

    async def describe_live_edge_transfer_async(
        self,
        request: live_20161101_models.DescribeLiveEdgeTransferRequest,
    ) -> live_20161101_models.DescribeLiveEdgeTransferResponse:
        """
        @summary Queries the configuration of edge stream relay.
        
        @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveEdgeTransferRequest
        @return: DescribeLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_edge_transfer_with_options_async(request, runtime)

    def describe_live_grtn_duration_with_options(
        self,
        request: live_20161101_models.DescribeLiveGrtnDurationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveGrtnDurationResponse:
        """
        @summary Queries the co-streaming usage data.
        
        @description    The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveGrtnDurationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveGrtnDurationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveGrtnDuration',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveGrtnDurationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_grtn_duration_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveGrtnDurationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveGrtnDurationResponse:
        """
        @summary Queries the co-streaming usage data.
        
        @description    The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveGrtnDurationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveGrtnDurationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveGrtnDuration',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveGrtnDurationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_grtn_duration(
        self,
        request: live_20161101_models.DescribeLiveGrtnDurationRequest,
    ) -> live_20161101_models.DescribeLiveGrtnDurationResponse:
        """
        @summary Queries the co-streaming usage data.
        
        @description    The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveGrtnDurationRequest
        @return: DescribeLiveGrtnDurationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_grtn_duration_with_options(request, runtime)

    async def describe_live_grtn_duration_async(
        self,
        request: live_20161101_models.DescribeLiveGrtnDurationRequest,
    ) -> live_20161101_models.DescribeLiveGrtnDurationResponse:
        """
        @summary Queries the co-streaming usage data.
        
        @description    The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveGrtnDurationRequest
        @return: DescribeLiveGrtnDurationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_grtn_duration_with_options_async(request, runtime)

    def describe_live_https_domain_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveHttpsDomainListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveHttpsDomainListResponse:
        """
        @summary Queries the information about all certificates that you have configured.
        
        @description You can call this operation to query the information about all certificates that you have configured.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveHttpsDomainListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveHttpsDomainListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveHttpsDomainList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveHttpsDomainListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_https_domain_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveHttpsDomainListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveHttpsDomainListResponse:
        """
        @summary Queries the information about all certificates that you have configured.
        
        @description You can call this operation to query the information about all certificates that you have configured.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveHttpsDomainListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveHttpsDomainListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveHttpsDomainList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveHttpsDomainListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_https_domain_list(
        self,
        request: live_20161101_models.DescribeLiveHttpsDomainListRequest,
    ) -> live_20161101_models.DescribeLiveHttpsDomainListResponse:
        """
        @summary Queries the information about all certificates that you have configured.
        
        @description You can call this operation to query the information about all certificates that you have configured.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveHttpsDomainListRequest
        @return: DescribeLiveHttpsDomainListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_https_domain_list_with_options(request, runtime)

    async def describe_live_https_domain_list_async(
        self,
        request: live_20161101_models.DescribeLiveHttpsDomainListRequest,
    ) -> live_20161101_models.DescribeLiveHttpsDomainListResponse:
        """
        @summary Queries the information about all certificates that you have configured.
        
        @description You can call this operation to query the information about all certificates that you have configured.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveHttpsDomainListRequest
        @return: DescribeLiveHttpsDomainListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_https_domain_list_with_options_async(request, runtime)

    def describe_live_interaction_metric_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveInteractionMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveInteractionMetricDataResponse:
        """
        @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
        
        @description    You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
        The time granularity for a query is 5 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveInteractionMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveInteractionMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.metric_type):
            query['MetricType'] = request.metric_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveInteractionMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveInteractionMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_interaction_metric_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveInteractionMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveInteractionMetricDataResponse:
        """
        @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
        
        @description    You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
        The time granularity for a query is 5 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveInteractionMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveInteractionMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.metric_type):
            query['MetricType'] = request.metric_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveInteractionMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveInteractionMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_interaction_metric_data(
        self,
        request: live_20161101_models.DescribeLiveInteractionMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveInteractionMetricDataResponse:
        """
        @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
        
        @description    You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
        The time granularity for a query is 5 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveInteractionMetricDataRequest
        @return: DescribeLiveInteractionMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_interaction_metric_data_with_options(request, runtime)

    async def describe_live_interaction_metric_data_async(
        self,
        request: live_20161101_models.DescribeLiveInteractionMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveInteractionMetricDataResponse:
        """
        @summary Queries the metric data of ApsaraVideo Real-time Communication (ARTC).
        
        @description    You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
        The time granularity for a query is 5 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveInteractionMetricDataRequest
        @return: DescribeLiveInteractionMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_interaction_metric_data_with_options_async(request, runtime)

    def describe_live_ip_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveIpInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveIpInfoResponse:
        """
        @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveIpInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveIpInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip):
            query['IP'] = request.ip
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveIpInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveIpInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_ip_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveIpInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveIpInfoResponse:
        """
        @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveIpInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveIpInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ip):
            query['IP'] = request.ip
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveIpInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveIpInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_ip_info(
        self,
        request: live_20161101_models.DescribeLiveIpInfoRequest,
    ) -> live_20161101_models.DescribeLiveIpInfoResponse:
        """
        @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveIpInfoRequest
        @return: DescribeLiveIpInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_ip_info_with_options(request, runtime)

    async def describe_live_ip_info_async(
        self,
        request: live_20161101_models.DescribeLiveIpInfoRequest,
    ) -> live_20161101_models.DescribeLiveIpInfoResponse:
        """
        @summary Checks whether a specified IP address belongs to an Alibaba Cloud point of presence (POP).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveIpInfoRequest
        @return: DescribeLiveIpInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_ip_info_with_options_async(request, runtime)

    def describe_live_lazy_pull_stream_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveLazyPullStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveLazyPullStreamConfigResponse:
        """
        @summary Queries the configurations of triggered stream pulling for a streaming domain.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
        ## QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveLazyPullStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveLazyPullStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveLazyPullStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveLazyPullStreamConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_lazy_pull_stream_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveLazyPullStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveLazyPullStreamConfigResponse:
        """
        @summary Queries the configurations of triggered stream pulling for a streaming domain.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
        ## QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveLazyPullStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveLazyPullStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveLazyPullStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveLazyPullStreamConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_lazy_pull_stream_config(
        self,
        request: live_20161101_models.DescribeLiveLazyPullStreamConfigRequest,
    ) -> live_20161101_models.DescribeLiveLazyPullStreamConfigResponse:
        """
        @summary Queries the configurations of triggered stream pulling for a streaming domain.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
        ## QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveLazyPullStreamConfigRequest
        @return: DescribeLiveLazyPullStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_lazy_pull_stream_config_with_options(request, runtime)

    async def describe_live_lazy_pull_stream_config_async(
        self,
        request: live_20161101_models.DescribeLiveLazyPullStreamConfigRequest,
    ) -> live_20161101_models.DescribeLiveLazyPullStreamConfigResponse:
        """
        @summary Queries the configurations of triggered stream pulling for a streaming domain.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
        ## QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveLazyPullStreamConfigRequest
        @return: DescribeLiveLazyPullStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_lazy_pull_stream_config_with_options_async(request, runtime)

    def describe_live_message_app_with_options(
        self,
        request: live_20161101_models.DescribeLiveMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageAppResponse:
        """
        @summary Query Interactive Message App
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_message_app_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageAppResponse:
        """
        @summary Query Interactive Message App
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_message_app(
        self,
        request: live_20161101_models.DescribeLiveMessageAppRequest,
    ) -> live_20161101_models.DescribeLiveMessageAppResponse:
        """
        @summary Query Interactive Message App
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageAppRequest
        @return: DescribeLiveMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_message_app_with_options(request, runtime)

    async def describe_live_message_app_async(
        self,
        request: live_20161101_models.DescribeLiveMessageAppRequest,
    ) -> live_20161101_models.DescribeLiveMessageAppResponse:
        """
        @summary Query Interactive Message App
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageAppRequest
        @return: DescribeLiveMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_message_app_with_options_async(request, runtime)

    def describe_live_message_group_with_options(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageGroupResponse:
        """
        @summary Queries the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_message_group_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageGroupResponse:
        """
        @summary Queries the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_message_group(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupRequest,
    ) -> live_20161101_models.DescribeLiveMessageGroupResponse:
        """
        @summary Queries the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupRequest
        @return: DescribeLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_message_group_with_options(request, runtime)

    async def describe_live_message_group_async(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupRequest,
    ) -> live_20161101_models.DescribeLiveMessageGroupResponse:
        """
        @summary Queries the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupRequest
        @return: DescribeLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_message_group_with_options_async(request, runtime)

    def describe_live_message_group_band_with_options(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageGroupBandResponse:
        """
        @summary Queries the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageGroupBandResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_message_group_band_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveMessageGroupBandResponse:
        """
        @summary Queries the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveMessageGroupBandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_message_group_band(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupBandRequest,
    ) -> live_20161101_models.DescribeLiveMessageGroupBandResponse:
        """
        @summary Queries the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupBandRequest
        @return: DescribeLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_message_group_band_with_options(request, runtime)

    async def describe_live_message_group_band_async(
        self,
        request: live_20161101_models.DescribeLiveMessageGroupBandRequest,
    ) -> live_20161101_models.DescribeLiveMessageGroupBandResponse:
        """
        @summary Queries the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveMessageGroupBandRequest
        @return: DescribeLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_message_group_band_with_options_async(request, runtime)

    def describe_live_package_config_with_options(
        self,
        request: live_20161101_models.DescribeLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePackageConfigResponse:
        """
        @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePackageConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_package_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePackageConfigResponse:
        """
        @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePackageConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_package_config(
        self,
        request: live_20161101_models.DescribeLivePackageConfigRequest,
    ) -> live_20161101_models.DescribeLivePackageConfigResponse:
        """
        @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePackageConfigRequest
        @return: DescribeLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_package_config_with_options(request, runtime)

    async def describe_live_package_config_async(
        self,
        request: live_20161101_models.DescribeLivePackageConfigRequest,
    ) -> live_20161101_models.DescribeLivePackageConfigResponse:
        """
        @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePackageConfigRequest
        @return: DescribeLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_package_config_with_options_async(request, runtime)

    def describe_live_private_line_areas_with_options(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAreasRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePrivateLineAreasResponse:
        """
        @summary Queries available access points where acceleration circuits start.
        
        @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAreasRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePrivateLineAreasResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePrivateLineAreas',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePrivateLineAreasResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_private_line_areas_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAreasRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePrivateLineAreasResponse:
        """
        @summary Queries available access points where acceleration circuits start.
        
        @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAreasRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePrivateLineAreasResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePrivateLineAreas',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePrivateLineAreasResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_private_line_areas(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAreasRequest,
    ) -> live_20161101_models.DescribeLivePrivateLineAreasResponse:
        """
        @summary Queries available access points where acceleration circuits start.
        
        @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAreasRequest
        @return: DescribeLivePrivateLineAreasResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_private_line_areas_with_options(request, runtime)

    async def describe_live_private_line_areas_async(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAreasRequest,
    ) -> live_20161101_models.DescribeLivePrivateLineAreasResponse:
        """
        @summary Queries available access points where acceleration circuits start.
        
        @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAreasRequest
        @return: DescribeLivePrivateLineAreasResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_private_line_areas_with_options_async(request, runtime)

    def describe_live_private_line_avail_gawith_options(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAvailGARequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePrivateLineAvailGAResponse:
        """
        @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
        
        @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAvailGARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePrivateLineAvailGAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_area):
            query['AccelerationArea'] = request.acceleration_area
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.is_ga_instance):
            query['IsGaInstance'] = request.is_ga_instance
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_center):
            query['VideoCenter'] = request.video_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePrivateLineAvailGA',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePrivateLineAvailGAResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_private_line_avail_gawith_options_async(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAvailGARequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePrivateLineAvailGAResponse:
        """
        @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
        
        @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAvailGARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePrivateLineAvailGAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.acceleration_area):
            query['AccelerationArea'] = request.acceleration_area
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.is_ga_instance):
            query['IsGaInstance'] = request.is_ga_instance
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_center):
            query['VideoCenter'] = request.video_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePrivateLineAvailGA',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePrivateLineAvailGAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_private_line_avail_ga(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAvailGARequest,
    ) -> live_20161101_models.DescribeLivePrivateLineAvailGAResponse:
        """
        @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
        
        @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAvailGARequest
        @return: DescribeLivePrivateLineAvailGAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_private_line_avail_gawith_options(request, runtime)

    async def describe_live_private_line_avail_ga_async(
        self,
        request: live_20161101_models.DescribeLivePrivateLineAvailGARequest,
    ) -> live_20161101_models.DescribeLivePrivateLineAvailGAResponse:
        """
        @summary Queries the binding information between Global Accelerator (GA) instances and acceleration circuits.
        
        @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePrivateLineAvailGARequest
        @return: DescribeLivePrivateLineAvailGAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_private_line_avail_gawith_options_async(request, runtime)

    def describe_live_producer_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveProducerUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveProducerUsageDataResponse:
        """
        @summary Queries the production studio usage data.
        
        @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveProducerUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveProducerUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance):
            query['Instance'] = request.instance
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveProducerUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveProducerUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_producer_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveProducerUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveProducerUsageDataResponse:
        """
        @summary Queries the production studio usage data.
        
        @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveProducerUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveProducerUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.instance):
            query['Instance'] = request.instance
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.app):
            query['app'] = request.app
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveProducerUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveProducerUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_producer_usage_data(
        self,
        request: live_20161101_models.DescribeLiveProducerUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveProducerUsageDataResponse:
        """
        @summary Queries the production studio usage data.
        
        @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveProducerUsageDataRequest
        @return: DescribeLiveProducerUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_producer_usage_data_with_options(request, runtime)

    async def describe_live_producer_usage_data_async(
        self,
        request: live_20161101_models.DescribeLiveProducerUsageDataRequest,
    ) -> live_20161101_models.DescribeLiveProducerUsageDataResponse:
        """
        @summary Queries the production studio usage data.
        
        @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveProducerUsageDataRequest
        @return: DescribeLiveProducerUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_producer_usage_data_with_options_async(request, runtime)

    def describe_live_pull_stream_config_with_options(
        self,
        request: live_20161101_models.DescribeLivePullStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullStreamConfigResponse:
        """
        @summary Queries the stream pulling configurations for a domain name.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLivePullStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullStreamConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_pull_stream_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePullStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullStreamConfigResponse:
        """
        @summary Queries the stream pulling configurations for a domain name.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLivePullStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullStreamConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_pull_stream_config(
        self,
        request: live_20161101_models.DescribeLivePullStreamConfigRequest,
    ) -> live_20161101_models.DescribeLivePullStreamConfigResponse:
        """
        @summary Queries the stream pulling configurations for a domain name.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLivePullStreamConfigRequest
        @return: DescribeLivePullStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_pull_stream_config_with_options(request, runtime)

    async def describe_live_pull_stream_config_async(
        self,
        request: live_20161101_models.DescribeLivePullStreamConfigRequest,
    ) -> live_20161101_models.DescribeLivePullStreamConfigResponse:
        """
        @summary Queries the stream pulling configurations for a domain name.
        
        @description ##
        This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLivePullStreamConfigRequest
        @return: DescribeLivePullStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_pull_stream_config_with_options_async(request, runtime)

    def describe_live_pull_to_push_with_options(
        self,
        request: live_20161101_models.DescribeLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullToPushResponse:
        """
        @summary Queries pulled-stream relay tasks.
        
        @description    You can call this operation to query the information about a pulled-stream relay task.
        This operation allows you to query the configurations and status of a task with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_pull_to_push_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullToPushResponse:
        """
        @summary Queries pulled-stream relay tasks.
        
        @description    You can call this operation to query the information about a pulled-stream relay task.
        This operation allows you to query the configurations and status of a task with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_pull_to_push(
        self,
        request: live_20161101_models.DescribeLivePullToPushRequest,
    ) -> live_20161101_models.DescribeLivePullToPushResponse:
        """
        @summary Queries pulled-stream relay tasks.
        
        @description    You can call this operation to query the information about a pulled-stream relay task.
        This operation allows you to query the configurations and status of a task with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushRequest
        @return: DescribeLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_pull_to_push_with_options(request, runtime)

    async def describe_live_pull_to_push_async(
        self,
        request: live_20161101_models.DescribeLivePullToPushRequest,
    ) -> live_20161101_models.DescribeLivePullToPushResponse:
        """
        @summary Queries pulled-stream relay tasks.
        
        @description    You can call this operation to query the information about a pulled-stream relay task.
        This operation allows you to query the configurations and status of a task with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushRequest
        @return: DescribeLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_pull_to_push_with_options_async(request, runtime)

    def describe_live_pull_to_push_list_with_options(
        self,
        request: live_20161101_models.DescribeLivePullToPushListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullToPushListResponse:
        """
        @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
        
        @description    You can call this operation to query pulled-stream relay tasks.
        You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullToPushListResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullToPushList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullToPushListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_pull_to_push_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePullToPushListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePullToPushListResponse:
        """
        @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
        
        @description    You can call this operation to query pulled-stream relay tasks.
        You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePullToPushListResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePullToPushList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePullToPushListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_pull_to_push_list(
        self,
        request: live_20161101_models.DescribeLivePullToPushListRequest,
    ) -> live_20161101_models.DescribeLivePullToPushListResponse:
        """
        @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
        
        @description    You can call this operation to query pulled-stream relay tasks.
        You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushListRequest
        @return: DescribeLivePullToPushListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_pull_to_push_list_with_options(request, runtime)

    async def describe_live_pull_to_push_list_async(
        self,
        request: live_20161101_models.DescribeLivePullToPushListRequest,
    ) -> live_20161101_models.DescribeLivePullToPushListResponse:
        """
        @summary Queries pulled-stream relay tasks. Fuzzy match is supported.
        
        @description    You can call this operation to query pulled-stream relay tasks.
        You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePullToPushListRequest
        @return: DescribeLivePullToPushListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_pull_to_push_list_with_options_async(request, runtime)

    def describe_live_push_proxy_log_with_options(
        self,
        request: live_20161101_models.DescribeLivePushProxyLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePushProxyLogResponse:
        """
        @summary Queries the stream relay logs, which are available for download.
        
        @description    The time granularity of the data is 1 hour.
        You can query data in the last 31 days.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePushProxyLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePushProxyLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePushProxyLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_push_proxy_log_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePushProxyLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePushProxyLogResponse:
        """
        @summary Queries the stream relay logs, which are available for download.
        
        @description    The time granularity of the data is 1 hour.
        You can query data in the last 31 days.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePushProxyLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePushProxyLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePushProxyLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_push_proxy_log(
        self,
        request: live_20161101_models.DescribeLivePushProxyLogRequest,
    ) -> live_20161101_models.DescribeLivePushProxyLogResponse:
        """
        @summary Queries the stream relay logs, which are available for download.
        
        @description    The time granularity of the data is 1 hour.
        You can query data in the last 31 days.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyLogRequest
        @return: DescribeLivePushProxyLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_push_proxy_log_with_options(request, runtime)

    async def describe_live_push_proxy_log_async(
        self,
        request: live_20161101_models.DescribeLivePushProxyLogRequest,
    ) -> live_20161101_models.DescribeLivePushProxyLogResponse:
        """
        @summary Queries the stream relay logs, which are available for download.
        
        @description    The time granularity of the data is 1 hour.
        You can query data in the last 31 days.
        If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyLogRequest
        @return: DescribeLivePushProxyLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_push_proxy_log_with_options_async(request, runtime)

    def describe_live_push_proxy_usage_data_with_options(
        self,
        request: live_20161101_models.DescribeLivePushProxyUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePushProxyUsageDataResponse:
        """
        @summary Queries the usage data of live center stream relay.
        
        @description    You can call this operation to query the usage data of live center stream relay.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 day.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePushProxyUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePushProxyUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePushProxyUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_push_proxy_usage_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLivePushProxyUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLivePushProxyUsageDataResponse:
        """
        @summary Queries the usage data of live center stream relay.
        
        @description    You can call this operation to query the usage data of live center stream relay.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 day.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLivePushProxyUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_by):
            query['SplitBy'] = request.split_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLivePushProxyUsageData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLivePushProxyUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_push_proxy_usage_data(
        self,
        request: live_20161101_models.DescribeLivePushProxyUsageDataRequest,
    ) -> live_20161101_models.DescribeLivePushProxyUsageDataResponse:
        """
        @summary Queries the usage data of live center stream relay.
        
        @description    You can call this operation to query the usage data of live center stream relay.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 day.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyUsageDataRequest
        @return: DescribeLivePushProxyUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_push_proxy_usage_data_with_options(request, runtime)

    async def describe_live_push_proxy_usage_data_async(
        self,
        request: live_20161101_models.DescribeLivePushProxyUsageDataRequest,
    ) -> live_20161101_models.DescribeLivePushProxyUsageDataResponse:
        """
        @summary Queries the usage data of live center stream relay.
        
        @description    You can call this operation to query the usage data of live center stream relay.
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 1 day.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLivePushProxyUsageDataRequest
        @return: DescribeLivePushProxyUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_push_proxy_usage_data_with_options_async(request, runtime)

    def describe_live_realtime_delivery_acc_with_options(
        self,
        request: live_20161101_models.DescribeLiveRealtimeDeliveryAccRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @description    You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
        You can query the data by UID.
        You are charged for both successful and failed real-time log deliveries.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRealtimeDeliveryAccRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRealtimeDeliveryAccResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project):
            query['Project'] = request.project
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRealtimeDeliveryAcc',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_realtime_delivery_acc_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRealtimeDeliveryAccRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @description    You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
        You can query the data by UID.
        You are charged for both successful and failed real-time log deliveries.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRealtimeDeliveryAccRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRealtimeDeliveryAccResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project):
            query['Project'] = request.project
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRealtimeDeliveryAcc',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_realtime_delivery_acc(
        self,
        request: live_20161101_models.DescribeLiveRealtimeDeliveryAccRequest,
    ) -> live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @description    You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
        You can query the data by UID.
        You are charged for both successful and failed real-time log deliveries.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRealtimeDeliveryAccRequest
        @return: DescribeLiveRealtimeDeliveryAccResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_realtime_delivery_acc_with_options(request, runtime)

    async def describe_live_realtime_delivery_acc_async(
        self,
        request: live_20161101_models.DescribeLiveRealtimeDeliveryAccRequest,
    ) -> live_20161101_models.DescribeLiveRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @description    You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
        You can query the data by UID.
        You are charged for both successful and failed real-time log deliveries.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRealtimeDeliveryAccRequest
        @return: DescribeLiveRealtimeDeliveryAccResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_realtime_delivery_acc_with_options_async(request, runtime)

    def describe_live_realtime_log_authorized_with_options(
        self,
        request: live_20161101_models.DescribeLiveRealtimeLogAuthorizedRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse:
        """
        @summary Queries the status of authorization for real-time log delivery.
        
        @description You can call this operation to query the status of authorization for real-time log delivery.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRealtimeLogAuthorizedRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRealtimeLogAuthorizedResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRealtimeLogAuthorized',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_realtime_log_authorized_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRealtimeLogAuthorizedRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse:
        """
        @summary Queries the status of authorization for real-time log delivery.
        
        @description You can call this operation to query the status of authorization for real-time log delivery.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRealtimeLogAuthorizedRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRealtimeLogAuthorizedResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRealtimeLogAuthorized',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_realtime_log_authorized(
        self,
        request: live_20161101_models.DescribeLiveRealtimeLogAuthorizedRequest,
    ) -> live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse:
        """
        @summary Queries the status of authorization for real-time log delivery.
        
        @description You can call this operation to query the status of authorization for real-time log delivery.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRealtimeLogAuthorizedRequest
        @return: DescribeLiveRealtimeLogAuthorizedResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_realtime_log_authorized_with_options(request, runtime)

    async def describe_live_realtime_log_authorized_async(
        self,
        request: live_20161101_models.DescribeLiveRealtimeLogAuthorizedRequest,
    ) -> live_20161101_models.DescribeLiveRealtimeLogAuthorizedResponse:
        """
        @summary Queries the status of authorization for real-time log delivery.
        
        @description You can call this operation to query the status of authorization for real-time log delivery.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRealtimeLogAuthorizedRequest
        @return: DescribeLiveRealtimeLogAuthorizedResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_realtime_log_authorized_with_options_async(request, runtime)

    def describe_live_record_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordConfigResponse:
        """
        @summary Queries all recording configurations of an application for a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_record_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordConfigResponse:
        """
        @summary Queries all recording configurations of an application for a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_record_config(
        self,
        request: live_20161101_models.DescribeLiveRecordConfigRequest,
    ) -> live_20161101_models.DescribeLiveRecordConfigResponse:
        """
        @summary Queries all recording configurations of an application for a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordConfigRequest
        @return: DescribeLiveRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_record_config_with_options(request, runtime)

    async def describe_live_record_config_async(
        self,
        request: live_20161101_models.DescribeLiveRecordConfigRequest,
    ) -> live_20161101_models.DescribeLiveRecordConfigResponse:
        """
        @summary Queries all recording configurations of an application for a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordConfigRequest
        @return: DescribeLiveRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_record_config_with_options_async(request, runtime)

    def describe_live_record_notify_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_record_notify_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_record_notify_config(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveRecordNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyConfigRequest
        @return: DescribeLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_record_notify_config_with_options(request, runtime)

    async def describe_live_record_notify_config_async(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveRecordNotifyConfigResponse:
        """
        @summary Queries the configuration of callbacks for live stream recording under a domain name.
        
        @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyConfigRequest
        @return: DescribeLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_record_notify_config_with_options_async(request, runtime)

    def describe_live_record_notify_records_with_options(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordNotifyRecordsResponse:
        """
        @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordNotifyRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordNotifyRecords',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordNotifyRecordsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_record_notify_records_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordNotifyRecordsResponse:
        """
        @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordNotifyRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordNotifyRecords',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordNotifyRecordsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_record_notify_records(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyRecordsRequest,
    ) -> live_20161101_models.DescribeLiveRecordNotifyRecordsResponse:
        """
        @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyRecordsRequest
        @return: DescribeLiveRecordNotifyRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_record_notify_records_with_options(request, runtime)

    async def describe_live_record_notify_records_async(
        self,
        request: live_20161101_models.DescribeLiveRecordNotifyRecordsRequest,
    ) -> live_20161101_models.DescribeLiveRecordNotifyRecordsResponse:
        """
        @summary Queries the recording callback records that are stored in Object Storage Service (OSS).
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveRecordNotifyRecordsRequest
        @return: DescribeLiveRecordNotifyRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_record_notify_records_with_options_async(request, runtime)

    def describe_live_record_vod_configs_with_options(
        self,
        request: live_20161101_models.DescribeLiveRecordVodConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordVodConfigsResponse:
        """
        @summary Queries Live-to-VOD configurations.
        
        @description ## [](#)Usage notes
        Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRecordVodConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordVodConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordVodConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordVodConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_record_vod_configs_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveRecordVodConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveRecordVodConfigsResponse:
        """
        @summary Queries Live-to-VOD configurations.
        
        @description ## [](#)Usage notes
        Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRecordVodConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveRecordVodConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveRecordVodConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveRecordVodConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_record_vod_configs(
        self,
        request: live_20161101_models.DescribeLiveRecordVodConfigsRequest,
    ) -> live_20161101_models.DescribeLiveRecordVodConfigsResponse:
        """
        @summary Queries Live-to-VOD configurations.
        
        @description ## [](#)Usage notes
        Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRecordVodConfigsRequest
        @return: DescribeLiveRecordVodConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_record_vod_configs_with_options(request, runtime)

    async def describe_live_record_vod_configs_async(
        self,
        request: live_20161101_models.DescribeLiveRecordVodConfigsRequest,
    ) -> live_20161101_models.DescribeLiveRecordVodConfigsResponse:
        """
        @summary Queries Live-to-VOD configurations.
        
        @description ## [](#)Usage notes
        Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveRecordVodConfigsRequest
        @return: DescribeLiveRecordVodConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_record_vod_configs_with_options_async(request, runtime)

    def describe_live_shift_configs_with_options(
        self,
        request: live_20161101_models.DescribeLiveShiftConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveShiftConfigsResponse:
        """
        @summary Queries the time shifting configurations under a domain name.
        
        @description This operation is applicable to the streaming domains.
        ## QPS limit
        A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveShiftConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveShiftConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveShiftConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveShiftConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_shift_configs_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveShiftConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveShiftConfigsResponse:
        """
        @summary Queries the time shifting configurations under a domain name.
        
        @description This operation is applicable to the streaming domains.
        ## QPS limit
        A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveShiftConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveShiftConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveShiftConfigs',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveShiftConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_shift_configs(
        self,
        request: live_20161101_models.DescribeLiveShiftConfigsRequest,
    ) -> live_20161101_models.DescribeLiveShiftConfigsResponse:
        """
        @summary Queries the time shifting configurations under a domain name.
        
        @description This operation is applicable to the streaming domains.
        ## QPS limit
        A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveShiftConfigsRequest
        @return: DescribeLiveShiftConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_shift_configs_with_options(request, runtime)

    async def describe_live_shift_configs_async(
        self,
        request: live_20161101_models.DescribeLiveShiftConfigsRequest,
    ) -> live_20161101_models.DescribeLiveShiftConfigsResponse:
        """
        @summary Queries the time shifting configurations under a domain name.
        
        @description This operation is applicable to the streaming domains.
        ## QPS limit
        A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveShiftConfigsRequest
        @return: DescribeLiveShiftConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_shift_configs_with_options_async(request, runtime)

    def describe_live_snapshot_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotConfigResponse:
        """
        @summary Queries the snapshot configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_snapshot_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotConfigResponse:
        """
        @summary Queries the snapshot configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_snapshot_config(
        self,
        request: live_20161101_models.DescribeLiveSnapshotConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotConfigResponse:
        """
        @summary Queries the snapshot configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotConfigRequest
        @return: DescribeLiveSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_snapshot_config_with_options(request, runtime)

    async def describe_live_snapshot_config_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotConfigResponse:
        """
        @summary Queries the snapshot configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotConfigRequest
        @return: DescribeLiveSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_snapshot_config_with_options_async(request, runtime)

    def describe_live_snapshot_detect_porn_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse:
        """
        @summary Queries video moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_snapshot_detect_porn_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse:
        """
        @summary Queries video moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_snapshot_detect_porn_config(
        self,
        request: live_20161101_models.DescribeLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse:
        """
        @summary Queries video moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotDetectPornConfigRequest
        @return: DescribeLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_snapshot_detect_porn_config_with_options(request, runtime)

    async def describe_live_snapshot_detect_porn_config_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotDetectPornConfigResponse:
        """
        @summary Queries video moderation configurations.
        
        @description    Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotDetectPornConfigRequest
        @return: DescribeLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_snapshot_detect_porn_config_with_options_async(request, runtime)

    def describe_live_snapshot_notify_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse:
        """
        @summary Queries the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_snapshot_notify_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse:
        """
        @summary Queries the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_snapshot_notify_config(
        self,
        request: live_20161101_models.DescribeLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse:
        """
        @summary Queries the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotNotifyConfigRequest
        @return: DescribeLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_snapshot_notify_config_with_options(request, runtime)

    async def describe_live_snapshot_notify_config_async(
        self,
        request: live_20161101_models.DescribeLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.DescribeLiveSnapshotNotifyConfigResponse:
        """
        @summary Queries the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveSnapshotNotifyConfigRequest
        @return: DescribeLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_snapshot_notify_config_with_options_async(request, runtime)

    def describe_live_stream_auth_checking_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamAuthCheckingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamAuthCheckingResponse:
        """
        @summary Queries the authentication status of an active stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamAuthCheckingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamAuthCheckingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.url):
            query['Url'] = request.url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamAuthChecking',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamAuthCheckingResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_auth_checking_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamAuthCheckingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamAuthCheckingResponse:
        """
        @summary Queries the authentication status of an active stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamAuthCheckingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamAuthCheckingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.url):
            query['Url'] = request.url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamAuthChecking',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamAuthCheckingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_auth_checking(
        self,
        request: live_20161101_models.DescribeLiveStreamAuthCheckingRequest,
    ) -> live_20161101_models.DescribeLiveStreamAuthCheckingResponse:
        """
        @summary Queries the authentication status of an active stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamAuthCheckingRequest
        @return: DescribeLiveStreamAuthCheckingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_auth_checking_with_options(request, runtime)

    async def describe_live_stream_auth_checking_async(
        self,
        request: live_20161101_models.DescribeLiveStreamAuthCheckingRequest,
    ) -> live_20161101_models.DescribeLiveStreamAuthCheckingResponse:
        """
        @summary Queries the authentication status of an active stream.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamAuthCheckingRequest
        @return: DescribeLiveStreamAuthCheckingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_auth_checking_with_options_async(request, runtime)

    def describe_live_stream_bit_rate_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
        
        @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamBitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_bit_rate_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
        
        @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamBitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_bit_rate_data(
        self,
        request: live_20161101_models.DescribeLiveStreamBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
        
        @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamBitRateDataRequest
        @return: DescribeLiveStreamBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_bit_rate_data_with_options(request, runtime)

    async def describe_live_stream_bit_rate_data_async(
        self,
        request: live_20161101_models.DescribeLiveStreamBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamBitRateDataResponse:
        """
        @summary Queries the frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream within a specified time period. You can call this operation to query historical data.
        
        @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamBitRateDataRequest
        @return: DescribeLiveStreamBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_bit_rate_data_with_options_async(request, runtime)

    def describe_live_stream_count_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamCountResponse:
        """
        @summary Queries the numbers of online source streams and transcoded streams.
        
        @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamCountResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamCount',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamCountResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_count_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamCountResponse:
        """
        @summary Queries the numbers of online source streams and transcoded streams.
        
        @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamCountResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamCount',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamCountResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_count(
        self,
        request: live_20161101_models.DescribeLiveStreamCountRequest,
    ) -> live_20161101_models.DescribeLiveStreamCountResponse:
        """
        @summary Queries the numbers of online source streams and transcoded streams.
        
        @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamCountRequest
        @return: DescribeLiveStreamCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_count_with_options(request, runtime)

    async def describe_live_stream_count_async(
        self,
        request: live_20161101_models.DescribeLiveStreamCountRequest,
    ) -> live_20161101_models.DescribeLiveStreamCountResponse:
        """
        @summary Queries the numbers of online source streams and transcoded streams.
        
        @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamCountRequest
        @return: DescribeLiveStreamCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_count_with_options_async(request, runtime)

    def describe_live_stream_delay_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamDelayConfigResponse:
        """
        @summary Queries the live streaming latency.
        
        @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_delay_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamDelayConfigResponse:
        """
        @summary Queries the live streaming latency.
        
        @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_delay_config(
        self,
        request: live_20161101_models.DescribeLiveStreamDelayConfigRequest,
    ) -> live_20161101_models.DescribeLiveStreamDelayConfigResponse:
        """
        @summary Queries the live streaming latency.
        
        @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamDelayConfigRequest
        @return: DescribeLiveStreamDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_delay_config_with_options(request, runtime)

    async def describe_live_stream_delay_config_async(
        self,
        request: live_20161101_models.DescribeLiveStreamDelayConfigRequest,
    ) -> live_20161101_models.DescribeLiveStreamDelayConfigResponse:
        """
        @summary Queries the live streaming latency.
        
        @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamDelayConfigRequest
        @return: DescribeLiveStreamDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_delay_config_with_options_async(request, runtime)

    def describe_live_stream_detail_frame_rate_and_bit_rate_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
        
        @description    You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query data in the last 90 days.
        The data is delayed for 3 to 5 minutes.
        The maximum time range that you can specify is 1 hour.
        
        @param request: DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamDetailFrameRateAndBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_detail_frame_rate_and_bit_rate_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
        
        @description    You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query data in the last 90 days.
        The data is delayed for 3 to 5 minutes.
        The maximum time range that you can specify is 1 hour.
        
        @param request: DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamDetailFrameRateAndBitRateData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_detail_frame_rate_and_bit_rate_data(
        self,
        request: live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
        
        @description    You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query data in the last 90 days.
        The data is delayed for 3 to 5 minutes.
        The maximum time range that you can specify is 1 hour.
        
        @param request: DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
        @return: DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_detail_frame_rate_and_bit_rate_data_with_options(request, runtime)

    async def describe_live_stream_detail_frame_rate_and_bit_rate_data_async(
        self,
        request: live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamDetailFrameRateAndBitRateDataResponse:
        """
        @summary Queries the audio and video frame rates and bitrates of a Real-Time Messaging Protocol (RTMP) stream.
        
        @description    You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        You can query data in the last 90 days.
        The data is delayed for 3 to 5 minutes.
        The maximum time range that you can specify is 1 hour.
        
        @param request: DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
        @return: DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_detail_frame_rate_and_bit_rate_data_with_options_async(request, runtime)

    def describe_live_stream_history_user_num_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamHistoryUserNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamHistoryUserNumResponse:
        """
        @summary Queries the number of historical online users for a live stream.
        
        @description    The data returned by this operation is delayed for an average of 2 to 5 minutes.
        This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
        This operation does not query the number of viewers that are watching transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamHistoryUserNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamHistoryUserNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamHistoryUserNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamHistoryUserNumResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_history_user_num_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamHistoryUserNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamHistoryUserNumResponse:
        """
        @summary Queries the number of historical online users for a live stream.
        
        @description    The data returned by this operation is delayed for an average of 2 to 5 minutes.
        This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
        This operation does not query the number of viewers that are watching transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamHistoryUserNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamHistoryUserNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamHistoryUserNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamHistoryUserNumResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_history_user_num(
        self,
        request: live_20161101_models.DescribeLiveStreamHistoryUserNumRequest,
    ) -> live_20161101_models.DescribeLiveStreamHistoryUserNumResponse:
        """
        @summary Queries the number of historical online users for a live stream.
        
        @description    The data returned by this operation is delayed for an average of 2 to 5 minutes.
        This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
        This operation does not query the number of viewers that are watching transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamHistoryUserNumRequest
        @return: DescribeLiveStreamHistoryUserNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_history_user_num_with_options(request, runtime)

    async def describe_live_stream_history_user_num_async(
        self,
        request: live_20161101_models.DescribeLiveStreamHistoryUserNumRequest,
    ) -> live_20161101_models.DescribeLiveStreamHistoryUserNumResponse:
        """
        @summary Queries the number of historical online users for a live stream.
        
        @description    The data returned by this operation is delayed for an average of 2 to 5 minutes.
        This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
        This operation does not query the number of viewers that are watching transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamHistoryUserNumRequest
        @return: DescribeLiveStreamHistoryUserNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_history_user_num_with_options_async(request, runtime)

    def describe_live_stream_merge_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMergeResponse:
        """
        @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMergeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_merge_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMergeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMergeResponse:
        """
        @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMergeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMergeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMerge',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMergeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_merge(
        self,
        request: live_20161101_models.DescribeLiveStreamMergeRequest,
    ) -> live_20161101_models.DescribeLiveStreamMergeResponse:
        """
        @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMergeRequest
        @return: DescribeLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_merge_with_options(request, runtime)

    async def describe_live_stream_merge_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMergeRequest,
    ) -> live_20161101_models.DescribeLiveStreamMergeResponse:
        """
        @summary Invoke DescribeLiveStreamMerge to query the primary-standby stream merging configuration.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMergeRequest
        @return: DescribeLiveStreamMergeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_merge_with_options_async(request, runtime)

    def describe_live_stream_metric_detail_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamMetricDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMetricDetailDataResponse:
        """
        @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
        
        @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
        The domain name that you want to query
        The maximum number of concurrent streams under the domain name
        The maximum number of concurrent online users in each stream
        The protocols used for the client requests
        >  The review is expected to be completed within one business day after you submit the ticket.
        ## [](#)Usage limits
        By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
        You can specify only one domain name in each call.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMetricDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMetricDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMetricDetailData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMetricDetailDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_metric_detail_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMetricDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMetricDetailDataResponse:
        """
        @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
        
        @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
        The domain name that you want to query
        The maximum number of concurrent streams under the domain name
        The maximum number of concurrent online users in each stream
        The protocols used for the client requests
        >  The review is expected to be completed within one business day after you submit the ticket.
        ## [](#)Usage limits
        By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
        You can specify only one domain name in each call.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMetricDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMetricDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMetricDetailData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMetricDetailDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_metric_detail_data(
        self,
        request: live_20161101_models.DescribeLiveStreamMetricDetailDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamMetricDetailDataResponse:
        """
        @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
        
        @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
        The domain name that you want to query
        The maximum number of concurrent streams under the domain name
        The maximum number of concurrent online users in each stream
        The protocols used for the client requests
        >  The review is expected to be completed within one business day after you submit the ticket.
        ## [](#)Usage limits
        By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
        You can specify only one domain name in each call.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMetricDetailDataRequest
        @return: DescribeLiveStreamMetricDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_metric_detail_data_with_options(request, runtime)

    async def describe_live_stream_metric_detail_data_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMetricDetailDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamMetricDetailDataResponse:
        """
        @summary Queries the monitoring data of streams for a specified domain name. Up to 5,000 rows of data can be returned per call.
        
        @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
        The domain name that you want to query
        The maximum number of concurrent streams under the domain name
        The maximum number of concurrent online users in each stream
        The protocols used for the client requests
        >  The review is expected to be completed within one business day after you submit the ticket.
        ## [](#)Usage limits
        By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
        You can specify only one domain name in each call.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMetricDetailDataRequest
        @return: DescribeLiveStreamMetricDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_metric_detail_data_with_options_async(request, runtime)

    def describe_live_stream_monitor_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamMonitorListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMonitorListResponse:
        """
        @summary Queries the list of created monitoring sessions.
        
        @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMonitorListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMonitorListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.order_rule):
            query['OrderRule'] = request.order_rule
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMonitorList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMonitorListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_monitor_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMonitorListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamMonitorListResponse:
        """
        @summary Queries the list of created monitoring sessions.
        
        @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMonitorListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamMonitorListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.order_rule):
            query['OrderRule'] = request.order_rule
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamMonitorList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamMonitorListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_monitor_list(
        self,
        request: live_20161101_models.DescribeLiveStreamMonitorListRequest,
    ) -> live_20161101_models.DescribeLiveStreamMonitorListResponse:
        """
        @summary Queries the list of created monitoring sessions.
        
        @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMonitorListRequest
        @return: DescribeLiveStreamMonitorListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_monitor_list_with_options(request, runtime)

    async def describe_live_stream_monitor_list_async(
        self,
        request: live_20161101_models.DescribeLiveStreamMonitorListRequest,
    ) -> live_20161101_models.DescribeLiveStreamMonitorListResponse:
        """
        @summary Queries the list of created monitoring sessions.
        
        @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamMonitorListRequest
        @return: DescribeLiveStreamMonitorListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_monitor_list_with_options_async(request, runtime)

    def describe_live_stream_preload_tasks_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamPreloadTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamPreloadTasksResponse:
        """
        @summary Queries prefetch tasks in the last three days.
        
        @description You can call this operation to query prefetch tasks in the last three days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPreloadTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamPreloadTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_url):
            query['PlayUrl'] = request.play_url
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamPreloadTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamPreloadTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_preload_tasks_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamPreloadTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamPreloadTasksResponse:
        """
        @summary Queries prefetch tasks in the last three days.
        
        @description You can call this operation to query prefetch tasks in the last three days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPreloadTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamPreloadTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_url):
            query['PlayUrl'] = request.play_url
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamPreloadTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamPreloadTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_preload_tasks(
        self,
        request: live_20161101_models.DescribeLiveStreamPreloadTasksRequest,
    ) -> live_20161101_models.DescribeLiveStreamPreloadTasksResponse:
        """
        @summary Queries prefetch tasks in the last three days.
        
        @description You can call this operation to query prefetch tasks in the last three days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPreloadTasksRequest
        @return: DescribeLiveStreamPreloadTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_preload_tasks_with_options(request, runtime)

    async def describe_live_stream_preload_tasks_async(
        self,
        request: live_20161101_models.DescribeLiveStreamPreloadTasksRequest,
    ) -> live_20161101_models.DescribeLiveStreamPreloadTasksResponse:
        """
        @summary Queries prefetch tasks in the last three days.
        
        @description You can call this operation to query prefetch tasks in the last three days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPreloadTasksRequest
        @return: DescribeLiveStreamPreloadTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_preload_tasks_with_options_async(request, runtime)

    def describe_live_stream_push_metric_detail_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamPushMetricDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse:
        """
        @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
        
        @description    You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPushMetricDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamPushMetricDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamPushMetricDetailData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_push_metric_detail_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamPushMetricDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse:
        """
        @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
        
        @description    You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPushMetricDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamPushMetricDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamPushMetricDetailData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_push_metric_detail_data(
        self,
        request: live_20161101_models.DescribeLiveStreamPushMetricDetailDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse:
        """
        @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
        
        @description    You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPushMetricDetailDataRequest
        @return: DescribeLiveStreamPushMetricDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_push_metric_detail_data_with_options(request, runtime)

    async def describe_live_stream_push_metric_detail_data_async(
        self,
        request: live_20161101_models.DescribeLiveStreamPushMetricDetailDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamPushMetricDetailDataResponse:
        """
        @summary Queries the stream ingest data of a specified domain name at the application level and the stream level.
        
        @description    You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
        The maximum time range to query is 24 hours.
        The minimum data granularity to query is 1 minute.
        You can query data in the last 31 days.
        This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamPushMetricDetailDataRequest
        @return: DescribeLiveStreamPushMetricDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_push_metric_detail_data_with_options_async(request, runtime)

    def describe_live_stream_record_content_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordContentResponse:
        """
        @summary Queries the recordings of a live stream.
        
        @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveStreamRecordContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_record_content_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordContentResponse:
        """
        @summary Queries the recordings of a live stream.
        
        @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveStreamRecordContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_record_content(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordContentRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordContentResponse:
        """
        @summary Queries the recordings of a live stream.
        
        @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveStreamRecordContentRequest
        @return: DescribeLiveStreamRecordContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_record_content_with_options(request, runtime)

    async def describe_live_stream_record_content_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordContentRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordContentResponse:
        """
        @summary Queries the recordings of a live stream.
        
        @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
        ## QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeLiveStreamRecordContentRequest
        @return: DescribeLiveStreamRecordContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_record_content_with_options_async(request, runtime)

    def describe_live_stream_record_index_file_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFileResponse:
        """
        @summary Queries the information about an index file.
        
        @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordIndexFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_id):
            query['RecordId'] = request.record_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordIndexFile',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordIndexFileResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_record_index_file_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFileResponse:
        """
        @summary Queries the information about an index file.
        
        @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordIndexFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_id):
            query['RecordId'] = request.record_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordIndexFile',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordIndexFileResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_record_index_file(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFileRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFileResponse:
        """
        @summary Queries the information about an index file.
        
        @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFileRequest
        @return: DescribeLiveStreamRecordIndexFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_record_index_file_with_options(request, runtime)

    async def describe_live_stream_record_index_file_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFileRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFileResponse:
        """
        @summary Queries the information about an index file.
        
        @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFileRequest
        @return: DescribeLiveStreamRecordIndexFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_record_index_file_with_options_async(request, runtime)

    def describe_live_stream_record_index_files_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse:
        """
        @summary Queries all index files within a specific time period.
        
        @description    ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_record_index_files_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse:
        """
        @summary Queries all index files within a specific time period.
        
        @description    ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamRecordIndexFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamRecordIndexFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_record_index_files(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse:
        """
        @summary Queries all index files within a specific time period.
        
        @description    ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFilesRequest
        @return: DescribeLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_record_index_files_with_options(request, runtime)

    async def describe_live_stream_record_index_files_async(
        self,
        request: live_20161101_models.DescribeLiveStreamRecordIndexFilesRequest,
    ) -> live_20161101_models.DescribeLiveStreamRecordIndexFilesResponse:
        """
        @summary Queries all index files within a specific time period.
        
        @description    ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
        OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamRecordIndexFilesRequest
        @return: DescribeLiveStreamRecordIndexFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_record_index_files_with_options_async(request, runtime)

    def describe_live_stream_snapshot_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamSnapshotInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamSnapshotInfoResponse:
        """
        @summary Queries the snapshots that were captured within a specific time period.
        
        @description You can query only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamSnapshotInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamSnapshotInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamSnapshotInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamSnapshotInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_snapshot_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamSnapshotInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamSnapshotInfoResponse:
        """
        @summary Queries the snapshots that were captured within a specific time period.
        
        @description You can query only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamSnapshotInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamSnapshotInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.order):
            query['Order'] = request.order
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamSnapshotInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamSnapshotInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_snapshot_info(
        self,
        request: live_20161101_models.DescribeLiveStreamSnapshotInfoRequest,
    ) -> live_20161101_models.DescribeLiveStreamSnapshotInfoResponse:
        """
        @summary Queries the snapshots that were captured within a specific time period.
        
        @description You can query only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamSnapshotInfoRequest
        @return: DescribeLiveStreamSnapshotInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_snapshot_info_with_options(request, runtime)

    async def describe_live_stream_snapshot_info_async(
        self,
        request: live_20161101_models.DescribeLiveStreamSnapshotInfoRequest,
    ) -> live_20161101_models.DescribeLiveStreamSnapshotInfoResponse:
        """
        @summary Queries the snapshots that were captured within a specific time period.
        
        @description You can query only snapshots that were captured in the last year.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamSnapshotInfoRequest
        @return: DescribeLiveStreamSnapshotInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_snapshot_info_with_options_async(request, runtime)

    def describe_live_stream_state_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamStateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamStateResponse:
        """
        @summary Queries the status of a stream in real time.
        
        @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamStateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamStateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamState',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamStateResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_state_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamStateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamStateResponse:
        """
        @summary Queries the status of a stream in real time.
        
        @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamStateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamStateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamState',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamStateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_state(
        self,
        request: live_20161101_models.DescribeLiveStreamStateRequest,
    ) -> live_20161101_models.DescribeLiveStreamStateResponse:
        """
        @summary Queries the status of a stream in real time.
        
        @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamStateRequest
        @return: DescribeLiveStreamStateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_state_with_options(request, runtime)

    async def describe_live_stream_state_async(
        self,
        request: live_20161101_models.DescribeLiveStreamStateRequest,
    ) -> live_20161101_models.DescribeLiveStreamStateResponse:
        """
        @summary Queries the status of a stream in real time.
        
        @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamStateRequest
        @return: DescribeLiveStreamStateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_state_with_options_async(request, runtime)

    def describe_live_stream_transcode_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeInfoResponse:
        """
        @summary Queries the transcoding configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_transcode_name):
            query['DomainTranscodeName'] = request.domain_transcode_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_transcode_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeInfoResponse:
        """
        @summary Queries the transcoding configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_transcode_name):
            query['DomainTranscodeName'] = request.domain_transcode_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_transcode_info(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeInfoRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeInfoResponse:
        """
        @summary Queries the transcoding configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeInfoRequest
        @return: DescribeLiveStreamTranscodeInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_transcode_info_with_options(request, runtime)

    async def describe_live_stream_transcode_info_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeInfoRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeInfoResponse:
        """
        @summary Queries the transcoding configurations of a streaming domain.
        
        @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeInfoRequest
        @return: DescribeLiveStreamTranscodeInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_transcode_info_with_options_async(request, runtime)

    def describe_live_stream_transcode_metric_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse:
        """
        @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
        
        @description    The maximum time range for a query is 24 hours.
        The minimum time granularity for a query is 5 minutes.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_transcode_metric_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse:
        """
        @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
        
        @description    The maximum time range for a query is 24 hours.
        The minimum time granularity for a query is 5 minutes.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_transcode_metric_data(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse:
        """
        @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
        
        @description    The maximum time range for a query is 24 hours.
        The minimum time granularity for a query is 5 minutes.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeMetricDataRequest
        @return: DescribeLiveStreamTranscodeMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_transcode_metric_data_with_options(request, runtime)

    async def describe_live_stream_transcode_metric_data_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeMetricDataResponse:
        """
        @summary Queries the transcoding data of a specified domain name at the application level and the stream level.
        
        @description    The maximum time range for a query is 24 hours.
        The minimum time granularity for a query is 5 minutes.
        You can query data in the last 31 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeMetricDataRequest
        @return: DescribeLiveStreamTranscodeMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_transcode_metric_data_with_options_async(request, runtime)

    def describe_live_stream_transcode_stream_num_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeStreamNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse:
        """
        @summary Queries the number of transcoded streams in real time.
        
        @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeStreamNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeStreamNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_type):
            query['SplitType'] = request.split_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeStreamNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_transcode_stream_num_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeStreamNumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse:
        """
        @summary Queries the number of transcoded streams in real time.
        
        @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeStreamNumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamTranscodeStreamNumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.split_type):
            query['SplitType'] = request.split_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamTranscodeStreamNum',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_transcode_stream_num(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeStreamNumRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse:
        """
        @summary Queries the number of transcoded streams in real time.
        
        @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeStreamNumRequest
        @return: DescribeLiveStreamTranscodeStreamNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_transcode_stream_num_with_options(request, runtime)

    async def describe_live_stream_transcode_stream_num_async(
        self,
        request: live_20161101_models.DescribeLiveStreamTranscodeStreamNumRequest,
    ) -> live_20161101_models.DescribeLiveStreamTranscodeStreamNumResponse:
        """
        @summary Queries the number of transcoded streams in real time.
        
        @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamTranscodeStreamNumRequest
        @return: DescribeLiveStreamTranscodeStreamNumResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_transcode_stream_num_with_options_async(request, runtime)

    def describe_live_stream_watermark_rules_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarkRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamWatermarkRulesResponse:
        """
        @summary Queries watermark rules.
        
        @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarkRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamWatermarkRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamWatermarkRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamWatermarkRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_watermark_rules_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarkRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamWatermarkRulesResponse:
        """
        @summary Queries watermark rules.
        
        @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarkRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamWatermarkRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamWatermarkRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamWatermarkRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_watermark_rules(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarkRulesRequest,
    ) -> live_20161101_models.DescribeLiveStreamWatermarkRulesResponse:
        """
        @summary Queries watermark rules.
        
        @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarkRulesRequest
        @return: DescribeLiveStreamWatermarkRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_watermark_rules_with_options(request, runtime)

    async def describe_live_stream_watermark_rules_async(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarkRulesRequest,
    ) -> live_20161101_models.DescribeLiveStreamWatermarkRulesResponse:
        """
        @summary Queries watermark rules.
        
        @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarkRulesRequest
        @return: DescribeLiveStreamWatermarkRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_watermark_rules_with_options_async(request, runtime)

    def describe_live_stream_watermarks_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamWatermarksResponse:
        """
        @summary Queries watermark templates.
        
        @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamWatermarksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.key_word):
            query['KeyWord'] = request.key_word
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamWatermarks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamWatermarksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_stream_watermarks_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamWatermarksResponse:
        """
        @summary Queries watermark templates.
        
        @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamWatermarksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.key_word):
            query['KeyWord'] = request.key_word
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamWatermarks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamWatermarksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_stream_watermarks(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarksRequest,
    ) -> live_20161101_models.DescribeLiveStreamWatermarksResponse:
        """
        @summary Queries watermark templates.
        
        @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarksRequest
        @return: DescribeLiveStreamWatermarksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_stream_watermarks_with_options(request, runtime)

    async def describe_live_stream_watermarks_async(
        self,
        request: live_20161101_models.DescribeLiveStreamWatermarksRequest,
    ) -> live_20161101_models.DescribeLiveStreamWatermarksResponse:
        """
        @summary Queries watermark templates.
        
        @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamWatermarksRequest
        @return: DescribeLiveStreamWatermarksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_stream_watermarks_with_options_async(request, runtime)

    def describe_live_streams_block_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsBlockListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsBlockListResponse:
        """
        @summary Queries the blacklist of live stream URLs under a main streaming domain.
        
        @description The stream URLs refer to the URLs for playing in particular.
        ## QPS limit
        A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveStreamsBlockListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsBlockListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsBlockList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsBlockListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_block_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsBlockListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsBlockListResponse:
        """
        @summary Queries the blacklist of live stream URLs under a main streaming domain.
        
        @description The stream URLs refer to the URLs for playing in particular.
        ## QPS limit
        A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveStreamsBlockListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsBlockListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsBlockList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsBlockListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_block_list(
        self,
        request: live_20161101_models.DescribeLiveStreamsBlockListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsBlockListResponse:
        """
        @summary Queries the blacklist of live stream URLs under a main streaming domain.
        
        @description The stream URLs refer to the URLs for playing in particular.
        ## QPS limit
        A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveStreamsBlockListRequest
        @return: DescribeLiveStreamsBlockListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_block_list_with_options(request, runtime)

    async def describe_live_streams_block_list_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsBlockListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsBlockListResponse:
        """
        @summary Queries the blacklist of live stream URLs under a main streaming domain.
        
        @description The stream URLs refer to the URLs for playing in particular.
        ## QPS limit
        A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: DescribeLiveStreamsBlockListRequest
        @return: DescribeLiveStreamsBlockListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_block_list_with_options_async(request, runtime)

    def describe_live_streams_control_history_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsControlHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsControlHistoryResponse:
        """
        @summary Queries the operation history of live streams under a domain name or in an application.
        
        @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsControlHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsControlHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsControlHistory',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsControlHistoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_control_history_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsControlHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsControlHistoryResponse:
        """
        @summary Queries the operation history of live streams under a domain name or in an application.
        
        @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsControlHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsControlHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsControlHistory',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsControlHistoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_control_history(
        self,
        request: live_20161101_models.DescribeLiveStreamsControlHistoryRequest,
    ) -> live_20161101_models.DescribeLiveStreamsControlHistoryResponse:
        """
        @summary Queries the operation history of live streams under a domain name or in an application.
        
        @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsControlHistoryRequest
        @return: DescribeLiveStreamsControlHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_control_history_with_options(request, runtime)

    async def describe_live_streams_control_history_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsControlHistoryRequest,
    ) -> live_20161101_models.DescribeLiveStreamsControlHistoryResponse:
        """
        @summary Queries the operation history of live streams under a domain name or in an application.
        
        @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsControlHistoryRequest
        @return: DescribeLiveStreamsControlHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_control_history_with_options_async(request, runtime)

    def describe_live_streams_notify_records_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse:
        """
        @summary Queries stream ingest callback records.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsNotifyRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsNotifyRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsNotifyRecords',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_notify_records_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse:
        """
        @summary Queries stream ingest callback records.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsNotifyRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsNotifyRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsNotifyRecords',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_notify_records(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyRecordsRequest,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse:
        """
        @summary Queries stream ingest callback records.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsNotifyRecordsRequest
        @return: DescribeLiveStreamsNotifyRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_notify_records_with_options(request, runtime)

    async def describe_live_streams_notify_records_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyRecordsRequest,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyRecordsResponse:
        """
        @summary Queries stream ingest callback records.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsNotifyRecordsRequest
        @return: DescribeLiveStreamsNotifyRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_notify_records_with_options_async(request, runtime)

    def describe_live_streams_notify_url_config_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Queries the callback configuration for stream ingest under an ingest domain.
        
        @param request: DescribeLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_notify_url_config_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Queries the callback configuration for stream ingest under an ingest domain.
        
        @param request: DescribeLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_notify_url_config(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Queries the callback configuration for stream ingest under an ingest domain.
        
        @param request: DescribeLiveStreamsNotifyUrlConfigRequest
        @return: DescribeLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_notify_url_config_with_options(request, runtime)

    async def describe_live_streams_notify_url_config_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.DescribeLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Queries the callback configuration for stream ingest under an ingest domain.
        
        @param request: DescribeLiveStreamsNotifyUrlConfigRequest
        @return: DescribeLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_notify_url_config_with_options_async(request, runtime)

    def describe_live_streams_online_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsOnlineListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsOnlineListResponse:
        """
        @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
        
        @description You can call this operation to query the following types of streams.
        all: all streams.
        raw: source streams.
        trans: transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsOnlineListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsOnlineListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.only_stream):
            query['OnlyStream'] = request.only_stream
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_type):
            query['QueryType'] = request.query_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsOnlineList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsOnlineListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_online_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsOnlineListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsOnlineListResponse:
        """
        @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
        
        @description You can call this operation to query the following types of streams.
        all: all streams.
        raw: source streams.
        trans: transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsOnlineListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsOnlineListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.only_stream):
            query['OnlyStream'] = request.only_stream
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_type):
            query['QueryType'] = request.query_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsOnlineList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsOnlineListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_online_list(
        self,
        request: live_20161101_models.DescribeLiveStreamsOnlineListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsOnlineListResponse:
        """
        @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
        
        @description You can call this operation to query the following types of streams.
        all: all streams.
        raw: source streams.
        trans: transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsOnlineListRequest
        @return: DescribeLiveStreamsOnlineListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_online_list_with_options(request, runtime)

    async def describe_live_streams_online_list_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsOnlineListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsOnlineListResponse:
        """
        @summary Queries the information about all active streams under a specified domain name or the active streams of an application under a specified domain name.
        
        @description You can call this operation to query the following types of streams.
        all: all streams.
        raw: source streams.
        trans: transcoded streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsOnlineListRequest
        @return: DescribeLiveStreamsOnlineListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_online_list_with_options_async(request, runtime)

    def describe_live_streams_publish_list_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsPublishListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsPublishListResponse:
        """
        @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
        
        @description ## [](#)Usage notes
        This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
        stream_name_desc: sorts the entries in descending order by stream name.
        stream_name_asc: sorts the entries in ascending order by stream name.
        publish_time_desc: sorts the entries in descending order by stream ingest time.
        publish_time_asc: sorts the entries in ascending order by stream ingest time.
        ## [](#qps-)QPS limit
        You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveStreamsPublishListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsPublishListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order_by):
            query['OrderBy'] = request.order_by
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_type):
            query['QueryType'] = request.query_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsPublishList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsPublishListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_publish_list_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsPublishListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsPublishListResponse:
        """
        @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
        
        @description ## [](#)Usage notes
        This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
        stream_name_desc: sorts the entries in descending order by stream name.
        stream_name_asc: sorts the entries in ascending order by stream name.
        publish_time_desc: sorts the entries in descending order by stream ingest time.
        publish_time_asc: sorts the entries in ascending order by stream ingest time.
        ## [](#qps-)QPS limit
        You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveStreamsPublishListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsPublishListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order_by):
            query['OrderBy'] = request.order_by
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.query_type):
            query['QueryType'] = request.query_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsPublishList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsPublishListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_publish_list(
        self,
        request: live_20161101_models.DescribeLiveStreamsPublishListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsPublishListResponse:
        """
        @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
        
        @description ## [](#)Usage notes
        This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
        stream_name_desc: sorts the entries in descending order by stream name.
        stream_name_asc: sorts the entries in ascending order by stream name.
        publish_time_desc: sorts the entries in descending order by stream ingest time.
        publish_time_asc: sorts the entries in ascending order by stream ingest time.
        ## [](#qps-)QPS limit
        You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveStreamsPublishListRequest
        @return: DescribeLiveStreamsPublishListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_publish_list_with_options(request, runtime)

    async def describe_live_streams_publish_list_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsPublishListRequest,
    ) -> live_20161101_models.DescribeLiveStreamsPublishListResponse:
        """
        @summary Queries the stream ingest records of a domain name or an application or stream under a domain name.
        
        @description ## [](#)Usage notes
        This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
        stream_name_desc: sorts the entries in descending order by stream name.
        stream_name_asc: sorts the entries in ascending order by stream name.
        publish_time_desc: sorts the entries in descending order by stream ingest time.
        publish_time_asc: sorts the entries in ascending order by stream ingest time.
        ## [](#qps-)QPS limit
        You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveStreamsPublishListRequest
        @return: DescribeLiveStreamsPublishListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_publish_list_with_options_async(request, runtime)

    def describe_live_streams_total_count_with_options(
        self,
        request: live_20161101_models.DescribeLiveStreamsTotalCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsTotalCountResponse:
        """
        @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
        
        @description    The maximum time range for a query is 15 days.
        You can query data in the last 18 months.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsTotalCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsTotalCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.typ):
            query['Typ'] = request.typ
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsTotalCount',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsTotalCountResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_streams_total_count_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsTotalCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveStreamsTotalCountResponse:
        """
        @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
        
        @description    The maximum time range for a query is 15 days.
        You can query data in the last 18 months.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsTotalCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveStreamsTotalCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.typ):
            query['Typ'] = request.typ
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveStreamsTotalCount',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveStreamsTotalCountResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_streams_total_count(
        self,
        request: live_20161101_models.DescribeLiveStreamsTotalCountRequest,
    ) -> live_20161101_models.DescribeLiveStreamsTotalCountResponse:
        """
        @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
        
        @description    The maximum time range for a query is 15 days.
        You can query data in the last 18 months.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsTotalCountRequest
        @return: DescribeLiveStreamsTotalCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_streams_total_count_with_options(request, runtime)

    async def describe_live_streams_total_count_async(
        self,
        request: live_20161101_models.DescribeLiveStreamsTotalCountRequest,
    ) -> live_20161101_models.DescribeLiveStreamsTotalCountResponse:
        """
        @summary Queries the total number of live streams within a specified time range. Data is collected on a daily basis.
        
        @description    The maximum time range for a query is 15 days.
        You can query data in the last 18 months.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveStreamsTotalCountRequest
        @return: DescribeLiveStreamsTotalCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_streams_total_count_with_options_async(request, runtime)

    def describe_live_top_domains_by_flow_with_options(
        self,
        request: live_20161101_models.DescribeLiveTopDomainsByFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveTopDomainsByFlowResponse:
        """
        @summary Queries the top domain names ranked by traffic.
        
        @description    If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveTopDomainsByFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveTopDomainsByFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveTopDomainsByFlow',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveTopDomainsByFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_top_domains_by_flow_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveTopDomainsByFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveTopDomainsByFlowResponse:
        """
        @summary Queries the top domain names ranked by traffic.
        
        @description    If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveTopDomainsByFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveTopDomainsByFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveTopDomainsByFlow',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveTopDomainsByFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_top_domains_by_flow(
        self,
        request: live_20161101_models.DescribeLiveTopDomainsByFlowRequest,
    ) -> live_20161101_models.DescribeLiveTopDomainsByFlowResponse:
        """
        @summary Queries the top domain names ranked by traffic.
        
        @description    If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveTopDomainsByFlowRequest
        @return: DescribeLiveTopDomainsByFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_top_domains_by_flow_with_options(request, runtime)

    async def describe_live_top_domains_by_flow_async(
        self,
        request: live_20161101_models.DescribeLiveTopDomainsByFlowRequest,
    ) -> live_20161101_models.DescribeLiveTopDomainsByFlowResponse:
        """
        @summary Queries the top domain names ranked by traffic.
        
        @description    If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
        You can query data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeLiveTopDomainsByFlowRequest
        @return: DescribeLiveTopDomainsByFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_top_domains_by_flow_with_options_async(request, runtime)

    def describe_live_traffic_domain_log_with_options(
        self,
        request: live_20161101_models.DescribeLiveTrafficDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveTrafficDomainLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveTrafficDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveTrafficDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveTrafficDomainLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveTrafficDomainLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_traffic_domain_log_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveTrafficDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveTrafficDomainLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveTrafficDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveTrafficDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveTrafficDomainLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveTrafficDomainLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_traffic_domain_log(
        self,
        request: live_20161101_models.DescribeLiveTrafficDomainLogRequest,
    ) -> live_20161101_models.DescribeLiveTrafficDomainLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveTrafficDomainLogRequest
        @return: DescribeLiveTrafficDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_traffic_domain_log_with_options(request, runtime)

    async def describe_live_traffic_domain_log_async(
        self,
        request: live_20161101_models.DescribeLiveTrafficDomainLogRequest,
    ) -> live_20161101_models.DescribeLiveTrafficDomainLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveTrafficDomainLogRequest
        @return: DescribeLiveTrafficDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_traffic_domain_log_with_options_async(request, runtime)

    def describe_live_up_video_audio_info_with_options(
        self,
        request: live_20161101_models.DescribeLiveUpVideoAudioInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUpVideoAudioInfoResponse:
        """
        @summary Queries the audio and video data of an ingested stream within a specific period of time.
        
        @description ### Usage notes
        - The maximum time range for a query is 24 hours.
        - The minimum time range for a query is 1 hour.
        - You can query data in the last 31 days.
        ### QPS limit
        You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUpVideoAudioInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUpVideoAudioInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUpVideoAudioInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUpVideoAudioInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_up_video_audio_info_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUpVideoAudioInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUpVideoAudioInfoResponse:
        """
        @summary Queries the audio and video data of an ingested stream within a specific period of time.
        
        @description ### Usage notes
        - The maximum time range for a query is 24 hours.
        - The minimum time range for a query is 1 hour.
        - You can query data in the last 31 days.
        ### QPS limit
        You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUpVideoAudioInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUpVideoAudioInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUpVideoAudioInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUpVideoAudioInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_up_video_audio_info(
        self,
        request: live_20161101_models.DescribeLiveUpVideoAudioInfoRequest,
    ) -> live_20161101_models.DescribeLiveUpVideoAudioInfoResponse:
        """
        @summary Queries the audio and video data of an ingested stream within a specific period of time.
        
        @description ### Usage notes
        - The maximum time range for a query is 24 hours.
        - The minimum time range for a query is 1 hour.
        - You can query data in the last 31 days.
        ### QPS limit
        You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUpVideoAudioInfoRequest
        @return: DescribeLiveUpVideoAudioInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_up_video_audio_info_with_options(request, runtime)

    async def describe_live_up_video_audio_info_async(
        self,
        request: live_20161101_models.DescribeLiveUpVideoAudioInfoRequest,
    ) -> live_20161101_models.DescribeLiveUpVideoAudioInfoResponse:
        """
        @summary Queries the audio and video data of an ingested stream within a specific period of time.
        
        @description ### Usage notes
        - The maximum time range for a query is 24 hours.
        - The minimum time range for a query is 1 hour.
        - You can query data in the last 31 days.
        ### QPS limit
        You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUpVideoAudioInfoRequest
        @return: DescribeLiveUpVideoAudioInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_up_video_audio_info_with_options_async(request, runtime)

    def describe_live_user_bill_prediction_with_options(
        self,
        request: live_20161101_models.DescribeLiveUserBillPredictionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserBillPredictionResponse:
        """
        @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
        Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
        Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
        Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
        Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserBillPredictionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserBillPredictionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserBillPrediction',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserBillPredictionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_user_bill_prediction_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUserBillPredictionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserBillPredictionResponse:
        """
        @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
        Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
        Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
        Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
        Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserBillPredictionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserBillPredictionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserBillPrediction',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserBillPredictionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_user_bill_prediction(
        self,
        request: live_20161101_models.DescribeLiveUserBillPredictionRequest,
    ) -> live_20161101_models.DescribeLiveUserBillPredictionResponse:
        """
        @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
        Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
        Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
        Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
        Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserBillPredictionRequest
        @return: DescribeLiveUserBillPredictionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_user_bill_prediction_with_options(request, runtime)

    async def describe_live_user_bill_prediction_async(
        self,
        request: live_20161101_models.DescribeLiveUserBillPredictionRequest,
    ) -> live_20161101_models.DescribeLiveUserBillPredictionResponse:
        """
        @summary Queries the estimated bills of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
        Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
        Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
        Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
        Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
        ## [](#qps-)QPS limit
        You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserBillPredictionRequest
        @return: DescribeLiveUserBillPredictionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_user_bill_prediction_with_options_async(request, runtime)

    def describe_live_user_domains_with_options(
        self,
        request: live_20161101_models.DescribeLiveUserDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserDomainsResponse:
        """
        @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description ## [](#)Usage notes
        You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserDomainsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_search_type):
            query['DomainSearchType'] = request.domain_search_type
        if not UtilClient.is_unset(request.domain_status):
            query['DomainStatus'] = request.domain_status
        if not UtilClient.is_unset(request.live_domain_type):
            query['LiveDomainType'] = request.live_domain_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_name):
            query['RegionName'] = request.region_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserDomains',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserDomainsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_user_domains_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUserDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserDomainsResponse:
        """
        @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description ## [](#)Usage notes
        You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserDomainsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_search_type):
            query['DomainSearchType'] = request.domain_search_type
        if not UtilClient.is_unset(request.domain_status):
            query['DomainStatus'] = request.domain_status
        if not UtilClient.is_unset(request.live_domain_type):
            query['LiveDomainType'] = request.live_domain_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_name):
            query['RegionName'] = request.region_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserDomains',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserDomainsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_user_domains(
        self,
        request: live_20161101_models.DescribeLiveUserDomainsRequest,
    ) -> live_20161101_models.DescribeLiveUserDomainsResponse:
        """
        @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description ## [](#)Usage notes
        You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserDomainsRequest
        @return: DescribeLiveUserDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_user_domains_with_options(request, runtime)

    async def describe_live_user_domains_async(
        self,
        request: live_20161101_models.DescribeLiveUserDomainsRequest,
    ) -> live_20161101_models.DescribeLiveUserDomainsResponse:
        """
        @summary Queries domain names of ApsaraVideo Live in your Alibaba Cloud account.
        
        @description ## [](#)Usage notes
        You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeLiveUserDomainsRequest
        @return: DescribeLiveUserDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_user_domains_with_options_async(request, runtime)

    def describe_live_user_stream_metric_data_with_options(
        self,
        request: live_20161101_models.DescribeLiveUserStreamMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserStreamMetricDataResponse:
        """
        @summary  
        
        @param request: DescribeLiveUserStreamMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserStreamMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserStreamMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserStreamMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_user_stream_metric_data_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUserStreamMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserStreamMetricDataResponse:
        """
        @summary  
        
        @param request: DescribeLiveUserStreamMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserStreamMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserStreamMetricData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserStreamMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_user_stream_metric_data(
        self,
        request: live_20161101_models.DescribeLiveUserStreamMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveUserStreamMetricDataResponse:
        """
        @summary  
        
        @param request: DescribeLiveUserStreamMetricDataRequest
        @return: DescribeLiveUserStreamMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_user_stream_metric_data_with_options(request, runtime)

    async def describe_live_user_stream_metric_data_async(
        self,
        request: live_20161101_models.DescribeLiveUserStreamMetricDataRequest,
    ) -> live_20161101_models.DescribeLiveUserStreamMetricDataResponse:
        """
        @summary  
        
        @param request: DescribeLiveUserStreamMetricDataRequest
        @return: DescribeLiveUserStreamMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_user_stream_metric_data_with_options_async(request, runtime)

    def describe_live_user_tags_with_options(
        self,
        request: live_20161101_models.DescribeLiveUserTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserTagsResponse:
        """
        @param request: DescribeLiveUserTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserTags',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_user_tags_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUserTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserTagsResponse:
        """
        @param request: DescribeLiveUserTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserTags',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_user_tags(
        self,
        request: live_20161101_models.DescribeLiveUserTagsRequest,
    ) -> live_20161101_models.DescribeLiveUserTagsResponse:
        """
        @param request: DescribeLiveUserTagsRequest
        @return: DescribeLiveUserTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_user_tags_with_options(request, runtime)

    async def describe_live_user_tags_async(
        self,
        request: live_20161101_models.DescribeLiveUserTagsRequest,
    ) -> live_20161101_models.DescribeLiveUserTagsResponse:
        """
        @param request: DescribeLiveUserTagsRequest
        @return: DescribeLiveUserTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_user_tags_with_options_async(request, runtime)

    def describe_live_user_traffic_log_with_options(
        self,
        request: live_20161101_models.DescribeLiveUserTrafficLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserTrafficLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveUserTrafficLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserTrafficLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserTrafficLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserTrafficLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_user_traffic_log_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveUserTrafficLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveUserTrafficLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveUserTrafficLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveUserTrafficLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveUserTrafficLog',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveUserTrafficLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_user_traffic_log(
        self,
        request: live_20161101_models.DescribeLiveUserTrafficLogRequest,
    ) -> live_20161101_models.DescribeLiveUserTrafficLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveUserTrafficLogRequest
        @return: DescribeLiveUserTrafficLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_user_traffic_log_with_options(request, runtime)

    async def describe_live_user_traffic_log_async(
        self,
        request: live_20161101_models.DescribeLiveUserTrafficLogRequest,
    ) -> live_20161101_models.DescribeLiveUserTrafficLogResponse:
        """
        @summary 
        
        @param request: DescribeLiveUserTrafficLogRequest
        @return: DescribeLiveUserTrafficLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_user_traffic_log_with_options_async(request, runtime)

    def describe_live_verify_content_with_options(
        self,
        request: live_20161101_models.DescribeLiveVerifyContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveVerifyContentResponse:
        """
        @summary Queries the ownership verification content of a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the ownership verification content of a single domain name.
        You can call this operation up to 30 times per second per account.
        When you call this operation, you need to specify a domain name as a request parameter.
        After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
        
        @param request: DescribeLiveVerifyContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveVerifyContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveVerifyContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveVerifyContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_live_verify_content_with_options_async(
        self,
        request: live_20161101_models.DescribeLiveVerifyContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeLiveVerifyContentResponse:
        """
        @summary Queries the ownership verification content of a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the ownership verification content of a single domain name.
        You can call this operation up to 30 times per second per account.
        When you call this operation, you need to specify a domain name as a request parameter.
        After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
        
        @param request: DescribeLiveVerifyContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLiveVerifyContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLiveVerifyContent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeLiveVerifyContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_live_verify_content(
        self,
        request: live_20161101_models.DescribeLiveVerifyContentRequest,
    ) -> live_20161101_models.DescribeLiveVerifyContentResponse:
        """
        @summary Queries the ownership verification content of a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the ownership verification content of a single domain name.
        You can call this operation up to 30 times per second per account.
        When you call this operation, you need to specify a domain name as a request parameter.
        After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
        
        @param request: DescribeLiveVerifyContentRequest
        @return: DescribeLiveVerifyContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_live_verify_content_with_options(request, runtime)

    async def describe_live_verify_content_async(
        self,
        request: live_20161101_models.DescribeLiveVerifyContentRequest,
    ) -> live_20161101_models.DescribeLiveVerifyContentResponse:
        """
        @summary Queries the ownership verification content of a domain name.
        
        @description ## [](#)Usage notes
        You can call this operation to query the ownership verification content of a single domain name.
        You can call this operation up to 30 times per second per account.
        When you call this operation, you need to specify a domain name as a request parameter.
        After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
        
        @param request: DescribeLiveVerifyContentRequest
        @return: DescribeLiveVerifyContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_live_verify_content_with_options_async(request, runtime)

    def describe_meter_live_bypass_duration_with_options(
        self,
        request: live_20161101_models.DescribeMeterLiveBypassDurationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeMeterLiveBypassDurationResponse:
        """
        @summary DescribeMeterLiveBypassDuration
        
        @description ## [](#)Usage notes
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeMeterLiveBypassDurationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMeterLiveBypassDurationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMeterLiveBypassDuration',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeMeterLiveBypassDurationResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_meter_live_bypass_duration_with_options_async(
        self,
        request: live_20161101_models.DescribeMeterLiveBypassDurationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeMeterLiveBypassDurationResponse:
        """
        @summary DescribeMeterLiveBypassDuration
        
        @description ## [](#)Usage notes
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeMeterLiveBypassDurationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMeterLiveBypassDurationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMeterLiveBypassDuration',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeMeterLiveBypassDurationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_meter_live_bypass_duration(
        self,
        request: live_20161101_models.DescribeMeterLiveBypassDurationRequest,
    ) -> live_20161101_models.DescribeMeterLiveBypassDurationResponse:
        """
        @summary DescribeMeterLiveBypassDuration
        
        @description ## [](#)Usage notes
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeMeterLiveBypassDurationRequest
        @return: DescribeMeterLiveBypassDurationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_meter_live_bypass_duration_with_options(request, runtime)

    async def describe_meter_live_bypass_duration_async(
        self,
        request: live_20161101_models.DescribeMeterLiveBypassDurationRequest,
    ) -> live_20161101_models.DescribeMeterLiveBypassDurationResponse:
        """
        @summary DescribeMeterLiveBypassDuration
        
        @description ## [](#)Usage notes
        The maximum time range for a query is 31 days.
        The minimum time granularity for a query is 5 minutes.
        You can query the data in the last 90 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeMeterLiveBypassDurationRequest
        @return: DescribeMeterLiveBypassDurationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_meter_live_bypass_duration_with_options_async(request, runtime)

    def describe_mix_stream_list_with_options(
        self,
        request: live_20161101_models.DescribeMixStreamListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeMixStreamListResponse:
        """
        @summary Queries stream mixing tasks.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeMixStreamListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMixStreamListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMixStreamList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeMixStreamListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_mix_stream_list_with_options_async(
        self,
        request: live_20161101_models.DescribeMixStreamListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeMixStreamListResponse:
        """
        @summary Queries stream mixing tasks.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeMixStreamListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMixStreamListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMixStreamList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeMixStreamListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_mix_stream_list(
        self,
        request: live_20161101_models.DescribeMixStreamListRequest,
    ) -> live_20161101_models.DescribeMixStreamListResponse:
        """
        @summary Queries stream mixing tasks.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeMixStreamListRequest
        @return: DescribeMixStreamListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_mix_stream_list_with_options(request, runtime)

    async def describe_mix_stream_list_async(
        self,
        request: live_20161101_models.DescribeMixStreamListRequest,
    ) -> live_20161101_models.DescribeMixStreamListResponse:
        """
        @summary Queries stream mixing tasks.
        
        @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeMixStreamListRequest
        @return: DescribeMixStreamListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_mix_stream_list_with_options_async(request, runtime)

    def describe_rtsnative_sdkfirst_frame_cost_with_options(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKFirstFrameCostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse:
        """
        @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
        
        @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKFirstFrameCostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKFirstFrameCostResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKFirstFrameCostShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKFirstFrameCost',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtsnative_sdkfirst_frame_cost_with_options_async(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKFirstFrameCostRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse:
        """
        @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
        
        @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKFirstFrameCostRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKFirstFrameCostResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKFirstFrameCostShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKFirstFrameCost',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtsnative_sdkfirst_frame_cost(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKFirstFrameCostRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse:
        """
        @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
        
        @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKFirstFrameCostRequest
        @return: DescribeRTSNativeSDKFirstFrameCostResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtsnative_sdkfirst_frame_cost_with_options(request, runtime)

    async def describe_rtsnative_sdkfirst_frame_cost_async(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKFirstFrameCostRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameCostResponse:
        """
        @summary Queries the information about the factors that cause latency of first frames within a specified period of time.
        
        @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKFirstFrameCostRequest
        @return: DescribeRTSNativeSDKFirstFrameCostResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtsnative_sdkfirst_frame_cost_with_options_async(request, runtime)

    def describe_rtsnative_sdkfirst_frame_delay_with_options(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse:
        """
        @summary Queries the average latency of first frames within a specified period of time.
        
        @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKFirstFrameDelayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKFirstFrameDelayResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKFirstFrameDelay',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtsnative_sdkfirst_frame_delay_with_options_async(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse:
        """
        @summary Queries the average latency of first frames within a specified period of time.
        
        @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKFirstFrameDelayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKFirstFrameDelayResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKFirstFrameDelay',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtsnative_sdkfirst_frame_delay(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse:
        """
        @summary Queries the average latency of first frames within a specified period of time.
        
        @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKFirstFrameDelayRequest
        @return: DescribeRTSNativeSDKFirstFrameDelayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtsnative_sdkfirst_frame_delay_with_options(request, runtime)

    async def describe_rtsnative_sdkfirst_frame_delay_async(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKFirstFrameDelayResponse:
        """
        @summary Queries the average latency of first frames within a specified period of time.
        
        @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKFirstFrameDelayRequest
        @return: DescribeRTSNativeSDKFirstFrameDelayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtsnative_sdkfirst_frame_delay_with_options_async(request, runtime)

    def describe_rtsnative_sdkplay_fail_status_with_options(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKPlayFailStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse:
        """
        @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
        
        @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKPlayFailStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKPlayFailStatusResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKPlayFailStatusShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKPlayFailStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtsnative_sdkplay_fail_status_with_options_async(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKPlayFailStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse:
        """
        @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
        
        @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKPlayFailStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKPlayFailStatusResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKPlayFailStatusShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKPlayFailStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtsnative_sdkplay_fail_status(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKPlayFailStatusRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse:
        """
        @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
        
        @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKPlayFailStatusRequest
        @return: DescribeRTSNativeSDKPlayFailStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtsnative_sdkplay_fail_status_with_options(request, runtime)

    async def describe_rtsnative_sdkplay_fail_status_async(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKPlayFailStatusRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayFailStatusResponse:
        """
        @summary Queries the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes.
        
        @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKPlayFailStatusRequest
        @return: DescribeRTSNativeSDKPlayFailStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtsnative_sdkplay_fail_status_with_options_async(request, runtime)

    def describe_rtsnative_sdkplay_time_with_options(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKPlayTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse:
        """
        @summary Queries the playback duration within a specified period of time.
        
        @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKPlayTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKPlayTimeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKPlayTimeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKPlayTime',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtsnative_sdkplay_time_with_options_async(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKPlayTimeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse:
        """
        @summary Queries the playback duration within a specified period of time.
        
        @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKPlayTimeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKPlayTimeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKPlayTimeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKPlayTime',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtsnative_sdkplay_time(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKPlayTimeRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse:
        """
        @summary Queries the playback duration within a specified period of time.
        
        @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKPlayTimeRequest
        @return: DescribeRTSNativeSDKPlayTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtsnative_sdkplay_time_with_options(request, runtime)

    async def describe_rtsnative_sdkplay_time_async(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKPlayTimeRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKPlayTimeResponse:
        """
        @summary Queries the playback duration within a specified period of time.
        
        @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKPlayTimeRequest
        @return: DescribeRTSNativeSDKPlayTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtsnative_sdkplay_time_with_options_async(request, runtime)

    def describe_rtsnative_sdkvv_data_with_options(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKVvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKVvDataResponse:
        """
        @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
        
        @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKVvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKVvDataResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKVvDataShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKVvData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKVvDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtsnative_sdkvv_data_with_options_async(
        self,
        tmp_req: live_20161101_models.DescribeRTSNativeSDKVvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRTSNativeSDKVvDataResponse:
        """
        @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
        
        @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param tmp_req: DescribeRTSNativeSDKVvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRTSNativeSDKVvDataResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.DescribeRTSNativeSDKVvDataShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.domain_name_list):
            request.domain_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.domain_name_list, 'DomainNameList', 'json')
        query = {}
        if not UtilClient.is_unset(request.data_interval):
            query['DataInterval'] = request.data_interval
        if not UtilClient.is_unset(request.domain_name_list_shrink):
            query['DomainNameList'] = request.domain_name_list_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRTSNativeSDKVvData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRTSNativeSDKVvDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtsnative_sdkvv_data(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKVvDataRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKVvDataResponse:
        """
        @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
        
        @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKVvDataRequest
        @return: DescribeRTSNativeSDKVvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtsnative_sdkvv_data_with_options(request, runtime)

    async def describe_rtsnative_sdkvv_data_async(
        self,
        request: live_20161101_models.DescribeRTSNativeSDKVvDataRequest,
    ) -> live_20161101_models.DescribeRTSNativeSDKVvDataResponse:
        """
        @summary Queries the total number of playbacks and the number of successful playbacks within a specified period of time.
        
        @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
        
        @param request: DescribeRTSNativeSDKVvDataRequest
        @return: DescribeRTSNativeSDKVvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtsnative_sdkvv_data_with_options_async(request, runtime)

    def describe_rtc_cloud_recording_files_with_options(
        self,
        request: live_20161101_models.DescribeRtcCloudRecordingFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRtcCloudRecordingFilesResponse:
        """
        @summary rtc
        
        @param request: DescribeRtcCloudRecordingFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRtcCloudRecordingFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRtcCloudRecordingFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRtcCloudRecordingFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtc_cloud_recording_files_with_options_async(
        self,
        request: live_20161101_models.DescribeRtcCloudRecordingFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRtcCloudRecordingFilesResponse:
        """
        @summary rtc
        
        @param request: DescribeRtcCloudRecordingFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRtcCloudRecordingFilesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRtcCloudRecordingFiles',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRtcCloudRecordingFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtc_cloud_recording_files(
        self,
        request: live_20161101_models.DescribeRtcCloudRecordingFilesRequest,
    ) -> live_20161101_models.DescribeRtcCloudRecordingFilesResponse:
        """
        @summary rtc
        
        @param request: DescribeRtcCloudRecordingFilesRequest
        @return: DescribeRtcCloudRecordingFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtc_cloud_recording_files_with_options(request, runtime)

    async def describe_rtc_cloud_recording_files_async(
        self,
        request: live_20161101_models.DescribeRtcCloudRecordingFilesRequest,
    ) -> live_20161101_models.DescribeRtcCloudRecordingFilesResponse:
        """
        @summary rtc
        
        @param request: DescribeRtcCloudRecordingFilesRequest
        @return: DescribeRtcCloudRecordingFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtc_cloud_recording_files_with_options_async(request, runtime)

    def describe_rtc_mpuevent_sub_with_options(
        self,
        request: live_20161101_models.DescribeRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRtcMPUEventSubResponse:
        """
        @summary Queries information about a subscription to mixed-stream relay events.
        
        @description ### Usage notes
        - You can call this operation to query information about a subscription to mixed-stream relay events.
        - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ### QPS limit
        - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRtcMPUEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_rtc_mpuevent_sub_with_options_async(
        self,
        request: live_20161101_models.DescribeRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeRtcMPUEventSubResponse:
        """
        @summary Queries information about a subscription to mixed-stream relay events.
        
        @description ### Usage notes
        - You can call this operation to query information about a subscription to mixed-stream relay events.
        - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ### QPS limit
        - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeRtcMPUEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_rtc_mpuevent_sub(
        self,
        request: live_20161101_models.DescribeRtcMPUEventSubRequest,
    ) -> live_20161101_models.DescribeRtcMPUEventSubResponse:
        """
        @summary Queries information about a subscription to mixed-stream relay events.
        
        @description ### Usage notes
        - You can call this operation to query information about a subscription to mixed-stream relay events.
        - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ### QPS limit
        - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeRtcMPUEventSubRequest
        @return: DescribeRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_rtc_mpuevent_sub_with_options(request, runtime)

    async def describe_rtc_mpuevent_sub_async(
        self,
        request: live_20161101_models.DescribeRtcMPUEventSubRequest,
    ) -> live_20161101_models.DescribeRtcMPUEventSubResponse:
        """
        @summary Queries information about a subscription to mixed-stream relay events.
        
        @description ### Usage notes
        - You can call this operation to query information about a subscription to mixed-stream relay events.
        - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ### QPS limit
        - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeRtcMPUEventSubRequest
        @return: DescribeRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_rtc_mpuevent_sub_with_options_async(request, runtime)

    def describe_show_list_with_options(
        self,
        request: live_20161101_models.DescribeShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeShowListResponse:
        """
        @summary Queries the details of the episode list.
        
        @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeShowListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_show_list_with_options_async(
        self,
        request: live_20161101_models.DescribeShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeShowListResponse:
        """
        @summary Queries the details of the episode list.
        
        @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeShowListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_show_list(
        self,
        request: live_20161101_models.DescribeShowListRequest,
    ) -> live_20161101_models.DescribeShowListResponse:
        """
        @summary Queries the details of the episode list.
        
        @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeShowListRequest
        @return: DescribeShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_show_list_with_options(request, runtime)

    async def describe_show_list_async(
        self,
        request: live_20161101_models.DescribeShowListRequest,
    ) -> live_20161101_models.DescribeShowListResponse:
        """
        @summary Queries the details of the episode list.
        
        @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeShowListRequest
        @return: DescribeShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_show_list_with_options_async(request, runtime)

    def describe_stream_location_block_with_options(
        self,
        request: live_20161101_models.DescribeStreamLocationBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeStreamLocationBlockResponse:
        """
        @summary Queries configurations of stream-level region blocking.
        
        @description Queries configurations of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeStreamLocationBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStreamLocationBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.block_type):
            query['BlockType'] = request.block_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStreamLocationBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeStreamLocationBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_stream_location_block_with_options_async(
        self,
        request: live_20161101_models.DescribeStreamLocationBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeStreamLocationBlockResponse:
        """
        @summary Queries configurations of stream-level region blocking.
        
        @description Queries configurations of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeStreamLocationBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStreamLocationBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.block_type):
            query['BlockType'] = request.block_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStreamLocationBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeStreamLocationBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_stream_location_block(
        self,
        request: live_20161101_models.DescribeStreamLocationBlockRequest,
    ) -> live_20161101_models.DescribeStreamLocationBlockResponse:
        """
        @summary Queries configurations of stream-level region blocking.
        
        @description Queries configurations of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeStreamLocationBlockRequest
        @return: DescribeStreamLocationBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_stream_location_block_with_options(request, runtime)

    async def describe_stream_location_block_async(
        self,
        request: live_20161101_models.DescribeStreamLocationBlockRequest,
    ) -> live_20161101_models.DescribeStreamLocationBlockResponse:
        """
        @summary Queries configurations of stream-level region blocking.
        
        @description Queries configurations of stream-level region blocking.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DescribeStreamLocationBlockRequest
        @return: DescribeStreamLocationBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_stream_location_block_with_options_async(request, runtime)

    def describe_studio_layouts_with_options(
        self,
        request: live_20161101_models.DescribeStudioLayoutsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeStudioLayoutsResponse:
        """
        @summary Queries one or more layouts of a virtual studio.
        
        @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
        ## QPS limits
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeStudioLayoutsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStudioLayoutsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStudioLayouts',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeStudioLayoutsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_studio_layouts_with_options_async(
        self,
        request: live_20161101_models.DescribeStudioLayoutsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeStudioLayoutsResponse:
        """
        @summary Queries one or more layouts of a virtual studio.
        
        @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
        ## QPS limits
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeStudioLayoutsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeStudioLayoutsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeStudioLayouts',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeStudioLayoutsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_studio_layouts(
        self,
        request: live_20161101_models.DescribeStudioLayoutsRequest,
    ) -> live_20161101_models.DescribeStudioLayoutsResponse:
        """
        @summary Queries one or more layouts of a virtual studio.
        
        @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
        ## QPS limits
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeStudioLayoutsRequest
        @return: DescribeStudioLayoutsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_studio_layouts_with_options(request, runtime)

    async def describe_studio_layouts_async(
        self,
        request: live_20161101_models.DescribeStudioLayoutsRequest,
    ) -> live_20161101_models.DescribeStudioLayoutsResponse:
        """
        @summary Queries one or more layouts of a virtual studio.
        
        @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
        ## QPS limits
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: DescribeStudioLayoutsRequest
        @return: DescribeStudioLayoutsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_studio_layouts_with_options_async(request, runtime)

    def describe_toutiao_live_play_with_options(
        self,
        request: live_20161101_models.DescribeToutiaoLivePlayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeToutiaoLivePlayResponse:
        """
        @summary Queries the stream pulling information about a live stream of a headline.
        
        @description You can call this operation to query the stream pulling information about a live stream of a headline.
        ## [](#qps-)QPS limits
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePlayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeToutiaoLivePlayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeToutiaoLivePlay',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeToutiaoLivePlayResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_toutiao_live_play_with_options_async(
        self,
        request: live_20161101_models.DescribeToutiaoLivePlayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeToutiaoLivePlayResponse:
        """
        @summary Queries the stream pulling information about a live stream of a headline.
        
        @description You can call this operation to query the stream pulling information about a live stream of a headline.
        ## [](#qps-)QPS limits
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePlayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeToutiaoLivePlayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeToutiaoLivePlay',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeToutiaoLivePlayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_toutiao_live_play(
        self,
        request: live_20161101_models.DescribeToutiaoLivePlayRequest,
    ) -> live_20161101_models.DescribeToutiaoLivePlayResponse:
        """
        @summary Queries the stream pulling information about a live stream of a headline.
        
        @description You can call this operation to query the stream pulling information about a live stream of a headline.
        ## [](#qps-)QPS limits
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePlayRequest
        @return: DescribeToutiaoLivePlayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_toutiao_live_play_with_options(request, runtime)

    async def describe_toutiao_live_play_async(
        self,
        request: live_20161101_models.DescribeToutiaoLivePlayRequest,
    ) -> live_20161101_models.DescribeToutiaoLivePlayResponse:
        """
        @summary Queries the stream pulling information about a live stream of a headline.
        
        @description You can call this operation to query the stream pulling information about a live stream of a headline.
        ## [](#qps-)QPS limits
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePlayRequest
        @return: DescribeToutiaoLivePlayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_toutiao_live_play_with_options_async(request, runtime)

    def describe_toutiao_live_publish_with_options(
        self,
        request: live_20161101_models.DescribeToutiaoLivePublishRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeToutiaoLivePublishResponse:
        """
        @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
        
        @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePublishRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeToutiaoLivePublishResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeToutiaoLivePublish',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeToutiaoLivePublishResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_toutiao_live_publish_with_options_async(
        self,
        request: live_20161101_models.DescribeToutiaoLivePublishRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeToutiaoLivePublishResponse:
        """
        @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
        
        @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePublishRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeToutiaoLivePublishResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeToutiaoLivePublish',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeToutiaoLivePublishResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_toutiao_live_publish(
        self,
        request: live_20161101_models.DescribeToutiaoLivePublishRequest,
    ) -> live_20161101_models.DescribeToutiaoLivePublishResponse:
        """
        @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
        
        @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePublishRequest
        @return: DescribeToutiaoLivePublishResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_toutiao_live_publish_with_options(request, runtime)

    async def describe_toutiao_live_publish_async(
        self,
        request: live_20161101_models.DescribeToutiaoLivePublishRequest,
    ) -> live_20161101_models.DescribeToutiaoLivePublishResponse:
        """
        @summary Queries the ingest information of a specified live stream that is ingested to Toutiao.
        
        @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeToutiaoLivePublishRequest
        @return: DescribeToutiaoLivePublishResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_toutiao_live_publish_with_options_async(request, runtime)

    def describe_uid_online_streams_with_options(
        self,
        request: live_20161101_models.DescribeUidOnlineStreamsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUidOnlineStreamsResponse:
        """
        @summary  uid app
        
        @param request: DescribeUidOnlineStreamsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUidOnlineStreamsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUidOnlineStreams',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUidOnlineStreamsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_uid_online_streams_with_options_async(
        self,
        request: live_20161101_models.DescribeUidOnlineStreamsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUidOnlineStreamsResponse:
        """
        @summary  uid app
        
        @param request: DescribeUidOnlineStreamsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUidOnlineStreamsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUidOnlineStreams',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUidOnlineStreamsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_uid_online_streams(
        self,
        request: live_20161101_models.DescribeUidOnlineStreamsRequest,
    ) -> live_20161101_models.DescribeUidOnlineStreamsResponse:
        """
        @summary  uid app
        
        @param request: DescribeUidOnlineStreamsRequest
        @return: DescribeUidOnlineStreamsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_uid_online_streams_with_options(request, runtime)

    async def describe_uid_online_streams_async(
        self,
        request: live_20161101_models.DescribeUidOnlineStreamsRequest,
    ) -> live_20161101_models.DescribeUidOnlineStreamsResponse:
        """
        @summary  uid app
        
        @param request: DescribeUidOnlineStreamsRequest
        @return: DescribeUidOnlineStreamsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_uid_online_streams_with_options_async(request, runtime)

    def describe_up_bps_peak_data_with_options(
        self,
        request: live_20161101_models.DescribeUpBpsPeakDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpBpsPeakDataResponse:
        """
        @summary Queries the daily peak inbound bandwidth.
        
        @description You can call this operation to query the daily peak inbound bandwidth.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpBpsPeakDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpBpsPeakData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpBpsPeakDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_up_bps_peak_data_with_options_async(
        self,
        request: live_20161101_models.DescribeUpBpsPeakDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpBpsPeakDataResponse:
        """
        @summary Queries the daily peak inbound bandwidth.
        
        @description You can call this operation to query the daily peak inbound bandwidth.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpBpsPeakDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpBpsPeakData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpBpsPeakDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_up_bps_peak_data(
        self,
        request: live_20161101_models.DescribeUpBpsPeakDataRequest,
    ) -> live_20161101_models.DescribeUpBpsPeakDataResponse:
        """
        @summary Queries the daily peak inbound bandwidth.
        
        @description You can call this operation to query the daily peak inbound bandwidth.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakDataRequest
        @return: DescribeUpBpsPeakDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_up_bps_peak_data_with_options(request, runtime)

    async def describe_up_bps_peak_data_async(
        self,
        request: live_20161101_models.DescribeUpBpsPeakDataRequest,
    ) -> live_20161101_models.DescribeUpBpsPeakDataResponse:
        """
        @summary Queries the daily peak inbound bandwidth.
        
        @description You can call this operation to query the daily peak inbound bandwidth.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakDataRequest
        @return: DescribeUpBpsPeakDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_up_bps_peak_data_with_options_async(request, runtime)

    def describe_up_bps_peak_of_line_with_options(
        self,
        request: live_20161101_models.DescribeUpBpsPeakOfLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpBpsPeakOfLineResponse:
        """
        @summary Queries the daily peak inbound bandwidth of a leased line.
        
        @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakOfLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpBpsPeakOfLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.line):
            query['Line'] = request.line
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpBpsPeakOfLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpBpsPeakOfLineResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_up_bps_peak_of_line_with_options_async(
        self,
        request: live_20161101_models.DescribeUpBpsPeakOfLineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpBpsPeakOfLineResponse:
        """
        @summary Queries the daily peak inbound bandwidth of a leased line.
        
        @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakOfLineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpBpsPeakOfLineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.line):
            query['Line'] = request.line
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpBpsPeakOfLine',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpBpsPeakOfLineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_up_bps_peak_of_line(
        self,
        request: live_20161101_models.DescribeUpBpsPeakOfLineRequest,
    ) -> live_20161101_models.DescribeUpBpsPeakOfLineResponse:
        """
        @summary Queries the daily peak inbound bandwidth of a leased line.
        
        @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakOfLineRequest
        @return: DescribeUpBpsPeakOfLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_up_bps_peak_of_line_with_options(request, runtime)

    async def describe_up_bps_peak_of_line_async(
        self,
        request: live_20161101_models.DescribeUpBpsPeakOfLineRequest,
    ) -> live_20161101_models.DescribeUpBpsPeakOfLineResponse:
        """
        @summary Queries the daily peak inbound bandwidth of a leased line.
        
        @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
        ## [](#qps-)QPS limit
        You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpBpsPeakOfLineRequest
        @return: DescribeUpBpsPeakOfLineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_up_bps_peak_of_line_with_options_async(request, runtime)

    def describe_up_peak_publish_stream_data_with_options(
        self,
        request: live_20161101_models.DescribeUpPeakPublishStreamDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpPeakPublishStreamDataResponse:
        """
        @summary Queries the daily peak number of concurrently ingested streams.
        
        @description You can call this operation to query the daily peak number of concurrently ingested streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpPeakPublishStreamDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpPeakPublishStreamDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpPeakPublishStreamData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpPeakPublishStreamDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_up_peak_publish_stream_data_with_options_async(
        self,
        request: live_20161101_models.DescribeUpPeakPublishStreamDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DescribeUpPeakPublishStreamDataResponse:
        """
        @summary Queries the daily peak number of concurrently ingested streams.
        
        @description You can call this operation to query the daily peak number of concurrently ingested streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpPeakPublishStreamDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUpPeakPublishStreamDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_switch):
            query['DomainSwitch'] = request.domain_switch
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUpPeakPublishStreamData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DescribeUpPeakPublishStreamDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_up_peak_publish_stream_data(
        self,
        request: live_20161101_models.DescribeUpPeakPublishStreamDataRequest,
    ) -> live_20161101_models.DescribeUpPeakPublishStreamDataResponse:
        """
        @summary Queries the daily peak number of concurrently ingested streams.
        
        @description You can call this operation to query the daily peak number of concurrently ingested streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpPeakPublishStreamDataRequest
        @return: DescribeUpPeakPublishStreamDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_up_peak_publish_stream_data_with_options(request, runtime)

    async def describe_up_peak_publish_stream_data_async(
        self,
        request: live_20161101_models.DescribeUpPeakPublishStreamDataRequest,
    ) -> live_20161101_models.DescribeUpPeakPublishStreamDataResponse:
        """
        @summary Queries the daily peak number of concurrently ingested streams.
        
        @description You can call this operation to query the daily peak number of concurrently ingested streams.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: DescribeUpPeakPublishStreamDataRequest
        @return: DescribeUpPeakPublishStreamDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_up_peak_publish_stream_data_with_options_async(request, runtime)

    def disable_live_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.DisableLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DisableLiveRealtimeLogDeliveryResponse:
        """
        @summary Suspends real-time log delivery for one or more domain names.
        
        @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DisableLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DisableLiveRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_live_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.DisableLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DisableLiveRealtimeLogDeliveryResponse:
        """
        @summary Suspends real-time log delivery for one or more domain names.
        
        @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DisableLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DisableLiveRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_live_realtime_log_delivery(
        self,
        request: live_20161101_models.DisableLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DisableLiveRealtimeLogDeliveryResponse:
        """
        @summary Suspends real-time log delivery for one or more domain names.
        
        @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DisableLiveRealtimeLogDeliveryRequest
        @return: DisableLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_live_realtime_log_delivery_with_options(request, runtime)

    async def disable_live_realtime_log_delivery_async(
        self,
        request: live_20161101_models.DisableLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.DisableLiveRealtimeLogDeliveryResponse:
        """
        @summary Suspends real-time log delivery for one or more domain names.
        
        @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DisableLiveRealtimeLogDeliveryRequest
        @return: DisableLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_live_realtime_log_delivery_with_options_async(request, runtime)

    def dynamic_update_water_mark_stream_rule_with_options(
        self,
        request: live_20161101_models.DynamicUpdateWaterMarkStreamRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse:
        """
        @summary Dynamically updates a watermark.
        
        @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the *TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DynamicUpdateWaterMarkStreamRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DynamicUpdateWaterMarkStreamRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DynamicUpdateWaterMarkStreamRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def dynamic_update_water_mark_stream_rule_with_options_async(
        self,
        request: live_20161101_models.DynamicUpdateWaterMarkStreamRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse:
        """
        @summary Dynamically updates a watermark.
        
        @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the *TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DynamicUpdateWaterMarkStreamRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DynamicUpdateWaterMarkStreamRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DynamicUpdateWaterMarkStreamRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def dynamic_update_water_mark_stream_rule(
        self,
        request: live_20161101_models.DynamicUpdateWaterMarkStreamRuleRequest,
    ) -> live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse:
        """
        @summary Dynamically updates a watermark.
        
        @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the *TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DynamicUpdateWaterMarkStreamRuleRequest
        @return: DynamicUpdateWaterMarkStreamRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.dynamic_update_water_mark_stream_rule_with_options(request, runtime)

    async def dynamic_update_water_mark_stream_rule_async(
        self,
        request: live_20161101_models.DynamicUpdateWaterMarkStreamRuleRequest,
    ) -> live_20161101_models.DynamicUpdateWaterMarkStreamRuleResponse:
        """
        @summary Dynamically updates a watermark.
        
        @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the *TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: DynamicUpdateWaterMarkStreamRuleRequest
        @return: DynamicUpdateWaterMarkStreamRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.dynamic_update_water_mark_stream_rule_with_options_async(request, runtime)

    def edit_playlist_with_options(
        self,
        request: live_20161101_models.EditPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EditPlaylistResponse:
        """
        @summary Edits an episode list.
        
        @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_config):
            query['ProgramConfig'] = request.program_config
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_items):
            query['ProgramItems'] = request.program_items
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EditPlaylistResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_playlist_with_options_async(
        self,
        request: live_20161101_models.EditPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EditPlaylistResponse:
        """
        @summary Edits an episode list.
        
        @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_config):
            query['ProgramConfig'] = request.program_config
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_items):
            query['ProgramItems'] = request.program_items
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EditPlaylistResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_playlist(
        self,
        request: live_20161101_models.EditPlaylistRequest,
    ) -> live_20161101_models.EditPlaylistResponse:
        """
        @summary Edits an episode list.
        
        @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditPlaylistRequest
        @return: EditPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_playlist_with_options(request, runtime)

    async def edit_playlist_async(
        self,
        request: live_20161101_models.EditPlaylistRequest,
    ) -> live_20161101_models.EditPlaylistResponse:
        """
        @summary Edits an episode list.
        
        @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditPlaylistRequest
        @return: EditPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_playlist_with_options_async(request, runtime)

    def edit_show_and_replace_with_options(
        self,
        request: live_20161101_models.EditShowAndReplaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EditShowAndReplaceResponse:
        """
        @summary Creates an editing task.
        
        @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditShowAndReplaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditShowAndReplaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_info):
            query['StorageInfo'] = request.storage_info
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditShowAndReplace',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EditShowAndReplaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_show_and_replace_with_options_async(
        self,
        request: live_20161101_models.EditShowAndReplaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EditShowAndReplaceResponse:
        """
        @summary Creates an editing task.
        
        @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditShowAndReplaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditShowAndReplaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_info):
            query['StorageInfo'] = request.storage_info
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditShowAndReplace',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EditShowAndReplaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_show_and_replace(
        self,
        request: live_20161101_models.EditShowAndReplaceRequest,
    ) -> live_20161101_models.EditShowAndReplaceResponse:
        """
        @summary Creates an editing task.
        
        @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditShowAndReplaceRequest
        @return: EditShowAndReplaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_show_and_replace_with_options(request, runtime)

    async def edit_show_and_replace_async(
        self,
        request: live_20161101_models.EditShowAndReplaceRequest,
    ) -> live_20161101_models.EditShowAndReplaceResponse:
        """
        @summary Creates an editing task.
        
        @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EditShowAndReplaceRequest
        @return: EditShowAndReplaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_show_and_replace_with_options_async(request, runtime)

    def effect_caster_urgent_with_options(
        self,
        request: live_20161101_models.EffectCasterUrgentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EffectCasterUrgentResponse:
        """
        @summary Switches a scene to the standby resource in a production studio.
        
        @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterUrgentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EffectCasterUrgentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EffectCasterUrgent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EffectCasterUrgentResponse(),
            self.call_api(params, req, runtime)
        )

    async def effect_caster_urgent_with_options_async(
        self,
        request: live_20161101_models.EffectCasterUrgentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EffectCasterUrgentResponse:
        """
        @summary Switches a scene to the standby resource in a production studio.
        
        @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterUrgentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EffectCasterUrgentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EffectCasterUrgent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EffectCasterUrgentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def effect_caster_urgent(
        self,
        request: live_20161101_models.EffectCasterUrgentRequest,
    ) -> live_20161101_models.EffectCasterUrgentResponse:
        """
        @summary Switches a scene to the standby resource in a production studio.
        
        @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterUrgentRequest
        @return: EffectCasterUrgentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.effect_caster_urgent_with_options(request, runtime)

    async def effect_caster_urgent_async(
        self,
        request: live_20161101_models.EffectCasterUrgentRequest,
    ) -> live_20161101_models.EffectCasterUrgentResponse:
        """
        @summary Switches a scene to the standby resource in a production studio.
        
        @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterUrgentRequest
        @return: EffectCasterUrgentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.effect_caster_urgent_with_options_async(request, runtime)

    def effect_caster_video_resource_with_options(
        self,
        request: live_20161101_models.EffectCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EffectCasterVideoResourceResponse:
        """
        @summary Updates the standby resource in a specified scene.
        
        @description Make sure that the resource is referenced by the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EffectCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EffectCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EffectCasterVideoResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def effect_caster_video_resource_with_options_async(
        self,
        request: live_20161101_models.EffectCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EffectCasterVideoResourceResponse:
        """
        @summary Updates the standby resource in a specified scene.
        
        @description Make sure that the resource is referenced by the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EffectCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EffectCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EffectCasterVideoResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def effect_caster_video_resource(
        self,
        request: live_20161101_models.EffectCasterVideoResourceRequest,
    ) -> live_20161101_models.EffectCasterVideoResourceResponse:
        """
        @summary Updates the standby resource in a specified scene.
        
        @description Make sure that the resource is referenced by the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterVideoResourceRequest
        @return: EffectCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.effect_caster_video_resource_with_options(request, runtime)

    async def effect_caster_video_resource_async(
        self,
        request: live_20161101_models.EffectCasterVideoResourceRequest,
    ) -> live_20161101_models.EffectCasterVideoResourceResponse:
        """
        @summary Updates the standby resource in a specified scene.
        
        @description Make sure that the resource is referenced by the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: EffectCasterVideoResourceRequest
        @return: EffectCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.effect_caster_video_resource_with_options_async(request, runtime)

    def enable_live_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.EnableLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EnableLiveRealtimeLogDeliveryResponse:
        """
        @summary Enables real-time log delivery for one or more domain names.
        
        @description ##
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: EnableLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EnableLiveRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_live_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.EnableLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.EnableLiveRealtimeLogDeliveryResponse:
        """
        @summary Enables real-time log delivery for one or more domain names.
        
        @description ##
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: EnableLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.EnableLiveRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_live_realtime_log_delivery(
        self,
        request: live_20161101_models.EnableLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.EnableLiveRealtimeLogDeliveryResponse:
        """
        @summary Enables real-time log delivery for one or more domain names.
        
        @description ##
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: EnableLiveRealtimeLogDeliveryRequest
        @return: EnableLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_live_realtime_log_delivery_with_options(request, runtime)

    async def enable_live_realtime_log_delivery_async(
        self,
        request: live_20161101_models.EnableLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.EnableLiveRealtimeLogDeliveryResponse:
        """
        @summary Enables real-time log delivery for one or more domain names.
        
        @description ##
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        ## QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: EnableLiveRealtimeLogDeliveryRequest
        @return: EnableLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_live_realtime_log_delivery_with_options_async(request, runtime)

    def forbid_live_stream_with_options(
        self,
        request: live_20161101_models.ForbidLiveStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ForbidLiveStreamResponse:
        """
        @summary Disables a live stream. You can specify the time when the live stream is resumed.
        
        @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
        >
        This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
        An interrupted live stream is not added to the blacklist and does not occupy the quota.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ForbidLiveStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ForbidLiveStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_stream_type):
            query['LiveStreamType'] = request.live_stream_type
        if not UtilClient.is_unset(request.oneshot):
            query['Oneshot'] = request.oneshot
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resume_time):
            query['ResumeTime'] = request.resume_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ForbidLiveStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ForbidLiveStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def forbid_live_stream_with_options_async(
        self,
        request: live_20161101_models.ForbidLiveStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ForbidLiveStreamResponse:
        """
        @summary Disables a live stream. You can specify the time when the live stream is resumed.
        
        @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
        >
        This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
        An interrupted live stream is not added to the blacklist and does not occupy the quota.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ForbidLiveStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ForbidLiveStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_stream_type):
            query['LiveStreamType'] = request.live_stream_type
        if not UtilClient.is_unset(request.oneshot):
            query['Oneshot'] = request.oneshot
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resume_time):
            query['ResumeTime'] = request.resume_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ForbidLiveStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ForbidLiveStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def forbid_live_stream(
        self,
        request: live_20161101_models.ForbidLiveStreamRequest,
    ) -> live_20161101_models.ForbidLiveStreamResponse:
        """
        @summary Disables a live stream. You can specify the time when the live stream is resumed.
        
        @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
        >
        This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
        An interrupted live stream is not added to the blacklist and does not occupy the quota.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ForbidLiveStreamRequest
        @return: ForbidLiveStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.forbid_live_stream_with_options(request, runtime)

    async def forbid_live_stream_async(
        self,
        request: live_20161101_models.ForbidLiveStreamRequest,
    ) -> live_20161101_models.ForbidLiveStreamResponse:
        """
        @summary Disables a live stream. You can specify the time when the live stream is resumed.
        
        @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
        >
        This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
        An interrupted live stream is not added to the blacklist and does not occupy the quota.
        ## [](#qps-)QPS limit
        You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ForbidLiveStreamRequest
        @return: ForbidLiveStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.forbid_live_stream_with_options_async(request, runtime)

    def get_all_custom_templates_with_options(
        self,
        request: live_20161101_models.GetAllCustomTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetAllCustomTemplatesResponse:
        """
        @summary Queries all custom stream mixing templates.
        
        @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetAllCustomTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAllCustomTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAllCustomTemplates',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetAllCustomTemplatesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_all_custom_templates_with_options_async(
        self,
        request: live_20161101_models.GetAllCustomTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetAllCustomTemplatesResponse:
        """
        @summary Queries all custom stream mixing templates.
        
        @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetAllCustomTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAllCustomTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAllCustomTemplates',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetAllCustomTemplatesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_all_custom_templates(
        self,
        request: live_20161101_models.GetAllCustomTemplatesRequest,
    ) -> live_20161101_models.GetAllCustomTemplatesResponse:
        """
        @summary Queries all custom stream mixing templates.
        
        @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetAllCustomTemplatesRequest
        @return: GetAllCustomTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_all_custom_templates_with_options(request, runtime)

    async def get_all_custom_templates_async(
        self,
        request: live_20161101_models.GetAllCustomTemplatesRequest,
    ) -> live_20161101_models.GetAllCustomTemplatesResponse:
        """
        @summary Queries all custom stream mixing templates.
        
        @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetAllCustomTemplatesRequest
        @return: GetAllCustomTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_all_custom_templates_with_options_async(request, runtime)

    def get_custom_template_with_options(
        self,
        request: live_20161101_models.GetCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetCustomTemplateResponse:
        """
        @summary Queries the information about a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetCustomTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_custom_template_with_options_async(
        self,
        request: live_20161101_models.GetCustomTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetCustomTemplateResponse:
        """
        @summary Queries the information about a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetCustomTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCustomTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCustomTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetCustomTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_custom_template(
        self,
        request: live_20161101_models.GetCustomTemplateRequest,
    ) -> live_20161101_models.GetCustomTemplateResponse:
        """
        @summary Queries the information about a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetCustomTemplateRequest
        @return: GetCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_custom_template_with_options(request, runtime)

    async def get_custom_template_async(
        self,
        request: live_20161101_models.GetCustomTemplateRequest,
    ) -> live_20161101_models.GetCustomTemplateResponse:
        """
        @summary Queries the information about a custom stream mixing template.
        
        @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetCustomTemplateRequest
        @return: GetCustomTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_custom_template_with_options_async(request, runtime)

    def get_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.GetEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEdgeTranscodeJobResponse:
        """
        @summary Queries the details of an edge transcoding task.
        
        @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.GetEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEdgeTranscodeJobResponse:
        """
        @summary Queries the details of an edge transcoding task.
        
        @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_edge_transcode_job(
        self,
        request: live_20161101_models.GetEdgeTranscodeJobRequest,
    ) -> live_20161101_models.GetEdgeTranscodeJobResponse:
        """
        @summary Queries the details of an edge transcoding task.
        
        @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeJobRequest
        @return: GetEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_edge_transcode_job_with_options(request, runtime)

    async def get_edge_transcode_job_async(
        self,
        request: live_20161101_models.GetEdgeTranscodeJobRequest,
    ) -> live_20161101_models.GetEdgeTranscodeJobResponse:
        """
        @summary Queries the details of an edge transcoding task.
        
        @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeJobRequest
        @return: GetEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_edge_transcode_job_with_options_async(request, runtime)

    def get_edge_transcode_template_with_options(
        self,
        request: live_20161101_models.GetEdgeTranscodeTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEdgeTranscodeTemplateResponse:
        """
        @summary Queries the details of an edge transcoding template.
        
        @description    You can call this operation to query the details of an edge transcoding template.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEdgeTranscodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEdgeTranscodeTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEdgeTranscodeTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_edge_transcode_template_with_options_async(
        self,
        request: live_20161101_models.GetEdgeTranscodeTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEdgeTranscodeTemplateResponse:
        """
        @summary Queries the details of an edge transcoding template.
        
        @description    You can call this operation to query the details of an edge transcoding template.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEdgeTranscodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEdgeTranscodeTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEdgeTranscodeTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_edge_transcode_template(
        self,
        request: live_20161101_models.GetEdgeTranscodeTemplateRequest,
    ) -> live_20161101_models.GetEdgeTranscodeTemplateResponse:
        """
        @summary Queries the details of an edge transcoding template.
        
        @description    You can call this operation to query the details of an edge transcoding template.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeTemplateRequest
        @return: GetEdgeTranscodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_edge_transcode_template_with_options(request, runtime)

    async def get_edge_transcode_template_async(
        self,
        request: live_20161101_models.GetEdgeTranscodeTemplateRequest,
    ) -> live_20161101_models.GetEdgeTranscodeTemplateResponse:
        """
        @summary Queries the details of an edge transcoding template.
        
        @description    You can call this operation to query the details of an edge transcoding template.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEdgeTranscodeTemplateRequest
        @return: GetEdgeTranscodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_edge_transcode_template_with_options_async(request, runtime)

    def get_editing_job_info_with_options(
        self,
        request: live_20161101_models.GetEditingJobInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEditingJobInfoResponse:
        """
        @summary Queries the information about editing tasks.
        
        @description    When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
        If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
        If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
        ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEditingJobInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingJobInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingJobInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEditingJobInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_editing_job_info_with_options_async(
        self,
        request: live_20161101_models.GetEditingJobInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetEditingJobInfoResponse:
        """
        @summary Queries the information about editing tasks.
        
        @description    When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
        If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
        If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
        ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEditingJobInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingJobInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingJobInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetEditingJobInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_editing_job_info(
        self,
        request: live_20161101_models.GetEditingJobInfoRequest,
    ) -> live_20161101_models.GetEditingJobInfoResponse:
        """
        @summary Queries the information about editing tasks.
        
        @description    When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
        If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
        If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
        ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEditingJobInfoRequest
        @return: GetEditingJobInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_editing_job_info_with_options(request, runtime)

    async def get_editing_job_info_async(
        self,
        request: live_20161101_models.GetEditingJobInfoRequest,
    ) -> live_20161101_models.GetEditingJobInfoResponse:
        """
        @summary Queries the information about editing tasks.
        
        @description    When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
        If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
        If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
        ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: GetEditingJobInfoRequest
        @return: GetEditingJobInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_editing_job_info_with_options_async(request, runtime)

    def get_message_app_with_options(
        self,
        request: live_20161101_models.GetMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageAppResponse:
        """
        @summary Queries the information about a specified interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_app_with_options_async(
        self,
        request: live_20161101_models.GetMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageAppResponse:
        """
        @summary Queries the information about a specified interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_app(
        self,
        request: live_20161101_models.GetMessageAppRequest,
    ) -> live_20161101_models.GetMessageAppResponse:
        """
        @summary Queries the information about a specified interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageAppRequest
        @return: GetMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_app_with_options(request, runtime)

    async def get_message_app_async(
        self,
        request: live_20161101_models.GetMessageAppRequest,
    ) -> live_20161101_models.GetMessageAppResponse:
        """
        @summary Queries the information about a specified interactive messaging application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageAppRequest
        @return: GetMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_app_with_options_async(request, runtime)

    def get_message_group_with_options(
        self,
        request: live_20161101_models.GetMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageGroupResponse:
        """
        @summary Queries the information about a message group.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_group_with_options_async(
        self,
        request: live_20161101_models.GetMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageGroupResponse:
        """
        @summary Queries the information about a message group.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_group(
        self,
        request: live_20161101_models.GetMessageGroupRequest,
    ) -> live_20161101_models.GetMessageGroupResponse:
        """
        @summary Queries the information about a message group.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageGroupRequest
        @return: GetMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_group_with_options(request, runtime)

    async def get_message_group_async(
        self,
        request: live_20161101_models.GetMessageGroupRequest,
    ) -> live_20161101_models.GetMessageGroupResponse:
        """
        @summary Queries the information about a message group.
        
        @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageGroupRequest
        @return: GetMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_group_with_options_async(request, runtime)

    def get_message_token_with_options(
        self,
        request: live_20161101_models.GetMessageTokenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageTokenResponse:
        """
        @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
        
        @description ##
        Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageTokenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageTokenResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.device_id):
            body['DeviceId'] = request.device_id
        if not UtilClient.is_unset(request.device_type):
            body['DeviceType'] = request.device_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageToken',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageTokenResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_token_with_options_async(
        self,
        request: live_20161101_models.GetMessageTokenRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetMessageTokenResponse:
        """
        @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
        
        @description ##
        Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageTokenRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageTokenResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.device_id):
            body['DeviceId'] = request.device_id
        if not UtilClient.is_unset(request.device_type):
            body['DeviceType'] = request.device_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetMessageToken',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetMessageTokenResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_token(
        self,
        request: live_20161101_models.GetMessageTokenRequest,
    ) -> live_20161101_models.GetMessageTokenResponse:
        """
        @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
        
        @description ##
        Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageTokenRequest
        @return: GetMessageTokenResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_token_with_options(request, runtime)

    async def get_message_token_async(
        self,
        request: live_20161101_models.GetMessageTokenRequest,
    ) -> live_20161101_models.GetMessageTokenResponse:
        """
        @summary Obtains a token that the client can use to establish a persistent connection over the LWP protocol and based on atomic capabilities.
        
        @description ##
        Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: GetMessageTokenRequest
        @return: GetMessageTokenResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_token_with_options_async(request, runtime)

    def get_transcode_task_status_with_options(
        self,
        request: live_20161101_models.GetTranscodeTaskStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetTranscodeTaskStatusResponse:
        """
        @param request: GetTranscodeTaskStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTaskStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcoding_template):
            query['TranscodingTemplate'] = request.transcoding_template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTaskStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetTranscodeTaskStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_transcode_task_status_with_options_async(
        self,
        request: live_20161101_models.GetTranscodeTaskStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.GetTranscodeTaskStatusResponse:
        """
        @param request: GetTranscodeTaskStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTaskStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcoding_template):
            query['TranscodingTemplate'] = request.transcoding_template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTaskStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.GetTranscodeTaskStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_transcode_task_status(
        self,
        request: live_20161101_models.GetTranscodeTaskStatusRequest,
    ) -> live_20161101_models.GetTranscodeTaskStatusResponse:
        """
        @param request: GetTranscodeTaskStatusRequest
        @return: GetTranscodeTaskStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_transcode_task_status_with_options(request, runtime)

    async def get_transcode_task_status_async(
        self,
        request: live_20161101_models.GetTranscodeTaskStatusRequest,
    ) -> live_20161101_models.GetTranscodeTaskStatusResponse:
        """
        @param request: GetTranscodeTaskStatusRequest
        @return: GetTranscodeTaskStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_transcode_task_status_with_options_async(request, runtime)

    def hot_live_rtc_stream_with_options(
        self,
        request: live_20161101_models.HotLiveRtcStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.HotLiveRtcStreamResponse:
        """
        @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: HotLiveRtcStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: HotLiveRtcStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.audio_msid):
            query['AudioMsid'] = request.audio_msid
        if not UtilClient.is_unset(request.connection_timeout):
            query['ConnectionTimeout'] = request.connection_timeout
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.media_timeout):
            query['MediaTimeout'] = request.media_timeout
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_code):
            query['RegionCode'] = request.region_code
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_msid):
            query['VideoMsid'] = request.video_msid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='HotLiveRtcStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.HotLiveRtcStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def hot_live_rtc_stream_with_options_async(
        self,
        request: live_20161101_models.HotLiveRtcStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.HotLiveRtcStreamResponse:
        """
        @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: HotLiveRtcStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: HotLiveRtcStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.audio_msid):
            query['AudioMsid'] = request.audio_msid
        if not UtilClient.is_unset(request.connection_timeout):
            query['ConnectionTimeout'] = request.connection_timeout
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.media_timeout):
            query['MediaTimeout'] = request.media_timeout
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_code):
            query['RegionCode'] = request.region_code
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.video_msid):
            query['VideoMsid'] = request.video_msid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='HotLiveRtcStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.HotLiveRtcStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def hot_live_rtc_stream(
        self,
        request: live_20161101_models.HotLiveRtcStreamRequest,
    ) -> live_20161101_models.HotLiveRtcStreamResponse:
        """
        @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: HotLiveRtcStreamRequest
        @return: HotLiveRtcStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.hot_live_rtc_stream_with_options(request, runtime)

    async def hot_live_rtc_stream_async(
        self,
        request: live_20161101_models.HotLiveRtcStreamRequest,
    ) -> live_20161101_models.HotLiveRtcStreamResponse:
        """
        @summary Configures prefetch for a live stream that is ingested based on Real-Time Communication (RTC).
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: HotLiveRtcStreamRequest
        @return: HotLiveRtcStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.hot_live_rtc_stream_with_options_async(request, runtime)

    def initialize_auto_show_list_task_with_options(
        self,
        request: live_20161101_models.InitializeAutoShowListTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.InitializeAutoShowListTaskResponse:
        """
        @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
        
        @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: InitializeAutoShowListTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitializeAutoShowListTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.call_back_url):
            query['CallBackUrl'] = request.call_back_url
        if not UtilClient.is_unset(request.caster_config):
            query['CasterConfig'] = request.caster_config
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitializeAutoShowListTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.InitializeAutoShowListTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def initialize_auto_show_list_task_with_options_async(
        self,
        request: live_20161101_models.InitializeAutoShowListTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.InitializeAutoShowListTaskResponse:
        """
        @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
        
        @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: InitializeAutoShowListTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitializeAutoShowListTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.call_back_url):
            query['CallBackUrl'] = request.call_back_url
        if not UtilClient.is_unset(request.caster_config):
            query['CasterConfig'] = request.caster_config
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitializeAutoShowListTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.InitializeAutoShowListTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def initialize_auto_show_list_task(
        self,
        request: live_20161101_models.InitializeAutoShowListTaskRequest,
    ) -> live_20161101_models.InitializeAutoShowListTaskResponse:
        """
        @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
        
        @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: InitializeAutoShowListTaskRequest
        @return: InitializeAutoShowListTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.initialize_auto_show_list_task_with_options(request, runtime)

    async def initialize_auto_show_list_task_async(
        self,
        request: live_20161101_models.InitializeAutoShowListTaskRequest,
    ) -> live_20161101_models.InitializeAutoShowListTaskResponse:
        """
        @summary Creates a scheduled task to start and stop the playback of a playlist at specified points in time.
        
        @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: InitializeAutoShowListTaskRequest
        @return: InitializeAutoShowListTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.initialize_auto_show_list_task_with_options_async(request, runtime)

    def join_message_group_with_options(
        self,
        request: live_20161101_models.JoinMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.JoinMessageGroupResponse:
        """
        @summary Joins a message group.
        
        @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: JoinMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_statistics):
            body['BroadCastStatistics'] = request.broad_cast_statistics
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='JoinMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.JoinMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def join_message_group_with_options_async(
        self,
        request: live_20161101_models.JoinMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.JoinMessageGroupResponse:
        """
        @summary Joins a message group.
        
        @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: JoinMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: JoinMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_statistics):
            body['BroadCastStatistics'] = request.broad_cast_statistics
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='JoinMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.JoinMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def join_message_group(
        self,
        request: live_20161101_models.JoinMessageGroupRequest,
    ) -> live_20161101_models.JoinMessageGroupResponse:
        """
        @summary Joins a message group.
        
        @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: JoinMessageGroupRequest
        @return: JoinMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.join_message_group_with_options(request, runtime)

    async def join_message_group_async(
        self,
        request: live_20161101_models.JoinMessageGroupRequest,
    ) -> live_20161101_models.JoinMessageGroupResponse:
        """
        @summary Joins a message group.
        
        @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: JoinMessageGroupRequest
        @return: JoinMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.join_message_group_with_options_async(request, runtime)

    def kick_live_message_group_user_with_options(
        self,
        request: live_20161101_models.KickLiveMessageGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.KickLiveMessageGroupUserResponse:
        """
        @summary Removes a user from an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: KickLiveMessageGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: KickLiveMessageGroupUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.kickoff_user):
            query['KickoffUser'] = request.kickoff_user
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='KickLiveMessageGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.KickLiveMessageGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def kick_live_message_group_user_with_options_async(
        self,
        request: live_20161101_models.KickLiveMessageGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.KickLiveMessageGroupUserResponse:
        """
        @summary Removes a user from an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: KickLiveMessageGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: KickLiveMessageGroupUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.kickoff_user):
            query['KickoffUser'] = request.kickoff_user
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='KickLiveMessageGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.KickLiveMessageGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def kick_live_message_group_user(
        self,
        request: live_20161101_models.KickLiveMessageGroupUserRequest,
    ) -> live_20161101_models.KickLiveMessageGroupUserResponse:
        """
        @summary Removes a user from an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: KickLiveMessageGroupUserRequest
        @return: KickLiveMessageGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.kick_live_message_group_user_with_options(request, runtime)

    async def kick_live_message_group_user_async(
        self,
        request: live_20161101_models.KickLiveMessageGroupUserRequest,
    ) -> live_20161101_models.KickLiveMessageGroupUserResponse:
        """
        @summary Removes a user from an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: KickLiveMessageGroupUserRequest
        @return: KickLiveMessageGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.kick_live_message_group_user_with_options_async(request, runtime)

    def leave_message_group_with_options(
        self,
        request: live_20161101_models.LeaveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.LeaveMessageGroupResponse:
        """
        @summary Leaves a message group.
        
        @description ##
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: LeaveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LeaveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_statistics):
            body['BroadCastStatistics'] = request.broad_cast_statistics
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='LeaveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.LeaveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def leave_message_group_with_options_async(
        self,
        request: live_20161101_models.LeaveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.LeaveMessageGroupResponse:
        """
        @summary Leaves a message group.
        
        @description ##
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: LeaveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LeaveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_statistics):
            body['BroadCastStatistics'] = request.broad_cast_statistics
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='LeaveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.LeaveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def leave_message_group(
        self,
        request: live_20161101_models.LeaveMessageGroupRequest,
    ) -> live_20161101_models.LeaveMessageGroupResponse:
        """
        @summary Leaves a message group.
        
        @description ##
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: LeaveMessageGroupRequest
        @return: LeaveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.leave_message_group_with_options(request, runtime)

    async def leave_message_group_async(
        self,
        request: live_20161101_models.LeaveMessageGroupRequest,
    ) -> live_20161101_models.LeaveMessageGroupResponse:
        """
        @summary Leaves a message group.
        
        @description ##
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: LeaveMessageGroupRequest
        @return: LeaveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.leave_message_group_with_options_async(request, runtime)

    def list_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.ListEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEdgeTranscodeJobResponse:
        """
        @summary Queries edge transcoding tasks.
        
        @description    You can call this operation to query edge transcoding tasks.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        You can query only tasks created or modified in the last 180 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.ListEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEdgeTranscodeJobResponse:
        """
        @summary Queries edge transcoding tasks.
        
        @description    You can call this operation to query edge transcoding tasks.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        You can query only tasks created or modified in the last 180 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_edge_transcode_job(
        self,
        request: live_20161101_models.ListEdgeTranscodeJobRequest,
    ) -> live_20161101_models.ListEdgeTranscodeJobResponse:
        """
        @summary Queries edge transcoding tasks.
        
        @description    You can call this operation to query edge transcoding tasks.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        You can query only tasks created or modified in the last 180 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeJobRequest
        @return: ListEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_edge_transcode_job_with_options(request, runtime)

    async def list_edge_transcode_job_async(
        self,
        request: live_20161101_models.ListEdgeTranscodeJobRequest,
    ) -> live_20161101_models.ListEdgeTranscodeJobResponse:
        """
        @summary Queries edge transcoding tasks.
        
        @description    You can call this operation to query edge transcoding tasks.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        You can query only tasks created or modified in the last 180 days.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeJobRequest
        @return: ListEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_edge_transcode_job_with_options_async(request, runtime)

    def list_edge_transcode_template_with_options(
        self,
        request: live_20161101_models.ListEdgeTranscodeTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEdgeTranscodeTemplateResponse:
        """
        @summary Queries the list of edge transcoding templates.
        
        @description    You can call this operation to query the list of edge transcoding templates.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEdgeTranscodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.video_codec):
            query['VideoCodec'] = request.video_codec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEdgeTranscodeTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEdgeTranscodeTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_edge_transcode_template_with_options_async(
        self,
        request: live_20161101_models.ListEdgeTranscodeTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEdgeTranscodeTemplateResponse:
        """
        @summary Queries the list of edge transcoding templates.
        
        @description    You can call this operation to query the list of edge transcoding templates.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEdgeTranscodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.keyword):
            query['Keyword'] = request.keyword
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.video_codec):
            query['VideoCodec'] = request.video_codec
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEdgeTranscodeTemplate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEdgeTranscodeTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_edge_transcode_template(
        self,
        request: live_20161101_models.ListEdgeTranscodeTemplateRequest,
    ) -> live_20161101_models.ListEdgeTranscodeTemplateResponse:
        """
        @summary Queries the list of edge transcoding templates.
        
        @description    You can call this operation to query the list of edge transcoding templates.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeTemplateRequest
        @return: ListEdgeTranscodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_edge_transcode_template_with_options(request, runtime)

    async def list_edge_transcode_template_async(
        self,
        request: live_20161101_models.ListEdgeTranscodeTemplateRequest,
    ) -> live_20161101_models.ListEdgeTranscodeTemplateResponse:
        """
        @summary Queries the list of edge transcoding templates.
        
        @description    You can call this operation to query the list of edge transcoding templates.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEdgeTranscodeTemplateRequest
        @return: ListEdgeTranscodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_edge_transcode_template_with_options_async(request, runtime)

    def list_event_sub_with_options(
        self,
        request: live_20161101_models.ListEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEventSubResponse:
        """
        @summary Queries the events generated in channels to which you subscribe.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventSubResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_event_sub_with_options_async(
        self,
        request: live_20161101_models.ListEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEventSubResponse:
        """
        @summary Queries the events generated in channels to which you subscribe.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventSubResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_event_sub(
        self,
        request: live_20161101_models.ListEventSubRequest,
    ) -> live_20161101_models.ListEventSubResponse:
        """
        @summary Queries the events generated in channels to which you subscribe.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubRequest
        @return: ListEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_event_sub_with_options(request, runtime)

    async def list_event_sub_async(
        self,
        request: live_20161101_models.ListEventSubRequest,
    ) -> live_20161101_models.ListEventSubResponse:
        """
        @summary Queries the events generated in channels to which you subscribe.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubRequest
        @return: ListEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_event_sub_with_options_async(request, runtime)

    def list_event_sub_event_with_options(
        self,
        request: live_20161101_models.ListEventSubEventRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEventSubEventResponse:
        """
        @summary Queries callback records.
        
        @description    The maximum time range to query is seven days.
        The minimum time granularity to query is 1 minute.
        You can query data in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubEventRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventSubEventResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventSubEvent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEventSubEventResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_event_sub_event_with_options_async(
        self,
        request: live_20161101_models.ListEventSubEventRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListEventSubEventResponse:
        """
        @summary Queries callback records.
        
        @description    The maximum time range to query is seven days.
        The minimum time granularity to query is 1 minute.
        You can query data in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubEventRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventSubEventResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventSubEvent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListEventSubEventResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_event_sub_event(
        self,
        request: live_20161101_models.ListEventSubEventRequest,
    ) -> live_20161101_models.ListEventSubEventResponse:
        """
        @summary Queries callback records.
        
        @description    The maximum time range to query is seven days.
        The minimum time granularity to query is 1 minute.
        You can query data in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubEventRequest
        @return: ListEventSubEventResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_event_sub_event_with_options(request, runtime)

    async def list_event_sub_event_async(
        self,
        request: live_20161101_models.ListEventSubEventRequest,
    ) -> live_20161101_models.ListEventSubEventResponse:
        """
        @summary Queries callback records.
        
        @description    The maximum time range to query is seven days.
        The minimum time granularity to query is 1 minute.
        You can query data in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListEventSubEventRequest
        @return: ListEventSubEventResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_event_sub_event_with_options_async(request, runtime)

    def list_live_delay_config_with_options(
        self,
        request: live_20161101_models.ListLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveDelayConfigResponse:
        """
        @summary Queries stream delay configurations.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_delay_config_with_options_async(
        self,
        request: live_20161101_models.ListLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveDelayConfigResponse:
        """
        @summary Queries stream delay configurations.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_num):
            query['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_delay_config(
        self,
        request: live_20161101_models.ListLiveDelayConfigRequest,
    ) -> live_20161101_models.ListLiveDelayConfigResponse:
        """
        @summary Queries stream delay configurations.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveDelayConfigRequest
        @return: ListLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_delay_config_with_options(request, runtime)

    async def list_live_delay_config_async(
        self,
        request: live_20161101_models.ListLiveDelayConfigRequest,
    ) -> live_20161101_models.ListLiveDelayConfigResponse:
        """
        @summary Queries stream delay configurations.
        
        @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveDelayConfigRequest
        @return: ListLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_delay_config_with_options_async(request, runtime)

    def list_live_message_apps_with_options(
        self,
        request: live_20161101_models.ListLiveMessageAppsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageAppsResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageAppsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageAppsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageApps',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageAppsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_message_apps_with_options_async(
        self,
        request: live_20161101_models.ListLiveMessageAppsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageAppsResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageAppsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageAppsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageApps',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageAppsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_message_apps(
        self,
        request: live_20161101_models.ListLiveMessageAppsRequest,
    ) -> live_20161101_models.ListLiveMessageAppsResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageAppsRequest
        @return: ListLiveMessageAppsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_message_apps_with_options(request, runtime)

    async def list_live_message_apps_async(
        self,
        request: live_20161101_models.ListLiveMessageAppsRequest,
    ) -> live_20161101_models.ListLiveMessageAppsResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageAppsRequest
        @return: ListLiveMessageAppsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_message_apps_with_options_async(request, runtime)

    def list_live_message_group_by_page_with_options(
        self,
        request: live_20161101_models.ListLiveMessageGroupByPageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupByPageResponse:
        """
        @summary Queries interactive messaging groups by page.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupByPageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupByPageResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupByPage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupByPageResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_message_group_by_page_with_options_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupByPageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupByPageResponse:
        """
        @summary Queries interactive messaging groups by page.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupByPageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupByPageResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupByPage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupByPageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_message_group_by_page(
        self,
        request: live_20161101_models.ListLiveMessageGroupByPageRequest,
    ) -> live_20161101_models.ListLiveMessageGroupByPageResponse:
        """
        @summary Queries interactive messaging groups by page.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupByPageRequest
        @return: ListLiveMessageGroupByPageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_message_group_by_page_with_options(request, runtime)

    async def list_live_message_group_by_page_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupByPageRequest,
    ) -> live_20161101_models.ListLiveMessageGroupByPageResponse:
        """
        @summary Queries interactive messaging groups by page.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupByPageRequest
        @return: ListLiveMessageGroupByPageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_message_group_by_page_with_options_async(request, runtime)

    def list_live_message_group_messages_with_options(
        self,
        request: live_20161101_models.ListLiveMessageGroupMessagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupMessagesResponse:
        """
        @summary Queries the messages sent in a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupMessagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupMessagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupMessages',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupMessagesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_message_group_messages_with_options_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupMessagesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupMessagesResponse:
        """
        @summary Queries the messages sent in a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupMessagesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupMessagesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupMessages',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupMessagesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_message_group_messages(
        self,
        request: live_20161101_models.ListLiveMessageGroupMessagesRequest,
    ) -> live_20161101_models.ListLiveMessageGroupMessagesResponse:
        """
        @summary Queries the messages sent in a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupMessagesRequest
        @return: ListLiveMessageGroupMessagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_message_group_messages_with_options(request, runtime)

    async def list_live_message_group_messages_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupMessagesRequest,
    ) -> live_20161101_models.ListLiveMessageGroupMessagesResponse:
        """
        @summary Queries the messages sent in a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupMessagesRequest
        @return: ListLiveMessageGroupMessagesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_message_group_messages_with_options_async(request, runtime)

    def list_live_message_group_users_with_options(
        self,
        request: live_20161101_models.ListLiveMessageGroupUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupUsersResponse:
        """
        @summary Queries the users in an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupUsersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_message_group_users_with_options_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupUsersResponse:
        """
        @summary Queries the users in an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroupUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupUsersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_message_group_users(
        self,
        request: live_20161101_models.ListLiveMessageGroupUsersRequest,
    ) -> live_20161101_models.ListLiveMessageGroupUsersResponse:
        """
        @summary Queries the users in an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupUsersRequest
        @return: ListLiveMessageGroupUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_message_group_users_with_options(request, runtime)

    async def list_live_message_group_users_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupUsersRequest,
    ) -> live_20161101_models.ListLiveMessageGroupUsersResponse:
        """
        @summary Queries the users in an interactive messaging group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupUsersRequest
        @return: ListLiveMessageGroupUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_message_group_users_with_options_async(request, runtime)

    def list_live_message_groups_with_options(
        self,
        request: live_20161101_models.ListLiveMessageGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupsResponse:
        """
        @summary Queries the interactive messaging groups in an interactive messaging application.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_status):
            query['GroupStatus'] = request.group_status
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroups',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_message_groups_with_options_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveMessageGroupsResponse:
        """
        @summary Queries the interactive messaging groups in an interactive messaging application.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveMessageGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_status):
            query['GroupStatus'] = request.group_status
        if not UtilClient.is_unset(request.next_page_token):
            query['NextPageToken'] = request.next_page_token
        if not UtilClient.is_unset(request.sort_type):
            query['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveMessageGroups',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveMessageGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_message_groups(
        self,
        request: live_20161101_models.ListLiveMessageGroupsRequest,
    ) -> live_20161101_models.ListLiveMessageGroupsResponse:
        """
        @summary Queries the interactive messaging groups in an interactive messaging application.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupsRequest
        @return: ListLiveMessageGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_message_groups_with_options(request, runtime)

    async def list_live_message_groups_async(
        self,
        request: live_20161101_models.ListLiveMessageGroupsRequest,
    ) -> live_20161101_models.ListLiveMessageGroupsResponse:
        """
        @summary Queries the interactive messaging groups in an interactive messaging application.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveMessageGroupsRequest
        @return: ListLiveMessageGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_message_groups_with_options_async(request, runtime)

    def list_live_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryResponse:
        """
        @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
        
        @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryResponse:
        """
        @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
        
        @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_realtime_log_delivery(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryResponse:
        """
        @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
        
        @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryRequest
        @return: ListLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_realtime_log_delivery_with_options(request, runtime)

    async def list_live_realtime_log_delivery_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryResponse:
        """
        @summary Queries all configurations of real-time log delivery under an Alibaba Cloud account.
        
        @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryRequest
        @return: ListLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_realtime_log_delivery_with_options_async(request, runtime)

    def list_live_realtime_log_delivery_domains_with_options(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse:
        """
        @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
        
        @description    You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryDomainsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDeliveryDomains',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_realtime_log_delivery_domains_with_options_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse:
        """
        @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
        
        @description    You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryDomainsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDeliveryDomains',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_realtime_log_delivery_domains(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryDomainsRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse:
        """
        @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
        
        @description    You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryDomainsRequest
        @return: ListLiveRealtimeLogDeliveryDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_realtime_log_delivery_domains_with_options(request, runtime)

    async def list_live_realtime_log_delivery_domains_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryDomainsRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryDomainsResponse:
        """
        @summary Queries all domain names that are associated with a specific configuration of real-time log delivery.
        
        @description    You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryDomainsRequest
        @return: ListLiveRealtimeLogDeliveryDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_realtime_log_delivery_domains_with_options_async(request, runtime)

    def list_live_realtime_log_delivery_infos_with_options(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse:
        """
        @summary Queries all configurations of real-time log delivery.
        
        @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryInfosResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDeliveryInfos',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_realtime_log_delivery_infos_with_options_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse:
        """
        @summary Queries all configurations of real-time log delivery.
        
        @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRealtimeLogDeliveryInfosResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRealtimeLogDeliveryInfos',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_realtime_log_delivery_infos(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryInfosRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse:
        """
        @summary Queries all configurations of real-time log delivery.
        
        @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryInfosRequest
        @return: ListLiveRealtimeLogDeliveryInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_realtime_log_delivery_infos_with_options(request, runtime)

    async def list_live_realtime_log_delivery_infos_async(
        self,
        request: live_20161101_models.ListLiveRealtimeLogDeliveryInfosRequest,
    ) -> live_20161101_models.ListLiveRealtimeLogDeliveryInfosResponse:
        """
        @summary Queries all configurations of real-time log delivery.
        
        @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListLiveRealtimeLogDeliveryInfosRequest
        @return: ListLiveRealtimeLogDeliveryInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_realtime_log_delivery_infos_with_options_async(request, runtime)

    def list_message_with_options(
        self,
        request: live_20161101_models.ListMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageResponse:
        """
        @summary Queries messages.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_message_with_options_async(
        self,
        request: live_20161101_models.ListMessageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageResponse:
        """
        @summary Queries messages.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessage',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_message(
        self,
        request: live_20161101_models.ListMessageRequest,
    ) -> live_20161101_models.ListMessageResponse:
        """
        @summary Queries messages.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageRequest
        @return: ListMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_message_with_options(request, runtime)

    async def list_message_async(
        self,
        request: live_20161101_models.ListMessageRequest,
    ) -> live_20161101_models.ListMessageResponse:
        """
        @summary Queries messages.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageRequest
        @return: ListMessageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_message_with_options_async(request, runtime)

    def list_message_app_with_options(
        self,
        request: live_20161101_models.ListMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageAppResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_message_app_with_options_async(
        self,
        request: live_20161101_models.ListMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageAppResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_message_app(
        self,
        request: live_20161101_models.ListMessageAppRequest,
    ) -> live_20161101_models.ListMessageAppResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageAppRequest
        @return: ListMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_message_app_with_options(request, runtime)

    async def list_message_app_async(
        self,
        request: live_20161101_models.ListMessageAppRequest,
    ) -> live_20161101_models.ListMessageAppResponse:
        """
        @summary Queries interactive messaging applications.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageAppRequest
        @return: ListMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_message_app_with_options_async(request, runtime)

    def list_message_group_with_options(
        self,
        request: live_20161101_models.ListMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupResponse:
        """
        @summary Queries the message groups of a specified user.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_message_group_with_options_async(
        self,
        request: live_20161101_models.ListMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupResponse:
        """
        @summary Queries the message groups of a specified user.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_message_group(
        self,
        request: live_20161101_models.ListMessageGroupRequest,
    ) -> live_20161101_models.ListMessageGroupResponse:
        """
        @summary Queries the message groups of a specified user.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupRequest
        @return: ListMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_message_group_with_options(request, runtime)

    async def list_message_group_async(
        self,
        request: live_20161101_models.ListMessageGroupRequest,
    ) -> live_20161101_models.ListMessageGroupResponse:
        """
        @summary Queries the message groups of a specified user.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupRequest
        @return: ListMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_message_group_with_options_async(request, runtime)

    def list_message_group_user_with_options(
        self,
        request: live_20161101_models.ListMessageGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupUserResponse:
        """
        @summary Queries the members of a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_message_group_user_with_options_async(
        self,
        request: live_20161101_models.ListMessageGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupUserResponse:
        """
        @summary Queries the members of a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_message_group_user(
        self,
        request: live_20161101_models.ListMessageGroupUserRequest,
    ) -> live_20161101_models.ListMessageGroupUserResponse:
        """
        @summary Queries the members of a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserRequest
        @return: ListMessageGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_message_group_user_with_options(request, runtime)

    async def list_message_group_user_async(
        self,
        request: live_20161101_models.ListMessageGroupUserRequest,
    ) -> live_20161101_models.ListMessageGroupUserResponse:
        """
        @summary Queries the members of a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserRequest
        @return: ListMessageGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_message_group_user_with_options_async(request, runtime)

    def list_message_group_user_by_id_with_options(
        self,
        tmp_req: live_20161101_models.ListMessageGroupUserByIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupUserByIdResponse:
        """
        @summary Queries user information by user ID.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: ListMessageGroupUserByIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupUserByIdResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ListMessageGroupUserByIdShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_id_list):
            request.user_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_id_list, 'UserIdList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id_list_shrink):
            body['UserIdList'] = request.user_id_list_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroupUserById',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupUserByIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_message_group_user_by_id_with_options_async(
        self,
        tmp_req: live_20161101_models.ListMessageGroupUserByIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMessageGroupUserByIdResponse:
        """
        @summary Queries user information by user ID.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: ListMessageGroupUserByIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMessageGroupUserByIdResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ListMessageGroupUserByIdShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.user_id_list):
            request.user_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.user_id_list, 'UserIdList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.user_id_list_shrink):
            body['UserIdList'] = request.user_id_list_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMessageGroupUserById',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMessageGroupUserByIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_message_group_user_by_id(
        self,
        request: live_20161101_models.ListMessageGroupUserByIdRequest,
    ) -> live_20161101_models.ListMessageGroupUserByIdResponse:
        """
        @summary Queries user information by user ID.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserByIdRequest
        @return: ListMessageGroupUserByIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_message_group_user_by_id_with_options(request, runtime)

    async def list_message_group_user_by_id_async(
        self,
        request: live_20161101_models.ListMessageGroupUserByIdRequest,
    ) -> live_20161101_models.ListMessageGroupUserByIdResponse:
        """
        @summary Queries user information by user ID.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMessageGroupUserByIdRequest
        @return: ListMessageGroupUserByIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_message_group_user_by_id_with_options_async(request, runtime)

    def list_mute_group_user_with_options(
        self,
        request: live_20161101_models.ListMuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMuteGroupUserResponse:
        """
        @summary Queries muted members in a messaging group.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMuteGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMuteGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_mute_group_user_with_options_async(
        self,
        request: live_20161101_models.ListMuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListMuteGroupUserResponse:
        """
        @summary Queries muted members in a messaging group.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMuteGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListMuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListMuteGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_mute_group_user(
        self,
        request: live_20161101_models.ListMuteGroupUserRequest,
    ) -> live_20161101_models.ListMuteGroupUserResponse:
        """
        @summary Queries muted members in a messaging group.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMuteGroupUserRequest
        @return: ListMuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_mute_group_user_with_options(request, runtime)

    async def list_mute_group_user_async(
        self,
        request: live_20161101_models.ListMuteGroupUserRequest,
    ) -> live_20161101_models.ListMuteGroupUserResponse:
        """
        @summary Queries muted members in a messaging group.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ListMuteGroupUserRequest
        @return: ListMuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_mute_group_user_with_options_async(request, runtime)

    def list_playlist_with_options(
        self,
        request: live_20161101_models.ListPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListPlaylistResponse:
        """
        @summary Queries the information about one or more episode lists.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page):
            query['Page'] = request.page
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListPlaylistResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_playlist_with_options_async(
        self,
        request: live_20161101_models.ListPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListPlaylistResponse:
        """
        @summary Queries the information about one or more episode lists.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page):
            query['Page'] = request.page
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListPlaylistResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_playlist(
        self,
        request: live_20161101_models.ListPlaylistRequest,
    ) -> live_20161101_models.ListPlaylistResponse:
        """
        @summary Queries the information about one or more episode lists.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistRequest
        @return: ListPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_playlist_with_options(request, runtime)

    async def list_playlist_async(
        self,
        request: live_20161101_models.ListPlaylistRequest,
    ) -> live_20161101_models.ListPlaylistResponse:
        """
        @summary Queries the information about one or more episode lists.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistRequest
        @return: ListPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_playlist_with_options_async(request, runtime)

    def list_playlist_items_with_options(
        self,
        request: live_20161101_models.ListPlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListPlaylistItemsResponse:
        """
        @summary Queries the information about episodes in an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_item_ids):
            query['ProgramItemIds'] = request.program_item_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListPlaylistItemsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_playlist_items_with_options_async(
        self,
        request: live_20161101_models.ListPlaylistItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListPlaylistItemsResponse:
        """
        @summary Queries the information about episodes in an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPlaylistItemsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.program_item_ids):
            query['ProgramItemIds'] = request.program_item_ids
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPlaylistItems',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListPlaylistItemsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_playlist_items(
        self,
        request: live_20161101_models.ListPlaylistItemsRequest,
    ) -> live_20161101_models.ListPlaylistItemsResponse:
        """
        @summary Queries the information about episodes in an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistItemsRequest
        @return: ListPlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_playlist_items_with_options(request, runtime)

    async def list_playlist_items_async(
        self,
        request: live_20161101_models.ListPlaylistItemsRequest,
    ) -> live_20161101_models.ListPlaylistItemsResponse:
        """
        @summary Queries the information about episodes in an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListPlaylistItemsRequest
        @return: ListPlaylistItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_playlist_items_with_options_async(request, runtime)

    def list_rtclive_rooms_with_options(
        self,
        request: live_20161101_models.ListRTCLiveRoomsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRTCLiveRoomsResponse:
        """
        @summary 
        
        @param request: ListRTCLiveRoomsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRTCLiveRoomsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRTCLiveRooms',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRTCLiveRoomsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_rtclive_rooms_with_options_async(
        self,
        request: live_20161101_models.ListRTCLiveRoomsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRTCLiveRoomsResponse:
        """
        @summary 
        
        @param request: ListRTCLiveRoomsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRTCLiveRoomsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRTCLiveRooms',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRTCLiveRoomsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_rtclive_rooms(
        self,
        request: live_20161101_models.ListRTCLiveRoomsRequest,
    ) -> live_20161101_models.ListRTCLiveRoomsResponse:
        """
        @summary 
        
        @param request: ListRTCLiveRoomsRequest
        @return: ListRTCLiveRoomsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_rtclive_rooms_with_options(request, runtime)

    async def list_rtclive_rooms_async(
        self,
        request: live_20161101_models.ListRTCLiveRoomsRequest,
    ) -> live_20161101_models.ListRTCLiveRoomsResponse:
        """
        @summary 
        
        @param request: ListRTCLiveRoomsRequest
        @return: ListRTCLiveRoomsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_rtclive_rooms_with_options_async(request, runtime)

    def list_rtc_mpuevent_sub_record_with_options(
        self,
        request: live_20161101_models.ListRtcMPUEventSubRecordRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRtcMPUEventSubRecordResponse:
        """
        @summary Queries the callback records of a subscription to mixed-stream relay events.
        
        @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUEventSubRecordRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRtcMPUEventSubRecordResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.sub_id):
            query['SubId'] = request.sub_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRtcMPUEventSubRecord',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRtcMPUEventSubRecordResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_rtc_mpuevent_sub_record_with_options_async(
        self,
        request: live_20161101_models.ListRtcMPUEventSubRecordRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRtcMPUEventSubRecordResponse:
        """
        @summary Queries the callback records of a subscription to mixed-stream relay events.
        
        @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUEventSubRecordRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRtcMPUEventSubRecordResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.sub_id):
            query['SubId'] = request.sub_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRtcMPUEventSubRecord',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRtcMPUEventSubRecordResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_rtc_mpuevent_sub_record(
        self,
        request: live_20161101_models.ListRtcMPUEventSubRecordRequest,
    ) -> live_20161101_models.ListRtcMPUEventSubRecordResponse:
        """
        @summary Queries the callback records of a subscription to mixed-stream relay events.
        
        @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUEventSubRecordRequest
        @return: ListRtcMPUEventSubRecordResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_rtc_mpuevent_sub_record_with_options(request, runtime)

    async def list_rtc_mpuevent_sub_record_async(
        self,
        request: live_20161101_models.ListRtcMPUEventSubRecordRequest,
    ) -> live_20161101_models.ListRtcMPUEventSubRecordResponse:
        """
        @summary Queries the callback records of a subscription to mixed-stream relay events.
        
        @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUEventSubRecordRequest
        @return: ListRtcMPUEventSubRecordResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_rtc_mpuevent_sub_record_with_options_async(request, runtime)

    def list_rtc_mputask_detail_with_options(
        self,
        request: live_20161101_models.ListRtcMPUTaskDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRtcMPUTaskDetailResponse:
        """
        @summary Queries the parameters of mixed-stream relay tasks.
        
        @description    You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
        By default, the query results are sorted in reverse chronological order based on the task update time.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUTaskDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRtcMPUTaskDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRtcMPUTaskDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRtcMPUTaskDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_rtc_mputask_detail_with_options_async(
        self,
        request: live_20161101_models.ListRtcMPUTaskDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ListRtcMPUTaskDetailResponse:
        """
        @summary Queries the parameters of mixed-stream relay tasks.
        
        @description    You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
        By default, the query results are sorted in reverse chronological order based on the task update time.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUTaskDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListRtcMPUTaskDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListRtcMPUTaskDetail',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ListRtcMPUTaskDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_rtc_mputask_detail(
        self,
        request: live_20161101_models.ListRtcMPUTaskDetailRequest,
    ) -> live_20161101_models.ListRtcMPUTaskDetailResponse:
        """
        @summary Queries the parameters of mixed-stream relay tasks.
        
        @description    You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
        By default, the query results are sorted in reverse chronological order based on the task update time.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUTaskDetailRequest
        @return: ListRtcMPUTaskDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_rtc_mputask_detail_with_options(request, runtime)

    async def list_rtc_mputask_detail_async(
        self,
        request: live_20161101_models.ListRtcMPUTaskDetailRequest,
    ) -> live_20161101_models.ListRtcMPUTaskDetailResponse:
        """
        @summary Queries the parameters of mixed-stream relay tasks.
        
        @description    You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
        By default, the query results are sorted in reverse chronological order based on the task update time.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ListRtcMPUTaskDetailRequest
        @return: ListRtcMPUTaskDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_rtc_mputask_detail_with_options_async(request, runtime)

    def live_upstream_qos_data_with_options(
        self,
        tmp_req: live_20161101_models.LiveUpstreamQosDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.LiveUpstreamQosDataResponse:
        """
        @summary 
        
        @param tmp_req: LiveUpstreamQosDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LiveUpstreamQosDataResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.LiveUpstreamQosDataShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cdn_domains):
            request.cdn_domains_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_domains, 'CdnDomains', 'json')
        if not UtilClient.is_unset(tmp_req.cdn_isps):
            request.cdn_isps_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_isps, 'CdnIsps', 'json')
        if not UtilClient.is_unset(tmp_req.cdn_provinces):
            request.cdn_provinces_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_provinces, 'CdnProvinces', 'json')
        if not UtilClient.is_unset(tmp_req.kwai_sidcs):
            request.kwai_sidcs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.kwai_sidcs, 'KwaiSidcs', 'json')
        if not UtilClient.is_unset(tmp_req.kwai_tsc):
            request.kwai_tsc_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.kwai_tsc, 'KwaiTsc', 'json')
        if not UtilClient.is_unset(tmp_req.upstream_domains):
            request.upstream_domains_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.upstream_domains, 'UpstreamDomains', 'json')
        query = {}
        if not UtilClient.is_unset(request.cdn_domains_shrink):
            query['CdnDomains'] = request.cdn_domains_shrink
        if not UtilClient.is_unset(request.cdn_isps_shrink):
            query['CdnIsps'] = request.cdn_isps_shrink
        if not UtilClient.is_unset(request.cdn_provinces_shrink):
            query['CdnProvinces'] = request.cdn_provinces_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.kwai_sidcs_shrink):
            query['KwaiSidcs'] = request.kwai_sidcs_shrink
        if not UtilClient.is_unset(request.kwai_tsc_shrink):
            query['KwaiTsc'] = request.kwai_tsc_shrink
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.upstream_domains_shrink):
            query['UpstreamDomains'] = request.upstream_domains_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='LiveUpstreamQosData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.LiveUpstreamQosDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def live_upstream_qos_data_with_options_async(
        self,
        tmp_req: live_20161101_models.LiveUpstreamQosDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.LiveUpstreamQosDataResponse:
        """
        @summary 
        
        @param tmp_req: LiveUpstreamQosDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: LiveUpstreamQosDataResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.LiveUpstreamQosDataShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cdn_domains):
            request.cdn_domains_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_domains, 'CdnDomains', 'json')
        if not UtilClient.is_unset(tmp_req.cdn_isps):
            request.cdn_isps_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_isps, 'CdnIsps', 'json')
        if not UtilClient.is_unset(tmp_req.cdn_provinces):
            request.cdn_provinces_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cdn_provinces, 'CdnProvinces', 'json')
        if not UtilClient.is_unset(tmp_req.kwai_sidcs):
            request.kwai_sidcs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.kwai_sidcs, 'KwaiSidcs', 'json')
        if not UtilClient.is_unset(tmp_req.kwai_tsc):
            request.kwai_tsc_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.kwai_tsc, 'KwaiTsc', 'json')
        if not UtilClient.is_unset(tmp_req.upstream_domains):
            request.upstream_domains_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.upstream_domains, 'UpstreamDomains', 'json')
        query = {}
        if not UtilClient.is_unset(request.cdn_domains_shrink):
            query['CdnDomains'] = request.cdn_domains_shrink
        if not UtilClient.is_unset(request.cdn_isps_shrink):
            query['CdnIsps'] = request.cdn_isps_shrink
        if not UtilClient.is_unset(request.cdn_provinces_shrink):
            query['CdnProvinces'] = request.cdn_provinces_shrink
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.kwai_sidcs_shrink):
            query['KwaiSidcs'] = request.kwai_sidcs_shrink
        if not UtilClient.is_unset(request.kwai_tsc_shrink):
            query['KwaiTsc'] = request.kwai_tsc_shrink
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.upstream_domains_shrink):
            query['UpstreamDomains'] = request.upstream_domains_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='LiveUpstreamQosData',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.LiveUpstreamQosDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def live_upstream_qos_data(
        self,
        request: live_20161101_models.LiveUpstreamQosDataRequest,
    ) -> live_20161101_models.LiveUpstreamQosDataResponse:
        """
        @summary 
        
        @param request: LiveUpstreamQosDataRequest
        @return: LiveUpstreamQosDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.live_upstream_qos_data_with_options(request, runtime)

    async def live_upstream_qos_data_async(
        self,
        request: live_20161101_models.LiveUpstreamQosDataRequest,
    ) -> live_20161101_models.LiveUpstreamQosDataResponse:
        """
        @summary 
        
        @param request: LiveUpstreamQosDataRequest
        @return: LiveUpstreamQosDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.live_upstream_qos_data_with_options_async(request, runtime)

    def migu_live_pull_to_push_start_with_options(
        self,
        request: live_20161101_models.MiguLivePullToPushStartRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MiguLivePullToPushStartResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStartRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MiguLivePullToPushStartResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.migu_data):
            query['MiguData'] = request.migu_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MiguLivePullToPushStart',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MiguLivePullToPushStartResponse(),
            self.call_api(params, req, runtime)
        )

    async def migu_live_pull_to_push_start_with_options_async(
        self,
        request: live_20161101_models.MiguLivePullToPushStartRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MiguLivePullToPushStartResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStartRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MiguLivePullToPushStartResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.migu_data):
            query['MiguData'] = request.migu_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MiguLivePullToPushStart',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MiguLivePullToPushStartResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def migu_live_pull_to_push_start(
        self,
        request: live_20161101_models.MiguLivePullToPushStartRequest,
    ) -> live_20161101_models.MiguLivePullToPushStartResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStartRequest
        @return: MiguLivePullToPushStartResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.migu_live_pull_to_push_start_with_options(request, runtime)

    async def migu_live_pull_to_push_start_async(
        self,
        request: live_20161101_models.MiguLivePullToPushStartRequest,
    ) -> live_20161101_models.MiguLivePullToPushStartResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStartRequest
        @return: MiguLivePullToPushStartResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.migu_live_pull_to_push_start_with_options_async(request, runtime)

    def migu_live_pull_to_push_status_with_options(
        self,
        request: live_20161101_models.MiguLivePullToPushStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MiguLivePullToPushStatusResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MiguLivePullToPushStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.migu_data):
            query['MiguData'] = request.migu_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MiguLivePullToPushStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MiguLivePullToPushStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def migu_live_pull_to_push_status_with_options_async(
        self,
        request: live_20161101_models.MiguLivePullToPushStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MiguLivePullToPushStatusResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MiguLivePullToPushStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.migu_data):
            query['MiguData'] = request.migu_data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MiguLivePullToPushStatus',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MiguLivePullToPushStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def migu_live_pull_to_push_status(
        self,
        request: live_20161101_models.MiguLivePullToPushStatusRequest,
    ) -> live_20161101_models.MiguLivePullToPushStatusResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStatusRequest
        @return: MiguLivePullToPushStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.migu_live_pull_to_push_status_with_options(request, runtime)

    async def migu_live_pull_to_push_status_async(
        self,
        request: live_20161101_models.MiguLivePullToPushStatusRequest,
    ) -> live_20161101_models.MiguLivePullToPushStatusResponse:
        """
        @summary 
        
        @param request: MiguLivePullToPushStatusRequest
        @return: MiguLivePullToPushStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.migu_live_pull_to_push_status_with_options_async(request, runtime)

    def modify_caster_component_with_options(
        self,
        request: live_20161101_models.ModifyCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterComponentResponse:
        """
        @summary Modifies a component of a production studio.
        
        @description You can call this operation to modify a text, image, or subtitle component.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caption_layer_content):
            query['CaptionLayerContent'] = request.caption_layer_content
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.component_layer):
            query['ComponentLayer'] = request.component_layer
        if not UtilClient.is_unset(request.component_name):
            query['ComponentName'] = request.component_name
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.effect):
            query['Effect'] = request.effect
        if not UtilClient.is_unset(request.image_layer_content):
            query['ImageLayerContent'] = request.image_layer_content
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.text_layer_content):
            query['TextLayerContent'] = request.text_layer_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterComponentResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_caster_component_with_options_async(
        self,
        request: live_20161101_models.ModifyCasterComponentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterComponentResponse:
        """
        @summary Modifies a component of a production studio.
        
        @description You can call this operation to modify a text, image, or subtitle component.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterComponentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterComponentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caption_layer_content):
            query['CaptionLayerContent'] = request.caption_layer_content
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.component_layer):
            query['ComponentLayer'] = request.component_layer
        if not UtilClient.is_unset(request.component_name):
            query['ComponentName'] = request.component_name
        if not UtilClient.is_unset(request.component_type):
            query['ComponentType'] = request.component_type
        if not UtilClient.is_unset(request.effect):
            query['Effect'] = request.effect
        if not UtilClient.is_unset(request.image_layer_content):
            query['ImageLayerContent'] = request.image_layer_content
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.text_layer_content):
            query['TextLayerContent'] = request.text_layer_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterComponent',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterComponentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_caster_component(
        self,
        request: live_20161101_models.ModifyCasterComponentRequest,
    ) -> live_20161101_models.ModifyCasterComponentResponse:
        """
        @summary Modifies a component of a production studio.
        
        @description You can call this operation to modify a text, image, or subtitle component.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterComponentRequest
        @return: ModifyCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_caster_component_with_options(request, runtime)

    async def modify_caster_component_async(
        self,
        request: live_20161101_models.ModifyCasterComponentRequest,
    ) -> live_20161101_models.ModifyCasterComponentResponse:
        """
        @summary Modifies a component of a production studio.
        
        @description You can call this operation to modify a text, image, or subtitle component.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterComponentRequest
        @return: ModifyCasterComponentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_caster_component_with_options_async(request, runtime)

    def modify_caster_episode_with_options(
        self,
        request: live_20161101_models.ModifyCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterEpisodeResponse:
        """
        @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
        
        @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.episode_name):
            query['EpisodeName'] = request.episode_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.switch_type):
            query['SwitchType'] = request.switch_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterEpisodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_caster_episode_with_options_async(
        self,
        request: live_20161101_models.ModifyCasterEpisodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterEpisodeResponse:
        """
        @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
        
        @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterEpisodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterEpisodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.episode_id):
            query['EpisodeId'] = request.episode_id
        if not UtilClient.is_unset(request.episode_name):
            query['EpisodeName'] = request.episode_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.switch_type):
            query['SwitchType'] = request.switch_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterEpisode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterEpisodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_caster_episode(
        self,
        request: live_20161101_models.ModifyCasterEpisodeRequest,
    ) -> live_20161101_models.ModifyCasterEpisodeResponse:
        """
        @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
        
        @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterEpisodeRequest
        @return: ModifyCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_caster_episode_with_options(request, runtime)

    async def modify_caster_episode_async(
        self,
        request: live_20161101_models.ModifyCasterEpisodeRequest,
    ) -> live_20161101_models.ModifyCasterEpisodeResponse:
        """
        @summary Modifies the configurations of an episode in a production studio. You cannot change the episode type.
        
        @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterEpisodeRequest
        @return: ModifyCasterEpisodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_caster_episode_with_options_async(request, runtime)

    def modify_caster_layout_with_options(
        self,
        request: live_20161101_models.ModifyCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterLayoutResponse:
        """
        @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.blend_list):
            query['BlendList'] = request.blend_list
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.video_layer):
            query['VideoLayer'] = request.video_layer
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_caster_layout_with_options_async(
        self,
        request: live_20161101_models.ModifyCasterLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterLayoutResponse:
        """
        @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.blend_list):
            query['BlendList'] = request.blend_list
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.video_layer):
            query['VideoLayer'] = request.video_layer
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_caster_layout(
        self,
        request: live_20161101_models.ModifyCasterLayoutRequest,
    ) -> live_20161101_models.ModifyCasterLayoutResponse:
        """
        @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterLayoutRequest
        @return: ModifyCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_caster_layout_with_options(request, runtime)

    async def modify_caster_layout_async(
        self,
        request: live_20161101_models.ModifyCasterLayoutRequest,
    ) -> live_20161101_models.ModifyCasterLayoutResponse:
        """
        @summary Modifies the layout configurations pf a production studio. You need to pass only parameters that you want to modify.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterLayoutRequest
        @return: ModifyCasterLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_caster_layout_with_options_async(request, runtime)

    def modify_caster_program_with_options(
        self,
        request: live_20161101_models.ModifyCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterProgramResponse:
        """
        @summary Modifies the episode list for carousel playback in a production studio.
        
        @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode):
            query['Episode'] = request.episode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterProgramResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_caster_program_with_options_async(
        self,
        request: live_20161101_models.ModifyCasterProgramRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterProgramResponse:
        """
        @summary Modifies the episode list for carousel playback in a production studio.
        
        @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterProgramRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterProgramResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.episode):
            query['Episode'] = request.episode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterProgram',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterProgramResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_caster_program(
        self,
        request: live_20161101_models.ModifyCasterProgramRequest,
    ) -> live_20161101_models.ModifyCasterProgramResponse:
        """
        @summary Modifies the episode list for carousel playback in a production studio.
        
        @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterProgramRequest
        @return: ModifyCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_caster_program_with_options(request, runtime)

    async def modify_caster_program_async(
        self,
        request: live_20161101_models.ModifyCasterProgramRequest,
    ) -> live_20161101_models.ModifyCasterProgramResponse:
        """
        @summary Modifies the episode list for carousel playback in a production studio.
        
        @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
        ## [](#qps-)QPS limit
        You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyCasterProgramRequest
        @return: ModifyCasterProgramResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_caster_program_with_options_async(request, runtime)

    def modify_caster_video_resource_with_options(
        self,
        request: live_20161101_models.ModifyCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterVideoResourceResponse:
        """
        @summary Changes the video source for a production studio.
        
        @description ## Usage notes
        You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ModifyCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_offset):
            query['BeginOffset'] = request.begin_offset
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_offset):
            query['EndOffset'] = request.end_offset
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_url):
            query['ImageUrl'] = request.image_url
        if not UtilClient.is_unset(request.live_stream_url):
            query['LiveStreamUrl'] = request.live_stream_url
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pts_callback_interval):
            query['PtsCallbackInterval'] = request.pts_callback_interval
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_name):
            query['ResourceName'] = request.resource_name
        if not UtilClient.is_unset(request.vod_url):
            query['VodUrl'] = request.vod_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterVideoResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_caster_video_resource_with_options_async(
        self,
        request: live_20161101_models.ModifyCasterVideoResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyCasterVideoResourceResponse:
        """
        @summary Changes the video source for a production studio.
        
        @description ## Usage notes
        You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ModifyCasterVideoResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyCasterVideoResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_offset):
            query['BeginOffset'] = request.begin_offset
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.end_offset):
            query['EndOffset'] = request.end_offset
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.image_url):
            query['ImageUrl'] = request.image_url
        if not UtilClient.is_unset(request.live_stream_url):
            query['LiveStreamUrl'] = request.live_stream_url
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pts_callback_interval):
            query['PtsCallbackInterval'] = request.pts_callback_interval
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_num):
            query['RepeatNum'] = request.repeat_num
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_name):
            query['ResourceName'] = request.resource_name
        if not UtilClient.is_unset(request.vod_url):
            query['VodUrl'] = request.vod_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyCasterVideoResource',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyCasterVideoResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_caster_video_resource(
        self,
        request: live_20161101_models.ModifyCasterVideoResourceRequest,
    ) -> live_20161101_models.ModifyCasterVideoResourceResponse:
        """
        @summary Changes the video source for a production studio.
        
        @description ## Usage notes
        You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ModifyCasterVideoResourceRequest
        @return: ModifyCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_caster_video_resource_with_options(request, runtime)

    async def modify_caster_video_resource_async(
        self,
        request: live_20161101_models.ModifyCasterVideoResourceRequest,
    ) -> live_20161101_models.ModifyCasterVideoResourceResponse:
        """
        @summary Changes the video source for a production studio.
        
        @description ## Usage notes
        You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
        ## QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: ModifyCasterVideoResourceRequest
        @return: ModifyCasterVideoResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_caster_video_resource_with_options_async(request, runtime)

    def modify_live_aistudio_with_options(
        self,
        tmp_req: live_20161101_models.ModifyLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveAIStudioResponse:
        """
        @summary Modifies a virtual studio template.
        
        @param tmp_req: ModifyLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveAIStudioResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveAIStudioShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.matting_layout):
            request.matting_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.matting_layout, 'MattingLayout', 'json')
        if not UtilClient.is_unset(tmp_req.media_layout):
            request.media_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.media_layout, 'MediaLayout', 'json')
        query = {}
        if not UtilClient.is_unset(request.background_resource_id):
            query['BackgroundResourceId'] = request.background_resource_id
        if not UtilClient.is_unset(request.background_resource_url):
            query['BackgroundResourceUrl'] = request.background_resource_url
        if not UtilClient.is_unset(request.background_type):
            query['BackgroundType'] = request.background_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.matting_layout_shrink):
            query['MattingLayout'] = request.matting_layout_shrink
        if not UtilClient.is_unset(request.matting_type):
            query['MattingType'] = request.matting_type
        if not UtilClient.is_unset(request.media_layout_shrink):
            query['MediaLayout'] = request.media_layout_shrink
        if not UtilClient.is_unset(request.media_resource_id):
            query['MediaResourceId'] = request.media_resource_id
        if not UtilClient.is_unset(request.media_resource_url):
            query['MediaResourceUrl'] = request.media_resource_url
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveAIStudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_aistudio_with_options_async(
        self,
        tmp_req: live_20161101_models.ModifyLiveAIStudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveAIStudioResponse:
        """
        @summary Modifies a virtual studio template.
        
        @param tmp_req: ModifyLiveAIStudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveAIStudioResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveAIStudioShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.matting_layout):
            request.matting_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.matting_layout, 'MattingLayout', 'json')
        if not UtilClient.is_unset(tmp_req.media_layout):
            request.media_layout_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.media_layout, 'MediaLayout', 'json')
        query = {}
        if not UtilClient.is_unset(request.background_resource_id):
            query['BackgroundResourceId'] = request.background_resource_id
        if not UtilClient.is_unset(request.background_resource_url):
            query['BackgroundResourceUrl'] = request.background_resource_url
        if not UtilClient.is_unset(request.background_type):
            query['BackgroundType'] = request.background_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.matting_layout_shrink):
            query['MattingLayout'] = request.matting_layout_shrink
        if not UtilClient.is_unset(request.matting_type):
            query['MattingType'] = request.matting_type
        if not UtilClient.is_unset(request.media_layout_shrink):
            query['MediaLayout'] = request.media_layout_shrink
        if not UtilClient.is_unset(request.media_resource_id):
            query['MediaResourceId'] = request.media_resource_id
        if not UtilClient.is_unset(request.media_resource_url):
            query['MediaResourceUrl'] = request.media_resource_url
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveAIStudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveAIStudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_aistudio(
        self,
        request: live_20161101_models.ModifyLiveAIStudioRequest,
    ) -> live_20161101_models.ModifyLiveAIStudioResponse:
        """
        @summary Modifies a virtual studio template.
        
        @param request: ModifyLiveAIStudioRequest
        @return: ModifyLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_aistudio_with_options(request, runtime)

    async def modify_live_aistudio_async(
        self,
        request: live_20161101_models.ModifyLiveAIStudioRequest,
    ) -> live_20161101_models.ModifyLiveAIStudioResponse:
        """
        @summary Modifies a virtual studio template.
        
        @param request: ModifyLiveAIStudioRequest
        @return: ModifyLiveAIStudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_aistudio_with_options_async(request, runtime)

    def modify_live_domain_schdm_by_property_with_options(
        self,
        request: live_20161101_models.ModifyLiveDomainSchdmByPropertyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse:
        """
        @summary Modifies the acceleration region of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveDomainSchdmByPropertyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveDomainSchdmByPropertyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.property):
            query['Property'] = request.property
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveDomainSchdmByProperty',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_domain_schdm_by_property_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveDomainSchdmByPropertyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse:
        """
        @summary Modifies the acceleration region of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveDomainSchdmByPropertyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveDomainSchdmByPropertyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.property):
            query['Property'] = request.property
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveDomainSchdmByProperty',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_domain_schdm_by_property(
        self,
        request: live_20161101_models.ModifyLiveDomainSchdmByPropertyRequest,
    ) -> live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse:
        """
        @summary Modifies the acceleration region of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveDomainSchdmByPropertyRequest
        @return: ModifyLiveDomainSchdmByPropertyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_domain_schdm_by_property_with_options(request, runtime)

    async def modify_live_domain_schdm_by_property_async(
        self,
        request: live_20161101_models.ModifyLiveDomainSchdmByPropertyRequest,
    ) -> live_20161101_models.ModifyLiveDomainSchdmByPropertyResponse:
        """
        @summary Modifies the acceleration region of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveDomainSchdmByPropertyRequest
        @return: ModifyLiveDomainSchdmByPropertyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_domain_schdm_by_property_with_options_async(request, runtime)

    def modify_live_message_app_audit_with_options(
        self,
        request: live_20161101_models.ModifyLiveMessageAppAuditRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppAuditResponse:
        """
        @summary Modifies the content moderation settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppAuditRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppAuditResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.audit_type):
            query['AuditType'] = request.audit_type
        if not UtilClient.is_unset(request.audit_url):
            query['AuditUrl'] = request.audit_url
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppAudit',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppAuditResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_app_audit_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppAuditRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppAuditResponse:
        """
        @summary Modifies the content moderation settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppAuditRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppAuditResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.audit_type):
            query['AuditType'] = request.audit_type
        if not UtilClient.is_unset(request.audit_url):
            query['AuditUrl'] = request.audit_url
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppAudit',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppAuditResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_app_audit(
        self,
        request: live_20161101_models.ModifyLiveMessageAppAuditRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppAuditResponse:
        """
        @summary Modifies the content moderation settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppAuditRequest
        @return: ModifyLiveMessageAppAuditResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_app_audit_with_options(request, runtime)

    async def modify_live_message_app_audit_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppAuditRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppAuditResponse:
        """
        @summary Modifies the content moderation settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppAuditRequest
        @return: ModifyLiveMessageAppAuditResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_app_audit_with_options_async(request, runtime)

    def modify_live_message_app_callback_with_options(
        self,
        request: live_20161101_models.ModifyLiveMessageAppCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppCallbackResponse:
        """
        @summary Modifies the callback settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.event_callback_url):
            query['EventCallbackUrl'] = request.event_callback_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppCallback',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppCallbackResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_app_callback_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppCallbackResponse:
        """
        @summary Modifies the callback settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.event_callback_url):
            query['EventCallbackUrl'] = request.event_callback_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppCallback',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppCallbackResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_app_callback(
        self,
        request: live_20161101_models.ModifyLiveMessageAppCallbackRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppCallbackResponse:
        """
        @summary Modifies the callback settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppCallbackRequest
        @return: ModifyLiveMessageAppCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_app_callback_with_options(request, runtime)

    async def modify_live_message_app_callback_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppCallbackRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppCallbackResponse:
        """
        @summary Modifies the callback settings of an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppCallbackRequest
        @return: ModifyLiveMessageAppCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_app_callback_with_options_async(request, runtime)

    def modify_live_message_app_disable_with_options(
        self,
        request: live_20161101_models.ModifyLiveMessageAppDisableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppDisableResponse:
        """
        @summary Disables or enables an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppDisableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppDisableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.disable):
            query['Disable'] = request.disable
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppDisable',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppDisableResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_app_disable_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppDisableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageAppDisableResponse:
        """
        @summary Disables or enables an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppDisableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageAppDisableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.disable):
            query['Disable'] = request.disable
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageAppDisable',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageAppDisableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_app_disable(
        self,
        request: live_20161101_models.ModifyLiveMessageAppDisableRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppDisableResponse:
        """
        @summary Disables or enables an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppDisableRequest
        @return: ModifyLiveMessageAppDisableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_app_disable_with_options(request, runtime)

    async def modify_live_message_app_disable_async(
        self,
        request: live_20161101_models.ModifyLiveMessageAppDisableRequest,
    ) -> live_20161101_models.ModifyLiveMessageAppDisableResponse:
        """
        @summary Disables or enables an interactive messaging application.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageAppDisableRequest
        @return: ModifyLiveMessageAppDisableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_app_disable_with_options_async(request, runtime)

    def modify_live_message_group_with_options(
        self,
        tmp_req: live_20161101_models.ModifyLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageGroupResponse:
        """
        @summary Modifies the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: ModifyLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.admin_list):
            request.admin_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.admin_list, 'AdminList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.admin_list_shrink):
            query['AdminList'] = request.admin_list_shrink
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_info):
            query['GroupInfo'] = request.group_info
        if not UtilClient.is_unset(request.modify_admin):
            query['ModifyAdmin'] = request.modify_admin
        if not UtilClient.is_unset(request.modify_info):
            query['ModifyInfo'] = request.modify_info
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_group_with_options_async(
        self,
        tmp_req: live_20161101_models.ModifyLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageGroupResponse:
        """
        @summary Modifies the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: ModifyLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.admin_list):
            request.admin_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.admin_list, 'AdminList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.admin_list_shrink):
            query['AdminList'] = request.admin_list_shrink
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_info):
            query['GroupInfo'] = request.group_info
        if not UtilClient.is_unset(request.modify_admin):
            query['ModifyAdmin'] = request.modify_admin
        if not UtilClient.is_unset(request.modify_info):
            query['ModifyInfo'] = request.modify_info
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_group(
        self,
        request: live_20161101_models.ModifyLiveMessageGroupRequest,
    ) -> live_20161101_models.ModifyLiveMessageGroupResponse:
        """
        @summary Modifies the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageGroupRequest
        @return: ModifyLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_group_with_options(request, runtime)

    async def modify_live_message_group_async(
        self,
        request: live_20161101_models.ModifyLiveMessageGroupRequest,
    ) -> live_20161101_models.ModifyLiveMessageGroupResponse:
        """
        @summary Modifies the information about an interactive messaging group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageGroupRequest
        @return: ModifyLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_group_with_options_async(request, runtime)

    def modify_live_message_group_band_with_options(
        self,
        tmp_req: live_20161101_models.ModifyLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageGroupBandResponse:
        """
        @summary Modifies the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: ModifyLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.bannned_users):
            request.bannned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.bannned_users, 'BannnedUsers', 'simple')
        if not UtilClient.is_unset(tmp_req.except_users):
            request.except_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.except_users, 'ExceptUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.banned_all):
            query['BannedAll'] = request.banned_all
        if not UtilClient.is_unset(request.bannned_users_shrink):
            query['BannnedUsers'] = request.bannned_users_shrink
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.except_users_shrink):
            query['ExceptUsers'] = request.except_users_shrink
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageGroupBandResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_group_band_with_options_async(
        self,
        tmp_req: live_20161101_models.ModifyLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageGroupBandResponse:
        """
        @summary Modifies the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: ModifyLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.ModifyLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.bannned_users):
            request.bannned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.bannned_users, 'BannnedUsers', 'simple')
        if not UtilClient.is_unset(tmp_req.except_users):
            request.except_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.except_users, 'ExceptUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.banned_all):
            query['BannedAll'] = request.banned_all
        if not UtilClient.is_unset(request.bannned_users_shrink):
            query['BannnedUsers'] = request.bannned_users_shrink
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.except_users_shrink):
            query['ExceptUsers'] = request.except_users_shrink
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageGroupBandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_group_band(
        self,
        request: live_20161101_models.ModifyLiveMessageGroupBandRequest,
    ) -> live_20161101_models.ModifyLiveMessageGroupBandResponse:
        """
        @summary Modifies the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageGroupBandRequest
        @return: ModifyLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_group_band_with_options(request, runtime)

    async def modify_live_message_group_band_async(
        self,
        request: live_20161101_models.ModifyLiveMessageGroupBandRequest,
    ) -> live_20161101_models.ModifyLiveMessageGroupBandResponse:
        """
        @summary Modifies the mute status of users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveMessageGroupBandRequest
        @return: ModifyLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_group_band_with_options_async(request, runtime)

    def modify_live_message_user_info_with_options(
        self,
        request: live_20161101_models.ModifyLiveMessageUserInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageUserInfoResponse:
        """
        @summary Modifies the information about a user.
        
        @param request: ModifyLiveMessageUserInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageUserInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        if not UtilClient.is_unset(request.user_meta_info):
            query['UserMetaInfo'] = request.user_meta_info
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageUserInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageUserInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_message_user_info_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveMessageUserInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveMessageUserInfoResponse:
        """
        @summary Modifies the information about a user.
        
        @param request: ModifyLiveMessageUserInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveMessageUserInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        if not UtilClient.is_unset(request.user_meta_info):
            query['UserMetaInfo'] = request.user_meta_info
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveMessageUserInfo',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveMessageUserInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_message_user_info(
        self,
        request: live_20161101_models.ModifyLiveMessageUserInfoRequest,
    ) -> live_20161101_models.ModifyLiveMessageUserInfoResponse:
        """
        @summary Modifies the information about a user.
        
        @param request: ModifyLiveMessageUserInfoRequest
        @return: ModifyLiveMessageUserInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_message_user_info_with_options(request, runtime)

    async def modify_live_message_user_info_async(
        self,
        request: live_20161101_models.ModifyLiveMessageUserInfoRequest,
    ) -> live_20161101_models.ModifyLiveMessageUserInfoResponse:
        """
        @summary Modifies the information about a user.
        
        @param request: ModifyLiveMessageUserInfoRequest
        @return: ModifyLiveMessageUserInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_message_user_info_with_options_async(request, runtime)

    def modify_live_realtime_log_delivery_with_options(
        self,
        request: live_20161101_models.ModifyLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse:
        """
        @summary Modifies the configuration of real-time log delivery for a domain name.
        
        @description    You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_live_realtime_log_delivery_with_options_async(
        self,
        request: live_20161101_models.ModifyLiveRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse:
        """
        @summary Modifies the configuration of real-time log delivery for a domain name.
        
        @description    You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLiveRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLiveRealtimeLogDelivery',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_live_realtime_log_delivery(
        self,
        request: live_20161101_models.ModifyLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse:
        """
        @summary Modifies the configuration of real-time log delivery for a domain name.
        
        @description    You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveRealtimeLogDeliveryRequest
        @return: ModifyLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_live_realtime_log_delivery_with_options(request, runtime)

    async def modify_live_realtime_log_delivery_async(
        self,
        request: live_20161101_models.ModifyLiveRealtimeLogDeliveryRequest,
    ) -> live_20161101_models.ModifyLiveRealtimeLogDeliveryResponse:
        """
        @summary Modifies the configuration of real-time log delivery for a domain name.
        
        @description    You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
        This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
        You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyLiveRealtimeLogDeliveryRequest
        @return: ModifyLiveRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_live_realtime_log_delivery_with_options_async(request, runtime)

    def modify_show_list_with_options(
        self,
        request: live_20161101_models.ModifyShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyShowListResponse:
        """
        @summary Modifies the attributes of an episode list.
        
        @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.high_priority_show_id):
            query['HighPriorityShowId'] = request.high_priority_show_id
        if not UtilClient.is_unset(request.high_priority_show_start_time):
            query['HighPriorityShowStartTime'] = request.high_priority_show_start_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_times):
            query['RepeatTimes'] = request.repeat_times
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.spot):
            query['Spot'] = request.spot
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyShowListResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_show_list_with_options_async(
        self,
        request: live_20161101_models.ModifyShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyShowListResponse:
        """
        @summary Modifies the attributes of an episode list.
        
        @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.high_priority_show_id):
            query['HighPriorityShowId'] = request.high_priority_show_id
        if not UtilClient.is_unset(request.high_priority_show_start_time):
            query['HighPriorityShowStartTime'] = request.high_priority_show_start_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.repeat_times):
            query['RepeatTimes'] = request.repeat_times
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.spot):
            query['Spot'] = request.spot
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyShowListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_show_list(
        self,
        request: live_20161101_models.ModifyShowListRequest,
    ) -> live_20161101_models.ModifyShowListResponse:
        """
        @summary Modifies the attributes of an episode list.
        
        @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyShowListRequest
        @return: ModifyShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_show_list_with_options(request, runtime)

    async def modify_show_list_async(
        self,
        request: live_20161101_models.ModifyShowListRequest,
    ) -> live_20161101_models.ModifyShowListResponse:
        """
        @summary Modifies the attributes of an episode list.
        
        @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyShowListRequest
        @return: ModifyShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_show_list_with_options_async(request, runtime)

    def modify_studio_layout_with_options(
        self,
        request: live_20161101_models.ModifyStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyStudioLayoutResponse:
        """
        @summary Modifies a layout of a virtual studio.
        
        @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bg_image_config):
            query['BgImageConfig'] = request.bg_image_config
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.common_config):
            query['CommonConfig'] = request.common_config
        if not UtilClient.is_unset(request.layer_order_config_list):
            query['LayerOrderConfigList'] = request.layer_order_config_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.layout_name):
            query['LayoutName'] = request.layout_name
        if not UtilClient.is_unset(request.media_input_config_list):
            query['MediaInputConfigList'] = request.media_input_config_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.screen_input_config_list):
            query['ScreenInputConfigList'] = request.screen_input_config_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyStudioLayoutResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_studio_layout_with_options_async(
        self,
        request: live_20161101_models.ModifyStudioLayoutRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ModifyStudioLayoutResponse:
        """
        @summary Modifies a layout of a virtual studio.
        
        @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyStudioLayoutRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyStudioLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bg_image_config):
            query['BgImageConfig'] = request.bg_image_config
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.common_config):
            query['CommonConfig'] = request.common_config
        if not UtilClient.is_unset(request.layer_order_config_list):
            query['LayerOrderConfigList'] = request.layer_order_config_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.layout_name):
            query['LayoutName'] = request.layout_name
        if not UtilClient.is_unset(request.media_input_config_list):
            query['MediaInputConfigList'] = request.media_input_config_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.screen_input_config_list):
            query['ScreenInputConfigList'] = request.screen_input_config_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyStudioLayout',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ModifyStudioLayoutResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_studio_layout(
        self,
        request: live_20161101_models.ModifyStudioLayoutRequest,
    ) -> live_20161101_models.ModifyStudioLayoutResponse:
        """
        @summary Modifies a layout of a virtual studio.
        
        @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyStudioLayoutRequest
        @return: ModifyStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_studio_layout_with_options(request, runtime)

    async def modify_studio_layout_async(
        self,
        request: live_20161101_models.ModifyStudioLayoutRequest,
    ) -> live_20161101_models.ModifyStudioLayoutResponse:
        """
        @summary Modifies a layout of a virtual studio.
        
        @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ModifyStudioLayoutRequest
        @return: ModifyStudioLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_studio_layout_with_options_async(request, runtime)

    def mute_all_group_user_with_options(
        self,
        request: live_20161101_models.MuteAllGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MuteAllGroupUserResponse:
        """
        @summary Mutes a message group. In this case, all members of the message group are muted.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteAllGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MuteAllGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='MuteAllGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MuteAllGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def mute_all_group_user_with_options_async(
        self,
        request: live_20161101_models.MuteAllGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MuteAllGroupUserResponse:
        """
        @summary Mutes a message group. In this case, all members of the message group are muted.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteAllGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MuteAllGroupUserResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='MuteAllGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MuteAllGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def mute_all_group_user(
        self,
        request: live_20161101_models.MuteAllGroupUserRequest,
    ) -> live_20161101_models.MuteAllGroupUserResponse:
        """
        @summary Mutes a message group. In this case, all members of the message group are muted.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteAllGroupUserRequest
        @return: MuteAllGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.mute_all_group_user_with_options(request, runtime)

    async def mute_all_group_user_async(
        self,
        request: live_20161101_models.MuteAllGroupUserRequest,
    ) -> live_20161101_models.MuteAllGroupUserResponse:
        """
        @summary Mutes a message group. In this case, all members of the message group are muted.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteAllGroupUserRequest
        @return: MuteAllGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.mute_all_group_user_with_options_async(request, runtime)

    def mute_group_user_with_options(
        self,
        tmp_req: live_20161101_models.MuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MuteGroupUserResponse:
        """
        @summary Mutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: MuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MuteGroupUserResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.MuteGroupUserShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mute_user_list):
            request.mute_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mute_user_list, 'MuteUserList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.mute_time):
            body['MuteTime'] = request.mute_time
        if not UtilClient.is_unset(request.mute_user_list_shrink):
            body['MuteUserList'] = request.mute_user_list_shrink
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='MuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MuteGroupUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def mute_group_user_with_options_async(
        self,
        tmp_req: live_20161101_models.MuteGroupUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.MuteGroupUserResponse:
        """
        @summary Mutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: MuteGroupUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MuteGroupUserResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.MuteGroupUserShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mute_user_list):
            request.mute_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mute_user_list, 'MuteUserList', 'simple')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.mute_time):
            body['MuteTime'] = request.mute_time
        if not UtilClient.is_unset(request.mute_user_list_shrink):
            body['MuteUserList'] = request.mute_user_list_shrink
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='MuteGroupUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.MuteGroupUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def mute_group_user(
        self,
        request: live_20161101_models.MuteGroupUserRequest,
    ) -> live_20161101_models.MuteGroupUserResponse:
        """
        @summary Mutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteGroupUserRequest
        @return: MuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.mute_group_user_with_options(request, runtime)

    async def mute_group_user_async(
        self,
        request: live_20161101_models.MuteGroupUserRequest,
    ) -> live_20161101_models.MuteGroupUserResponse:
        """
        @summary Mutes members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: MuteGroupUserRequest
        @return: MuteGroupUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.mute_group_user_with_options_async(request, runtime)

    def open_live_shift_with_options(
        self,
        request: live_20161101_models.OpenLiveShiftRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.OpenLiveShiftResponse:
        """
        @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description You cannot configure time shifting and delayed transcoding at the same time.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: OpenLiveShiftRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenLiveShiftResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vision):
            query['Vision'] = request.vision
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenLiveShift',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.OpenLiveShiftResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_live_shift_with_options_async(
        self,
        request: live_20161101_models.OpenLiveShiftRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.OpenLiveShiftResponse:
        """
        @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description You cannot configure time shifting and delayed transcoding at the same time.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: OpenLiveShiftRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenLiveShiftResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.duration):
            query['Duration'] = request.duration
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vision):
            query['Vision'] = request.vision
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenLiveShift',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.OpenLiveShiftResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_live_shift(
        self,
        request: live_20161101_models.OpenLiveShiftRequest,
    ) -> live_20161101_models.OpenLiveShiftResponse:
        """
        @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description You cannot configure time shifting and delayed transcoding at the same time.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: OpenLiveShiftRequest
        @return: OpenLiveShiftResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_live_shift_with_options(request, runtime)

    async def open_live_shift_async(
        self,
        request: live_20161101_models.OpenLiveShiftRequest,
    ) -> live_20161101_models.OpenLiveShiftResponse:
        """
        @summary Enables time shifting for a domain name, or an application or a live stream under the domain name.
        
        @description You cannot configure time shifting and delayed transcoding at the same time.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: OpenLiveShiftRequest
        @return: OpenLiveShiftResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_live_shift_with_options_async(request, runtime)

    def play_choosen_show_with_options(
        self,
        request: live_20161101_models.PlayChoosenShowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PlayChoosenShowResponse:
        """
        @summary Switches to a specified episode.
        
        @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: PlayChoosenShowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PlayChoosenShowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PlayChoosenShow',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PlayChoosenShowResponse(),
            self.call_api(params, req, runtime)
        )

    async def play_choosen_show_with_options_async(
        self,
        request: live_20161101_models.PlayChoosenShowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PlayChoosenShowResponse:
        """
        @summary Switches to a specified episode.
        
        @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: PlayChoosenShowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PlayChoosenShowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PlayChoosenShow',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PlayChoosenShowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def play_choosen_show(
        self,
        request: live_20161101_models.PlayChoosenShowRequest,
    ) -> live_20161101_models.PlayChoosenShowResponse:
        """
        @summary Switches to a specified episode.
        
        @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: PlayChoosenShowRequest
        @return: PlayChoosenShowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.play_choosen_show_with_options(request, runtime)

    async def play_choosen_show_async(
        self,
        request: live_20161101_models.PlayChoosenShowRequest,
    ) -> live_20161101_models.PlayChoosenShowResponse:
        """
        @summary Switches to a specified episode.
        
        @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: PlayChoosenShowRequest
        @return: PlayChoosenShowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.play_choosen_show_with_options_async(request, runtime)

    def publish_live_staging_config_to_production_with_options(
        self,
        request: live_20161101_models.PublishLiveStagingConfigToProductionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PublishLiveStagingConfigToProductionResponse:
        """
        @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: PublishLiveStagingConfigToProductionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishLiveStagingConfigToProductionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishLiveStagingConfigToProduction',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PublishLiveStagingConfigToProductionResponse(),
            self.call_api(params, req, runtime)
        )

    async def publish_live_staging_config_to_production_with_options_async(
        self,
        request: live_20161101_models.PublishLiveStagingConfigToProductionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PublishLiveStagingConfigToProductionResponse:
        """
        @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: PublishLiveStagingConfigToProductionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishLiveStagingConfigToProductionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishLiveStagingConfigToProduction',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PublishLiveStagingConfigToProductionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def publish_live_staging_config_to_production(
        self,
        request: live_20161101_models.PublishLiveStagingConfigToProductionRequest,
    ) -> live_20161101_models.PublishLiveStagingConfigToProductionResponse:
        """
        @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: PublishLiveStagingConfigToProductionRequest
        @return: PublishLiveStagingConfigToProductionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.publish_live_staging_config_to_production_with_options(request, runtime)

    async def publish_live_staging_config_to_production_async(
        self,
        request: live_20161101_models.PublishLiveStagingConfigToProductionRequest,
    ) -> live_20161101_models.PublishLiveStagingConfigToProductionResponse:
        """
        @summary Publishes the configurations of an accelerated domain name from the canary release environment to the production environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: PublishLiveStagingConfigToProductionRequest
        @return: PublishLiveStagingConfigToProductionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.publish_live_staging_config_to_production_with_options_async(request, runtime)

    def put_record_storage_life_cycle_with_options(
        self,
        tmp_req: live_20161101_models.PutRecordStorageLifeCycleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PutRecordStorageLifeCycleResponse:
        """
        @summary 
        
        @description ## 
        - 
        - `Tag`  `[0-9]+days`
        - 3
        - 
        - 124
        
        @param tmp_req: PutRecordStorageLifeCycleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutRecordStorageLifeCycleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.PutRecordStorageLifeCycleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.stream_ids):
            request.stream_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.stream_ids, 'StreamIds', 'json')
        body = {}
        if not UtilClient.is_unset(request.stream_ids_shrink):
            body['StreamIds'] = request.stream_ids_shrink
        if not UtilClient.is_unset(request.tag):
            body['Tag'] = request.tag
        if not UtilClient.is_unset(request.unix_timestamp):
            body['UnixTimestamp'] = request.unix_timestamp
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PutRecordStorageLifeCycle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PutRecordStorageLifeCycleResponse(),
            self.call_api(params, req, runtime)
        )

    async def put_record_storage_life_cycle_with_options_async(
        self,
        tmp_req: live_20161101_models.PutRecordStorageLifeCycleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.PutRecordStorageLifeCycleResponse:
        """
        @summary 
        
        @description ## 
        - 
        - `Tag`  `[0-9]+days`
        - 3
        - 
        - 124
        
        @param tmp_req: PutRecordStorageLifeCycleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutRecordStorageLifeCycleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.PutRecordStorageLifeCycleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.stream_ids):
            request.stream_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.stream_ids, 'StreamIds', 'json')
        body = {}
        if not UtilClient.is_unset(request.stream_ids_shrink):
            body['StreamIds'] = request.stream_ids_shrink
        if not UtilClient.is_unset(request.tag):
            body['Tag'] = request.tag
        if not UtilClient.is_unset(request.unix_timestamp):
            body['UnixTimestamp'] = request.unix_timestamp
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PutRecordStorageLifeCycle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.PutRecordStorageLifeCycleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def put_record_storage_life_cycle(
        self,
        request: live_20161101_models.PutRecordStorageLifeCycleRequest,
    ) -> live_20161101_models.PutRecordStorageLifeCycleResponse:
        """
        @summary 
        
        @description ## 
        - 
        - `Tag`  `[0-9]+days`
        - 3
        - 
        - 124
        
        @param request: PutRecordStorageLifeCycleRequest
        @return: PutRecordStorageLifeCycleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.put_record_storage_life_cycle_with_options(request, runtime)

    async def put_record_storage_life_cycle_async(
        self,
        request: live_20161101_models.PutRecordStorageLifeCycleRequest,
    ) -> live_20161101_models.PutRecordStorageLifeCycleResponse:
        """
        @summary 
        
        @description ## 
        - 
        - `Tag`  `[0-9]+days`
        - 3
        - 
        - 124
        
        @param request: PutRecordStorageLifeCycleRequest
        @return: PutRecordStorageLifeCycleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.put_record_storage_life_cycle_with_options_async(request, runtime)

    def query_live_domain_multi_stream_list_with_options(
        self,
        request: live_20161101_models.QueryLiveDomainMultiStreamListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryLiveDomainMultiStreamListResponse:
        """
        @summary Queries the dual-stream disaster recovery records of online streams.
        
        @param request: QueryLiveDomainMultiStreamListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryLiveDomainMultiStreamListResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryLiveDomainMultiStreamList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryLiveDomainMultiStreamListResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_live_domain_multi_stream_list_with_options_async(
        self,
        request: live_20161101_models.QueryLiveDomainMultiStreamListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryLiveDomainMultiStreamListResponse:
        """
        @summary Queries the dual-stream disaster recovery records of online streams.
        
        @param request: QueryLiveDomainMultiStreamListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryLiveDomainMultiStreamListResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryLiveDomainMultiStreamList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryLiveDomainMultiStreamListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_live_domain_multi_stream_list(
        self,
        request: live_20161101_models.QueryLiveDomainMultiStreamListRequest,
    ) -> live_20161101_models.QueryLiveDomainMultiStreamListResponse:
        """
        @summary Queries the dual-stream disaster recovery records of online streams.
        
        @param request: QueryLiveDomainMultiStreamListRequest
        @return: QueryLiveDomainMultiStreamListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_live_domain_multi_stream_list_with_options(request, runtime)

    async def query_live_domain_multi_stream_list_async(
        self,
        request: live_20161101_models.QueryLiveDomainMultiStreamListRequest,
    ) -> live_20161101_models.QueryLiveDomainMultiStreamListResponse:
        """
        @summary Queries the dual-stream disaster recovery records of online streams.
        
        @param request: QueryLiveDomainMultiStreamListRequest
        @return: QueryLiveDomainMultiStreamListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_live_domain_multi_stream_list_with_options_async(request, runtime)

    def query_message_app_with_options(
        self,
        request: live_20161101_models.QueryMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryMessageAppResponse:
        """
        @summary Queries interactive messaging applications based on specified conditions.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: QueryMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='QueryMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_message_app_with_options_async(
        self,
        request: live_20161101_models.QueryMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryMessageAppResponse:
        """
        @summary Queries interactive messaging applications based on specified conditions.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: QueryMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryMessageAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.page_num):
            body['PageNum'] = request.page_num
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_type):
            body['SortType'] = request.sort_type
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='QueryMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_message_app(
        self,
        request: live_20161101_models.QueryMessageAppRequest,
    ) -> live_20161101_models.QueryMessageAppResponse:
        """
        @summary Queries interactive messaging applications based on specified conditions.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: QueryMessageAppRequest
        @return: QueryMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_message_app_with_options(request, runtime)

    async def query_message_app_async(
        self,
        request: live_20161101_models.QueryMessageAppRequest,
    ) -> live_20161101_models.QueryMessageAppResponse:
        """
        @summary Queries interactive messaging applications based on specified conditions.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: QueryMessageAppRequest
        @return: QueryMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_message_app_with_options_async(request, runtime)

    def query_rtc_asr_tasks_with_options(
        self,
        request: live_20161101_models.QueryRtcAsrTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryRtcAsrTasksResponse:
        """
        @summary Queries the status of a speech-to-text or translation task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QueryRtcAsrTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryRtcAsrTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryRtcAsrTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryRtcAsrTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_rtc_asr_tasks_with_options_async(
        self,
        request: live_20161101_models.QueryRtcAsrTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QueryRtcAsrTasksResponse:
        """
        @summary Queries the status of a speech-to-text or translation task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QueryRtcAsrTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryRtcAsrTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryRtcAsrTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QueryRtcAsrTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_rtc_asr_tasks(
        self,
        request: live_20161101_models.QueryRtcAsrTasksRequest,
    ) -> live_20161101_models.QueryRtcAsrTasksResponse:
        """
        @summary Queries the status of a speech-to-text or translation task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QueryRtcAsrTasksRequest
        @return: QueryRtcAsrTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_rtc_asr_tasks_with_options(request, runtime)

    async def query_rtc_asr_tasks_async(
        self,
        request: live_20161101_models.QueryRtcAsrTasksRequest,
    ) -> live_20161101_models.QueryRtcAsrTasksResponse:
        """
        @summary Queries the status of a speech-to-text or translation task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QueryRtcAsrTasksRequest
        @return: QueryRtcAsrTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_rtc_asr_tasks_with_options_async(request, runtime)

    def query_snapshot_callback_auth_with_options(
        self,
        request: live_20161101_models.QuerySnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QuerySnapshotCallbackAuthResponse:
        """
        @summary Queries the configuration of authentication for snapshot callbacks.
        
        @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QuerySnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QuerySnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QuerySnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QuerySnapshotCallbackAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_snapshot_callback_auth_with_options_async(
        self,
        request: live_20161101_models.QuerySnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.QuerySnapshotCallbackAuthResponse:
        """
        @summary Queries the configuration of authentication for snapshot callbacks.
        
        @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QuerySnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QuerySnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QuerySnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.QuerySnapshotCallbackAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_snapshot_callback_auth(
        self,
        request: live_20161101_models.QuerySnapshotCallbackAuthRequest,
    ) -> live_20161101_models.QuerySnapshotCallbackAuthResponse:
        """
        @summary Queries the configuration of authentication for snapshot callbacks.
        
        @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QuerySnapshotCallbackAuthRequest
        @return: QuerySnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_snapshot_callback_auth_with_options(request, runtime)

    async def query_snapshot_callback_auth_async(
        self,
        request: live_20161101_models.QuerySnapshotCallbackAuthRequest,
    ) -> live_20161101_models.QuerySnapshotCallbackAuthResponse:
        """
        @summary Queries the configuration of authentication for snapshot callbacks.
        
        @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: QuerySnapshotCallbackAuthRequest
        @return: QuerySnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_snapshot_callback_auth_with_options_async(request, runtime)

    def real_time_record_command_with_options(
        self,
        request: live_20161101_models.RealTimeRecordCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RealTimeRecordCommandResponse:
        """
        @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
        If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
        If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
        If a live stream that you manually record is interrupted, the recording stops.
        If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RealTimeRecordCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RealTimeRecordCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.command):
            query['Command'] = request.command
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RealTimeRecordCommand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RealTimeRecordCommandResponse(),
            self.call_api(params, req, runtime)
        )

    async def real_time_record_command_with_options_async(
        self,
        request: live_20161101_models.RealTimeRecordCommandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RealTimeRecordCommandResponse:
        """
        @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
        If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
        If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
        If a live stream that you manually record is interrupted, the recording stops.
        If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RealTimeRecordCommandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RealTimeRecordCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.command):
            query['Command'] = request.command
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RealTimeRecordCommand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RealTimeRecordCommandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def real_time_record_command(
        self,
        request: live_20161101_models.RealTimeRecordCommandRequest,
    ) -> live_20161101_models.RealTimeRecordCommandResponse:
        """
        @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
        If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
        If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
        If a live stream that you manually record is interrupted, the recording stops.
        If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RealTimeRecordCommandRequest
        @return: RealTimeRecordCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.real_time_record_command_with_options(request, runtime)

    async def real_time_record_command_async(
        self,
        request: live_20161101_models.RealTimeRecordCommandRequest,
    ) -> live_20161101_models.RealTimeRecordCommandResponse:
        """
        @summary Controls recordings manually on demand. For example, you can call this operation to start or stop recording at a specific point in time.
        
        @description    Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
        If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
        If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
        If a live stream that you manually record is interrupted, the recording stops.
        If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RealTimeRecordCommandRequest
        @return: RealTimeRecordCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.real_time_record_command_with_options_async(request, runtime)

    def recover_live_message_deleted_group_with_options(
        self,
        request: live_20161101_models.RecoverLiveMessageDeletedGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RecoverLiveMessageDeletedGroupResponse:
        """
        @summary Restores a deleted interactive messaging group.
        
        @description    You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
        After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RecoverLiveMessageDeletedGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverLiveMessageDeletedGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverLiveMessageDeletedGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RecoverLiveMessageDeletedGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def recover_live_message_deleted_group_with_options_async(
        self,
        request: live_20161101_models.RecoverLiveMessageDeletedGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RecoverLiveMessageDeletedGroupResponse:
        """
        @summary Restores a deleted interactive messaging group.
        
        @description    You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
        After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RecoverLiveMessageDeletedGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RecoverLiveMessageDeletedGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RecoverLiveMessageDeletedGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RecoverLiveMessageDeletedGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def recover_live_message_deleted_group(
        self,
        request: live_20161101_models.RecoverLiveMessageDeletedGroupRequest,
    ) -> live_20161101_models.RecoverLiveMessageDeletedGroupResponse:
        """
        @summary Restores a deleted interactive messaging group.
        
        @description    You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
        After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RecoverLiveMessageDeletedGroupRequest
        @return: RecoverLiveMessageDeletedGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.recover_live_message_deleted_group_with_options(request, runtime)

    async def recover_live_message_deleted_group_async(
        self,
        request: live_20161101_models.RecoverLiveMessageDeletedGroupRequest,
    ) -> live_20161101_models.RecoverLiveMessageDeletedGroupResponse:
        """
        @summary Restores a deleted interactive messaging group.
        
        @description    You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
        After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RecoverLiveMessageDeletedGroupRequest
        @return: RecoverLiveMessageDeletedGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.recover_live_message_deleted_group_with_options_async(request, runtime)

    def remove_live_message_group_band_with_options(
        self,
        tmp_req: live_20161101_models.RemoveLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveLiveMessageGroupBandResponse:
        """
        @summary Unmutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: RemoveLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.RemoveLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.unbanned_users):
            request.unbanned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.unbanned_users, 'UnbannedUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.unbanned_users_shrink):
            query['UnbannedUsers'] = request.unbanned_users_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveLiveMessageGroupBandResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_live_message_group_band_with_options_async(
        self,
        tmp_req: live_20161101_models.RemoveLiveMessageGroupBandRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveLiveMessageGroupBandResponse:
        """
        @summary Unmutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: RemoveLiveMessageGroupBandRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveLiveMessageGroupBandResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.RemoveLiveMessageGroupBandShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.unbanned_users):
            request.unbanned_users_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.unbanned_users, 'UnbannedUsers', 'simple')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.unbanned_users_shrink):
            query['UnbannedUsers'] = request.unbanned_users_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveLiveMessageGroupBand',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveLiveMessageGroupBandResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_live_message_group_band(
        self,
        request: live_20161101_models.RemoveLiveMessageGroupBandRequest,
    ) -> live_20161101_models.RemoveLiveMessageGroupBandResponse:
        """
        @summary Unmutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveLiveMessageGroupBandRequest
        @return: RemoveLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_live_message_group_band_with_options(request, runtime)

    async def remove_live_message_group_band_async(
        self,
        request: live_20161101_models.RemoveLiveMessageGroupBandRequest,
    ) -> live_20161101_models.RemoveLiveMessageGroupBandResponse:
        """
        @summary Unmutes one or more users.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveLiveMessageGroupBandRequest
        @return: RemoveLiveMessageGroupBandResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_live_message_group_band_with_options_async(request, runtime)

    def remove_show_from_show_list_with_options(
        self,
        request: live_20161101_models.RemoveShowFromShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveShowFromShowListResponse:
        """
        @summary Removes a specified episode from an episode list.
        
        @description ## [](#)Usage notes
        You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: RemoveShowFromShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveShowFromShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.is_batch_mode):
            query['isBatchMode'] = request.is_batch_mode
        if not UtilClient.is_unset(request.show_id_list):
            query['showIdList'] = request.show_id_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveShowFromShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveShowFromShowListResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_show_from_show_list_with_options_async(
        self,
        request: live_20161101_models.RemoveShowFromShowListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveShowFromShowListResponse:
        """
        @summary Removes a specified episode from an episode list.
        
        @description ## [](#)Usage notes
        You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: RemoveShowFromShowListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveShowFromShowListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_id):
            query['ShowId'] = request.show_id
        if not UtilClient.is_unset(request.is_batch_mode):
            query['isBatchMode'] = request.is_batch_mode
        if not UtilClient.is_unset(request.show_id_list):
            query['showIdList'] = request.show_id_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveShowFromShowList',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveShowFromShowListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_show_from_show_list(
        self,
        request: live_20161101_models.RemoveShowFromShowListRequest,
    ) -> live_20161101_models.RemoveShowFromShowListResponse:
        """
        @summary Removes a specified episode from an episode list.
        
        @description ## [](#)Usage notes
        You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: RemoveShowFromShowListRequest
        @return: RemoveShowFromShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_show_from_show_list_with_options(request, runtime)

    async def remove_show_from_show_list_async(
        self,
        request: live_20161101_models.RemoveShowFromShowListRequest,
    ) -> live_20161101_models.RemoveShowFromShowListResponse:
        """
        @summary Removes a specified episode from an episode list.
        
        @description ## [](#)Usage notes
        You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: RemoveShowFromShowListRequest
        @return: RemoveShowFromShowListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_show_from_show_list_with_options_async(request, runtime)

    def remove_terminals_with_options(
        self,
        request: live_20161101_models.RemoveTerminalsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveTerminalsResponse:
        """
        @summary Removes users from a channel.
        
        @description You can call this operation to remove one or more users from a channel.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveTerminalsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTerminalsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.terminal_ids):
            query['TerminalIds'] = request.terminal_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTerminals',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveTerminalsResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_terminals_with_options_async(
        self,
        request: live_20161101_models.RemoveTerminalsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RemoveTerminalsResponse:
        """
        @summary Removes users from a channel.
        
        @description You can call this operation to remove one or more users from a channel.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveTerminalsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTerminalsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.terminal_ids):
            query['TerminalIds'] = request.terminal_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTerminals',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RemoveTerminalsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_terminals(
        self,
        request: live_20161101_models.RemoveTerminalsRequest,
    ) -> live_20161101_models.RemoveTerminalsResponse:
        """
        @summary Removes users from a channel.
        
        @description You can call this operation to remove one or more users from a channel.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveTerminalsRequest
        @return: RemoveTerminalsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_terminals_with_options(request, runtime)

    async def remove_terminals_async(
        self,
        request: live_20161101_models.RemoveTerminalsRequest,
    ) -> live_20161101_models.RemoveTerminalsResponse:
        """
        @summary Removes users from a channel.
        
        @description You can call this operation to remove one or more users from a channel.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RemoveTerminalsRequest
        @return: RemoveTerminalsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_terminals_with_options_async(request, runtime)

    def restart_caster_with_options(
        self,
        request: live_20161101_models.RestartCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartCasterResponse:
        """
        @summary Restarts a production studio.
        
        @description    Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
        After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def restart_caster_with_options_async(
        self,
        request: live_20161101_models.RestartCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartCasterResponse:
        """
        @summary Restarts a production studio.
        
        @description    Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
        After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restart_caster(
        self,
        request: live_20161101_models.RestartCasterRequest,
    ) -> live_20161101_models.RestartCasterResponse:
        """
        @summary Restarts a production studio.
        
        @description    Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
        After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartCasterRequest
        @return: RestartCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restart_caster_with_options(request, runtime)

    async def restart_caster_async(
        self,
        request: live_20161101_models.RestartCasterRequest,
    ) -> live_20161101_models.RestartCasterResponse:
        """
        @summary Restarts a production studio.
        
        @description    Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
        After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartCasterRequest
        @return: RestartCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restart_caster_with_options_async(request, runtime)

    def restart_live_pull_to_push_with_options(
        self,
        request: live_20161101_models.RestartLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartLivePullToPushResponse:
        """
        @summary Restarts a pulled-stream relay task.
        
        @description    You can call this operation to restart a pulled-stream relay task.
        You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
        You cannot restart a task if the start time specified for the task has not been reached.
        If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
        If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def restart_live_pull_to_push_with_options_async(
        self,
        request: live_20161101_models.RestartLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartLivePullToPushResponse:
        """
        @summary Restarts a pulled-stream relay task.
        
        @description    You can call this operation to restart a pulled-stream relay task.
        You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
        You cannot restart a task if the start time specified for the task has not been reached.
        If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
        If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restart_live_pull_to_push(
        self,
        request: live_20161101_models.RestartLivePullToPushRequest,
    ) -> live_20161101_models.RestartLivePullToPushResponse:
        """
        @summary Restarts a pulled-stream relay task.
        
        @description    You can call this operation to restart a pulled-stream relay task.
        You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
        You cannot restart a task if the start time specified for the task has not been reached.
        If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
        If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartLivePullToPushRequest
        @return: RestartLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restart_live_pull_to_push_with_options(request, runtime)

    async def restart_live_pull_to_push_async(
        self,
        request: live_20161101_models.RestartLivePullToPushRequest,
    ) -> live_20161101_models.RestartLivePullToPushResponse:
        """
        @summary Restarts a pulled-stream relay task.
        
        @description    You can call this operation to restart a pulled-stream relay task.
        You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
        You cannot restart a task if the start time specified for the task has not been reached.
        If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
        If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: RestartLivePullToPushRequest
        @return: RestartLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restart_live_pull_to_push_with_options_async(request, runtime)

    def restart_transcode_task_with_options(
        self,
        request: live_20161101_models.RestartTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartTranscodeTaskResponse:
        """
        @param request: RestartTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcoding_template):
            query['TranscodingTemplate'] = request.transcoding_template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartTranscodeTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartTranscodeTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def restart_transcode_task_with_options_async(
        self,
        request: live_20161101_models.RestartTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RestartTranscodeTaskResponse:
        """
        @param request: RestartTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.push_domain):
            query['PushDomain'] = request.push_domain
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcoding_template):
            query['TranscodingTemplate'] = request.transcoding_template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartTranscodeTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RestartTranscodeTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restart_transcode_task(
        self,
        request: live_20161101_models.RestartTranscodeTaskRequest,
    ) -> live_20161101_models.RestartTranscodeTaskResponse:
        """
        @param request: RestartTranscodeTaskRequest
        @return: RestartTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restart_transcode_task_with_options(request, runtime)

    async def restart_transcode_task_async(
        self,
        request: live_20161101_models.RestartTranscodeTaskRequest,
    ) -> live_20161101_models.RestartTranscodeTaskResponse:
        """
        @param request: RestartTranscodeTaskRequest
        @return: RestartTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restart_transcode_task_with_options_async(request, runtime)

    def resume_live_stream_with_options(
        self,
        request: live_20161101_models.ResumeLiveStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ResumeLiveStreamResponse:
        """
        @summary Resumes the ingest of a live stream.
        
        @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ResumeLiveStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResumeLiveStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_stream_type):
            query['LiveStreamType'] = request.live_stream_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResumeLiveStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ResumeLiveStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def resume_live_stream_with_options_async(
        self,
        request: live_20161101_models.ResumeLiveStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.ResumeLiveStreamResponse:
        """
        @summary Resumes the ingest of a live stream.
        
        @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ResumeLiveStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResumeLiveStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.live_stream_type):
            query['LiveStreamType'] = request.live_stream_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResumeLiveStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.ResumeLiveStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def resume_live_stream(
        self,
        request: live_20161101_models.ResumeLiveStreamRequest,
    ) -> live_20161101_models.ResumeLiveStreamResponse:
        """
        @summary Resumes the ingest of a live stream.
        
        @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ResumeLiveStreamRequest
        @return: ResumeLiveStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.resume_live_stream_with_options(request, runtime)

    async def resume_live_stream_async(
        self,
        request: live_20161101_models.ResumeLiveStreamRequest,
    ) -> live_20161101_models.ResumeLiveStreamResponse:
        """
        @summary Resumes the ingest of a live stream.
        
        @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: ResumeLiveStreamRequest
        @return: ResumeLiveStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.resume_live_stream_with_options_async(request, runtime)

    def rollback_live_staging_config_with_options(
        self,
        request: live_20161101_models.RollbackLiveStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RollbackLiveStagingConfigResponse:
        """
        @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: RollbackLiveStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RollbackLiveStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RollbackLiveStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RollbackLiveStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def rollback_live_staging_config_with_options_async(
        self,
        request: live_20161101_models.RollbackLiveStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.RollbackLiveStagingConfigResponse:
        """
        @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: RollbackLiveStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RollbackLiveStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RollbackLiveStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.RollbackLiveStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def rollback_live_staging_config(
        self,
        request: live_20161101_models.RollbackLiveStagingConfigRequest,
    ) -> live_20161101_models.RollbackLiveStagingConfigResponse:
        """
        @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: RollbackLiveStagingConfigRequest
        @return: RollbackLiveStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.rollback_live_staging_config_with_options(request, runtime)

    async def rollback_live_staging_config_async(
        self,
        request: live_20161101_models.RollbackLiveStagingConfigRequest,
    ) -> live_20161101_models.RollbackLiveStagingConfigResponse:
        """
        @summary Rolls back the configurations of an accelerated domain name in the canary release environment.
        
        @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
        ## QPS limit
        A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
        
        @param request: RollbackLiveStagingConfigRequest
        @return: RollbackLiveStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.rollback_live_staging_config_with_options_async(request, runtime)

    def send_like_with_options(
        self,
        request: live_20161101_models.SendLikeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLikeResponse:
        """
        @summary Configures likes in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendLikeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLikeResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.count):
            body['Count'] = request.count
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendLike',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLikeResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_like_with_options_async(
        self,
        request: live_20161101_models.SendLikeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLikeResponse:
        """
        @summary Configures likes in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendLikeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLikeResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.broad_cast_type):
            body['BroadCastType'] = request.broad_cast_type
        if not UtilClient.is_unset(request.count):
            body['Count'] = request.count
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendLike',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLikeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_like(
        self,
        request: live_20161101_models.SendLikeRequest,
    ) -> live_20161101_models.SendLikeResponse:
        """
        @summary Configures likes in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendLikeRequest
        @return: SendLikeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_like_with_options(request, runtime)

    async def send_like_async(
        self,
        request: live_20161101_models.SendLikeRequest,
    ) -> live_20161101_models.SendLikeResponse:
        """
        @summary Configures likes in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendLikeRequest
        @return: SendLikeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_like_with_options_async(request, runtime)

    def send_live_message_group_with_options(
        self,
        request: live_20161101_models.SendLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLiveMessageGroupResponse:
        """
        @summary Sends a message to a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.msg_tid):
            query['MsgTid'] = request.msg_tid
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.no_cache):
            query['NoCache'] = request.no_cache
        if not UtilClient.is_unset(request.no_storage):
            query['NoStorage'] = request.no_storage
        if not UtilClient.is_unset(request.sender_id):
            query['SenderId'] = request.sender_id
        if not UtilClient.is_unset(request.sender_meta_info):
            query['SenderMetaInfo'] = request.sender_meta_info
        if not UtilClient.is_unset(request.statics_increase):
            query['StaticsIncrease'] = request.statics_increase
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_live_message_group_with_options_async(
        self,
        request: live_20161101_models.SendLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLiveMessageGroupResponse:
        """
        @summary Sends a message to a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.msg_tid):
            query['MsgTid'] = request.msg_tid
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.no_cache):
            query['NoCache'] = request.no_cache
        if not UtilClient.is_unset(request.no_storage):
            query['NoStorage'] = request.no_storage
        if not UtilClient.is_unset(request.sender_id):
            query['SenderId'] = request.sender_id
        if not UtilClient.is_unset(request.sender_meta_info):
            query['SenderMetaInfo'] = request.sender_meta_info
        if not UtilClient.is_unset(request.statics_increase):
            query['StaticsIncrease'] = request.statics_increase
        if not UtilClient.is_unset(request.weight):
            query['Weight'] = request.weight
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_live_message_group(
        self,
        request: live_20161101_models.SendLiveMessageGroupRequest,
    ) -> live_20161101_models.SendLiveMessageGroupResponse:
        """
        @summary Sends a message to a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageGroupRequest
        @return: SendLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_live_message_group_with_options(request, runtime)

    async def send_live_message_group_async(
        self,
        request: live_20161101_models.SendLiveMessageGroupRequest,
    ) -> live_20161101_models.SendLiveMessageGroupResponse:
        """
        @summary Sends a message to a group.
        
        @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageGroupRequest
        @return: SendLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_live_message_group_with_options_async(request, runtime)

    def send_live_message_user_with_options(
        self,
        request: live_20161101_models.SendLiveMessageUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLiveMessageUserResponse:
        """
        @summary Sends a message to a specified user. The user is identified by ReceiverId.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLiveMessageUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.high_reliability):
            query['HighReliability'] = request.high_reliability
        if not UtilClient.is_unset(request.msg_tid):
            query['MsgTid'] = request.msg_tid
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.receiver_id):
            query['ReceiverId'] = request.receiver_id
        if not UtilClient.is_unset(request.sender_id):
            query['SenderId'] = request.sender_id
        if not UtilClient.is_unset(request.sender_info):
            query['SenderInfo'] = request.sender_info
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendLiveMessageUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLiveMessageUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_live_message_user_with_options_async(
        self,
        request: live_20161101_models.SendLiveMessageUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendLiveMessageUserResponse:
        """
        @summary Sends a message to a specified user. The user is identified by ReceiverId.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendLiveMessageUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.high_reliability):
            query['HighReliability'] = request.high_reliability
        if not UtilClient.is_unset(request.msg_tid):
            query['MsgTid'] = request.msg_tid
        if not UtilClient.is_unset(request.msg_type):
            query['MsgType'] = request.msg_type
        if not UtilClient.is_unset(request.receiver_id):
            query['ReceiverId'] = request.receiver_id
        if not UtilClient.is_unset(request.sender_id):
            query['SenderId'] = request.sender_id
        if not UtilClient.is_unset(request.sender_info):
            query['SenderInfo'] = request.sender_info
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SendLiveMessageUser',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendLiveMessageUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_live_message_user(
        self,
        request: live_20161101_models.SendLiveMessageUserRequest,
    ) -> live_20161101_models.SendLiveMessageUserResponse:
        """
        @summary Sends a message to a specified user. The user is identified by ReceiverId.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageUserRequest
        @return: SendLiveMessageUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_live_message_user_with_options(request, runtime)

    async def send_live_message_user_async(
        self,
        request: live_20161101_models.SendLiveMessageUserRequest,
    ) -> live_20161101_models.SendLiveMessageUserResponse:
        """
        @summary Sends a message to a specified user. The user is identified by ReceiverId.
        
        @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SendLiveMessageUserRequest
        @return: SendLiveMessageUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_live_message_user_with_options_async(request, runtime)

    def send_message_to_group_with_options(
        self,
        request: live_20161101_models.SendMessageToGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendMessageToGroupResponse:
        """
        @summary Sends a message to all members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendMessageToGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.skip_audit):
            query['SkipAudit'] = request.skip_audit
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data):
            body['Data'] = request.data
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendMessageToGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendMessageToGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_message_to_group_with_options_async(
        self,
        request: live_20161101_models.SendMessageToGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendMessageToGroupResponse:
        """
        @summary Sends a message to all members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendMessageToGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.skip_audit):
            query['SkipAudit'] = request.skip_audit
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data):
            body['Data'] = request.data
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendMessageToGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendMessageToGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_message_to_group(
        self,
        request: live_20161101_models.SendMessageToGroupRequest,
    ) -> live_20161101_models.SendMessageToGroupResponse:
        """
        @summary Sends a message to all members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupRequest
        @return: SendMessageToGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_message_to_group_with_options(request, runtime)

    async def send_message_to_group_async(
        self,
        request: live_20161101_models.SendMessageToGroupRequest,
    ) -> live_20161101_models.SendMessageToGroupResponse:
        """
        @summary Sends a message to all members in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupRequest
        @return: SendMessageToGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_message_to_group_with_options_async(request, runtime)

    def send_message_to_group_users_with_options(
        self,
        tmp_req: live_20161101_models.SendMessageToGroupUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendMessageToGroupUsersResponse:
        """
        @summary Sends a message to specified users in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: SendMessageToGroupUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendMessageToGroupUsersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.SendMessageToGroupUsersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.receiver_id_list):
            request.receiver_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.receiver_id_list, 'ReceiverIdList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.skip_audit):
            query['SkipAudit'] = request.skip_audit
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data):
            body['Data'] = request.data
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.receiver_id_list_shrink):
            body['ReceiverIdList'] = request.receiver_id_list_shrink
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendMessageToGroupUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendMessageToGroupUsersResponse(),
            self.call_api(params, req, runtime)
        )

    async def send_message_to_group_users_with_options_async(
        self,
        tmp_req: live_20161101_models.SendMessageToGroupUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SendMessageToGroupUsersResponse:
        """
        @summary Sends a message to specified users in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: SendMessageToGroupUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SendMessageToGroupUsersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.SendMessageToGroupUsersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.receiver_id_list):
            request.receiver_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.receiver_id_list, 'ReceiverIdList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.skip_audit):
            query['SkipAudit'] = request.skip_audit
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data):
            body['Data'] = request.data
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.operator_user_id):
            body['OperatorUserId'] = request.operator_user_id
        if not UtilClient.is_unset(request.receiver_id_list_shrink):
            body['ReceiverIdList'] = request.receiver_id_list_shrink
        if not UtilClient.is_unset(request.type):
            body['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='SendMessageToGroupUsers',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SendMessageToGroupUsersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def send_message_to_group_users(
        self,
        request: live_20161101_models.SendMessageToGroupUsersRequest,
    ) -> live_20161101_models.SendMessageToGroupUsersResponse:
        """
        @summary Sends a message to specified users in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupUsersRequest
        @return: SendMessageToGroupUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.send_message_to_group_users_with_options(request, runtime)

    async def send_message_to_group_users_async(
        self,
        request: live_20161101_models.SendMessageToGroupUsersRequest,
    ) -> live_20161101_models.SendMessageToGroupUsersResponse:
        """
        @summary Sends a message to specified users in a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SendMessageToGroupUsersRequest
        @return: SendMessageToGroupUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.send_message_to_group_users_with_options_async(request, runtime)

    def set_caster_channel_with_options(
        self,
        request: live_20161101_models.SetCasterChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterChannelResponse:
        """
        @summary Configures a channel of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.face_beauty):
            query['FaceBeauty'] = request.face_beauty
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_status):
            query['PlayStatus'] = request.play_status
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.seek_offset):
            query['SeekOffset'] = request.seek_offset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterChannel',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterChannelResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_caster_channel_with_options_async(
        self,
        request: live_20161101_models.SetCasterChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterChannelResponse:
        """
        @summary Configures a channel of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.face_beauty):
            query['FaceBeauty'] = request.face_beauty
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_status):
            query['PlayStatus'] = request.play_status
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.seek_offset):
            query['SeekOffset'] = request.seek_offset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterChannel',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterChannelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_caster_channel(
        self,
        request: live_20161101_models.SetCasterChannelRequest,
    ) -> live_20161101_models.SetCasterChannelResponse:
        """
        @summary Configures a channel of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterChannelRequest
        @return: SetCasterChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_caster_channel_with_options(request, runtime)

    async def set_caster_channel_async(
        self,
        request: live_20161101_models.SetCasterChannelRequest,
    ) -> live_20161101_models.SetCasterChannelResponse:
        """
        @summary Configures a channel of a production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterChannelRequest
        @return: SetCasterChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_caster_channel_with_options_async(request, runtime)

    def set_caster_config_with_options(
        self,
        request: live_20161101_models.SetCasterConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterConfigResponse:
        """
        @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_switch_urgent_config):
            query['AutoSwitchUrgentConfig'] = request.auto_switch_urgent_config
        if not UtilClient.is_unset(request.auto_switch_urgent_on):
            query['AutoSwitchUrgentOn'] = request.auto_switch_urgent_on
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.channel_enable):
            query['ChannelEnable'] = request.channel_enable
        if not UtilClient.is_unset(request.delay):
            query['Delay'] = request.delay
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_effect):
            query['ProgramEffect'] = request.program_effect
        if not UtilClient.is_unset(request.program_name):
            query['ProgramName'] = request.program_name
        if not UtilClient.is_unset(request.record_config):
            query['RecordConfig'] = request.record_config
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.side_output_url):
            query['SideOutputUrl'] = request.side_output_url
        if not UtilClient.is_unset(request.side_output_url_list):
            query['SideOutputUrlList'] = request.side_output_url_list
        if not UtilClient.is_unset(request.sync_groups_config):
            query['SyncGroupsConfig'] = request.sync_groups_config
        if not UtilClient.is_unset(request.transcode_config):
            query['TranscodeConfig'] = request.transcode_config
        if not UtilClient.is_unset(request.urgent_image_id):
            query['UrgentImageId'] = request.urgent_image_id
        if not UtilClient.is_unset(request.urgent_image_url):
            query['UrgentImageUrl'] = request.urgent_image_url
        if not UtilClient.is_unset(request.urgent_live_stream_url):
            query['UrgentLiveStreamUrl'] = request.urgent_live_stream_url
        if not UtilClient.is_unset(request.urgent_material_id):
            query['UrgentMaterialId'] = request.urgent_material_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_caster_config_with_options_async(
        self,
        request: live_20161101_models.SetCasterConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterConfigResponse:
        """
        @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_switch_urgent_config):
            query['AutoSwitchUrgentConfig'] = request.auto_switch_urgent_config
        if not UtilClient.is_unset(request.auto_switch_urgent_on):
            query['AutoSwitchUrgentOn'] = request.auto_switch_urgent_on
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.caster_name):
            query['CasterName'] = request.caster_name
        if not UtilClient.is_unset(request.channel_enable):
            query['ChannelEnable'] = request.channel_enable
        if not UtilClient.is_unset(request.delay):
            query['Delay'] = request.delay
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_effect):
            query['ProgramEffect'] = request.program_effect
        if not UtilClient.is_unset(request.program_name):
            query['ProgramName'] = request.program_name
        if not UtilClient.is_unset(request.record_config):
            query['RecordConfig'] = request.record_config
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.side_output_url):
            query['SideOutputUrl'] = request.side_output_url
        if not UtilClient.is_unset(request.side_output_url_list):
            query['SideOutputUrlList'] = request.side_output_url_list
        if not UtilClient.is_unset(request.sync_groups_config):
            query['SyncGroupsConfig'] = request.sync_groups_config
        if not UtilClient.is_unset(request.transcode_config):
            query['TranscodeConfig'] = request.transcode_config
        if not UtilClient.is_unset(request.urgent_image_id):
            query['UrgentImageId'] = request.urgent_image_id
        if not UtilClient.is_unset(request.urgent_image_url):
            query['UrgentImageUrl'] = request.urgent_image_url
        if not UtilClient.is_unset(request.urgent_live_stream_url):
            query['UrgentLiveStreamUrl'] = request.urgent_live_stream_url
        if not UtilClient.is_unset(request.urgent_material_id):
            query['UrgentMaterialId'] = request.urgent_material_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_caster_config(
        self,
        request: live_20161101_models.SetCasterConfigRequest,
    ) -> live_20161101_models.SetCasterConfigResponse:
        """
        @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterConfigRequest
        @return: SetCasterConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_caster_config_with_options(request, runtime)

    async def set_caster_config_async(
        self,
        request: live_20161101_models.SetCasterConfigRequest,
    ) -> live_20161101_models.SetCasterConfigResponse:
        """
        @summary Configures a production studio. For example, you can specify the name of the production studio, configure the transcoding settings, and configure the recording settings.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetCasterConfigRequest
        @return: SetCasterConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_caster_config_with_options_async(request, runtime)

    def set_caster_scene_config_with_options(
        self,
        request: live_20161101_models.SetCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterSceneConfigResponse:
        """
        @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        
        @description ## [](#)Usage notes
        This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterSceneConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_caster_scene_config_with_options_async(
        self,
        request: live_20161101_models.SetCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetCasterSceneConfigResponse:
        """
        @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        
        @description ## [](#)Usage notes
        This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetCasterSceneConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_caster_scene_config(
        self,
        request: live_20161101_models.SetCasterSceneConfigRequest,
    ) -> live_20161101_models.SetCasterSceneConfigResponse:
        """
        @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        
        @description ## [](#)Usage notes
        This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetCasterSceneConfigRequest
        @return: SetCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_caster_scene_config_with_options(request, runtime)

    async def set_caster_scene_config_async(
        self,
        request: live_20161101_models.SetCasterSceneConfigRequest,
    ) -> live_20161101_models.SetCasterSceneConfigResponse:
        """
        @summary Configures all settings of a scene. This is done by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        
        @description ## [](#)Usage notes
        This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetCasterSceneConfigRequest
        @return: SetCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_caster_scene_config_with_options_async(request, runtime)

    def set_live_domain_certificate_with_options(
        self,
        request: live_20161101_models.SetLiveDomainCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
        
        @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.cert_type):
            query['CertType'] = request.cert_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.force_set):
            query['ForceSet'] = request.force_set
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainCertificate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_domain_certificate_with_options_async(
        self,
        request: live_20161101_models.SetLiveDomainCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
        
        @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.cert_type):
            query['CertType'] = request.cert_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.force_set):
            query['ForceSet'] = request.force_set
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainCertificate',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_domain_certificate(
        self,
        request: live_20161101_models.SetLiveDomainCertificateRequest,
    ) -> live_20161101_models.SetLiveDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
        
        @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainCertificateRequest
        @return: SetLiveDomainCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_domain_certificate_with_options(request, runtime)

    async def set_live_domain_certificate_async(
        self,
        request: live_20161101_models.SetLiveDomainCertificateRequest,
    ) -> live_20161101_models.SetLiveDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name, and modifies the certificate information.
        
        @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainCertificateRequest
        @return: SetLiveDomainCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_domain_certificate_with_options_async(request, runtime)

    def set_live_domain_multi_stream_config_with_options(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamConfigResponse:
        """
        @summary Configures dual-stream disaster recovery for a streaming domain.
        
        @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainMultiStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_domain_multi_stream_config_with_options_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamConfigResponse:
        """
        @summary Configures dual-stream disaster recovery for a streaming domain.
        
        @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainMultiStreamConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_domain_multi_stream_config(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamConfigRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamConfigResponse:
        """
        @summary Configures dual-stream disaster recovery for a streaming domain.
        
        @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainMultiStreamConfigRequest
        @return: SetLiveDomainMultiStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_domain_multi_stream_config_with_options(request, runtime)

    async def set_live_domain_multi_stream_config_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamConfigRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamConfigResponse:
        """
        @summary Configures dual-stream disaster recovery for a streaming domain.
        
        @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveDomainMultiStreamConfigRequest
        @return: SetLiveDomainMultiStreamConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_domain_multi_stream_config_with_options_async(request, runtime)

    def set_live_domain_multi_stream_master_with_options(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamMasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamMasterResponse:
        """
        @summary Manually switches between the active stream and standby stream.
        
        @param request: SetLiveDomainMultiStreamMasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamMasterResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamMaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamMasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_domain_multi_stream_master_with_options_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamMasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamMasterResponse:
        """
        @summary Manually switches between the active stream and standby stream.
        
        @param request: SetLiveDomainMultiStreamMasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamMasterResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamMaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamMasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_domain_multi_stream_master(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamMasterRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamMasterResponse:
        """
        @summary Manually switches between the active stream and standby stream.
        
        @param request: SetLiveDomainMultiStreamMasterRequest
        @return: SetLiveDomainMultiStreamMasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_domain_multi_stream_master_with_options(request, runtime)

    async def set_live_domain_multi_stream_master_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamMasterRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamMasterResponse:
        """
        @summary Manually switches between the active stream and standby stream.
        
        @param request: SetLiveDomainMultiStreamMasterRequest
        @return: SetLiveDomainMultiStreamMasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_domain_multi_stream_master_with_options_async(request, runtime)

    def set_live_domain_multi_stream_optimal_mode_with_options(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamOptimalModeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse:
        """
        @summary Configures the auto mode of dual-stream disaster recovery.
        
        @param request: SetLiveDomainMultiStreamOptimalModeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamOptimalModeResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamOptimalMode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_domain_multi_stream_optimal_mode_with_options_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamOptimalModeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse:
        """
        @summary Configures the auto mode of dual-stream disaster recovery.
        
        @param request: SetLiveDomainMultiStreamOptimalModeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainMultiStreamOptimalModeResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainMultiStreamOptimalMode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_domain_multi_stream_optimal_mode(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamOptimalModeRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse:
        """
        @summary Configures the auto mode of dual-stream disaster recovery.
        
        @param request: SetLiveDomainMultiStreamOptimalModeRequest
        @return: SetLiveDomainMultiStreamOptimalModeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_domain_multi_stream_optimal_mode_with_options(request, runtime)

    async def set_live_domain_multi_stream_optimal_mode_async(
        self,
        request: live_20161101_models.SetLiveDomainMultiStreamOptimalModeRequest,
    ) -> live_20161101_models.SetLiveDomainMultiStreamOptimalModeResponse:
        """
        @summary Configures the auto mode of dual-stream disaster recovery.
        
        @param request: SetLiveDomainMultiStreamOptimalModeRequest
        @return: SetLiveDomainMultiStreamOptimalModeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_domain_multi_stream_optimal_mode_with_options_async(request, runtime)

    def set_live_domain_staging_config_with_options(
        self,
        request: live_20161101_models.SetLiveDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainStagingConfigResponse:
        """
        @summary Sets or modifies domain name configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see *Format of the Functions parameter**.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetLiveDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_domain_staging_config_with_options_async(
        self,
        request: live_20161101_models.SetLiveDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveDomainStagingConfigResponse:
        """
        @summary Sets or modifies domain name configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see *Format of the Functions parameter**.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetLiveDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveDomainStagingConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveDomainStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_domain_staging_config(
        self,
        request: live_20161101_models.SetLiveDomainStagingConfigRequest,
    ) -> live_20161101_models.SetLiveDomainStagingConfigResponse:
        """
        @summary Sets or modifies domain name configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see *Format of the Functions parameter**.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetLiveDomainStagingConfigRequest
        @return: SetLiveDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_domain_staging_config_with_options(request, runtime)

    async def set_live_domain_staging_config_async(
        self,
        request: live_20161101_models.SetLiveDomainStagingConfigRequest,
    ) -> live_20161101_models.SetLiveDomainStagingConfigResponse:
        """
        @summary Sets or modifies domain name configurations in the canary release environment.
        
        @description ## [](#)Usage notes
        Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see *Format of the Functions parameter**.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: SetLiveDomainStagingConfigRequest
        @return: SetLiveDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_domain_staging_config_with_options_async(request, runtime)

    def set_live_edge_transfer_with_options(
        self,
        request: live_20161101_models.SetLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveEdgeTransferResponse:
        """
        @summary Sets the configuration of edge stream relay.
        
        @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
        |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
        |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.http_dns):
            query['HttpDns'] = request.http_dns
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.target_domain_list):
            query['TargetDomainList'] = request.target_domain_list
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveEdgeTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_edge_transfer_with_options_async(
        self,
        request: live_20161101_models.SetLiveEdgeTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveEdgeTransferResponse:
        """
        @summary Sets the configuration of edge stream relay.
        
        @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
        |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
        |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveEdgeTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveEdgeTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.http_dns):
            query['HttpDns'] = request.http_dns
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.target_domain_list):
            query['TargetDomainList'] = request.target_domain_list
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveEdgeTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveEdgeTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_edge_transfer(
        self,
        request: live_20161101_models.SetLiveEdgeTransferRequest,
    ) -> live_20161101_models.SetLiveEdgeTransferResponse:
        """
        @summary Sets the configuration of edge stream relay.
        
        @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
        |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
        |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveEdgeTransferRequest
        @return: SetLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_edge_transfer_with_options(request, runtime)

    async def set_live_edge_transfer_async(
        self,
        request: live_20161101_models.SetLiveEdgeTransferRequest,
    ) -> live_20161101_models.SetLiveEdgeTransferResponse:
        """
        @summary Sets the configuration of edge stream relay.
        
        @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
        |Scenario|Analysis|Result|
        |---|---|---|
        |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
        |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
        |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
        ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveEdgeTransferRequest
        @return: SetLiveEdgeTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_edge_transfer_with_options_async(request, runtime)

    def set_live_lazy_pull_stream_info_config_with_options(
        self,
        request: live_20161101_models.SetLiveLazyPullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Creates a configuration of triggered stream pulling.
        
        @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
        >  The IPv6 protocol is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveLazyPullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveLazyPullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_app_name):
            query['PullAppName'] = request.pull_app_name
        if not UtilClient.is_unset(request.pull_domain_name):
            query['PullDomainName'] = request.pull_domain_name
        if not UtilClient.is_unset(request.pull_protocol):
            query['PullProtocol'] = request.pull_protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.transcode_lazy):
            query['TranscodeLazy'] = request.transcode_lazy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveLazyPullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_lazy_pull_stream_info_config_with_options_async(
        self,
        request: live_20161101_models.SetLiveLazyPullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Creates a configuration of triggered stream pulling.
        
        @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
        >  The IPv6 protocol is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveLazyPullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveLazyPullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pull_app_name):
            query['PullAppName'] = request.pull_app_name
        if not UtilClient.is_unset(request.pull_domain_name):
            query['PullDomainName'] = request.pull_domain_name
        if not UtilClient.is_unset(request.pull_protocol):
            query['PullProtocol'] = request.pull_protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.transcode_lazy):
            query['TranscodeLazy'] = request.transcode_lazy
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveLazyPullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_lazy_pull_stream_info_config(
        self,
        request: live_20161101_models.SetLiveLazyPullStreamInfoConfigRequest,
    ) -> live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Creates a configuration of triggered stream pulling.
        
        @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
        >  The IPv6 protocol is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveLazyPullStreamInfoConfigRequest
        @return: SetLiveLazyPullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_lazy_pull_stream_info_config_with_options(request, runtime)

    async def set_live_lazy_pull_stream_info_config_async(
        self,
        request: live_20161101_models.SetLiveLazyPullStreamInfoConfigRequest,
    ) -> live_20161101_models.SetLiveLazyPullStreamInfoConfigResponse:
        """
        @summary Creates a configuration of triggered stream pulling.
        
        @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
        >  The IPv6 protocol is not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveLazyPullStreamInfoConfigRequest
        @return: SetLiveLazyPullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_lazy_pull_stream_info_config_with_options_async(request, runtime)

    def set_live_mpu_task_sei_with_options(
        self,
        request: live_20161101_models.SetLiveMpuTaskSeiRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveMpuTaskSeiResponse:
        """
        @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
        
        @description ## [](#)Usage notes
        You can call this operation to configure custom SEI for a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveMpuTaskSeiRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveMpuTaskSeiResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.custom_sei):
            query['CustomSei'] = request.custom_sei
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveMpuTaskSei',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveMpuTaskSeiResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_mpu_task_sei_with_options_async(
        self,
        request: live_20161101_models.SetLiveMpuTaskSeiRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveMpuTaskSeiResponse:
        """
        @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
        
        @description ## [](#)Usage notes
        You can call this operation to configure custom SEI for a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveMpuTaskSeiRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveMpuTaskSeiResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.custom_sei):
            query['CustomSei'] = request.custom_sei
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveMpuTaskSei',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveMpuTaskSeiResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_mpu_task_sei(
        self,
        request: live_20161101_models.SetLiveMpuTaskSeiRequest,
    ) -> live_20161101_models.SetLiveMpuTaskSeiResponse:
        """
        @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
        
        @description ## [](#)Usage notes
        You can call this operation to configure custom SEI for a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveMpuTaskSeiRequest
        @return: SetLiveMpuTaskSeiResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_mpu_task_sei_with_options(request, runtime)

    async def set_live_mpu_task_sei_async(
        self,
        request: live_20161101_models.SetLiveMpuTaskSeiRequest,
    ) -> live_20161101_models.SetLiveMpuTaskSeiResponse:
        """
        @summary Configures custom supplemental enhancement information (SEI) for co-streaming.
        
        @description ## [](#)Usage notes
        You can call this operation to configure custom SEI for a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveMpuTaskSeiRequest
        @return: SetLiveMpuTaskSeiResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_mpu_task_sei_with_options_async(request, runtime)

    def set_live_stream_block_with_options(
        self,
        request: live_20161101_models.SetLiveStreamBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamBlockResponse:
        """
        @summary Configures stream-level region blocking.
        
        @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
        ### [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.block_type):
            query['BlockType'] = request.block_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.location_list):
            query['LocationList'] = request.location_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.release_time):
            query['ReleaseTime'] = request.release_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamBlockResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_stream_block_with_options_async(
        self,
        request: live_20161101_models.SetLiveStreamBlockRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamBlockResponse:
        """
        @summary Configures stream-level region blocking.
        
        @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
        ### [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamBlockRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamBlockResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.block_type):
            query['BlockType'] = request.block_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.location_list):
            query['LocationList'] = request.location_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.release_time):
            query['ReleaseTime'] = request.release_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamBlock',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamBlockResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_stream_block(
        self,
        request: live_20161101_models.SetLiveStreamBlockRequest,
    ) -> live_20161101_models.SetLiveStreamBlockResponse:
        """
        @summary Configures stream-level region blocking.
        
        @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
        ### [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamBlockRequest
        @return: SetLiveStreamBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_stream_block_with_options(request, runtime)

    async def set_live_stream_block_async(
        self,
        request: live_20161101_models.SetLiveStreamBlockRequest,
    ) -> live_20161101_models.SetLiveStreamBlockResponse:
        """
        @summary Configures stream-level region blocking.
        
        @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
        ### [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamBlockRequest
        @return: SetLiveStreamBlockResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_stream_block_with_options_async(request, runtime)

    def set_live_stream_delay_config_with_options(
        self,
        request: live_20161101_models.SetLiveStreamDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamDelayConfigResponse:
        """
        @summary Configures the live streaming latency.
        
        @description    You can call this operation to configure the latency of a streaming domain.
        Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
        Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
        For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
        The actual HLS segment size is not smaller than the GOP size.
        The latency of HLS-based playback equals the configured segment size times 3.
        If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.flv_delay):
            query['FlvDelay'] = request.flv_delay
        if not UtilClient.is_unset(request.flv_level):
            query['FlvLevel'] = request.flv_level
        if not UtilClient.is_unset(request.hls_delay):
            query['HlsDelay'] = request.hls_delay
        if not UtilClient.is_unset(request.hls_level):
            query['HlsLevel'] = request.hls_level
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rtmp_delay):
            query['RtmpDelay'] = request.rtmp_delay
        if not UtilClient.is_unset(request.rtmp_level):
            query['RtmpLevel'] = request.rtmp_level
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_stream_delay_config_with_options_async(
        self,
        request: live_20161101_models.SetLiveStreamDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamDelayConfigResponse:
        """
        @summary Configures the live streaming latency.
        
        @description    You can call this operation to configure the latency of a streaming domain.
        Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
        Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
        For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
        The actual HLS segment size is not smaller than the GOP size.
        The latency of HLS-based playback equals the configured segment size times 3.
        If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.flv_delay):
            query['FlvDelay'] = request.flv_delay
        if not UtilClient.is_unset(request.flv_level):
            query['FlvLevel'] = request.flv_level
        if not UtilClient.is_unset(request.hls_delay):
            query['HlsDelay'] = request.hls_delay
        if not UtilClient.is_unset(request.hls_level):
            query['HlsLevel'] = request.hls_level
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rtmp_delay):
            query['RtmpDelay'] = request.rtmp_delay
        if not UtilClient.is_unset(request.rtmp_level):
            query['RtmpLevel'] = request.rtmp_level
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_stream_delay_config(
        self,
        request: live_20161101_models.SetLiveStreamDelayConfigRequest,
    ) -> live_20161101_models.SetLiveStreamDelayConfigResponse:
        """
        @summary Configures the live streaming latency.
        
        @description    You can call this operation to configure the latency of a streaming domain.
        Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
        Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
        For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
        The actual HLS segment size is not smaller than the GOP size.
        The latency of HLS-based playback equals the configured segment size times 3.
        If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamDelayConfigRequest
        @return: SetLiveStreamDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_stream_delay_config_with_options(request, runtime)

    async def set_live_stream_delay_config_async(
        self,
        request: live_20161101_models.SetLiveStreamDelayConfigRequest,
    ) -> live_20161101_models.SetLiveStreamDelayConfigResponse:
        """
        @summary Configures the live streaming latency.
        
        @description    You can call this operation to configure the latency of a streaming domain.
        Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
        Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
        For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
        The actual HLS segment size is not smaller than the GOP size.
        The latency of HLS-based playback equals the configured segment size times 3.
        If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamDelayConfigRequest
        @return: SetLiveStreamDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_stream_delay_config_with_options_async(request, runtime)

    def set_live_stream_preload_tasks_with_options(
        self,
        request: live_20161101_models.SetLiveStreamPreloadTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamPreloadTasksResponse:
        """
        @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
        
        @description    You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
        URLs in the HTTP Live Steaming (HLS) format are not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamPreloadTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamPreloadTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_url):
            query['PlayUrl'] = request.play_url
        if not UtilClient.is_unset(request.preloaded_end_time):
            query['PreloadedEndTime'] = request.preloaded_end_time
        if not UtilClient.is_unset(request.preloaded_start_time):
            query['PreloadedStartTime'] = request.preloaded_start_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamPreloadTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamPreloadTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_stream_preload_tasks_with_options_async(
        self,
        request: live_20161101_models.SetLiveStreamPreloadTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamPreloadTasksResponse:
        """
        @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
        
        @description    You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
        URLs in the HTTP Live Steaming (HLS) format are not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamPreloadTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamPreloadTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_url):
            query['PlayUrl'] = request.play_url
        if not UtilClient.is_unset(request.preloaded_end_time):
            query['PreloadedEndTime'] = request.preloaded_end_time
        if not UtilClient.is_unset(request.preloaded_start_time):
            query['PreloadedStartTime'] = request.preloaded_start_time
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamPreloadTasks',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamPreloadTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_stream_preload_tasks(
        self,
        request: live_20161101_models.SetLiveStreamPreloadTasksRequest,
    ) -> live_20161101_models.SetLiveStreamPreloadTasksResponse:
        """
        @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
        
        @description    You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
        URLs in the HTTP Live Steaming (HLS) format are not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamPreloadTasksRequest
        @return: SetLiveStreamPreloadTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_stream_preload_tasks_with_options(request, runtime)

    async def set_live_stream_preload_tasks_async(
        self,
        request: live_20161101_models.SetLiveStreamPreloadTasksRequest,
    ) -> live_20161101_models.SetLiveStreamPreloadTasksResponse:
        """
        @summary Configures a prefetch task. You can specify multiple URLs to prefetch at a time.
        
        @description    You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
        URLs in the HTTP Live Steaming (HLS) format are not supported.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamPreloadTasksRequest
        @return: SetLiveStreamPreloadTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_stream_preload_tasks_with_options_async(request, runtime)

    def set_live_streams_notify_url_config_with_options(
        self,
        request: live_20161101_models.SetLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Configures stream ingest callbacks under an ingest domain.
        
        @description    You can call this operation to configure the callback URL and authentication information of an ingest domain.
        If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.exception_notify_url):
            query['ExceptionNotifyUrl'] = request.exception_notify_url
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.switch_notify_url):
            query['SwitchNotifyUrl'] = request.switch_notify_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_live_streams_notify_url_config_with_options_async(
        self,
        request: live_20161101_models.SetLiveStreamsNotifyUrlConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Configures stream ingest callbacks under an ingest domain.
        
        @description    You can call this operation to configure the callback URL and authentication information of an ingest domain.
        If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamsNotifyUrlConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetLiveStreamsNotifyUrlConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.exception_notify_url):
            query['ExceptionNotifyUrl'] = request.exception_notify_url
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.switch_notify_url):
            query['SwitchNotifyUrl'] = request.switch_notify_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetLiveStreamsNotifyUrlConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_live_streams_notify_url_config(
        self,
        request: live_20161101_models.SetLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Configures stream ingest callbacks under an ingest domain.
        
        @description    You can call this operation to configure the callback URL and authentication information of an ingest domain.
        If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamsNotifyUrlConfigRequest
        @return: SetLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_live_streams_notify_url_config_with_options(request, runtime)

    async def set_live_streams_notify_url_config_async(
        self,
        request: live_20161101_models.SetLiveStreamsNotifyUrlConfigRequest,
    ) -> live_20161101_models.SetLiveStreamsNotifyUrlConfigResponse:
        """
        @summary Configures stream ingest callbacks under an ingest domain.
        
        @description    You can call this operation to configure the callback URL and authentication information of an ingest domain.
        If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetLiveStreamsNotifyUrlConfigRequest
        @return: SetLiveStreamsNotifyUrlConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_live_streams_notify_url_config_with_options_async(request, runtime)

    def set_show_list_background_with_options(
        self,
        request: live_20161101_models.SetShowListBackgroundRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetShowListBackgroundResponse:
        """
        @summary Configures the background of the episode list.
        
        @description    Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetShowListBackgroundRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetShowListBackgroundResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.resource_url):
            query['ResourceUrl'] = request.resource_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetShowListBackground',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetShowListBackgroundResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_show_list_background_with_options_async(
        self,
        request: live_20161101_models.SetShowListBackgroundRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetShowListBackgroundResponse:
        """
        @summary Configures the background of the episode list.
        
        @description    Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetShowListBackgroundRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetShowListBackgroundResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.material_id):
            query['MaterialId'] = request.material_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.resource_url):
            query['ResourceUrl'] = request.resource_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetShowListBackground',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetShowListBackgroundResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_show_list_background(
        self,
        request: live_20161101_models.SetShowListBackgroundRequest,
    ) -> live_20161101_models.SetShowListBackgroundResponse:
        """
        @summary Configures the background of the episode list.
        
        @description    Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetShowListBackgroundRequest
        @return: SetShowListBackgroundResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_show_list_background_with_options(request, runtime)

    async def set_show_list_background_async(
        self,
        request: live_20161101_models.SetShowListBackgroundRequest,
    ) -> live_20161101_models.SetShowListBackgroundResponse:
        """
        @summary Configures the background of the episode list.
        
        @description    Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
        You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
        >
        When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
        When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetShowListBackgroundRequest
        @return: SetShowListBackgroundResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_show_list_background_with_options_async(request, runtime)

    def set_snapshot_callback_auth_with_options(
        self,
        request: live_20161101_models.SetSnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetSnapshotCallbackAuthResponse:
        """
        @summary Configures authentication for snapshot callbacks.
        
        @description    Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
        You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetSnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetSnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_auth_key):
            query['CallbackAuthKey'] = request.callback_auth_key
        if not UtilClient.is_unset(request.callback_req_auth):
            query['CallbackReqAuth'] = request.callback_req_auth
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetSnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetSnapshotCallbackAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_snapshot_callback_auth_with_options_async(
        self,
        request: live_20161101_models.SetSnapshotCallbackAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.SetSnapshotCallbackAuthResponse:
        """
        @summary Configures authentication for snapshot callbacks.
        
        @description    Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
        You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetSnapshotCallbackAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetSnapshotCallbackAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback_auth_key):
            query['CallbackAuthKey'] = request.callback_auth_key
        if not UtilClient.is_unset(request.callback_req_auth):
            query['CallbackReqAuth'] = request.callback_req_auth
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetSnapshotCallbackAuth',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.SetSnapshotCallbackAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_snapshot_callback_auth(
        self,
        request: live_20161101_models.SetSnapshotCallbackAuthRequest,
    ) -> live_20161101_models.SetSnapshotCallbackAuthResponse:
        """
        @summary Configures authentication for snapshot callbacks.
        
        @description    Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
        You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetSnapshotCallbackAuthRequest
        @return: SetSnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_snapshot_callback_auth_with_options(request, runtime)

    async def set_snapshot_callback_auth_async(
        self,
        request: live_20161101_models.SetSnapshotCallbackAuthRequest,
    ) -> live_20161101_models.SetSnapshotCallbackAuthResponse:
        """
        @summary Configures authentication for snapshot callbacks.
        
        @description    Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
        You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
        ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: SetSnapshotCallbackAuthRequest
        @return: SetSnapshotCallbackAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_snapshot_callback_auth_with_options_async(request, runtime)

    def start_caster_with_options(
        self,
        request: live_20161101_models.StartCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartCasterResponse:
        """
        @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_caster_with_options_async(
        self,
        request: live_20161101_models.StartCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartCasterResponse:
        """
        @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_caster(
        self,
        request: live_20161101_models.StartCasterRequest,
    ) -> live_20161101_models.StartCasterResponse:
        """
        @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterRequest
        @return: StartCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_caster_with_options(request, runtime)

    async def start_caster_async(
        self,
        request: live_20161101_models.StartCasterRequest,
    ) -> live_20161101_models.StartCasterResponse:
        """
        @summary Starts a production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterRequest
        @return: StartCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_caster_with_options_async(request, runtime)

    def start_caster_scene_with_options(
        self,
        request: live_20161101_models.StartCasterSceneRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartCasterSceneResponse:
        """
        @summary Starts a specified preview (PVW) scene.
        
        @description You can call this operation to start a specified PVW scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterSceneRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartCasterSceneResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartCasterScene',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartCasterSceneResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_caster_scene_with_options_async(
        self,
        request: live_20161101_models.StartCasterSceneRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartCasterSceneResponse:
        """
        @summary Starts a specified preview (PVW) scene.
        
        @description You can call this operation to start a specified PVW scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterSceneRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartCasterSceneResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartCasterScene',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartCasterSceneResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_caster_scene(
        self,
        request: live_20161101_models.StartCasterSceneRequest,
    ) -> live_20161101_models.StartCasterSceneResponse:
        """
        @summary Starts a specified preview (PVW) scene.
        
        @description You can call this operation to start a specified PVW scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterSceneRequest
        @return: StartCasterSceneResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_caster_scene_with_options(request, runtime)

    async def start_caster_scene_async(
        self,
        request: live_20161101_models.StartCasterSceneRequest,
    ) -> live_20161101_models.StartCasterSceneResponse:
        """
        @summary Starts a specified preview (PVW) scene.
        
        @description You can call this operation to start a specified PVW scene.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartCasterSceneRequest
        @return: StartCasterSceneResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_caster_scene_with_options_async(request, runtime)

    def start_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.StartEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartEdgeTranscodeJobResponse:
        """
        @summary Starts an edge transcoding task.
        
        @description    You can call this operation to start an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.StartEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartEdgeTranscodeJobResponse:
        """
        @summary Starts an edge transcoding task.
        
        @description    You can call this operation to start an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_edge_transcode_job(
        self,
        request: live_20161101_models.StartEdgeTranscodeJobRequest,
    ) -> live_20161101_models.StartEdgeTranscodeJobResponse:
        """
        @summary Starts an edge transcoding task.
        
        @description    You can call this operation to start an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartEdgeTranscodeJobRequest
        @return: StartEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_edge_transcode_job_with_options(request, runtime)

    async def start_edge_transcode_job_async(
        self,
        request: live_20161101_models.StartEdgeTranscodeJobRequest,
    ) -> live_20161101_models.StartEdgeTranscodeJobResponse:
        """
        @summary Starts an edge transcoding task.
        
        @description    You can call this operation to start an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartEdgeTranscodeJobRequest
        @return: StartEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_edge_transcode_job_with_options_async(request, runtime)

    def start_live_domain_with_options(
        self,
        request: live_20161101_models.StartLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveDomainResponse:
        """
        @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
        
        @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_live_domain_with_options_async(
        self,
        request: live_20161101_models.StartLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveDomainResponse:
        """
        @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
        
        @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_live_domain(
        self,
        request: live_20161101_models.StartLiveDomainRequest,
    ) -> live_20161101_models.StartLiveDomainResponse:
        """
        @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
        
        @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveDomainRequest
        @return: StartLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_live_domain_with_options(request, runtime)

    async def start_live_domain_async(
        self,
        request: live_20161101_models.StartLiveDomainRequest,
    ) -> live_20161101_models.StartLiveDomainResponse:
        """
        @summary Enables a disabled domain name. After the domain name is enabled, its status changes to online.
        
        @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveDomainRequest
        @return: StartLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_live_domain_with_options_async(request, runtime)

    def start_live_mputask_with_options(
        self,
        tmp_req: live_20161101_models.StartLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveMPUTaskResponse:
        """
        @summary Creates a mixed-stream relay task.
        
        @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
        ### [](#)Lifecycle of a stream relay task
        *Start**\
        Call the StartLiveMPUTask operation to create a task.
        If no user joins the channel, an error indicating that the channel does not exist is returned.
        Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
        If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
        We recommend that you record the task status, task mode, and task parameters on your business server.
        Task status: started or stopped.
        Task mode: single-stream relay or mixed-stream relay.
        Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
        In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
        If the task has not been automatically cleared by the system, the task is directly started.
        If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
        *End**\
        After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
        If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: StartLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveMPUTaskResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.StartLiveMPUTaskShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.multi_stream_url):
            request.multi_stream_urlshrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.multi_stream_url, 'MultiStreamURL', 'json')
        if not UtilClient.is_unset(tmp_req.sei_params):
            request.sei_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sei_params, 'SeiParams', 'json')
        if not UtilClient.is_unset(tmp_req.single_sub_params):
            request.single_sub_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.single_sub_params, 'SingleSubParams', 'json')
        if not UtilClient.is_unset(tmp_req.transcode_params):
            request.transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.transcode_params, 'TranscodeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.max_idle_time):
            query['MaxIdleTime'] = request.max_idle_time
        if not UtilClient.is_unset(request.mix_mode):
            query['MixMode'] = request.mix_mode
        if not UtilClient.is_unset(request.multi_stream_urlshrink):
            query['MultiStreamURL'] = request.multi_stream_urlshrink
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.sei_params_shrink):
            query['SeiParams'] = request.sei_params_shrink
        if not UtilClient.is_unset(request.single_sub_params_shrink):
            query['SingleSubParams'] = request.single_sub_params_shrink
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        if not UtilClient.is_unset(request.transcode_params_shrink):
            query['TranscodeParams'] = request.transcode_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveMPUTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_live_mputask_with_options_async(
        self,
        tmp_req: live_20161101_models.StartLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveMPUTaskResponse:
        """
        @summary Creates a mixed-stream relay task.
        
        @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
        ### [](#)Lifecycle of a stream relay task
        *Start**\
        Call the StartLiveMPUTask operation to create a task.
        If no user joins the channel, an error indicating that the channel does not exist is returned.
        Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
        If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
        We recommend that you record the task status, task mode, and task parameters on your business server.
        Task status: started or stopped.
        Task mode: single-stream relay or mixed-stream relay.
        Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
        In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
        If the task has not been automatically cleared by the system, the task is directly started.
        If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
        *End**\
        After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
        If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: StartLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveMPUTaskResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.StartLiveMPUTaskShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.multi_stream_url):
            request.multi_stream_urlshrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.multi_stream_url, 'MultiStreamURL', 'json')
        if not UtilClient.is_unset(tmp_req.sei_params):
            request.sei_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sei_params, 'SeiParams', 'json')
        if not UtilClient.is_unset(tmp_req.single_sub_params):
            request.single_sub_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.single_sub_params, 'SingleSubParams', 'json')
        if not UtilClient.is_unset(tmp_req.transcode_params):
            request.transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.transcode_params, 'TranscodeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.max_idle_time):
            query['MaxIdleTime'] = request.max_idle_time
        if not UtilClient.is_unset(request.mix_mode):
            query['MixMode'] = request.mix_mode
        if not UtilClient.is_unset(request.multi_stream_urlshrink):
            query['MultiStreamURL'] = request.multi_stream_urlshrink
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.sei_params_shrink):
            query['SeiParams'] = request.sei_params_shrink
        if not UtilClient.is_unset(request.single_sub_params_shrink):
            query['SingleSubParams'] = request.single_sub_params_shrink
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        if not UtilClient.is_unset(request.transcode_params_shrink):
            query['TranscodeParams'] = request.transcode_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveMPUTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_live_mputask(
        self,
        request: live_20161101_models.StartLiveMPUTaskRequest,
    ) -> live_20161101_models.StartLiveMPUTaskResponse:
        """
        @summary Creates a mixed-stream relay task.
        
        @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
        ### [](#)Lifecycle of a stream relay task
        *Start**\
        Call the StartLiveMPUTask operation to create a task.
        If no user joins the channel, an error indicating that the channel does not exist is returned.
        Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
        If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
        We recommend that you record the task status, task mode, and task parameters on your business server.
        Task status: started or stopped.
        Task mode: single-stream relay or mixed-stream relay.
        Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
        In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
        If the task has not been automatically cleared by the system, the task is directly started.
        If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
        *End**\
        After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
        If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveMPUTaskRequest
        @return: StartLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_live_mputask_with_options(request, runtime)

    async def start_live_mputask_async(
        self,
        request: live_20161101_models.StartLiveMPUTaskRequest,
    ) -> live_20161101_models.StartLiveMPUTaskResponse:
        """
        @summary Creates a mixed-stream relay task.
        
        @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
        ### [](#)Lifecycle of a stream relay task
        *Start**\
        Call the StartLiveMPUTask operation to create a task.
        If no user joins the channel, an error indicating that the channel does not exist is returned.
        Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
        If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
        We recommend that you record the task status, task mode, and task parameters on your business server.
        Task status: started or stopped.
        Task mode: single-stream relay or mixed-stream relay.
        Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
        In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
        If the task has not been automatically cleared by the system, the task is directly started.
        If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
        *End**\
        After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
        If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveMPUTaskRequest
        @return: StartLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_live_mputask_with_options_async(request, runtime)

    def start_live_stream_monitor_with_options(
        self,
        request: live_20161101_models.StartLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveStreamMonitorResponse:
        """
        @summary Starts live monitoring.
        
        @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveStreamMonitorResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_live_stream_monitor_with_options_async(
        self,
        request: live_20161101_models.StartLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartLiveStreamMonitorResponse:
        """
        @summary Starts live monitoring.
        
        @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartLiveStreamMonitorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_live_stream_monitor(
        self,
        request: live_20161101_models.StartLiveStreamMonitorRequest,
    ) -> live_20161101_models.StartLiveStreamMonitorResponse:
        """
        @summary Starts live monitoring.
        
        @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveStreamMonitorRequest
        @return: StartLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_live_stream_monitor_with_options(request, runtime)

    async def start_live_stream_monitor_async(
        self,
        request: live_20161101_models.StartLiveStreamMonitorRequest,
    ) -> live_20161101_models.StartLiveStreamMonitorResponse:
        """
        @summary Starts live monitoring.
        
        @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartLiveStreamMonitorRequest
        @return: StartLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_live_stream_monitor_with_options_async(request, runtime)

    def start_playlist_with_options(
        self,
        request: live_20161101_models.StartPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartPlaylistResponse:
        """
        @summary Starts playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resume_mode):
            query['ResumeMode'] = request.resume_mode
        if not UtilClient.is_unset(request.start_item_id):
            query['StartItemId'] = request.start_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartPlaylistResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_playlist_with_options_async(
        self,
        request: live_20161101_models.StartPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartPlaylistResponse:
        """
        @summary Starts playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.offset):
            query['Offset'] = request.offset
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resume_mode):
            query['ResumeMode'] = request.resume_mode
        if not UtilClient.is_unset(request.start_item_id):
            query['StartItemId'] = request.start_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartPlaylistResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_playlist(
        self,
        request: live_20161101_models.StartPlaylistRequest,
    ) -> live_20161101_models.StartPlaylistResponse:
        """
        @summary Starts playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartPlaylistRequest
        @return: StartPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_playlist_with_options(request, runtime)

    async def start_playlist_async(
        self,
        request: live_20161101_models.StartPlaylistRequest,
    ) -> live_20161101_models.StartPlaylistResponse:
        """
        @summary Starts playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StartPlaylistRequest
        @return: StartPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_playlist_with_options_async(request, runtime)

    def start_rtc_cloud_recording_with_options(
        self,
        tmp_req: live_20161101_models.StartRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param tmp_req: StartRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartRtcCloudRecordingResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.StartRtcCloudRecordingShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mix_layout_params):
            request.mix_layout_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_layout_params, 'MixLayoutParams', 'json')
        if not UtilClient.is_unset(tmp_req.mix_transcode_params):
            request.mix_transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_transcode_params, 'MixTranscodeParams', 'json')
        if not UtilClient.is_unset(tmp_req.record_params):
            request.record_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.record_params, 'RecordParams', 'json')
        if not UtilClient.is_unset(tmp_req.storage_params):
            request.storage_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.storage_params, 'StorageParams', 'json')
        if not UtilClient.is_unset(tmp_req.subscribe_params):
            request.subscribe_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.subscribe_params, 'SubscribeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.max_idle_time):
            query['MaxIdleTime'] = request.max_idle_time
        if not UtilClient.is_unset(request.mix_layout_params_shrink):
            query['MixLayoutParams'] = request.mix_layout_params_shrink
        if not UtilClient.is_unset(request.mix_transcode_params_shrink):
            query['MixTranscodeParams'] = request.mix_transcode_params_shrink
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.record_params_shrink):
            query['RecordParams'] = request.record_params_shrink
        if not UtilClient.is_unset(request.storage_params_shrink):
            query['StorageParams'] = request.storage_params_shrink
        if not UtilClient.is_unset(request.subscribe_params_shrink):
            query['SubscribeParams'] = request.subscribe_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartRtcCloudRecordingResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_rtc_cloud_recording_with_options_async(
        self,
        tmp_req: live_20161101_models.StartRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StartRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param tmp_req: StartRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartRtcCloudRecordingResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.StartRtcCloudRecordingShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mix_layout_params):
            request.mix_layout_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_layout_params, 'MixLayoutParams', 'json')
        if not UtilClient.is_unset(tmp_req.mix_transcode_params):
            request.mix_transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_transcode_params, 'MixTranscodeParams', 'json')
        if not UtilClient.is_unset(tmp_req.record_params):
            request.record_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.record_params, 'RecordParams', 'json')
        if not UtilClient.is_unset(tmp_req.storage_params):
            request.storage_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.storage_params, 'StorageParams', 'json')
        if not UtilClient.is_unset(tmp_req.subscribe_params):
            request.subscribe_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.subscribe_params, 'SubscribeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.max_idle_time):
            query['MaxIdleTime'] = request.max_idle_time
        if not UtilClient.is_unset(request.mix_layout_params_shrink):
            query['MixLayoutParams'] = request.mix_layout_params_shrink
        if not UtilClient.is_unset(request.mix_transcode_params_shrink):
            query['MixTranscodeParams'] = request.mix_transcode_params_shrink
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.record_params_shrink):
            query['RecordParams'] = request.record_params_shrink
        if not UtilClient.is_unset(request.storage_params_shrink):
            query['StorageParams'] = request.storage_params_shrink
        if not UtilClient.is_unset(request.subscribe_params_shrink):
            query['SubscribeParams'] = request.subscribe_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StartRtcCloudRecordingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_rtc_cloud_recording(
        self,
        request: live_20161101_models.StartRtcCloudRecordingRequest,
    ) -> live_20161101_models.StartRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StartRtcCloudRecordingRequest
        @return: StartRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_rtc_cloud_recording_with_options(request, runtime)

    async def start_rtc_cloud_recording_async(
        self,
        request: live_20161101_models.StartRtcCloudRecordingRequest,
    ) -> live_20161101_models.StartRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StartRtcCloudRecordingRequest
        @return: StartRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_rtc_cloud_recording_with_options_async(request, runtime)

    def stop_caster_with_options(
        self,
        request: live_20161101_models.StopCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopCasterResponse:
        """
        @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopCasterResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_caster_with_options_async(
        self,
        request: live_20161101_models.StopCasterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopCasterResponse:
        """
        @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopCasterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopCasterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopCaster',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopCasterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_caster(
        self,
        request: live_20161101_models.StopCasterRequest,
    ) -> live_20161101_models.StopCasterResponse:
        """
        @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopCasterRequest
        @return: StopCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_caster_with_options(request, runtime)

    async def stop_caster_async(
        self,
        request: live_20161101_models.StopCasterRequest,
    ) -> live_20161101_models.StopCasterResponse:
        """
        @summary Stops a production studio. This stops the PVW and PGM scenes of the production studio.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopCasterRequest
        @return: StopCasterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_caster_with_options_async(request, runtime)

    def stop_caster_scene_with_options(
        self,
        request: live_20161101_models.StopCasterSceneRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopCasterSceneResponse:
        """
        @summary Stops a specified preview scene.
        
        @description ## Usage note
        This operation is only applicable to the PVW scenes.
        
        @param request: StopCasterSceneRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopCasterSceneResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopCasterScene',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopCasterSceneResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_caster_scene_with_options_async(
        self,
        request: live_20161101_models.StopCasterSceneRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopCasterSceneResponse:
        """
        @summary Stops a specified preview scene.
        
        @description ## Usage note
        This operation is only applicable to the PVW scenes.
        
        @param request: StopCasterSceneRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopCasterSceneResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopCasterScene',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopCasterSceneResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_caster_scene(
        self,
        request: live_20161101_models.StopCasterSceneRequest,
    ) -> live_20161101_models.StopCasterSceneResponse:
        """
        @summary Stops a specified preview scene.
        
        @description ## Usage note
        This operation is only applicable to the PVW scenes.
        
        @param request: StopCasterSceneRequest
        @return: StopCasterSceneResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_caster_scene_with_options(request, runtime)

    async def stop_caster_scene_async(
        self,
        request: live_20161101_models.StopCasterSceneRequest,
    ) -> live_20161101_models.StopCasterSceneResponse:
        """
        @summary Stops a specified preview scene.
        
        @description ## Usage note
        This operation is only applicable to the PVW scenes.
        
        @param request: StopCasterSceneRequest
        @return: StopCasterSceneResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_caster_scene_with_options_async(request, runtime)

    def stop_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.StopEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopEdgeTranscodeJobResponse:
        """
        @summary Stops an edge transcoding task.
        
        @description    You can call this operation to stop an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.StopEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopEdgeTranscodeJobResponse:
        """
        @summary Stops an edge transcoding task.
        
        @description    You can call this operation to stop an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_edge_transcode_job(
        self,
        request: live_20161101_models.StopEdgeTranscodeJobRequest,
    ) -> live_20161101_models.StopEdgeTranscodeJobResponse:
        """
        @summary Stops an edge transcoding task.
        
        @description    You can call this operation to stop an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopEdgeTranscodeJobRequest
        @return: StopEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_edge_transcode_job_with_options(request, runtime)

    async def stop_edge_transcode_job_async(
        self,
        request: live_20161101_models.StopEdgeTranscodeJobRequest,
    ) -> live_20161101_models.StopEdgeTranscodeJobResponse:
        """
        @summary Stops an edge transcoding task.
        
        @description    You can call this operation to stop an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopEdgeTranscodeJobRequest
        @return: StopEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_edge_transcode_job_with_options_async(request, runtime)

    def stop_live_domain_with_options(
        self,
        request: live_20161101_models.StopLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveDomainResponse:
        """
        @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
        
        @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_live_domain_with_options_async(
        self,
        request: live_20161101_models.StopLiveDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveDomainResponse:
        """
        @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
        
        @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveDomain',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_live_domain(
        self,
        request: live_20161101_models.StopLiveDomainRequest,
    ) -> live_20161101_models.StopLiveDomainResponse:
        """
        @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
        
        @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveDomainRequest
        @return: StopLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_live_domain_with_options(request, runtime)

    async def stop_live_domain_async(
        self,
        request: live_20161101_models.StopLiveDomainRequest,
    ) -> live_20161101_models.StopLiveDomainResponse:
        """
        @summary Disables an enabled domain name. After the domain name is disabled, its status changes to offline.
        
        @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveDomainRequest
        @return: StopLiveDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_live_domain_with_options_async(request, runtime)

    def stop_live_mputask_with_options(
        self,
        request: live_20161101_models.StopLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveMPUTaskResponse:
        """
        @summary Stops a mixed-stream relay task.
        
        @description    Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
        If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveMPUTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveMPUTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_live_mputask_with_options_async(
        self,
        request: live_20161101_models.StopLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveMPUTaskResponse:
        """
        @summary Stops a mixed-stream relay task.
        
        @description    Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
        If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveMPUTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveMPUTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_live_mputask(
        self,
        request: live_20161101_models.StopLiveMPUTaskRequest,
    ) -> live_20161101_models.StopLiveMPUTaskResponse:
        """
        @summary Stops a mixed-stream relay task.
        
        @description    Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
        If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveMPUTaskRequest
        @return: StopLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_live_mputask_with_options(request, runtime)

    async def stop_live_mputask_async(
        self,
        request: live_20161101_models.StopLiveMPUTaskRequest,
    ) -> live_20161101_models.StopLiveMPUTaskResponse:
        """
        @summary Stops a mixed-stream relay task.
        
        @description    Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
        If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveMPUTaskRequest
        @return: StopLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_live_mputask_with_options_async(request, runtime)

    def stop_live_pull_to_push_with_options(
        self,
        request: live_20161101_models.StopLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLivePullToPushResponse:
        """
        @summary Stops a pulled-stream relay task.
        
        @description    You can call this operation to stop a pulled-stream relay task.
        You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_live_pull_to_push_with_options_async(
        self,
        request: live_20161101_models.StopLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLivePullToPushResponse:
        """
        @summary Stops a pulled-stream relay task.
        
        @description    You can call this operation to stop a pulled-stream relay task.
        You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLivePullToPushResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_live_pull_to_push(
        self,
        request: live_20161101_models.StopLivePullToPushRequest,
    ) -> live_20161101_models.StopLivePullToPushResponse:
        """
        @summary Stops a pulled-stream relay task.
        
        @description    You can call this operation to stop a pulled-stream relay task.
        You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLivePullToPushRequest
        @return: StopLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_live_pull_to_push_with_options(request, runtime)

    async def stop_live_pull_to_push_async(
        self,
        request: live_20161101_models.StopLivePullToPushRequest,
    ) -> live_20161101_models.StopLivePullToPushResponse:
        """
        @summary Stops a pulled-stream relay task.
        
        @description    You can call this operation to stop a pulled-stream relay task.
        You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLivePullToPushRequest
        @return: StopLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_live_pull_to_push_with_options_async(request, runtime)

    def stop_live_stream_monitor_with_options(
        self,
        request: live_20161101_models.StopLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveStreamMonitorResponse:
        """
        @summary Stops live monitoring.
        
        @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveStreamMonitorResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_live_stream_monitor_with_options_async(
        self,
        request: live_20161101_models.StopLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopLiveStreamMonitorResponse:
        """
        @summary Stops live monitoring.
        
        @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopLiveStreamMonitorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_live_stream_monitor(
        self,
        request: live_20161101_models.StopLiveStreamMonitorRequest,
    ) -> live_20161101_models.StopLiveStreamMonitorResponse:
        """
        @summary Stops live monitoring.
        
        @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveStreamMonitorRequest
        @return: StopLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_live_stream_monitor_with_options(request, runtime)

    async def stop_live_stream_monitor_async(
        self,
        request: live_20161101_models.StopLiveStreamMonitorRequest,
    ) -> live_20161101_models.StopLiveStreamMonitorResponse:
        """
        @summary Stops live monitoring.
        
        @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter *MonitorId**, and then start live monitoring.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopLiveStreamMonitorRequest
        @return: StopLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_live_stream_monitor_with_options_async(request, runtime)

    def stop_playlist_with_options(
        self,
        request: live_20161101_models.StopPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopPlaylistResponse:
        """
        @summary Stops playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopPlaylistResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_playlist_with_options_async(
        self,
        request: live_20161101_models.StopPlaylistRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopPlaylistResponse:
        """
        @summary Stops playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopPlaylistRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopPlaylistResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.program_id):
            query['ProgramId'] = request.program_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopPlaylist',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopPlaylistResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_playlist(
        self,
        request: live_20161101_models.StopPlaylistRequest,
    ) -> live_20161101_models.StopPlaylistResponse:
        """
        @summary Stops playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopPlaylistRequest
        @return: StopPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_playlist_with_options(request, runtime)

    async def stop_playlist_async(
        self,
        request: live_20161101_models.StopPlaylistRequest,
    ) -> live_20161101_models.StopPlaylistResponse:
        """
        @summary Stops playing an episode list.
        
        @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopPlaylistRequest
        @return: StopPlaylistResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_playlist_with_options_async(request, runtime)

    def stop_rtc_asr_task_with_options(
        self,
        request: live_20161101_models.StopRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopRtcAsrTaskResponse:
        """
        @summary Stops a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopRtcAsrTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_rtc_asr_task_with_options_async(
        self,
        request: live_20161101_models.StopRtcAsrTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopRtcAsrTaskResponse:
        """
        @summary Stops a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopRtcAsrTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopRtcAsrTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopRtcAsrTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopRtcAsrTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_rtc_asr_task(
        self,
        request: live_20161101_models.StopRtcAsrTaskRequest,
    ) -> live_20161101_models.StopRtcAsrTaskResponse:
        """
        @summary Stops a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopRtcAsrTaskRequest
        @return: StopRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_rtc_asr_task_with_options(request, runtime)

    async def stop_rtc_asr_task_async(
        self,
        request: live_20161101_models.StopRtcAsrTaskRequest,
    ) -> live_20161101_models.StopRtcAsrTaskResponse:
        """
        @summary Stops a live subtitle task.
        
        @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: StopRtcAsrTaskRequest
        @return: StopRtcAsrTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_rtc_asr_task_with_options_async(request, runtime)

    def stop_rtc_cloud_recording_with_options(
        self,
        request: live_20161101_models.StopRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StopRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopRtcCloudRecordingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopRtcCloudRecordingResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_rtc_cloud_recording_with_options_async(
        self,
        request: live_20161101_models.StopRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.StopRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StopRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopRtcCloudRecordingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.StopRtcCloudRecordingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_rtc_cloud_recording(
        self,
        request: live_20161101_models.StopRtcCloudRecordingRequest,
    ) -> live_20161101_models.StopRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StopRtcCloudRecordingRequest
        @return: StopRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_rtc_cloud_recording_with_options(request, runtime)

    async def stop_rtc_cloud_recording_async(
        self,
        request: live_20161101_models.StopRtcCloudRecordingRequest,
    ) -> live_20161101_models.StopRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: StopRtcCloudRecordingRequest
        @return: StopRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_rtc_cloud_recording_with_options_async(request, runtime)

    def tag_live_resources_with_options(
        self,
        request: live_20161101_models.TagLiveResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.TagLiveResourcesResponse:
        """
        @summary The N tags that you want to add for the resource.
        
        @description The key of the tag. Valid values of N: *1 to 20**.
        
        @param request: TagLiveResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagLiveResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagLiveResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.TagLiveResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_live_resources_with_options_async(
        self,
        request: live_20161101_models.TagLiveResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.TagLiveResourcesResponse:
        """
        @summary The N tags that you want to add for the resource.
        
        @description The key of the tag. Valid values of N: *1 to 20**.
        
        @param request: TagLiveResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagLiveResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagLiveResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.TagLiveResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_live_resources(
        self,
        request: live_20161101_models.TagLiveResourcesRequest,
    ) -> live_20161101_models.TagLiveResourcesResponse:
        """
        @summary The N tags that you want to add for the resource.
        
        @description The key of the tag. Valid values of N: *1 to 20**.
        
        @param request: TagLiveResourcesRequest
        @return: TagLiveResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_live_resources_with_options(request, runtime)

    async def tag_live_resources_async(
        self,
        request: live_20161101_models.TagLiveResourcesRequest,
    ) -> live_20161101_models.TagLiveResourcesResponse:
        """
        @summary The N tags that you want to add for the resource.
        
        @description The key of the tag. Valid values of N: *1 to 20**.
        
        @param request: TagLiveResourcesRequest
        @return: TagLiveResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_live_resources_with_options_async(request, runtime)

    def un_tag_live_resources_with_options(
        self,
        request: live_20161101_models.UnTagLiveResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UnTagLiveResourcesResponse:
        """
        @summary 
        
        @param request: UnTagLiveResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagLiveResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagLiveResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UnTagLiveResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def un_tag_live_resources_with_options_async(
        self,
        request: live_20161101_models.UnTagLiveResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UnTagLiveResourcesResponse:
        """
        @summary 
        
        @param request: UnTagLiveResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagLiveResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagLiveResources',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UnTagLiveResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def un_tag_live_resources(
        self,
        request: live_20161101_models.UnTagLiveResourcesRequest,
    ) -> live_20161101_models.UnTagLiveResourcesResponse:
        """
        @summary 
        
        @param request: UnTagLiveResourcesRequest
        @return: UnTagLiveResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.un_tag_live_resources_with_options(request, runtime)

    async def un_tag_live_resources_async(
        self,
        request: live_20161101_models.UnTagLiveResourcesRequest,
    ) -> live_20161101_models.UnTagLiveResourcesResponse:
        """
        @summary 
        
        @param request: UnTagLiveResourcesRequest
        @return: UnTagLiveResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.un_tag_live_resources_with_options_async(request, runtime)

    def unban_live_message_group_with_options(
        self,
        request: live_20161101_models.UnbanLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UnbanLiveMessageGroupResponse:
        """
        @summary Unmutes a group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UnbanLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnbanLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnbanLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UnbanLiveMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def unban_live_message_group_with_options_async(
        self,
        request: live_20161101_models.UnbanLiveMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UnbanLiveMessageGroupResponse:
        """
        @summary Unmutes a group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UnbanLiveMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnbanLiveMessageGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.data_center):
            query['DataCenter'] = request.data_center
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnbanLiveMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UnbanLiveMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def unban_live_message_group(
        self,
        request: live_20161101_models.UnbanLiveMessageGroupRequest,
    ) -> live_20161101_models.UnbanLiveMessageGroupResponse:
        """
        @summary Unmutes a group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UnbanLiveMessageGroupRequest
        @return: UnbanLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.unban_live_message_group_with_options(request, runtime)

    async def unban_live_message_group_async(
        self,
        request: live_20161101_models.UnbanLiveMessageGroupRequest,
    ) -> live_20161101_models.UnbanLiveMessageGroupResponse:
        """
        @summary Unmutes a group.
        
        @description    Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
        If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UnbanLiveMessageGroupRequest
        @return: UnbanLiveMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.unban_live_message_group_with_options_async(request, runtime)

    def update_caster_resource_group_with_options(
        self,
        request: live_20161101_models.UpdateCasterResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterResourceGroupResponse:
        """
        @summary Changes the resource group to which a production studio belongs.
        
        @description ## [](#)Usage notes
        To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateCasterResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterResourceGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_caster_resource_group_with_options_async(
        self,
        request: live_20161101_models.UpdateCasterResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterResourceGroupResponse:
        """
        @summary Changes the resource group to which a production studio belongs.
        
        @description ## [](#)Usage notes
        To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateCasterResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.new_resource_group_id):
            query['NewResourceGroupId'] = request.new_resource_group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterResourceGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_caster_resource_group(
        self,
        request: live_20161101_models.UpdateCasterResourceGroupRequest,
    ) -> live_20161101_models.UpdateCasterResourceGroupResponse:
        """
        @summary Changes the resource group to which a production studio belongs.
        
        @description ## [](#)Usage notes
        To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateCasterResourceGroupRequest
        @return: UpdateCasterResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_caster_resource_group_with_options(request, runtime)

    async def update_caster_resource_group_async(
        self,
        request: live_20161101_models.UpdateCasterResourceGroupRequest,
    ) -> live_20161101_models.UpdateCasterResourceGroupResponse:
        """
        @summary Changes the resource group to which a production studio belongs.
        
        @description ## [](#)Usage notes
        To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateCasterResourceGroupRequest
        @return: UpdateCasterResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_caster_resource_group_with_options_async(request, runtime)

    def update_caster_scene_audio_with_options(
        self,
        request: live_20161101_models.UpdateCasterSceneAudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterSceneAudioResponse:
        """
        @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneAudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterSceneAudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.follow_enable):
            query['FollowEnable'] = request.follow_enable
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterSceneAudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterSceneAudioResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_caster_scene_audio_with_options_async(
        self,
        request: live_20161101_models.UpdateCasterSceneAudioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterSceneAudioResponse:
        """
        @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneAudioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterSceneAudioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audio_layer):
            query['AudioLayer'] = request.audio_layer
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.follow_enable):
            query['FollowEnable'] = request.follow_enable
        if not UtilClient.is_unset(request.mix_list):
            query['MixList'] = request.mix_list
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterSceneAudio',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterSceneAudioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_caster_scene_audio(
        self,
        request: live_20161101_models.UpdateCasterSceneAudioRequest,
    ) -> live_20161101_models.UpdateCasterSceneAudioResponse:
        """
        @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneAudioRequest
        @return: UpdateCasterSceneAudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_caster_scene_audio_with_options(request, runtime)

    async def update_caster_scene_audio_async(
        self,
        request: live_20161101_models.UpdateCasterSceneAudioRequest,
    ) -> live_20161101_models.UpdateCasterSceneAudioResponse:
        """
        @summary Modifies the audio configurations of a scene. This operation also allows you to add an audio configuration or apply an existing audio configuration to a new scene.
        
        @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneAudioRequest
        @return: UpdateCasterSceneAudioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_caster_scene_audio_with_options_async(request, runtime)

    def update_caster_scene_config_with_options(
        self,
        request: live_20161101_models.UpdateCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterSceneConfigResponse:
        """
        @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        
        @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterSceneConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_caster_scene_config_with_options_async(
        self,
        request: live_20161101_models.UpdateCasterSceneConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCasterSceneConfigResponse:
        """
        @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        
        @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCasterSceneConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.caster_id):
            query['CasterId'] = request.caster_id
        if not UtilClient.is_unset(request.component_id):
            query['ComponentId'] = request.component_id
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene_id):
            query['SceneId'] = request.scene_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCasterSceneConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCasterSceneConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_caster_scene_config(
        self,
        request: live_20161101_models.UpdateCasterSceneConfigRequest,
    ) -> live_20161101_models.UpdateCasterSceneConfigResponse:
        """
        @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        
        @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneConfigRequest
        @return: UpdateCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_caster_scene_config_with_options(request, runtime)

    async def update_caster_scene_config_async(
        self,
        request: live_20161101_models.UpdateCasterSceneConfigRequest,
    ) -> live_20161101_models.UpdateCasterSceneConfigResponse:
        """
        @summary Modifies a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        
        @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateCasterSceneConfigRequest
        @return: UpdateCasterSceneConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_caster_scene_config_with_options_async(request, runtime)

    def update_custom_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.UpdateCustomLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCustomLiveStreamTranscodeResponse:
        """
        @summary Updates a custom transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: custom H.264 standard transcoding.
        h264-nbhd: custom H.264 Narrowband HD transcoding.
        h265: custom H.265 standard transcoding.
        h265-nbhd: custom H.265 Narrowband HD transcoding.
        audio: audio-only transcoding.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account.
        
        @param request: UpdateCustomLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCustomLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.bitrate_with_source):
            query['BitrateWithSource'] = request.bitrate_with_source
        if not UtilClient.is_unset(request.de_interlaced):
            query['DeInterlaced'] = request.de_interlaced
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.ext_with_source):
            query['ExtWithSource'] = request.ext_with_source
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.fps_with_source):
            query['FpsWithSource'] = request.fps_with_source
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.res_with_source):
            query['ResWithSource'] = request.res_with_source
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCustomLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCustomLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_custom_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.UpdateCustomLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateCustomLiveStreamTranscodeResponse:
        """
        @summary Updates a custom transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: custom H.264 standard transcoding.
        h264-nbhd: custom H.264 Narrowband HD transcoding.
        h265: custom H.265 standard transcoding.
        h265-nbhd: custom H.265 Narrowband HD transcoding.
        audio: audio-only transcoding.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account.
        
        @param request: UpdateCustomLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCustomLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.bitrate_with_source):
            query['BitrateWithSource'] = request.bitrate_with_source
        if not UtilClient.is_unset(request.de_interlaced):
            query['DeInterlaced'] = request.de_interlaced
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.ext_with_source):
            query['ExtWithSource'] = request.ext_with_source
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.fps_with_source):
            query['FpsWithSource'] = request.fps_with_source
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.res_with_source):
            query['ResWithSource'] = request.res_with_source
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCustomLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateCustomLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_custom_live_stream_transcode(
        self,
        request: live_20161101_models.UpdateCustomLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateCustomLiveStreamTranscodeResponse:
        """
        @summary Updates a custom transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: custom H.264 standard transcoding.
        h264-nbhd: custom H.264 Narrowband HD transcoding.
        h265: custom H.265 standard transcoding.
        h265-nbhd: custom H.265 Narrowband HD transcoding.
        audio: audio-only transcoding.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account.
        
        @param request: UpdateCustomLiveStreamTranscodeRequest
        @return: UpdateCustomLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_custom_live_stream_transcode_with_options(request, runtime)

    async def update_custom_live_stream_transcode_async(
        self,
        request: live_20161101_models.UpdateCustomLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateCustomLiveStreamTranscodeResponse:
        """
        @summary Updates a custom transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates:
        h264: custom H.264 standard transcoding.
        h264-nbhd: custom H.264 Narrowband HD transcoding.
        h265: custom H.265 standard transcoding.
        h265-nbhd: custom H.265 Narrowband HD transcoding.
        audio: audio-only transcoding.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account.
        
        @param request: UpdateCustomLiveStreamTranscodeRequest
        @return: UpdateCustomLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_custom_live_stream_transcode_with_options_async(request, runtime)

    def update_edge_transcode_job_with_options(
        self,
        request: live_20161101_models.UpdateEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateEdgeTranscodeJobResponse:
        """
        @summary Updates an edge transcoding task.
        
        @description    You can call this operation to update an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_input):
            query['StreamInput'] = request.stream_input
        if not UtilClient.is_unset(request.stream_output):
            query['StreamOutput'] = request.stream_output
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateEdgeTranscodeJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_edge_transcode_job_with_options_async(
        self,
        request: live_20161101_models.UpdateEdgeTranscodeJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateEdgeTranscodeJobResponse:
        """
        @summary Updates an edge transcoding task.
        
        @description    You can call this operation to update an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEdgeTranscodeJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEdgeTranscodeJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['ClusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_input):
            query['StreamInput'] = request.stream_input
        if not UtilClient.is_unset(request.stream_output):
            query['StreamOutput'] = request.stream_output
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEdgeTranscodeJob',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateEdgeTranscodeJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_edge_transcode_job(
        self,
        request: live_20161101_models.UpdateEdgeTranscodeJobRequest,
    ) -> live_20161101_models.UpdateEdgeTranscodeJobResponse:
        """
        @summary Updates an edge transcoding task.
        
        @description    You can call this operation to update an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEdgeTranscodeJobRequest
        @return: UpdateEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_edge_transcode_job_with_options(request, runtime)

    async def update_edge_transcode_job_async(
        self,
        request: live_20161101_models.UpdateEdgeTranscodeJobRequest,
    ) -> live_20161101_models.UpdateEdgeTranscodeJobResponse:
        """
        @summary Updates an edge transcoding task.
        
        @description    You can call this operation to update an edge transcoding task.
        To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
        ## [](#qps-)QPS limit
        You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEdgeTranscodeJobRequest
        @return: UpdateEdgeTranscodeJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_edge_transcode_job_with_options_async(request, runtime)

    def update_event_sub_with_options(
        self,
        request: live_20161101_models.UpdateEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateEventSubResponse:
        """
        @summary Updates a callback that is used to subscribe to channel or user events.
        
        @description    Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
        If you only want to update specific parameters, you must also specify the other required parameters with their original values.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.events):
            query['Events'] = request.events
        if not UtilClient.is_unset(request.subscribe_id):
            query['SubscribeId'] = request.subscribe_id
        if not UtilClient.is_unset(request.users):
            query['Users'] = request.users
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_event_sub_with_options_async(
        self,
        request: live_20161101_models.UpdateEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateEventSubResponse:
        """
        @summary Updates a callback that is used to subscribe to channel or user events.
        
        @description    Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
        If you only want to update specific parameters, you must also specify the other required parameters with their original values.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.events):
            query['Events'] = request.events
        if not UtilClient.is_unset(request.subscribe_id):
            query['SubscribeId'] = request.subscribe_id
        if not UtilClient.is_unset(request.users):
            query['Users'] = request.users
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_event_sub(
        self,
        request: live_20161101_models.UpdateEventSubRequest,
    ) -> live_20161101_models.UpdateEventSubResponse:
        """
        @summary Updates a callback that is used to subscribe to channel or user events.
        
        @description    Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
        If you only want to update specific parameters, you must also specify the other required parameters with their original values.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEventSubRequest
        @return: UpdateEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_event_sub_with_options(request, runtime)

    async def update_event_sub_async(
        self,
        request: live_20161101_models.UpdateEventSubRequest,
    ) -> live_20161101_models.UpdateEventSubResponse:
        """
        @summary Updates a callback that is used to subscribe to channel or user events.
        
        @description    Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
        An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
        If you only want to update specific parameters, you must also specify the other required parameters with their original values.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateEventSubRequest
        @return: UpdateEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_event_sub_with_options_async(request, runtime)

    def update_live_aiproduce_rules_with_options(
        self,
        request: live_20161101_models.UpdateLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAIProduceRulesResponse:
        """
        @summary Updates a subtitle rule.
        
        @description You can call this operation to modify the parameters of a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.is_lazy):
            query['IsLazy'] = request.is_lazy
        if not UtilClient.is_unset(request.live_template):
            query['LiveTemplate'] = request.live_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.suffix):
            query['Suffix'] = request.suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAIProduceRulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_aiproduce_rules_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveAIProduceRulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAIProduceRulesResponse:
        """
        @summary Updates a subtitle rule.
        
        @description You can call this operation to modify the parameters of a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAIProduceRulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAIProduceRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.is_lazy):
            query['IsLazy'] = request.is_lazy
        if not UtilClient.is_unset(request.live_template):
            query['LiveTemplate'] = request.live_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rules_id):
            query['RulesId'] = request.rules_id
        if not UtilClient.is_unset(request.studio_name):
            query['StudioName'] = request.studio_name
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.suffix):
            query['Suffix'] = request.suffix
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAIProduceRules',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAIProduceRulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_aiproduce_rules(
        self,
        request: live_20161101_models.UpdateLiveAIProduceRulesRequest,
    ) -> live_20161101_models.UpdateLiveAIProduceRulesResponse:
        """
        @summary Updates a subtitle rule.
        
        @description You can call this operation to modify the parameters of a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAIProduceRulesRequest
        @return: UpdateLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_aiproduce_rules_with_options(request, runtime)

    async def update_live_aiproduce_rules_async(
        self,
        request: live_20161101_models.UpdateLiveAIProduceRulesRequest,
    ) -> live_20161101_models.UpdateLiveAIProduceRulesResponse:
        """
        @summary Updates a subtitle rule.
        
        @description You can call this operation to modify the parameters of a specified subtitle rule.
        >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAIProduceRulesRequest
        @return: UpdateLiveAIProduceRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_aiproduce_rules_with_options_async(request, runtime)

    def update_live_aisubtitle_with_options(
        self,
        tmp_req: live_20161101_models.UpdateLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAISubtitleResponse:
        """
        @summary Updates a subtitle template.
        
        @param tmp_req: UpdateLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAISubtitleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLiveAISubtitleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.position_normalized):
            request.position_normalized_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.position_normalized, 'PositionNormalized', 'json')
        query = {}
        if not UtilClient.is_unset(request.bg_color):
            query['BgColor'] = request.bg_color
        if not UtilClient.is_unset(request.bg_width_normalized):
            query['BgWidthNormalized'] = request.bg_width_normalized
        if not UtilClient.is_unset(request.border_width_normalized):
            query['BorderWidthNormalized'] = request.border_width_normalized
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dst_language):
            query['DstLanguage'] = request.dst_language
        if not UtilClient.is_unset(request.font_color):
            query['FontColor'] = request.font_color
        if not UtilClient.is_unset(request.font_name):
            query['FontName'] = request.font_name
        if not UtilClient.is_unset(request.font_size_normalized):
            query['FontSizeNormalized'] = request.font_size_normalized
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.max_lines):
            query['MaxLines'] = request.max_lines
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position_normalized_shrink):
            query['PositionNormalized'] = request.position_normalized_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_source_lan):
            query['ShowSourceLan'] = request.show_source_lan
        if not UtilClient.is_unset(request.src_language):
            query['SrcLanguage'] = request.src_language
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        if not UtilClient.is_unset(request.word_per_line):
            query['WordPerLine'] = request.word_per_line
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAISubtitleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_aisubtitle_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateLiveAISubtitleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAISubtitleResponse:
        """
        @summary Updates a subtitle template.
        
        @param tmp_req: UpdateLiveAISubtitleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAISubtitleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLiveAISubtitleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.position_normalized):
            request.position_normalized_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.position_normalized, 'PositionNormalized', 'json')
        query = {}
        if not UtilClient.is_unset(request.bg_color):
            query['BgColor'] = request.bg_color
        if not UtilClient.is_unset(request.bg_width_normalized):
            query['BgWidthNormalized'] = request.bg_width_normalized
        if not UtilClient.is_unset(request.border_width_normalized):
            query['BorderWidthNormalized'] = request.border_width_normalized
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dst_language):
            query['DstLanguage'] = request.dst_language
        if not UtilClient.is_unset(request.font_color):
            query['FontColor'] = request.font_color
        if not UtilClient.is_unset(request.font_name):
            query['FontName'] = request.font_name
        if not UtilClient.is_unset(request.font_size_normalized):
            query['FontSizeNormalized'] = request.font_size_normalized
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.max_lines):
            query['MaxLines'] = request.max_lines
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position_normalized_shrink):
            query['PositionNormalized'] = request.position_normalized_shrink
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.show_source_lan):
            query['ShowSourceLan'] = request.show_source_lan
        if not UtilClient.is_unset(request.src_language):
            query['SrcLanguage'] = request.src_language
        if not UtilClient.is_unset(request.subtitle_id):
            query['SubtitleId'] = request.subtitle_id
        if not UtilClient.is_unset(request.subtitle_name):
            query['SubtitleName'] = request.subtitle_name
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        if not UtilClient.is_unset(request.word_per_line):
            query['WordPerLine'] = request.word_per_line
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAISubtitle',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAISubtitleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_aisubtitle(
        self,
        request: live_20161101_models.UpdateLiveAISubtitleRequest,
    ) -> live_20161101_models.UpdateLiveAISubtitleResponse:
        """
        @summary Updates a subtitle template.
        
        @param request: UpdateLiveAISubtitleRequest
        @return: UpdateLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_aisubtitle_with_options(request, runtime)

    async def update_live_aisubtitle_async(
        self,
        request: live_20161101_models.UpdateLiveAISubtitleRequest,
    ) -> live_20161101_models.UpdateLiveAISubtitleResponse:
        """
        @summary Updates a subtitle template.
        
        @param request: UpdateLiveAISubtitleRequest
        @return: UpdateLiveAISubtitleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_aisubtitle_with_options_async(request, runtime)

    def update_live_app_record_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAppRecordConfigResponse:
        """
        @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
        
        @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_format):
            query['RecordFormat'] = request.record_format
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcode_record_format):
            query['TranscodeRecordFormat'] = request.transcode_record_format
        if not UtilClient.is_unset(request.transcode_templates):
            query['TranscodeTemplates'] = request.transcode_templates
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAppRecordConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_app_record_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveAppRecordConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAppRecordConfigResponse:
        """
        @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
        
        @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppRecordConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAppRecordConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.record_format):
            query['RecordFormat'] = request.record_format
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transcode_record_format):
            query['TranscodeRecordFormat'] = request.transcode_record_format
        if not UtilClient.is_unset(request.transcode_templates):
            query['TranscodeTemplates'] = request.transcode_templates
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAppRecordConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAppRecordConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_app_record_config(
        self,
        request: live_20161101_models.UpdateLiveAppRecordConfigRequest,
    ) -> live_20161101_models.UpdateLiveAppRecordConfigResponse:
        """
        @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
        
        @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppRecordConfigRequest
        @return: UpdateLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_app_record_config_with_options(request, runtime)

    async def update_live_app_record_config_async(
        self,
        request: live_20161101_models.UpdateLiveAppRecordConfigRequest,
    ) -> live_20161101_models.UpdateLiveAppRecordConfigResponse:
        """
        @summary Updates a recording configuration for an application. The recordings are stored in Object Storage Service (OSS).
        
        @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppRecordConfigRequest
        @return: UpdateLiveAppRecordConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_app_record_config_with_options_async(request, runtime)

    def update_live_app_snapshot_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAppSnapshotConfigResponse:
        """
        @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
        
        @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.overwrite_oss_object):
            query['OverwriteOssObject'] = request.overwrite_oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sequence_oss_object):
            query['SequenceOssObject'] = request.sequence_oss_object
        if not UtilClient.is_unset(request.time_interval):
            query['TimeInterval'] = request.time_interval
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAppSnapshotConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_app_snapshot_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveAppSnapshotConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAppSnapshotConfigResponse:
        """
        @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
        
        @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppSnapshotConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAppSnapshotConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.overwrite_oss_object):
            query['OverwriteOssObject'] = request.overwrite_oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sequence_oss_object):
            query['SequenceOssObject'] = request.sequence_oss_object
        if not UtilClient.is_unset(request.time_interval):
            query['TimeInterval'] = request.time_interval
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAppSnapshotConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAppSnapshotConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_app_snapshot_config(
        self,
        request: live_20161101_models.UpdateLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.UpdateLiveAppSnapshotConfigResponse:
        """
        @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
        
        @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppSnapshotConfigRequest
        @return: UpdateLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_app_snapshot_config_with_options(request, runtime)

    async def update_live_app_snapshot_config_async(
        self,
        request: live_20161101_models.UpdateLiveAppSnapshotConfigRequest,
    ) -> live_20161101_models.UpdateLiveAppSnapshotConfigResponse:
        """
        @summary Modifies a snapshot configuration of a streaming domain. The captured snapshots are stored in Object Storage Service (OSS). The modification takes effect after you restart stream ingest.
        
        @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAppSnapshotConfigRequest
        @return: UpdateLiveAppSnapshotConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_app_snapshot_config_with_options_async(request, runtime)

    def update_live_audio_audit_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAudioAuditConfigResponse:
        """
        @summary Modifies an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAudioAuditConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_audio_audit_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAudioAuditConfigResponse:
        """
        @summary Modifies an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAudioAuditConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAudioAuditConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.biz_type):
            query['BizType'] = request.biz_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAudioAuditConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAudioAuditConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_audio_audit_config(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.UpdateLiveAudioAuditConfigResponse:
        """
        @summary Modifies an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAudioAuditConfigRequest
        @return: UpdateLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_audio_audit_config_with_options(request, runtime)

    async def update_live_audio_audit_config_async(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditConfigRequest,
    ) -> live_20161101_models.UpdateLiveAudioAuditConfigResponse:
        """
        @summary Modifies an audio moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveAudioAuditConfigRequest
        @return: UpdateLiveAudioAuditConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_audio_audit_config_with_options_async(request, runtime)

    def update_live_audio_audit_notify_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for audio moderation results.
        
        @param request: UpdateLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.callback_template):
            query['CallbackTemplate'] = request.callback_template
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_audio_audit_notify_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for audio moderation results.
        
        @param request: UpdateLiveAudioAuditNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveAudioAuditNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.callback):
            query['Callback'] = request.callback
        if not UtilClient.is_unset(request.callback_template):
            query['CallbackTemplate'] = request.callback_template
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveAudioAuditNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_audio_audit_notify_config(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for audio moderation results.
        
        @param request: UpdateLiveAudioAuditNotifyConfigRequest
        @return: UpdateLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_audio_audit_notify_config_with_options(request, runtime)

    async def update_live_audio_audit_notify_config_async(
        self,
        request: live_20161101_models.UpdateLiveAudioAuditNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveAudioAuditNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for audio moderation results.
        
        @param request: UpdateLiveAudioAuditNotifyConfigRequest
        @return: UpdateLiveAudioAuditNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_audio_audit_notify_config_with_options_async(request, runtime)

    def update_live_center_transfer_with_options(
        self,
        request: live_20161101_models.UpdateLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveCenterTransferResponse:
        """
        @summary Modifies the configurations of live center stream relay.
        
        @description You can call this operation to modify only the *time-related** parameters, including TransferArgs, StartTime, and EndTime.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveCenterTransferResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_center_transfer_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveCenterTransferRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveCenterTransferResponse:
        """
        @summary Modifies the configurations of live center stream relay.
        
        @description You can call this operation to modify only the *time-related** parameters, including TransferArgs, StartTime, and EndTime.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveCenterTransferRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveCenterTransferResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.dst_url):
            query['DstUrl'] = request.dst_url
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.transfer_args):
            query['TransferArgs'] = request.transfer_args
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveCenterTransfer',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveCenterTransferResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_center_transfer(
        self,
        request: live_20161101_models.UpdateLiveCenterTransferRequest,
    ) -> live_20161101_models.UpdateLiveCenterTransferResponse:
        """
        @summary Modifies the configurations of live center stream relay.
        
        @description You can call this operation to modify only the *time-related** parameters, including TransferArgs, StartTime, and EndTime.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveCenterTransferRequest
        @return: UpdateLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_center_transfer_with_options(request, runtime)

    async def update_live_center_transfer_async(
        self,
        request: live_20161101_models.UpdateLiveCenterTransferRequest,
    ) -> live_20161101_models.UpdateLiveCenterTransferResponse:
        """
        @summary Modifies the configurations of live center stream relay.
        
        @description You can call this operation to modify only the *time-related** parameters, including TransferArgs, StartTime, and EndTime.
        ## [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveCenterTransferRequest
        @return: UpdateLiveCenterTransferResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_center_transfer_with_options_async(request, runtime)

    def update_live_delay_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveDelayConfigResponse:
        """
        @summary Updates a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.task_trigger_mode):
            query['TaskTriggerMode'] = request.task_trigger_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveDelayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_delay_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveDelayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveDelayConfigResponse:
        """
        @summary Updates a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateLiveDelayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveDelayConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.delay_time):
            query['DelayTime'] = request.delay_time
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        if not UtilClient.is_unset(request.task_trigger_mode):
            query['TaskTriggerMode'] = request.task_trigger_mode
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveDelayConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveDelayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_delay_config(
        self,
        request: live_20161101_models.UpdateLiveDelayConfigRequest,
    ) -> live_20161101_models.UpdateLiveDelayConfigResponse:
        """
        @summary Updates a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateLiveDelayConfigRequest
        @return: UpdateLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_delay_config_with_options(request, runtime)

    async def update_live_delay_config_async(
        self,
        request: live_20161101_models.UpdateLiveDelayConfigRequest,
    ) -> live_20161101_models.UpdateLiveDelayConfigResponse:
        """
        @summary Updates a stream delay configuration.
        
        @description ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateLiveDelayConfigRequest
        @return: UpdateLiveDelayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_delay_config_with_options_async(request, runtime)

    def update_live_detect_notify_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveDetectNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
        
        @description    Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveDetectNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_detect_notify_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveDetectNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveDetectNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
        
        @description    Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveDetectNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveDetectNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveDetectNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveDetectNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_detect_notify_config(
        self,
        request: live_20161101_models.UpdateLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveDetectNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
        
        @description    Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveDetectNotifyConfigRequest
        @return: UpdateLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_detect_notify_config_with_options(request, runtime)

    async def update_live_detect_notify_config_async(
        self,
        request: live_20161101_models.UpdateLiveDetectNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveDetectNotifyConfigResponse:
        """
        @summary Modifies the configuration of callbacks for video moderation results. As a result, the callback URL that is used to receive the callback notifications is changed.
        
        @description    Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveDetectNotifyConfigRequest
        @return: UpdateLiveDetectNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_detect_notify_config_with_options_async(request, runtime)

    def update_live_mputask_with_options(
        self,
        tmp_req: live_20161101_models.UpdateLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveMPUTaskResponse:
        """
        @summary Updates a mixed-stream relay task.
        
        @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: UpdateLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveMPUTaskResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLiveMPUTaskShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.multi_stream_url):
            request.multi_stream_urlshrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.multi_stream_url, 'MultiStreamURL', 'json')
        if not UtilClient.is_unset(tmp_req.sei_params):
            request.sei_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sei_params, 'SeiParams', 'json')
        if not UtilClient.is_unset(tmp_req.single_sub_params):
            request.single_sub_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.single_sub_params, 'SingleSubParams', 'json')
        if not UtilClient.is_unset(tmp_req.transcode_params):
            request.transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.transcode_params, 'TranscodeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.mix_mode):
            query['MixMode'] = request.mix_mode
        if not UtilClient.is_unset(request.multi_stream_urlshrink):
            query['MultiStreamURL'] = request.multi_stream_urlshrink
        if not UtilClient.is_unset(request.sei_params_shrink):
            query['SeiParams'] = request.sei_params_shrink
        if not UtilClient.is_unset(request.single_sub_params_shrink):
            query['SingleSubParams'] = request.single_sub_params_shrink
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        if not UtilClient.is_unset(request.transcode_params_shrink):
            query['TranscodeParams'] = request.transcode_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveMPUTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_mputask_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateLiveMPUTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveMPUTaskResponse:
        """
        @summary Updates a mixed-stream relay task.
        
        @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: UpdateLiveMPUTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveMPUTaskResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLiveMPUTaskShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.multi_stream_url):
            request.multi_stream_urlshrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.multi_stream_url, 'MultiStreamURL', 'json')
        if not UtilClient.is_unset(tmp_req.sei_params):
            request.sei_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sei_params, 'SeiParams', 'json')
        if not UtilClient.is_unset(tmp_req.single_sub_params):
            request.single_sub_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.single_sub_params, 'SingleSubParams', 'json')
        if not UtilClient.is_unset(tmp_req.transcode_params):
            request.transcode_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.transcode_params, 'TranscodeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel_id):
            query['ChannelId'] = request.channel_id
        if not UtilClient.is_unset(request.mix_mode):
            query['MixMode'] = request.mix_mode
        if not UtilClient.is_unset(request.multi_stream_urlshrink):
            query['MultiStreamURL'] = request.multi_stream_urlshrink
        if not UtilClient.is_unset(request.sei_params_shrink):
            query['SeiParams'] = request.sei_params_shrink
        if not UtilClient.is_unset(request.single_sub_params_shrink):
            query['SingleSubParams'] = request.single_sub_params_shrink
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        if not UtilClient.is_unset(request.transcode_params_shrink):
            query['TranscodeParams'] = request.transcode_params_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveMPUTask',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveMPUTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_mputask(
        self,
        request: live_20161101_models.UpdateLiveMPUTaskRequest,
    ) -> live_20161101_models.UpdateLiveMPUTaskResponse:
        """
        @summary Updates a mixed-stream relay task.
        
        @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveMPUTaskRequest
        @return: UpdateLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_mputask_with_options(request, runtime)

    async def update_live_mputask_async(
        self,
        request: live_20161101_models.UpdateLiveMPUTaskRequest,
    ) -> live_20161101_models.UpdateLiveMPUTaskResponse:
        """
        @summary Updates a mixed-stream relay task.
        
        @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
        ## [](#qps-)QPS limit
        You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveMPUTaskRequest
        @return: UpdateLiveMPUTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_mputask_with_options_async(request, runtime)

    def update_live_package_config_with_options(
        self,
        request: live_20161101_models.UpdateLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePackageConfigResponse:
        """
        @summary Updates a live stream encapsulation configuration.
        
        @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_duration):
            query['PartDuration'] = request.part_duration
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.segment_duration):
            query['SegmentDuration'] = request.segment_duration
        if not UtilClient.is_unset(request.segment_num):
            query['SegmentNum'] = request.segment_num
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePackageConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_package_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLivePackageConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePackageConfigResponse:
        """
        @summary Updates a live stream encapsulation configuration.
        
        @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePackageConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePackageConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.ignore_transcode):
            query['IgnoreTranscode'] = request.ignore_transcode
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_duration):
            query['PartDuration'] = request.part_duration
        if not UtilClient.is_unset(request.protocol):
            query['Protocol'] = request.protocol
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.segment_duration):
            query['SegmentDuration'] = request.segment_duration
        if not UtilClient.is_unset(request.segment_num):
            query['SegmentNum'] = request.segment_num
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePackageConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePackageConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_package_config(
        self,
        request: live_20161101_models.UpdateLivePackageConfigRequest,
    ) -> live_20161101_models.UpdateLivePackageConfigResponse:
        """
        @summary Updates a live stream encapsulation configuration.
        
        @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePackageConfigRequest
        @return: UpdateLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_package_config_with_options(request, runtime)

    async def update_live_package_config_async(
        self,
        request: live_20161101_models.UpdateLivePackageConfigRequest,
    ) -> live_20161101_models.UpdateLivePackageConfigResponse:
        """
        @summary Updates a live stream encapsulation configuration.
        
        @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
        ## [](#qps-)QPS limit
        You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePackageConfigRequest
        @return: UpdateLivePackageConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_package_config_with_options_async(request, runtime)

    def update_live_pull_stream_info_config_with_options(
        self,
        request: live_20161101_models.UpdateLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePullStreamInfoConfigResponse:
        """
        @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePullStreamInfoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_pull_stream_info_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLivePullStreamInfoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePullStreamInfoConfigResponse:
        """
        @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullStreamInfoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePullStreamInfoConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePullStreamInfoConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePullStreamInfoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_pull_stream_info_config(
        self,
        request: live_20161101_models.UpdateLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.UpdateLivePullStreamInfoConfigResponse:
        """
        @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullStreamInfoConfigRequest
        @return: UpdateLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_pull_stream_info_config_with_options(request, runtime)

    async def update_live_pull_stream_info_config_async(
        self,
        request: live_20161101_models.UpdateLivePullStreamInfoConfigRequest,
    ) -> live_20161101_models.UpdateLivePullStreamInfoConfigResponse:
        """
        @summary Modifies the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        
        @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
        >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
        ## [](#qps-)QPS limit
        You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullStreamInfoConfigRequest
        @return: UpdateLivePullStreamInfoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_pull_stream_info_config_with_options_async(request, runtime)

    def update_live_pull_to_push_with_options(
        self,
        tmp_req: live_20161101_models.UpdateLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePullToPushResponse:
        """
        @summary Updates a pulled-stream relay task.
        
        @description    You can call this operation to update a pulled-stream relay task.
        As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
        If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
        If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: UpdateLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePullToPushResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLivePullToPushShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.source_urls):
            request.source_urls_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.source_urls, 'SourceUrls', 'json')
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePullToPushResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_pull_to_push_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateLivePullToPushRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLivePullToPushResponse:
        """
        @summary Updates a pulled-stream relay task.
        
        @description    You can call this operation to update a pulled-stream relay task.
        As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
        If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
        If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param tmp_req: UpdateLivePullToPushRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLivePullToPushResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateLivePullToPushShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.source_urls):
            request.source_urls_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.source_urls, 'SourceUrls', 'json')
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLivePullToPush',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLivePullToPushResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_pull_to_push(
        self,
        request: live_20161101_models.UpdateLivePullToPushRequest,
    ) -> live_20161101_models.UpdateLivePullToPushResponse:
        """
        @summary Updates a pulled-stream relay task.
        
        @description    You can call this operation to update a pulled-stream relay task.
        As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
        If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
        If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullToPushRequest
        @return: UpdateLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_pull_to_push_with_options(request, runtime)

    async def update_live_pull_to_push_async(
        self,
        request: live_20161101_models.UpdateLivePullToPushRequest,
    ) -> live_20161101_models.UpdateLivePullToPushResponse:
        """
        @summary Updates a pulled-stream relay task.
        
        @description    You can call this operation to update a pulled-stream relay task.
        As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
        If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
        If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLivePullToPushRequest
        @return: UpdateLivePullToPushResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_pull_to_push_with_options_async(request, runtime)

    def update_live_record_notify_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveRecordNotifyConfigResponse:
        """
        @summary Modifies the recording callback configuration of a streaming domain.
        
        @description You can call this operation to modify the following settings:
        The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
        The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
        The setting that specifies whether to enable callbacks for recording status.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.need_status_notify):
            query['NeedStatusNotify'] = request.need_status_notify
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.on_demand_url):
            query['OnDemandUrl'] = request.on_demand_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveRecordNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_record_notify_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveRecordNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveRecordNotifyConfigResponse:
        """
        @summary Modifies the recording callback configuration of a streaming domain.
        
        @description You can call this operation to modify the following settings:
        The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
        The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
        The setting that specifies whether to enable callbacks for recording status.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveRecordNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.need_status_notify):
            query['NeedStatusNotify'] = request.need_status_notify
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.on_demand_url):
            query['OnDemandUrl'] = request.on_demand_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveRecordNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveRecordNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_record_notify_config(
        self,
        request: live_20161101_models.UpdateLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveRecordNotifyConfigResponse:
        """
        @summary Modifies the recording callback configuration of a streaming domain.
        
        @description You can call this operation to modify the following settings:
        The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
        The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
        The setting that specifies whether to enable callbacks for recording status.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordNotifyConfigRequest
        @return: UpdateLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_record_notify_config_with_options(request, runtime)

    async def update_live_record_notify_config_async(
        self,
        request: live_20161101_models.UpdateLiveRecordNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveRecordNotifyConfigResponse:
        """
        @summary Modifies the recording callback configuration of a streaming domain.
        
        @description You can call this operation to modify the following settings:
        The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
        The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
        The setting that specifies whether to enable callbacks for recording status.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordNotifyConfigRequest
        @return: UpdateLiveRecordNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_record_notify_config_with_options_async(request, runtime)

    def update_live_record_vod_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveRecordVodConfigResponse:
        """
        @summary Updates a Live-to-VOD configuration.
        
        @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.auto_compose):
            query['AutoCompose'] = request.auto_compose
        if not UtilClient.is_unset(request.compose_vod_transcode_group_id):
            query['ComposeVodTranscodeGroupId'] = request.compose_vod_transcode_group_id
        if not UtilClient.is_unset(request.cycle_duration):
            query['CycleDuration'] = request.cycle_duration
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vod_transcode_group_id):
            query['VodTranscodeGroupId'] = request.vod_transcode_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveRecordVodConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_record_vod_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveRecordVodConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveRecordVodConfigResponse:
        """
        @summary Updates a Live-to-VOD configuration.
        
        @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordVodConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveRecordVodConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.auto_compose):
            query['AutoCompose'] = request.auto_compose
        if not UtilClient.is_unset(request.compose_vod_transcode_group_id):
            query['ComposeVodTranscodeGroupId'] = request.compose_vod_transcode_group_id
        if not UtilClient.is_unset(request.cycle_duration):
            query['CycleDuration'] = request.cycle_duration
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.on_demand):
            query['OnDemand'] = request.on_demand
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.vod_transcode_group_id):
            query['VodTranscodeGroupId'] = request.vod_transcode_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveRecordVodConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveRecordVodConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_record_vod_config(
        self,
        request: live_20161101_models.UpdateLiveRecordVodConfigRequest,
    ) -> live_20161101_models.UpdateLiveRecordVodConfigResponse:
        """
        @summary Updates a Live-to-VOD configuration.
        
        @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordVodConfigRequest
        @return: UpdateLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_record_vod_config_with_options(request, runtime)

    async def update_live_record_vod_config_async(
        self,
        request: live_20161101_models.UpdateLiveRecordVodConfigRequest,
    ) -> live_20161101_models.UpdateLiveRecordVodConfigResponse:
        """
        @summary Updates a Live-to-VOD configuration.
        
        @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveRecordVodConfigRequest
        @return: UpdateLiveRecordVodConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_record_vod_config_with_options_async(request, runtime)

    def update_live_snapshot_detect_porn_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse:
        """
        @summary Modifies a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_snapshot_detect_porn_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveSnapshotDetectPornConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse:
        """
        @summary Modifies a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotDetectPornConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveSnapshotDetectPornConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.oss_bucket):
            query['OssBucket'] = request.oss_bucket
        if not UtilClient.is_unset(request.oss_endpoint):
            query['OssEndpoint'] = request.oss_endpoint
        if not UtilClient.is_unset(request.oss_object):
            query['OssObject'] = request.oss_object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveSnapshotDetectPornConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_snapshot_detect_porn_config(
        self,
        request: live_20161101_models.UpdateLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse:
        """
        @summary Modifies a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotDetectPornConfigRequest
        @return: UpdateLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_snapshot_detect_porn_config_with_options(request, runtime)

    async def update_live_snapshot_detect_porn_config_async(
        self,
        request: live_20161101_models.UpdateLiveSnapshotDetectPornConfigRequest,
    ) -> live_20161101_models.UpdateLiveSnapshotDetectPornConfigResponse:
        """
        @summary Modifies a video moderation configuration.
        
        @description    Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
        Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotDetectPornConfigRequest
        @return: UpdateLiveSnapshotDetectPornConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_snapshot_detect_porn_config_with_options_async(request, runtime)

    def update_live_snapshot_notify_config_with_options(
        self,
        request: live_20161101_models.UpdateLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse:
        """
        @summary Modifies the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_snapshot_notify_config_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveSnapshotNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse:
        """
        @summary Modifies the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveSnapshotNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.notify_auth_key):
            query['NotifyAuthKey'] = request.notify_auth_key
        if not UtilClient.is_unset(request.notify_req_auth):
            query['NotifyReqAuth'] = request.notify_req_auth
        if not UtilClient.is_unset(request.notify_url):
            query['NotifyUrl'] = request.notify_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveSnapshotNotifyConfig',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_snapshot_notify_config(
        self,
        request: live_20161101_models.UpdateLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse:
        """
        @summary Modifies the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotNotifyConfigRequest
        @return: UpdateLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_snapshot_notify_config_with_options(request, runtime)

    async def update_live_snapshot_notify_config_async(
        self,
        request: live_20161101_models.UpdateLiveSnapshotNotifyConfigRequest,
    ) -> live_20161101_models.UpdateLiveSnapshotNotifyConfigResponse:
        """
        @summary Modifies the configuration of snapshot callbacks.
        
        @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveSnapshotNotifyConfigRequest
        @return: UpdateLiveSnapshotNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_snapshot_notify_config_with_options_async(request, runtime)

    def update_live_stream_monitor_with_options(
        self,
        request: live_20161101_models.UpdateLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamMonitorResponse:
        """
        @summary Updates the configurations of a monitoring session.
        
        @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.ding_talk_web_hook_url):
            query['DingTalkWebHookUrl'] = request.ding_talk_web_hook_url
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.input_list):
            query['InputList'] = request.input_list
        if not UtilClient.is_unset(request.monitor_config):
            query['MonitorConfig'] = request.monitor_config
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.monitor_name):
            query['MonitorName'] = request.monitor_name
        if not UtilClient.is_unset(request.output_template):
            query['OutputTemplate'] = request.output_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamMonitorResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_stream_monitor_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveStreamMonitorRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamMonitorResponse:
        """
        @summary Updates the configurations of a monitoring session.
        
        @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamMonitorRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.ding_talk_web_hook_url):
            query['DingTalkWebHookUrl'] = request.ding_talk_web_hook_url
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.input_list):
            query['InputList'] = request.input_list
        if not UtilClient.is_unset(request.monitor_config):
            query['MonitorConfig'] = request.monitor_config
        if not UtilClient.is_unset(request.monitor_id):
            query['MonitorId'] = request.monitor_id
        if not UtilClient.is_unset(request.monitor_name):
            query['MonitorName'] = request.monitor_name
        if not UtilClient.is_unset(request.output_template):
            query['OutputTemplate'] = request.output_template
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.stream):
            query['Stream'] = request.stream
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamMonitor',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamMonitorResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_stream_monitor(
        self,
        request: live_20161101_models.UpdateLiveStreamMonitorRequest,
    ) -> live_20161101_models.UpdateLiveStreamMonitorResponse:
        """
        @summary Updates the configurations of a monitoring session.
        
        @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamMonitorRequest
        @return: UpdateLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_stream_monitor_with_options(request, runtime)

    async def update_live_stream_monitor_async(
        self,
        request: live_20161101_models.UpdateLiveStreamMonitorRequest,
    ) -> live_20161101_models.UpdateLiveStreamMonitorResponse:
        """
        @summary Updates the configurations of a monitoring session.
        
        @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamMonitorRequest
        @return: UpdateLiveStreamMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_stream_monitor_with_options_async(request, runtime)

    def update_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.UpdateLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamTranscodeResponse:
        """
        @summary Updates a default transcoding configuration.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account.
        
        @param request: UpdateLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamTranscodeResponse:
        """
        @summary Updates a default transcoding configuration.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account.
        
        @param request: UpdateLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.encrypt_parameters):
            query['EncryptParameters'] = request.encrypt_parameters
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_stream_transcode(
        self,
        request: live_20161101_models.UpdateLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateLiveStreamTranscodeResponse:
        """
        @summary Updates a default transcoding configuration.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account.
        
        @param request: UpdateLiveStreamTranscodeRequest
        @return: UpdateLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_stream_transcode_with_options(request, runtime)

    async def update_live_stream_transcode_async(
        self,
        request: live_20161101_models.UpdateLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateLiveStreamTranscodeResponse:
        """
        @summary Updates a default transcoding configuration.
        
        @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD transcoding templates are supported for this operation.
        ## [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account.
        
        @param request: UpdateLiveStreamTranscodeRequest
        @return: UpdateLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_stream_transcode_with_options_async(request, runtime)

    def update_live_stream_watermark_with_options(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkResponse:
        """
        @summary Updates a watermark template.
        
        @description This operation allows you to modify the parameters of a watermark template with a specified ID.
        ## QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: UpdateLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.offset_corner):
            query['OffsetCorner'] = request.offset_corner
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.picture_url):
            query['PictureUrl'] = request.picture_url
        if not UtilClient.is_unset(request.ref_height):
            query['RefHeight'] = request.ref_height
        if not UtilClient.is_unset(request.ref_width):
            query['RefWidth'] = request.ref_width
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.transparency):
            query['Transparency'] = request.transparency
        if not UtilClient.is_unset(request.xoffset):
            query['XOffset'] = request.xoffset
        if not UtilClient.is_unset(request.yoffset):
            query['YOffset'] = request.yoffset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_stream_watermark_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkResponse:
        """
        @summary Updates a watermark template.
        
        @description This operation allows you to modify the parameters of a watermark template with a specified ID.
        ## QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: UpdateLiveStreamWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.offset_corner):
            query['OffsetCorner'] = request.offset_corner
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.picture_url):
            query['PictureUrl'] = request.picture_url
        if not UtilClient.is_unset(request.ref_height):
            query['RefHeight'] = request.ref_height
        if not UtilClient.is_unset(request.ref_width):
            query['RefWidth'] = request.ref_width
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.transparency):
            query['Transparency'] = request.transparency
        if not UtilClient.is_unset(request.xoffset):
            query['XOffset'] = request.xoffset
        if not UtilClient.is_unset(request.yoffset):
            query['YOffset'] = request.yoffset
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamWatermark',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_stream_watermark(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRequest,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkResponse:
        """
        @summary Updates a watermark template.
        
        @description This operation allows you to modify the parameters of a watermark template with a specified ID.
        ## QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: UpdateLiveStreamWatermarkRequest
        @return: UpdateLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_stream_watermark_with_options(request, runtime)

    async def update_live_stream_watermark_async(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRequest,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkResponse:
        """
        @summary Updates a watermark template.
        
        @description This operation allows you to modify the parameters of a watermark template with a specified ID.
        ## QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
        
        @param request: UpdateLiveStreamWatermarkRequest
        @return: UpdateLiveStreamWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_stream_watermark_with_options_async(request, runtime)

    def update_live_stream_watermark_rule_with_options(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkRuleResponse:
        """
        @summary Updates a watermark rule.
        
        @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamWatermarkRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_live_stream_watermark_rule_with_options_async(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkRuleResponse:
        """
        @summary Updates a watermark rule.
        
        @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamWatermarkRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateLiveStreamWatermarkRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateLiveStreamWatermarkRule',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateLiveStreamWatermarkRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_live_stream_watermark_rule(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkRuleResponse:
        """
        @summary Updates a watermark rule.
        
        @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamWatermarkRuleRequest
        @return: UpdateLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_live_stream_watermark_rule_with_options(request, runtime)

    async def update_live_stream_watermark_rule_async(
        self,
        request: live_20161101_models.UpdateLiveStreamWatermarkRuleRequest,
    ) -> live_20161101_models.UpdateLiveStreamWatermarkRuleResponse:
        """
        @summary Updates a watermark rule.
        
        @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
        ## [](#qps-)QPS limit
        You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateLiveStreamWatermarkRuleRequest
        @return: UpdateLiveStreamWatermarkRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_live_stream_watermark_rule_with_options_async(request, runtime)

    def update_message_app_with_options(
        self,
        tmp_req: live_20161101_models.UpdateMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMessageAppResponse:
        """
        @summary Updates the configurations of an interactive message application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: UpdateMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMessageAppResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateMessageAppShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.app_config):
            request.app_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.app_config, 'AppConfig', 'json')
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_config_shrink):
            body['AppConfig'] = request.app_config_shrink
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMessageAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_message_app_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateMessageAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMessageAppResponse:
        """
        @summary Updates the configurations of an interactive message application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: UpdateMessageAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMessageAppResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateMessageAppShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.app_config):
            request.app_config_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.app_config, 'AppConfig', 'json')
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_config_shrink):
            body['AppConfig'] = request.app_config_shrink
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateMessageApp',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMessageAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_message_app(
        self,
        request: live_20161101_models.UpdateMessageAppRequest,
    ) -> live_20161101_models.UpdateMessageAppResponse:
        """
        @summary Updates the configurations of an interactive message application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateMessageAppRequest
        @return: UpdateMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_message_app_with_options(request, runtime)

    async def update_message_app_async(
        self,
        request: live_20161101_models.UpdateMessageAppRequest,
    ) -> live_20161101_models.UpdateMessageAppResponse:
        """
        @summary Updates the configurations of an interactive message application.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateMessageAppRequest
        @return: UpdateMessageAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_message_app_with_options_async(request, runtime)

    def update_message_group_with_options(
        self,
        tmp_req: live_20161101_models.UpdateMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMessageGroupResponse:
        """
        @summary Updates the information about a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: UpdateMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMessageGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_message_group_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateMessageGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMessageGroupResponse:
        """
        @summary Updates the information about a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param tmp_req: UpdateMessageGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMessageGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateMessageGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.extension):
            request.extension_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.extension, 'Extension', 'json')
        body = {}
        if not UtilClient.is_unset(request.app_id):
            body['AppId'] = request.app_id
        if not UtilClient.is_unset(request.extension_shrink):
            body['Extension'] = request.extension_shrink
        if not UtilClient.is_unset(request.group_id):
            body['GroupId'] = request.group_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateMessageGroup',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMessageGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_message_group(
        self,
        request: live_20161101_models.UpdateMessageGroupRequest,
    ) -> live_20161101_models.UpdateMessageGroupResponse:
        """
        @summary Updates the information about a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateMessageGroupRequest
        @return: UpdateMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_message_group_with_options(request, runtime)

    async def update_message_group_async(
        self,
        request: live_20161101_models.UpdateMessageGroupRequest,
    ) -> live_20161101_models.UpdateMessageGroupResponse:
        """
        @summary Updates the information about a message group.
        
        @description ## QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: UpdateMessageGroupRequest
        @return: UpdateMessageGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_message_group_with_options_async(request, runtime)

    def update_mix_stream_with_options(
        self,
        request: live_20161101_models.UpdateMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMixStreamResponse:
        """
        @summary Updates a stream mixing task.
        
        @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.input_stream_list):
            query['InputStreamList'] = request.input_stream_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMixStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_mix_stream_with_options_async(
        self,
        request: live_20161101_models.UpdateMixStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateMixStreamResponse:
        """
        @summary Updates a stream mixing task.
        
        @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateMixStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMixStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.input_stream_list):
            query['InputStreamList'] = request.input_stream_list
        if not UtilClient.is_unset(request.layout_id):
            query['LayoutId'] = request.layout_id
        if not UtilClient.is_unset(request.mix_stream_id):
            query['MixStreamId'] = request.mix_stream_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMixStream',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateMixStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_mix_stream(
        self,
        request: live_20161101_models.UpdateMixStreamRequest,
    ) -> live_20161101_models.UpdateMixStreamResponse:
        """
        @summary Updates a stream mixing task.
        
        @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateMixStreamRequest
        @return: UpdateMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_mix_stream_with_options(request, runtime)

    async def update_mix_stream_async(
        self,
        request: live_20161101_models.UpdateMixStreamRequest,
    ) -> live_20161101_models.UpdateMixStreamResponse:
        """
        @summary Updates a stream mixing task.
        
        @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateMixStreamRequest
        @return: UpdateMixStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_mix_stream_with_options_async(request, runtime)

    def update_rtc_cloud_recording_with_options(
        self,
        tmp_req: live_20161101_models.UpdateRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param tmp_req: UpdateRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtcCloudRecordingResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateRtcCloudRecordingShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mix_layout_params):
            request.mix_layout_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_layout_params, 'MixLayoutParams', 'json')
        if not UtilClient.is_unset(tmp_req.subscribe_params):
            request.subscribe_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.subscribe_params, 'SubscribeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.mix_layout_params_shrink):
            query['MixLayoutParams'] = request.mix_layout_params_shrink
        if not UtilClient.is_unset(request.subscribe_params_shrink):
            query['SubscribeParams'] = request.subscribe_params_shrink
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtcCloudRecordingResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_rtc_cloud_recording_with_options_async(
        self,
        tmp_req: live_20161101_models.UpdateRtcCloudRecordingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param tmp_req: UpdateRtcCloudRecordingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtcCloudRecordingResponse
        """
        UtilClient.validate_model(tmp_req)
        request = live_20161101_models.UpdateRtcCloudRecordingShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.mix_layout_params):
            request.mix_layout_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.mix_layout_params, 'MixLayoutParams', 'json')
        if not UtilClient.is_unset(tmp_req.subscribe_params):
            request.subscribe_params_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.subscribe_params, 'SubscribeParams', 'json')
        query = {}
        if not UtilClient.is_unset(request.mix_layout_params_shrink):
            query['MixLayoutParams'] = request.mix_layout_params_shrink
        if not UtilClient.is_unset(request.subscribe_params_shrink):
            query['SubscribeParams'] = request.subscribe_params_shrink
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtcCloudRecording',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtcCloudRecordingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_rtc_cloud_recording(
        self,
        request: live_20161101_models.UpdateRtcCloudRecordingRequest,
    ) -> live_20161101_models.UpdateRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: UpdateRtcCloudRecordingRequest
        @return: UpdateRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_rtc_cloud_recording_with_options(request, runtime)

    async def update_rtc_cloud_recording_async(
        self,
        request: live_20161101_models.UpdateRtcCloudRecordingRequest,
    ) -> live_20161101_models.UpdateRtcCloudRecordingResponse:
        """
        @summary rtc
        
        @param request: UpdateRtcCloudRecordingRequest
        @return: UpdateRtcCloudRecordingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_rtc_cloud_recording_with_options_async(request, runtime)

    def update_rtc_mpuevent_sub_with_options(
        self,
        request: live_20161101_models.UpdateRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtcMPUEventSubResponse:
        """
        @summary Updates a subscription to mixed-stream relay events.
        
        @description    You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_ids):
            query['ChannelIds'] = request.channel_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtcMPUEventSubResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_rtc_mpuevent_sub_with_options_async(
        self,
        request: live_20161101_models.UpdateRtcMPUEventSubRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtcMPUEventSubResponse:
        """
        @summary Updates a subscription to mixed-stream relay events.
        
        @description    You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateRtcMPUEventSubRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtcMPUEventSubResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackUrl'] = request.callback_url
        if not UtilClient.is_unset(request.channel_ids):
            query['ChannelIds'] = request.channel_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtcMPUEventSub',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtcMPUEventSubResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_rtc_mpuevent_sub(
        self,
        request: live_20161101_models.UpdateRtcMPUEventSubRequest,
    ) -> live_20161101_models.UpdateRtcMPUEventSubResponse:
        """
        @summary Updates a subscription to mixed-stream relay events.
        
        @description    You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateRtcMPUEventSubRequest
        @return: UpdateRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_rtc_mpuevent_sub_with_options(request, runtime)

    async def update_rtc_mpuevent_sub_async(
        self,
        request: live_20161101_models.UpdateRtcMPUEventSubRequest,
    ) -> live_20161101_models.UpdateRtcMPUEventSubResponse:
        """
        @summary Updates a subscription to mixed-stream relay events.
        
        @description    You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
        Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
        ## [](#qps-)QPS limit
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
        
        @param request: UpdateRtcMPUEventSubRequest
        @return: UpdateRtcMPUEventSubResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_rtc_mpuevent_sub_with_options_async(request, runtime)

    def update_rts_live_stream_transcode_with_options(
        self,
        request: live_20161101_models.UpdateRtsLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtsLiveStreamTranscodeResponse:
        """
        @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account.
        
        @param request: UpdateRtsLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtsLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.delete_bframes):
            query['DeleteBframes'] = request.delete_bframes
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.opus):
            query['Opus'] = request.opus
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtsLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtsLiveStreamTranscodeResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_rts_live_stream_transcode_with_options_async(
        self,
        request: live_20161101_models.UpdateRtsLiveStreamTranscodeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.UpdateRtsLiveStreamTranscodeResponse:
        """
        @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account.
        
        @param request: UpdateRtsLiveStreamTranscodeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateRtsLiveStreamTranscodeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app):
            query['App'] = request.app
        if not UtilClient.is_unset(request.audio_bitrate):
            query['AudioBitrate'] = request.audio_bitrate
        if not UtilClient.is_unset(request.audio_channel_num):
            query['AudioChannelNum'] = request.audio_channel_num
        if not UtilClient.is_unset(request.audio_codec):
            query['AudioCodec'] = request.audio_codec
        if not UtilClient.is_unset(request.audio_profile):
            query['AudioProfile'] = request.audio_profile
        if not UtilClient.is_unset(request.audio_rate):
            query['AudioRate'] = request.audio_rate
        if not UtilClient.is_unset(request.delete_bframes):
            query['DeleteBframes'] = request.delete_bframes
        if not UtilClient.is_unset(request.domain):
            query['Domain'] = request.domain
        if not UtilClient.is_unset(request.fps):
            query['FPS'] = request.fps
        if not UtilClient.is_unset(request.gop):
            query['Gop'] = request.gop
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.lazy):
            query['Lazy'] = request.lazy
        if not UtilClient.is_unset(request.opus):
            query['Opus'] = request.opus
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.profile):
            query['Profile'] = request.profile
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.template):
            query['Template'] = request.template
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.video_bitrate):
            query['VideoBitrate'] = request.video_bitrate
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateRtsLiveStreamTranscode',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.UpdateRtsLiveStreamTranscodeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_rts_live_stream_transcode(
        self,
        request: live_20161101_models.UpdateRtsLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateRtsLiveStreamTranscodeResponse:
        """
        @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account.
        
        @param request: UpdateRtsLiveStreamTranscodeRequest
        @return: UpdateRtsLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_rts_live_stream_transcode_with_options(request, runtime)

    async def update_rts_live_stream_transcode_async(
        self,
        request: live_20161101_models.UpdateRtsLiveStreamTranscodeRequest,
    ) -> live_20161101_models.UpdateRtsLiveStreamTranscodeResponse:
        """
        @summary Updates a custom Real-Time Streaming (RTS) transcoding configuration.
        
        @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
        ## [](#qps-)QPS limit
        You can call this operation up to 10 times per second per account.
        
        @param request: UpdateRtsLiveStreamTranscodeRequest
        @return: UpdateRtsLiveStreamTranscodeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_rts_live_stream_transcode_with_options_async(request, runtime)

    def verify_live_domain_owner_with_options(
        self,
        request: live_20161101_models.VerifyLiveDomainOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.VerifyLiveDomainOwnerResponse:
        """
        @summary Verifies the ownership of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: VerifyLiveDomainOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VerifyLiveDomainOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.verify_type):
            query['VerifyType'] = request.verify_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VerifyLiveDomainOwner',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.VerifyLiveDomainOwnerResponse(),
            self.call_api(params, req, runtime)
        )

    async def verify_live_domain_owner_with_options_async(
        self,
        request: live_20161101_models.VerifyLiveDomainOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> live_20161101_models.VerifyLiveDomainOwnerResponse:
        """
        @summary Verifies the ownership of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: VerifyLiveDomainOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VerifyLiveDomainOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.verify_type):
            query['VerifyType'] = request.verify_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VerifyLiveDomainOwner',
            version='2016-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            live_20161101_models.VerifyLiveDomainOwnerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def verify_live_domain_owner(
        self,
        request: live_20161101_models.VerifyLiveDomainOwnerRequest,
    ) -> live_20161101_models.VerifyLiveDomainOwnerResponse:
        """
        @summary Verifies the ownership of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: VerifyLiveDomainOwnerRequest
        @return: VerifyLiveDomainOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.verify_live_domain_owner_with_options(request, runtime)

    async def verify_live_domain_owner_async(
        self,
        request: live_20161101_models.VerifyLiveDomainOwnerRequest,
    ) -> live_20161101_models.VerifyLiveDomainOwnerResponse:
        """
        @summary Verifies the ownership of a domain name.
        
        @description ### [](#qps-)QPS limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
        
        @param request: VerifyLiveDomainOwnerRequest
        @return: VerifyLiveDomainOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.verify_live_domain_owner_with_options_async(request, runtime)
