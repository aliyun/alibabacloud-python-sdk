# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from __future__ import annotations

from typing import List

from alibabacloud_cloudapi20160714 import models as main_models
from darabonba.model import DaraModel

class DescribeApiGroupResponseBody(DaraModel):
    def __init__(
        self,
        base_path: str = None,
        billing_status: str = None,
        cloud_market_commodity: bool = None,
        cms_monitor_group: str = None,
        compatible_flags: str = None,
        created_time: str = None,
        custom_app_code_config: str = None,
        custom_domains: main_models.DescribeApiGroupResponseBodyCustomDomains = None,
        custom_trace_config: str = None,
        customer_configs: str = None,
        dedicated_instance_type: str = None,
        default_domain: str = None,
        description: str = None,
        disable_inner_domain: bool = None,
        group_id: str = None,
        group_name: str = None,
        https_policy: str = None,
        illegal_status: str = None,
        instance_id: str = None,
        instance_type: str = None,
        ipv_6status: str = None,
        migration_error: str = None,
        migration_status: str = None,
        modified_time: str = None,
        passthrough_headers: str = None,
        region_id: str = None,
        request_id: str = None,
        stage_items: main_models.DescribeApiGroupResponseBodyStageItems = None,
        status: str = None,
        sub_domain: str = None,
        traffic_limit: int = None,
        user_log_config: str = None,
        vpc_domain: str = None,
        vpc_slb_intranet_domain: str = None,
    ):
        # The root path of the API.
        self.base_path = base_path
        # The billing status of the API group.
        # 
        # *   **NORMAL**: The API group is normal.
        # *   **LOCKED**: The API group is locked due to overdue payments.
        self.billing_status = billing_status
        # The products on Alibaba Cloud Marketplace.
        self.cloud_market_commodity = cloud_market_commodity
        # The CloudMonitor application group.
        self.cms_monitor_group = cms_monitor_group
        # The list of associated tags. Separate multiple tags with commas (,).
        self.compatible_flags = compatible_flags
        # The creation time (UTC) of the API group.
        self.created_time = created_time
        # The custom appcode configuration.
        self.custom_app_code_config = custom_app_code_config
        # The details about the custom domain name.
        self.custom_domains = custom_domains
        # The custom trace configuration.
        self.custom_trace_config = custom_trace_config
        # The list of custom configuration items.
        self.customer_configs = customer_configs
        # The type of exclusive instance where the group is located
        # 
        # - VPC fusion type exclusive instance: vpc_connect
        # - Traditional type exclusive instance: normal
        self.dedicated_instance_type = dedicated_instance_type
        # The default domain name.
        self.default_domain = default_domain
        # The description of the API group.
        self.description = description
        # Indicates whether access over the public second-level domain name is enabled. Valid values:
        # 
        # *   true
        # *   false
        self.disable_inner_domain = disable_inner_domain
        # The ID of the API group. This ID is generated by the system and globally unique.
        self.group_id = group_id
        # The name of the group to which the API belongs.
        self.group_name = group_name
        # The HTTPS policy.
        self.https_policy = https_policy
        # The validity status of the API group. Valid values:
        # 
        # *   **NORMAL**: The API group is normal.
        # *   **LOCKED**: The API group is locked because it is not valid.
        self.illegal_status = illegal_status
        # The ID of the instance.
        self.instance_id = instance_id
        # The type of the instance.
        # 
        # *   CLASSIC_SHARED: shared instance that uses the classic network configuration
        # *   VPC_SHARED: shared instance that uses VPC
        # *   VPC_DEDICATED: dedicated instance that uses VPC
        self.instance_type = instance_type
        # The IPv6 status.
        self.ipv_6status = ipv_6status
        # The reason for the failure of the group migration instance task. When the value of the MigrationStatus parameter is Failed, it is not empty.
        self.migration_error = migration_error
        # Group migration instance task status
        # 
        # - Running
        # - Success
        # - Failed
        self.migration_status = migration_status
        # The last modification time (UTC) of the API group.
        self.modified_time = modified_time
        # Specifies whether to pass headers.
        self.passthrough_headers = passthrough_headers
        # The region to which the API group belongs.
        self.region_id = region_id
        # The ID of the request.
        self.request_id = request_id
        # The runtime environment information.
        self.stage_items = stage_items
        # The status of the API group.
        # 
        # *   **NORMAL**: The API group is normal.
        # *   **DELETE**: The API group is deleted.
        self.status = status
        # The second-level domain name automatically assigned to the API group.
        self.sub_domain = sub_domain
        # The upper QPS limit of the API group. The default value is 500. You can increase the upper limit by submitting an application.
        self.traffic_limit = traffic_limit
        # The user log settings.
        self.user_log_config = user_log_config
        # The VPC domain name.
        self.vpc_domain = vpc_domain
        # The VPC SLB domain name.
        self.vpc_slb_intranet_domain = vpc_slb_intranet_domain

    def validate(self):
        if self.custom_domains:
            self.custom_domains.validate()
        if self.stage_items:
            self.stage_items.validate()

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.base_path is not None:
            result['BasePath'] = self.base_path

        if self.billing_status is not None:
            result['BillingStatus'] = self.billing_status

        if self.cloud_market_commodity is not None:
            result['CloudMarketCommodity'] = self.cloud_market_commodity

        if self.cms_monitor_group is not None:
            result['CmsMonitorGroup'] = self.cms_monitor_group

        if self.compatible_flags is not None:
            result['CompatibleFlags'] = self.compatible_flags

        if self.created_time is not None:
            result['CreatedTime'] = self.created_time

        if self.custom_app_code_config is not None:
            result['CustomAppCodeConfig'] = self.custom_app_code_config

        if self.custom_domains is not None:
            result['CustomDomains'] = self.custom_domains.to_map()

        if self.custom_trace_config is not None:
            result['CustomTraceConfig'] = self.custom_trace_config

        if self.customer_configs is not None:
            result['CustomerConfigs'] = self.customer_configs

        if self.dedicated_instance_type is not None:
            result['DedicatedInstanceType'] = self.dedicated_instance_type

        if self.default_domain is not None:
            result['DefaultDomain'] = self.default_domain

        if self.description is not None:
            result['Description'] = self.description

        if self.disable_inner_domain is not None:
            result['DisableInnerDomain'] = self.disable_inner_domain

        if self.group_id is not None:
            result['GroupId'] = self.group_id

        if self.group_name is not None:
            result['GroupName'] = self.group_name

        if self.https_policy is not None:
            result['HttpsPolicy'] = self.https_policy

        if self.illegal_status is not None:
            result['IllegalStatus'] = self.illegal_status

        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id

        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type

        if self.ipv_6status is not None:
            result['Ipv6Status'] = self.ipv_6status

        if self.migration_error is not None:
            result['MigrationError'] = self.migration_error

        if self.migration_status is not None:
            result['MigrationStatus'] = self.migration_status

        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time

        if self.passthrough_headers is not None:
            result['PassthroughHeaders'] = self.passthrough_headers

        if self.region_id is not None:
            result['RegionId'] = self.region_id

        if self.request_id is not None:
            result['RequestId'] = self.request_id

        if self.stage_items is not None:
            result['StageItems'] = self.stage_items.to_map()

        if self.status is not None:
            result['Status'] = self.status

        if self.sub_domain is not None:
            result['SubDomain'] = self.sub_domain

        if self.traffic_limit is not None:
            result['TrafficLimit'] = self.traffic_limit

        if self.user_log_config is not None:
            result['UserLogConfig'] = self.user_log_config

        if self.vpc_domain is not None:
            result['VpcDomain'] = self.vpc_domain

        if self.vpc_slb_intranet_domain is not None:
            result['VpcSlbIntranetDomain'] = self.vpc_slb_intranet_domain

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BasePath') is not None:
            self.base_path = m.get('BasePath')

        if m.get('BillingStatus') is not None:
            self.billing_status = m.get('BillingStatus')

        if m.get('CloudMarketCommodity') is not None:
            self.cloud_market_commodity = m.get('CloudMarketCommodity')

        if m.get('CmsMonitorGroup') is not None:
            self.cms_monitor_group = m.get('CmsMonitorGroup')

        if m.get('CompatibleFlags') is not None:
            self.compatible_flags = m.get('CompatibleFlags')

        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')

        if m.get('CustomAppCodeConfig') is not None:
            self.custom_app_code_config = m.get('CustomAppCodeConfig')

        if m.get('CustomDomains') is not None:
            temp_model = main_models.DescribeApiGroupResponseBodyCustomDomains()
            self.custom_domains = temp_model.from_map(m.get('CustomDomains'))

        if m.get('CustomTraceConfig') is not None:
            self.custom_trace_config = m.get('CustomTraceConfig')

        if m.get('CustomerConfigs') is not None:
            self.customer_configs = m.get('CustomerConfigs')

        if m.get('DedicatedInstanceType') is not None:
            self.dedicated_instance_type = m.get('DedicatedInstanceType')

        if m.get('DefaultDomain') is not None:
            self.default_domain = m.get('DefaultDomain')

        if m.get('Description') is not None:
            self.description = m.get('Description')

        if m.get('DisableInnerDomain') is not None:
            self.disable_inner_domain = m.get('DisableInnerDomain')

        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')

        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')

        if m.get('HttpsPolicy') is not None:
            self.https_policy = m.get('HttpsPolicy')

        if m.get('IllegalStatus') is not None:
            self.illegal_status = m.get('IllegalStatus')

        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')

        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')

        if m.get('Ipv6Status') is not None:
            self.ipv_6status = m.get('Ipv6Status')

        if m.get('MigrationError') is not None:
            self.migration_error = m.get('MigrationError')

        if m.get('MigrationStatus') is not None:
            self.migration_status = m.get('MigrationStatus')

        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')

        if m.get('PassthroughHeaders') is not None:
            self.passthrough_headers = m.get('PassthroughHeaders')

        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')

        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')

        if m.get('StageItems') is not None:
            temp_model = main_models.DescribeApiGroupResponseBodyStageItems()
            self.stage_items = temp_model.from_map(m.get('StageItems'))

        if m.get('Status') is not None:
            self.status = m.get('Status')

        if m.get('SubDomain') is not None:
            self.sub_domain = m.get('SubDomain')

        if m.get('TrafficLimit') is not None:
            self.traffic_limit = m.get('TrafficLimit')

        if m.get('UserLogConfig') is not None:
            self.user_log_config = m.get('UserLogConfig')

        if m.get('VpcDomain') is not None:
            self.vpc_domain = m.get('VpcDomain')

        if m.get('VpcSlbIntranetDomain') is not None:
            self.vpc_slb_intranet_domain = m.get('VpcSlbIntranetDomain')

        return self

class DescribeApiGroupResponseBodyStageItems(DaraModel):
    def __init__(
        self,
        stage_info: List[main_models.DescribeApiGroupResponseBodyStageItemsStageInfo] = None,
    ):
        self.stage_info = stage_info

    def validate(self):
        if self.stage_info:
            for v1 in self.stage_info:
                 if v1:
                    v1.validate()

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        result['StageInfo'] = []
        if self.stage_info is not None:
            for k1 in self.stage_info:
                result['StageInfo'].append(k1.to_map() if k1 else None)

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.stage_info = []
        if m.get('StageInfo') is not None:
            for k1 in m.get('StageInfo'):
                temp_model = main_models.DescribeApiGroupResponseBodyStageItemsStageInfo()
                self.stage_info.append(temp_model.from_map(k1))

        return self

class DescribeApiGroupResponseBodyStageItemsStageInfo(DaraModel):
    def __init__(
        self,
        description: str = None,
        stage_id: str = None,
        stage_name: str = None,
    ):
        # The environment description.
        self.description = description
        # The environment ID.
        self.stage_id = stage_id
        # The environment name.
        self.stage_name = stage_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.description is not None:
            result['Description'] = self.description

        if self.stage_id is not None:
            result['StageId'] = self.stage_id

        if self.stage_name is not None:
            result['StageName'] = self.stage_name

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')

        if m.get('StageId') is not None:
            self.stage_id = m.get('StageId')

        if m.get('StageName') is not None:
            self.stage_name = m.get('StageName')

        return self

class DescribeApiGroupResponseBodyCustomDomains(DaraModel):
    def __init__(
        self,
        domain_item: List[main_models.DescribeApiGroupResponseBodyCustomDomainsDomainItem] = None,
    ):
        self.domain_item = domain_item

    def validate(self):
        if self.domain_item:
            for v1 in self.domain_item:
                 if v1:
                    v1.validate()

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        result['DomainItem'] = []
        if self.domain_item is not None:
            for k1 in self.domain_item:
                result['DomainItem'].append(k1.to_map() if k1 else None)

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_item = []
        if m.get('DomainItem') is not None:
            for k1 in m.get('DomainItem'):
                temp_model = main_models.DescribeApiGroupResponseBodyCustomDomainsDomainItem()
                self.domain_item.append(temp_model.from_map(k1))

        return self

class DescribeApiGroupResponseBodyCustomDomainsDomainItem(DaraModel):
    def __init__(
        self,
        bind_stage_alias: str = None,
        bind_stage_name: str = None,
        certificate_id: str = None,
        certificate_name: str = None,
        certificate_valid_end: int = None,
        certificate_valid_start: int = None,
        client_cert_sdn_pass_through: bool = None,
        custom_domain_type: str = None,
        domain_binding_status: str = None,
        domain_cnamestatus: str = None,
        domain_legal_status: str = None,
        domain_name: str = None,
        domain_remark: str = None,
        domain_web_socket_status: str = None,
        is_http_redirect_to_https: bool = None,
        ssl_ocsp_cache_enable: bool = None,
        ssl_ocsp_enable: bool = None,
        ssl_verify_depth: int = None,
        wildcard_domain_patterns: str = None,
    ):
        # The alias of the associated environment.
        self.bind_stage_alias = bind_stage_alias
        # The environment in which the associated API group runs.
        self.bind_stage_name = bind_stage_name
        # The SSL certificate ID, which is automatically generated by the system.
        self.certificate_id = certificate_id
        # The name of the SSL certificate.
        self.certificate_name = certificate_name
        # The time when the certificate expires.
        self.certificate_valid_end = certificate_valid_end
        # The time when the certificate takes effect.
        self.certificate_valid_start = certificate_valid_start
        self.client_cert_sdn_pass_through = client_cert_sdn_pass_through
        # The type of the custom domain name.
        self.custom_domain_type = custom_domain_type
        # The binding status of the custom domain name. Valid values:
        # 
        # *   **BINDING**: The domain name is bound.
        # *   **BOUND**: The domain name is not bound.
        self.domain_binding_status = domain_binding_status
        # The domain name resolution status. Valid values:
        # 
        # *   **RESOLVED**
        # *   **UNRESOLVED**
        self.domain_cnamestatus = domain_cnamestatus
        # The validity status of the domain name. Valid values:
        # 
        # *   **NORMAL**: The domain name is valid.
        # *   **ABNORMAL**: The domain name is invalid. This status affects API calls and needs to be rectified as soon as possible.
        self.domain_legal_status = domain_legal_status
        # The domain name.
        self.domain_name = domain_name
        # Remarks about the domain name, such as the cause of an exception.
        self.domain_remark = domain_remark
        # The status of the domain that uses the WebSocket feature.
        self.domain_web_socket_status = domain_web_socket_status
        # Indicates whether to redirect HTTP requests to HTTPS.
        self.is_http_redirect_to_https = is_http_redirect_to_https
        self.ssl_ocsp_cache_enable = ssl_ocsp_cache_enable
        self.ssl_ocsp_enable = ssl_ocsp_enable
        self.ssl_verify_depth = ssl_verify_depth
        # The wildcard domain name mode.
        self.wildcard_domain_patterns = wildcard_domain_patterns

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.bind_stage_alias is not None:
            result['BindStageAlias'] = self.bind_stage_alias

        if self.bind_stage_name is not None:
            result['BindStageName'] = self.bind_stage_name

        if self.certificate_id is not None:
            result['CertificateId'] = self.certificate_id

        if self.certificate_name is not None:
            result['CertificateName'] = self.certificate_name

        if self.certificate_valid_end is not None:
            result['CertificateValidEnd'] = self.certificate_valid_end

        if self.certificate_valid_start is not None:
            result['CertificateValidStart'] = self.certificate_valid_start

        if self.client_cert_sdn_pass_through is not None:
            result['ClientCertSDnPassThrough'] = self.client_cert_sdn_pass_through

        if self.custom_domain_type is not None:
            result['CustomDomainType'] = self.custom_domain_type

        if self.domain_binding_status is not None:
            result['DomainBindingStatus'] = self.domain_binding_status

        if self.domain_cnamestatus is not None:
            result['DomainCNAMEStatus'] = self.domain_cnamestatus

        if self.domain_legal_status is not None:
            result['DomainLegalStatus'] = self.domain_legal_status

        if self.domain_name is not None:
            result['DomainName'] = self.domain_name

        if self.domain_remark is not None:
            result['DomainRemark'] = self.domain_remark

        if self.domain_web_socket_status is not None:
            result['DomainWebSocketStatus'] = self.domain_web_socket_status

        if self.is_http_redirect_to_https is not None:
            result['IsHttpRedirectToHttps'] = self.is_http_redirect_to_https

        if self.ssl_ocsp_cache_enable is not None:
            result['SslOcspCacheEnable'] = self.ssl_ocsp_cache_enable

        if self.ssl_ocsp_enable is not None:
            result['SslOcspEnable'] = self.ssl_ocsp_enable

        if self.ssl_verify_depth is not None:
            result['SslVerifyDepth'] = self.ssl_verify_depth

        if self.wildcard_domain_patterns is not None:
            result['WildcardDomainPatterns'] = self.wildcard_domain_patterns

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindStageAlias') is not None:
            self.bind_stage_alias = m.get('BindStageAlias')

        if m.get('BindStageName') is not None:
            self.bind_stage_name = m.get('BindStageName')

        if m.get('CertificateId') is not None:
            self.certificate_id = m.get('CertificateId')

        if m.get('CertificateName') is not None:
            self.certificate_name = m.get('CertificateName')

        if m.get('CertificateValidEnd') is not None:
            self.certificate_valid_end = m.get('CertificateValidEnd')

        if m.get('CertificateValidStart') is not None:
            self.certificate_valid_start = m.get('CertificateValidStart')

        if m.get('ClientCertSDnPassThrough') is not None:
            self.client_cert_sdn_pass_through = m.get('ClientCertSDnPassThrough')

        if m.get('CustomDomainType') is not None:
            self.custom_domain_type = m.get('CustomDomainType')

        if m.get('DomainBindingStatus') is not None:
            self.domain_binding_status = m.get('DomainBindingStatus')

        if m.get('DomainCNAMEStatus') is not None:
            self.domain_cnamestatus = m.get('DomainCNAMEStatus')

        if m.get('DomainLegalStatus') is not None:
            self.domain_legal_status = m.get('DomainLegalStatus')

        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')

        if m.get('DomainRemark') is not None:
            self.domain_remark = m.get('DomainRemark')

        if m.get('DomainWebSocketStatus') is not None:
            self.domain_web_socket_status = m.get('DomainWebSocketStatus')

        if m.get('IsHttpRedirectToHttps') is not None:
            self.is_http_redirect_to_https = m.get('IsHttpRedirectToHttps')

        if m.get('SslOcspCacheEnable') is not None:
            self.ssl_ocsp_cache_enable = m.get('SslOcspCacheEnable')

        if m.get('SslOcspEnable') is not None:
            self.ssl_ocsp_enable = m.get('SslOcspEnable')

        if m.get('SslVerifyDepth') is not None:
            self.ssl_verify_depth = m.get('SslVerifyDepth')

        if m.get('WildcardDomainPatterns') is not None:
            self.wildcard_domain_patterns = m.get('WildcardDomainPatterns')

        return self

